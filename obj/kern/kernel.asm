
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
    vmcall
#endif

    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
#endif

# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
#endif
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
	...

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4virt>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 00 23 04 80 	movabs $0x8004230038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 00 23 04 80 	movabs $0x8004230000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 a5 00 20 04 80 	movabs $0x80042000a5,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	53                   	push   %rbx
  800420005d:	48 83 ec 20          	sub    $0x20,%rsp
  8004200061:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  8004200065:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
			 "+m" (*addr), "=a" (result):
  8004200068:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420006c:	8b 45 dc             	mov    -0x24(%rbp),%eax
			 "+m" (*addr), "=a" (result):
  800420006f:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200073:	89 c3                	mov    %eax,%ebx
  8004200075:	89 d8                	mov    %ebx,%eax
  8004200077:	f0 87 02             	lock xchg %eax,(%rdx)
  800420007a:	89 c3                	mov    %eax,%ebx
  800420007c:	89 5d f4             	mov    %ebx,-0xc(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420007f:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8004200082:	48 83 c4 20          	add    $0x20,%rsp
  8004200086:	5b                   	pop    %rbx
  8004200087:	5d                   	pop    %rbp
  8004200088:	c3                   	retq   

0000008004200089 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004200089:	55                   	push   %rbp
  800420008a:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800420008d:	48 bf 00 07 23 04 80 	movabs $0x8004230700,%rdi
  8004200094:	00 00 00 
  8004200097:	48 b8 b9 76 21 04 80 	movabs $0x80042176b9,%rax
  800420009e:	00 00 00 
  80042000a1:	ff d0                	callq  *%rax
}
  80042000a3:	5d                   	pop    %rbp
  80042000a4:	c3                   	retq   

00000080042000a5 <i386_init>:
static void boot_aps(void);


void
i386_init(void)
{
  80042000a5:	55                   	push   %rbp
  80042000a6:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  80042000a9:	48 ba 10 60 49 04 80 	movabs $0x8004496010,%rdx
  80042000b0:	00 00 00 
  80042000b3:	48 b8 5e 14 48 04 80 	movabs $0x800448145e,%rax
  80042000ba:	00 00 00 
  80042000bd:	48 89 d1             	mov    %rdx,%rcx
  80042000c0:	48 29 c1             	sub    %rax,%rcx
  80042000c3:	48 89 c8             	mov    %rcx,%rax
  80042000c6:	48 89 c2             	mov    %rax,%rdx
  80042000c9:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ce:	48 bf 5e 14 48 04 80 	movabs $0x800448145e,%rdi
  80042000d5:	00 00 00 
  80042000d8:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042000df:	00 00 00 
  80042000e2:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000e4:	48 b8 21 12 20 04 80 	movabs $0x8004201221,%rax
  80042000eb:	00 00 00 
  80042000ee:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000f0:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000f5:	48 bf 00 c4 21 04 80 	movabs $0x800421c400,%rdi
  80042000fc:	00 00 00 
  80042000ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200104:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420010b:	00 00 00 
  800420010e:	ff d2                	callq  *%rdx
	}
#endif

#ifndef VMM_GUEST
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
  8004200110:	48 b8 10 60 49 04 80 	movabs $0x8004496010,%rax
  8004200117:	00 00 00 
  800420011a:	48 89 c6             	mov    %rax,%rsi
  800420011d:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200124:	00 00 00 
  8004200127:	48 b8 0b 5e 21 04 80 	movabs $0x8004215e0b,%rax
  800420012e:	00 00 00 
  8004200131:	ff d0                	callq  *%rax
  8004200133:	48 ba 48 37 48 04 80 	movabs $0x8004483748,%rdx
  800420013a:	00 00 00 
  800420013d:	48 89 02             	mov    %rax,(%rdx)
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200140:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200145:	48 ba a5 22 20 04 80 	movabs $0x80042022a5,%rdx
  800420014c:	00 00 00 
  800420014f:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200151:	48 b8 05 76 20 04 80 	movabs $0x8004207605,%rax
  8004200158:	00 00 00 
  800420015b:	ff d0                	callq  *%rax
	trap_init();
  800420015d:	48 b8 00 92 20 04 80 	movabs $0x8004209200,%rax
  8004200164:	00 00 00 
  8004200167:	ff d0                	callq  *%rax

#ifndef VMM_GUEST
	// Lab 4 multiprocessor initialization functions
	mp_init();
  8004200169:	48 b8 87 6d 21 04 80 	movabs $0x8004216d87,%rax
  8004200170:	00 00 00 
  8004200173:	ff d0                	callq  *%rax
	lapic_init();
  8004200175:	48 b8 32 71 21 04 80 	movabs $0x8004217132,%rax
  800420017c:	00 00 00 
  800420017f:	ff d0                	callq  *%rax
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200181:	48 b8 74 8d 20 04 80 	movabs $0x8004208d74,%rax
  8004200188:	00 00 00 
  800420018b:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:

#ifndef VMM_GUEST
	lock_kernel();
  800420018d:	48 b8 89 00 20 04 80 	movabs $0x8004200089,%rax
  8004200194:	00 00 00 
  8004200197:	ff d0                	callq  *%rax
	// Starting non-boot CPUs
	boot_aps();
  8004200199:	48 b8 f3 01 20 04 80 	movabs $0x80042001f3,%rax
  80042001a0:	00 00 00 
  80042001a3:	ff d0                	callq  *%rax
#endif

	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042001a5:	be 01 00 00 00       	mov    $0x1,%esi
  80042001aa:	48 bf 31 d7 29 04 80 	movabs $0x800429d731,%rdi
  80042001b1:	00 00 00 
  80042001b4:	48 b8 9c 84 20 04 80 	movabs $0x800420849c,%rax
  80042001bb:	00 00 00 
  80042001be:	ff d0                	callq  *%rax
	// Touch all you want.
#if defined(TEST_EPT_MAP)
	test_ept_map();
#endif

	ENV_CREATE(user_icode, ENV_TYPE_USER);
  80042001c0:	be 00 00 00 00       	mov    $0x0,%esi
  80042001c5:	48 bf a9 60 28 04 80 	movabs $0x80042860a9,%rdi
  80042001cc:	00 00 00 
  80042001cf:	48 b8 9c 84 20 04 80 	movabs $0x800420849c,%rax
  80042001d6:	00 00 00 
  80042001d9:	ff d0                	callq  *%rax
#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  80042001db:	48 b8 51 10 20 04 80 	movabs $0x8004201051,%rax
  80042001e2:	00 00 00 
  80042001e5:	ff d0                	callq  *%rax

	// Schedule and run the first user environment!
	sched_yield();
  80042001e7:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  80042001ee:	00 00 00 
  80042001f1:	ff d0                	callq  *%rax

00000080042001f3 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042001f3:	55                   	push   %rbp
  80042001f4:	48 89 e5             	mov    %rsp,%rbp
  80042001f7:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042001fb:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200202:	00 
  8004200203:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200207:	48 c1 e8 0c          	shr    $0xc,%rax
  800420020b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420020e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200211:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004200218:	00 00 00 
  800420021b:	48 8b 00             	mov    (%rax),%rax
  800420021e:	48 39 c2             	cmp    %rax,%rdx
  8004200221:	72 32                	jb     8004200255 <boot_aps+0x62>
  8004200223:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200227:	48 89 c1             	mov    %rax,%rcx
  800420022a:	48 ba 20 c4 21 04 80 	movabs $0x800421c420,%rdx
  8004200231:	00 00 00 
  8004200234:	be 83 00 00 00       	mov    $0x83,%esi
  8004200239:	48 bf 43 c4 21 04 80 	movabs $0x800421c443,%rdi
  8004200240:	00 00 00 
  8004200243:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200248:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420024f:	00 00 00 
  8004200252:	41 ff d0             	callq  *%r8
  8004200255:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420025c:	00 00 00 
  800420025f:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004200263:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200267:	48 ba c6 68 21 04 80 	movabs $0x80042168c6,%rdx
  800420026e:	00 00 00 
  8004200271:	48 b8 e0 67 21 04 80 	movabs $0x80042167e0,%rax
  8004200278:	00 00 00 
  800420027b:	48 89 d1             	mov    %rdx,%rcx
  800420027e:	48 29 c1             	sub    %rax,%rcx
  8004200281:	48 89 c8             	mov    %rcx,%rax
  8004200284:	48 89 c2             	mov    %rax,%rdx
  8004200287:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420028b:	48 be e0 67 21 04 80 	movabs $0x80042167e0,%rsi
  8004200292:	00 00 00 
  8004200295:	48 89 c7             	mov    %rax,%rdi
  8004200298:	48 b8 d2 03 21 04 80 	movabs $0x80042103d2,%rax
  800420029f:	00 00 00 
  80042002a2:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042002a4:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042002ab:	00 00 00 
  80042002ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002b2:	e9 10 01 00 00       	jmpq   80042003c7 <boot_aps+0x1d4>
		if (c == cpus + cpunum())  // We've started already.
  80042002b7:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042002be:	00 00 00 
  80042002c1:	ff d0                	callq  *%rax
  80042002c3:	48 98                	cltq   
  80042002c5:	48 c1 e0 03          	shl    $0x3,%rax
  80042002c9:	48 89 c2             	mov    %rax,%rdx
  80042002cc:	48 c1 e2 04          	shl    $0x4,%rdx
  80042002d0:	48 01 c2             	add    %rax,%rdx
  80042002d3:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042002da:	00 00 00 
  80042002dd:	48 01 d0             	add    %rdx,%rax
  80042002e0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002e4:	0f 84 d4 00 00 00    	je     80042003be <boot_aps+0x1cb>
			continue;

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002ea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002ee:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042002f5:	00 00 00 
  80042002f8:	48 89 d1             	mov    %rdx,%rcx
  80042002fb:	48 29 c1             	sub    %rax,%rcx
  80042002fe:	48 89 c8             	mov    %rcx,%rax
  8004200301:	48 89 c2             	mov    %rax,%rdx
  8004200304:	48 c1 fa 03          	sar    $0x3,%rdx
  8004200308:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  800420030f:	f0 f0 f0 
  8004200312:	48 0f af c2          	imul   %rdx,%rax
  8004200316:	48 83 c0 01          	add    $0x1,%rax
  800420031a:	48 89 c2             	mov    %rax,%rdx
  800420031d:	48 c1 e2 10          	shl    $0x10,%rdx
  8004200321:	48 b8 00 60 48 04 80 	movabs $0x8004486000,%rax
  8004200328:	00 00 00 
  800420032b:	48 01 c2             	add    %rax,%rdx
  800420032e:	48 b8 58 37 48 04 80 	movabs $0x8004483758,%rax
  8004200335:	00 00 00 
  8004200338:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420033b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420033f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200343:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420034a:	00 00 00 
  800420034d:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200351:	77 32                	ja     8004200385 <boot_aps+0x192>
  8004200353:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200357:	48 89 c1             	mov    %rax,%rcx
  800420035a:	48 ba 50 c4 21 04 80 	movabs $0x800421c450,%rdx
  8004200361:	00 00 00 
  8004200364:	be 8d 00 00 00       	mov    $0x8d,%esi
  8004200369:	48 bf 43 c4 21 04 80 	movabs $0x800421c443,%rdi
  8004200370:	00 00 00 
  8004200373:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200378:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420037f:	00 00 00 
  8004200382:	41 ff d0             	callq  *%r8
  8004200385:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420038c:	ff ff ff 
  800420038f:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004200393:	89 c2                	mov    %eax,%edx
  8004200395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200399:	0f b6 00             	movzbl (%rax),%eax
  800420039c:	0f b6 c0             	movzbl %al,%eax
  800420039f:	89 d6                	mov    %edx,%esi
  80042003a1:	89 c7                	mov    %eax,%edi
  80042003a3:	48 b8 9d 73 21 04 80 	movabs $0x800421739d,%rax
  80042003aa:	00 00 00 
  80042003ad:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003af:	90                   	nop
  80042003b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003b4:	8b 40 04             	mov    0x4(%rax),%eax
  80042003b7:	83 f8 01             	cmp    $0x1,%eax
  80042003ba:	75 f4                	jne    80042003b0 <boot_aps+0x1bd>
  80042003bc:	eb 01                	jmp    80042003bf <boot_aps+0x1cc>
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == cpus + cpunum())  // We've started already.
			continue;
  80042003be:	90                   	nop

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003bf:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  80042003c6:	00 
  80042003c7:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  80042003ce:	00 00 00 
  80042003d1:	8b 00                	mov    (%rax),%eax
  80042003d3:	48 98                	cltq   
  80042003d5:	48 c1 e0 03          	shl    $0x3,%rax
  80042003d9:	48 89 c2             	mov    %rax,%rdx
  80042003dc:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003e0:	48 01 c2             	add    %rax,%rdx
  80042003e3:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042003ea:	00 00 00 
  80042003ed:	48 01 d0             	add    %rdx,%rax
  80042003f0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003f4:	0f 87 bd fe ff ff    	ja     80042002b7 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  80042003fa:	c9                   	leaveq 
  80042003fb:	c3                   	retq   

00000080042003fc <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042003fc:	55                   	push   %rbp
  80042003fd:	48 89 e5             	mov    %rsp,%rbp
  8004200400:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200404:	48 b8 60 37 48 04 80 	movabs $0x8004483760,%rax
  800420040b:	00 00 00 
  800420040e:	48 8b 00             	mov    (%rax),%rax
  8004200411:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200415:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200419:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420041c:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004200423:	00 00 00 
  8004200426:	ff d0                	callq  *%rax
  8004200428:	89 c6                	mov    %eax,%esi
  800420042a:	48 bf 74 c4 21 04 80 	movabs $0x800421c474,%rdi
  8004200431:	00 00 00 
  8004200434:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200439:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004200440:	00 00 00 
  8004200443:	ff d2                	callq  *%rdx

	lapic_init();
  8004200445:	48 b8 32 71 21 04 80 	movabs $0x8004217132,%rax
  800420044c:	00 00 00 
  800420044f:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200451:	48 b8 46 77 20 04 80 	movabs $0x8004207746,%rax
  8004200458:	00 00 00 
  800420045b:	ff d0                	callq  *%rax
	trap_init_percpu();
  800420045d:	48 b8 1d be 20 04 80 	movabs $0x800420be1d,%rax
  8004200464:	00 00 00 
  8004200467:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200469:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004200470:	00 00 00 
  8004200473:	ff d0                	callq  *%rax
  8004200475:	48 98                	cltq   
  8004200477:	48 c1 e0 03          	shl    $0x3,%rax
  800420047b:	48 89 c2             	mov    %rax,%rdx
  800420047e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200482:	48 01 c2             	add    %rax,%rdx
  8004200485:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420048c:	00 00 00 
  800420048f:	48 01 d0             	add    %rdx,%rax
  8004200492:	48 83 c0 04          	add    $0x4,%rax
  8004200496:	be 01 00 00 00       	mov    $0x1,%esi
  800420049b:	48 89 c7             	mov    %rax,%rdi
  800420049e:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  80042004a5:	00 00 00 
  80042004a8:	ff d0                	callq  *%rax

	lock_kernel();
  80042004aa:	48 b8 89 00 20 04 80 	movabs $0x8004200089,%rax
  80042004b1:	00 00 00 
  80042004b4:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	sched_yield();
  80042004b6:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  80042004bd:	00 00 00 
  80042004c0:	ff d0                	callq  *%rax

00000080042004c2 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004c2:	55                   	push   %rbp
  80042004c3:	48 89 e5             	mov    %rsp,%rbp
  80042004c6:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004cd:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042004d4:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042004da:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004e1:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042004e8:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042004ef:	84 c0                	test   %al,%al
  80042004f1:	74 20                	je     8004200513 <_panic+0x51>
  80042004f3:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042004f7:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042004fb:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042004ff:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200503:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200507:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420050b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420050f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200513:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  800420051a:	48 b8 50 37 48 04 80 	movabs $0x8004483750,%rax
  8004200521:	00 00 00 
  8004200524:	48 8b 00             	mov    (%rax),%rax
  8004200527:	48 85 c0             	test   %rax,%rax
  800420052a:	0f 85 b7 00 00 00    	jne    80042005e7 <_panic+0x125>
		goto dead;
	panicstr = fmt;
  8004200530:	48 b8 50 37 48 04 80 	movabs $0x8004483750,%rax
  8004200537:	00 00 00 
  800420053a:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200541:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200544:	fa                   	cli    
  8004200545:	fc                   	cld    

	va_start(ap, fmt);
  8004200546:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420054d:	00 00 00 
  8004200550:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200557:	00 00 00 
  800420055a:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420055e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200565:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420056c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  8004200573:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420057a:	00 00 00 
  800420057d:	ff d0                	callq  *%rax
  800420057f:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  8004200585:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800420058c:	89 c6                	mov    %eax,%esi
  800420058e:	48 bf 90 c4 21 04 80 	movabs $0x800421c490,%rdi
  8004200595:	00 00 00 
  8004200598:	b8 00 00 00 00       	mov    $0x0,%eax
  800420059d:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  80042005a4:	00 00 00 
  80042005a7:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  80042005aa:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042005b1:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005b8:	48 89 d6             	mov    %rdx,%rsi
  80042005bb:	48 89 c7             	mov    %rax,%rdi
  80042005be:	48 b8 1b 90 20 04 80 	movabs $0x800420901b,%rax
  80042005c5:	00 00 00 
  80042005c8:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005ca:	48 bf b2 c4 21 04 80 	movabs $0x800421c4b2,%rdi
  80042005d1:	00 00 00 
  80042005d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005d9:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042005e0:	00 00 00 
  80042005e3:	ff d2                	callq  *%rdx
  80042005e5:	eb 01                	jmp    80042005e8 <_panic+0x126>
_panic(const char *file, int line, const char *fmt,...)
{
	va_list ap;

	if (panicstr)
		goto dead;
  80042005e7:	90                   	nop
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005e8:	bf 00 00 00 00       	mov    $0x0,%edi
  80042005ed:	48 b8 1f 17 20 04 80 	movabs $0x800420171f,%rax
  80042005f4:	00 00 00 
  80042005f7:	ff d0                	callq  *%rax
  80042005f9:	eb ed                	jmp    80042005e8 <_panic+0x126>

00000080042005fb <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042005fb:	55                   	push   %rbp
  80042005fc:	48 89 e5             	mov    %rsp,%rbp
  80042005ff:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200606:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420060d:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200613:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420061a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200621:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200628:	84 c0                	test   %al,%al
  800420062a:	74 20                	je     800420064c <_warn+0x51>
  800420062c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200630:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200634:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200638:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420063c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200640:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200644:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200648:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420064c:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200653:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420065a:	00 00 00 
  800420065d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200664:	00 00 00 
  8004200667:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420066b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200672:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200679:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  8004200680:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200686:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420068d:	48 89 c6             	mov    %rax,%rsi
  8004200690:	48 bf b4 c4 21 04 80 	movabs $0x800421c4b4,%rdi
  8004200697:	00 00 00 
  800420069a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420069f:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  80042006a6:	00 00 00 
  80042006a9:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042006ab:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006b2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006b9:	48 89 d6             	mov    %rdx,%rsi
  80042006bc:	48 89 c7             	mov    %rax,%rdi
  80042006bf:	48 b8 1b 90 20 04 80 	movabs $0x800420901b,%rax
  80042006c6:	00 00 00 
  80042006c9:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006cb:	48 bf b2 c4 21 04 80 	movabs $0x800421c4b2,%rdi
  80042006d2:	00 00 00 
  80042006d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006da:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042006e1:	00 00 00 
  80042006e4:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006e6:	c9                   	leaveq 
  80042006e7:	c3                   	retq   

00000080042006e8 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006e8:	55                   	push   %rbp
  80042006e9:	48 89 e5             	mov    %rsp,%rbp
  80042006ec:	53                   	push   %rbx
  80042006ed:	48 83 ec 28          	sub    $0x28,%rsp
  80042006f1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006f8:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042006fb:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80042006fe:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200701:	ec                   	in     (%dx),%al
  8004200702:	89 c3                	mov    %eax,%ebx
  8004200704:	88 5d f3             	mov    %bl,-0xd(%rbp)
    return data;
  8004200707:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420070e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200711:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  8004200714:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200717:	ec                   	in     (%dx),%al
  8004200718:	89 c3                	mov    %eax,%ebx
  800420071a:	88 5d eb             	mov    %bl,-0x15(%rbp)
    return data;
  800420071d:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200724:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200727:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  800420072a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420072d:	ec                   	in     (%dx),%al
  800420072e:	89 c3                	mov    %eax,%ebx
  8004200730:	88 5d e3             	mov    %bl,-0x1d(%rbp)
    return data;
  8004200733:	c7 45 dc 84 00 00 00 	movl   $0x84,-0x24(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420073a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420073d:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  8004200740:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200743:	ec                   	in     (%dx),%al
  8004200744:	89 c3                	mov    %eax,%ebx
  8004200746:	88 5d db             	mov    %bl,-0x25(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200749:	48 83 c4 28          	add    $0x28,%rsp
  800420074d:	5b                   	pop    %rbx
  800420074e:	5d                   	pop    %rbp
  800420074f:	c3                   	retq   

0000008004200750 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200750:	55                   	push   %rbp
  8004200751:	48 89 e5             	mov    %rsp,%rbp
  8004200754:	53                   	push   %rbx
  8004200755:	48 83 ec 18          	sub    $0x18,%rsp
  8004200759:	c7 45 f4 fd 03 00 00 	movl   $0x3fd,-0xc(%rbp)
  8004200760:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200763:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004200766:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200769:	ec                   	in     (%dx),%al
  800420076a:	89 c3                	mov    %eax,%ebx
  800420076c:	88 5d f3             	mov    %bl,-0xd(%rbp)
    return data;
  800420076f:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200773:	0f b6 c0             	movzbl %al,%eax
  8004200776:	83 e0 01             	and    $0x1,%eax
  8004200779:	85 c0                	test   %eax,%eax
  800420077b:	75 07                	jne    8004200784 <serial_proc_data+0x34>
		return -1;
  800420077d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200782:	eb 1d                	jmp    80042007a1 <serial_proc_data+0x51>
  8004200784:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420078b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420078e:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004200791:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200794:	ec                   	in     (%dx),%al
  8004200795:	89 c3                	mov    %eax,%ebx
  8004200797:	88 5d eb             	mov    %bl,-0x15(%rbp)
    return data;
  800420079a:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
	return inb(COM1+COM_RX);
  800420079e:	0f b6 c0             	movzbl %al,%eax
}
  80042007a1:	48 83 c4 18          	add    $0x18,%rsp
  80042007a5:	5b                   	pop    %rbx
  80042007a6:	5d                   	pop    %rbp
  80042007a7:	c3                   	retq   

00000080042007a8 <serial_intr>:

void
serial_intr(void)
{
  80042007a8:	55                   	push   %rbp
  80042007a9:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007ac:	48 b8 00 20 48 04 80 	movabs $0x8004482000,%rax
  80042007b3:	00 00 00 
  80042007b6:	0f b6 00             	movzbl (%rax),%eax
  80042007b9:	84 c0                	test   %al,%al
  80042007bb:	74 16                	je     80042007d3 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007bd:	48 bf 50 07 20 04 80 	movabs $0x8004200750,%rdi
  80042007c4:	00 00 00 
  80042007c7:	48 b8 a2 10 20 04 80 	movabs $0x80042010a2,%rax
  80042007ce:	00 00 00 
  80042007d1:	ff d0                	callq  *%rax
}
  80042007d3:	5d                   	pop    %rbp
  80042007d4:	c3                   	retq   

00000080042007d5 <serial_putc>:

static void
serial_putc(int c)
{
  80042007d5:	55                   	push   %rbp
  80042007d6:	48 89 e5             	mov    %rsp,%rbp
  80042007d9:	53                   	push   %rbx
  80042007da:	48 83 ec 28          	sub    $0x28,%rsp
  80042007de:	89 7d d4             	mov    %edi,-0x2c(%rbp)
	int i;

	for (i = 0;
  80042007e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042007e8:	eb 10                	jmp    80042007fa <serial_putc+0x25>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042007ea:	48 b8 e8 06 20 04 80 	movabs $0x80042006e8,%rax
  80042007f1:	00 00 00 
  80042007f4:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007f6:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042007fa:	c7 45 f0 fd 03 00 00 	movl   $0x3fd,-0x10(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200801:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200804:	89 55 d0             	mov    %edx,-0x30(%rbp)
  8004200807:	8b 55 d0             	mov    -0x30(%rbp),%edx
  800420080a:	ec                   	in     (%dx),%al
  800420080b:	89 c3                	mov    %eax,%ebx
  800420080d:	88 5d ef             	mov    %bl,-0x11(%rbp)
    return data;
  8004200810:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200814:	0f b6 c0             	movzbl %al,%eax
  8004200817:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  800420081a:	85 c0                	test   %eax,%eax
  800420081c:	75 09                	jne    8004200827 <serial_putc+0x52>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420081e:	81 7d f4 ff 31 00 00 	cmpl   $0x31ff,-0xc(%rbp)
  8004200825:	7e c3                	jle    80042007ea <serial_putc+0x15>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200827:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420082a:	0f b6 c0             	movzbl %al,%eax
  800420082d:	c7 45 e8 f8 03 00 00 	movl   $0x3f8,-0x18(%rbp)
  8004200834:	88 45 e7             	mov    %al,-0x19(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200837:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420083b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420083e:	ee                   	out    %al,(%dx)
}
  800420083f:	48 83 c4 28          	add    $0x28,%rsp
  8004200843:	5b                   	pop    %rbx
  8004200844:	5d                   	pop    %rbp
  8004200845:	c3                   	retq   

0000008004200846 <serial_init>:

static void
serial_init(void)
{
  8004200846:	55                   	push   %rbp
  8004200847:	48 89 e5             	mov    %rsp,%rbp
  800420084a:	53                   	push   %rbx
  800420084b:	48 83 ec 68          	sub    $0x68,%rsp
  800420084f:	c7 45 ec fa 03 00 00 	movl   $0x3fa,-0x14(%rbp)
  8004200856:	c6 45 eb 00          	movb   $0x0,-0x15(%rbp)
  800420085a:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420085e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200861:	ee                   	out    %al,(%dx)
  8004200862:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%rbp)
  8004200869:	c6 45 e3 80          	movb   $0x80,-0x1d(%rbp)
  800420086d:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200871:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200874:	ee                   	out    %al,(%dx)
  8004200875:	c7 45 dc f8 03 00 00 	movl   $0x3f8,-0x24(%rbp)
  800420087c:	c6 45 db 0c          	movb   $0xc,-0x25(%rbp)
  8004200880:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200884:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200887:	ee                   	out    %al,(%dx)
  8004200888:	c7 45 d4 f9 03 00 00 	movl   $0x3f9,-0x2c(%rbp)
  800420088f:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200893:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200897:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420089a:	ee                   	out    %al,(%dx)
  800420089b:	c7 45 cc fb 03 00 00 	movl   $0x3fb,-0x34(%rbp)
  80042008a2:	c6 45 cb 03          	movb   $0x3,-0x35(%rbp)
  80042008a6:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042008aa:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042008ad:	ee                   	out    %al,(%dx)
  80042008ae:	c7 45 c4 fc 03 00 00 	movl   $0x3fc,-0x3c(%rbp)
  80042008b5:	c6 45 c3 00          	movb   $0x0,-0x3d(%rbp)
  80042008b9:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  80042008bd:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042008c0:	ee                   	out    %al,(%dx)
  80042008c1:	c7 45 bc f9 03 00 00 	movl   $0x3f9,-0x44(%rbp)
  80042008c8:	c6 45 bb 01          	movb   $0x1,-0x45(%rbp)
  80042008cc:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042008d0:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042008d3:	ee                   	out    %al,(%dx)
  80042008d4:	c7 45 b4 fd 03 00 00 	movl   $0x3fd,-0x4c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008db:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042008de:	89 55 9c             	mov    %edx,-0x64(%rbp)
  80042008e1:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042008e4:	ec                   	in     (%dx),%al
  80042008e5:	89 c3                	mov    %eax,%ebx
  80042008e7:	88 5d b3             	mov    %bl,-0x4d(%rbp)
    return data;
  80042008ea:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  80042008ee:	3c ff                	cmp    $0xff,%al
  80042008f0:	0f 95 c2             	setne  %dl
  80042008f3:	48 b8 00 20 48 04 80 	movabs $0x8004482000,%rax
  80042008fa:	00 00 00 
  80042008fd:	88 10                	mov    %dl,(%rax)
  80042008ff:	c7 45 ac fa 03 00 00 	movl   $0x3fa,-0x54(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200906:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004200909:	89 55 9c             	mov    %edx,-0x64(%rbp)
  800420090c:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420090f:	ec                   	in     (%dx),%al
  8004200910:	89 c3                	mov    %eax,%ebx
  8004200912:	88 5d ab             	mov    %bl,-0x55(%rbp)
    return data;
  8004200915:	c7 45 a4 f8 03 00 00 	movl   $0x3f8,-0x5c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420091c:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  800420091f:	89 55 9c             	mov    %edx,-0x64(%rbp)
  8004200922:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004200925:	ec                   	in     (%dx),%al
  8004200926:	89 c3                	mov    %eax,%ebx
  8004200928:	88 5d a3             	mov    %bl,-0x5d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  800420092b:	48 b8 00 20 48 04 80 	movabs $0x8004482000,%rax
  8004200932:	00 00 00 
  8004200935:	0f b6 00             	movzbl (%rax),%eax
  8004200938:	84 c0                	test   %al,%al
  800420093a:	74 23                	je     800420095f <serial_init+0x119>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  800420093c:	48 b8 04 06 23 04 80 	movabs $0x8004230604,%rax
  8004200943:	00 00 00 
  8004200946:	0f b7 00             	movzwl (%rax),%eax
  8004200949:	0f b7 c0             	movzwl %ax,%eax
  800420094c:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200951:	89 c7                	mov    %eax,%edi
  8004200953:	48 b8 c6 8e 20 04 80 	movabs $0x8004208ec6,%rax
  800420095a:	00 00 00 
  800420095d:	ff d0                	callq  *%rax
}
  800420095f:	48 83 c4 68          	add    $0x68,%rsp
  8004200963:	5b                   	pop    %rbx
  8004200964:	5d                   	pop    %rbp
  8004200965:	c3                   	retq   

0000008004200966 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200966:	55                   	push   %rbp
  8004200967:	48 89 e5             	mov    %rsp,%rbp
  800420096a:	53                   	push   %rbx
  800420096b:	48 83 ec 38          	sub    $0x38,%rsp
  800420096f:	89 7d c4             	mov    %edi,-0x3c(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200972:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004200979:	eb 10                	jmp    800420098b <lpt_putc+0x25>
		delay();
  800420097b:	48 b8 e8 06 20 04 80 	movabs $0x80042006e8,%rax
  8004200982:	00 00 00 
  8004200985:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200987:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420098b:	c7 45 f0 79 03 00 00 	movl   $0x379,-0x10(%rbp)
  8004200992:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200995:	89 55 c0             	mov    %edx,-0x40(%rbp)
  8004200998:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800420099b:	ec                   	in     (%dx),%al
  800420099c:	89 c3                	mov    %eax,%ebx
  800420099e:	88 5d ef             	mov    %bl,-0x11(%rbp)
    return data;
  80042009a1:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042009a5:	84 c0                	test   %al,%al
  80042009a7:	78 09                	js     80042009b2 <lpt_putc+0x4c>
  80042009a9:	81 7d f4 ff 31 00 00 	cmpl   $0x31ff,-0xc(%rbp)
  80042009b0:	7e c9                	jle    800420097b <lpt_putc+0x15>
		delay();
	outb(0x378+0, c);
  80042009b2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042009b5:	0f b6 c0             	movzbl %al,%eax
  80042009b8:	c7 45 e8 78 03 00 00 	movl   $0x378,-0x18(%rbp)
  80042009bf:	88 45 e7             	mov    %al,-0x19(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009c2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009c6:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009c9:	ee                   	out    %al,(%dx)
  80042009ca:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  80042009d1:	c6 45 df 0d          	movb   $0xd,-0x21(%rbp)
  80042009d5:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042009d9:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042009dc:	ee                   	out    %al,(%dx)
  80042009dd:	c7 45 d8 7a 03 00 00 	movl   $0x37a,-0x28(%rbp)
  80042009e4:	c6 45 d7 08          	movb   $0x8,-0x29(%rbp)
  80042009e8:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
  80042009ec:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80042009ef:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  80042009f0:	48 83 c4 38          	add    $0x38,%rsp
  80042009f4:	5b                   	pop    %rbx
  80042009f5:	5d                   	pop    %rbp
  80042009f6:	c3                   	retq   

00000080042009f7 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  80042009f7:	55                   	push   %rbp
  80042009f8:	48 89 e5             	mov    %rsp,%rbp
  80042009fb:	53                   	push   %rbx
  80042009fc:	48 83 ec 38          	sub    $0x38,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200a00:	c7 45 f0 00 80 0b 04 	movl   $0x40b8000,-0x10(%rbp)
  8004200a07:	c7 45 f4 80 00 00 00 	movl   $0x80,-0xc(%rbp)
	was = *cp;
  8004200a0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a12:	0f b7 00             	movzwl (%rax),%eax
  8004200a15:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a1d:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200a22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a26:	0f b7 00             	movzwl (%rax),%eax
  8004200a29:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a2d:	74 20                	je     8004200a4f <cga_init+0x58>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a2f:	c7 45 f0 00 00 0b 04 	movl   $0x40b0000,-0x10(%rbp)
  8004200a36:	c7 45 f4 80 00 00 00 	movl   $0x80,-0xc(%rbp)
		addr_6845 = MONO_BASE;
  8004200a3d:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200a44:	00 00 00 
  8004200a47:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a4d:	eb 1b                	jmp    8004200a6a <cga_init+0x73>
	} else {
		*cp = was;
  8004200a4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a53:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  8004200a57:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a5a:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200a61:	00 00 00 
  8004200a64:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a6a:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200a71:	00 00 00 
  8004200a74:	8b 00                	mov    (%rax),%eax
  8004200a76:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004200a79:	c6 45 e3 0e          	movb   $0xe,-0x1d(%rbp)
  8004200a7d:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200a81:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200a84:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200a85:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200a8c:	00 00 00 
  8004200a8f:	8b 00                	mov    (%rax),%eax
  8004200a91:	83 c0 01             	add    $0x1,%eax
  8004200a94:	89 45 dc             	mov    %eax,-0x24(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a97:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200a9a:	89 55 c4             	mov    %edx,-0x3c(%rbp)
  8004200a9d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004200aa0:	ec                   	in     (%dx),%al
  8004200aa1:	89 c3                	mov    %eax,%ebx
  8004200aa3:	88 5d db             	mov    %bl,-0x25(%rbp)
    return data;
  8004200aa6:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200aaa:	0f b6 c0             	movzbl %al,%eax
  8004200aad:	c1 e0 08             	shl    $0x8,%eax
  8004200ab0:	89 45 e8             	mov    %eax,-0x18(%rbp)
	outb(addr_6845, 15);
  8004200ab3:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200aba:	00 00 00 
  8004200abd:	8b 00                	mov    (%rax),%eax
  8004200abf:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004200ac2:	c6 45 d3 0f          	movb   $0xf,-0x2d(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200ac6:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200aca:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200acd:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200ace:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200ad5:	00 00 00 
  8004200ad8:	8b 00                	mov    (%rax),%eax
  8004200ada:	83 c0 01             	add    $0x1,%eax
  8004200add:	89 45 cc             	mov    %eax,-0x34(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ae0:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200ae3:	89 55 c4             	mov    %edx,-0x3c(%rbp)
  8004200ae6:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004200ae9:	ec                   	in     (%dx),%al
  8004200aea:	89 c3                	mov    %eax,%ebx
  8004200aec:	88 5d cb             	mov    %bl,-0x35(%rbp)
    return data;
  8004200aef:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004200af3:	0f b6 c0             	movzbl %al,%eax
  8004200af6:	09 45 e8             	or     %eax,-0x18(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200af9:	48 b8 08 20 48 04 80 	movabs $0x8004482008,%rax
  8004200b00:	00 00 00 
  8004200b03:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004200b07:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200b0a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200b0d:	89 c2                	mov    %eax,%edx
  8004200b0f:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200b16:	00 00 00 
  8004200b19:	66 89 10             	mov    %dx,(%rax)
}
  8004200b1c:	48 83 c4 38          	add    $0x38,%rsp
  8004200b20:	5b                   	pop    %rbx
  8004200b21:	5d                   	pop    %rbp
  8004200b22:	c3                   	retq   

0000008004200b23 <cga_putc>:



static void
cga_putc(int c)
{
  8004200b23:	55                   	push   %rbp
  8004200b24:	48 89 e5             	mov    %rsp,%rbp
  8004200b27:	48 83 ec 40          	sub    $0x40,%rsp
  8004200b2b:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200b2e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b31:	b0 00                	mov    $0x0,%al
  8004200b33:	85 c0                	test   %eax,%eax
  8004200b35:	75 07                	jne    8004200b3e <cga_putc+0x1b>
		c |= 0x0700;
  8004200b37:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200b3e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b41:	25 ff 00 00 00       	and    $0xff,%eax
  8004200b46:	83 f8 09             	cmp    $0x9,%eax
  8004200b49:	0f 84 f9 00 00 00    	je     8004200c48 <cga_putc+0x125>
  8004200b4f:	83 f8 09             	cmp    $0x9,%eax
  8004200b52:	7f 0a                	jg     8004200b5e <cga_putc+0x3b>
  8004200b54:	83 f8 08             	cmp    $0x8,%eax
  8004200b57:	74 18                	je     8004200b71 <cga_putc+0x4e>
  8004200b59:	e9 41 01 00 00       	jmpq   8004200c9f <cga_putc+0x17c>
  8004200b5e:	83 f8 0a             	cmp    $0xa,%eax
  8004200b61:	74 74                	je     8004200bd7 <cga_putc+0xb4>
  8004200b63:	83 f8 0d             	cmp    $0xd,%eax
  8004200b66:	0f 84 88 00 00 00    	je     8004200bf4 <cga_putc+0xd1>
  8004200b6c:	e9 2e 01 00 00       	jmpq   8004200c9f <cga_putc+0x17c>
	case '\b':
		if (crt_pos > 0) {
  8004200b71:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200b78:	00 00 00 
  8004200b7b:	0f b7 00             	movzwl (%rax),%eax
  8004200b7e:	66 85 c0             	test   %ax,%ax
  8004200b81:	0f 84 53 01 00 00    	je     8004200cda <cga_putc+0x1b7>
			crt_pos--;
  8004200b87:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200b8e:	00 00 00 
  8004200b91:	0f b7 00             	movzwl (%rax),%eax
  8004200b94:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b97:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200b9e:	00 00 00 
  8004200ba1:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200ba4:	48 b8 08 20 48 04 80 	movabs $0x8004482008,%rax
  8004200bab:	00 00 00 
  8004200bae:	48 8b 10             	mov    (%rax),%rdx
  8004200bb1:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200bb8:	00 00 00 
  8004200bbb:	0f b7 00             	movzwl (%rax),%eax
  8004200bbe:	0f b7 c0             	movzwl %ax,%eax
  8004200bc1:	48 01 c0             	add    %rax,%rax
  8004200bc4:	48 01 c2             	add    %rax,%rdx
  8004200bc7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bca:	b0 00                	mov    $0x0,%al
  8004200bcc:	83 c8 20             	or     $0x20,%eax
  8004200bcf:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200bd2:	e9 03 01 00 00       	jmpq   8004200cda <cga_putc+0x1b7>
	case '\n':
		crt_pos += CRT_COLS;
  8004200bd7:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200bde:	00 00 00 
  8004200be1:	0f b7 00             	movzwl (%rax),%eax
  8004200be4:	8d 50 50             	lea    0x50(%rax),%edx
  8004200be7:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200bee:	00 00 00 
  8004200bf1:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200bf4:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200bfb:	00 00 00 
  8004200bfe:	0f b7 30             	movzwl (%rax),%esi
  8004200c01:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200c08:	00 00 00 
  8004200c0b:	0f b7 08             	movzwl (%rax),%ecx
  8004200c0e:	0f b7 c1             	movzwl %cx,%eax
  8004200c11:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c17:	c1 e8 10             	shr    $0x10,%eax
  8004200c1a:	89 c2                	mov    %eax,%edx
  8004200c1c:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c20:	89 d0                	mov    %edx,%eax
  8004200c22:	c1 e0 02             	shl    $0x2,%eax
  8004200c25:	01 d0                	add    %edx,%eax
  8004200c27:	c1 e0 04             	shl    $0x4,%eax
  8004200c2a:	89 ca                	mov    %ecx,%edx
  8004200c2c:	66 29 c2             	sub    %ax,%dx
  8004200c2f:	89 f0                	mov    %esi,%eax
  8004200c31:	66 29 d0             	sub    %dx,%ax
  8004200c34:	89 c2                	mov    %eax,%edx
  8004200c36:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200c3d:	00 00 00 
  8004200c40:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c43:	e9 93 00 00 00       	jmpq   8004200cdb <cga_putc+0x1b8>
	case '\t':
		cons_putc(' ');
  8004200c48:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c4d:	48 b8 e1 11 20 04 80 	movabs $0x80042011e1,%rax
  8004200c54:	00 00 00 
  8004200c57:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c59:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c5e:	48 b8 e1 11 20 04 80 	movabs $0x80042011e1,%rax
  8004200c65:	00 00 00 
  8004200c68:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c6a:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c6f:	48 b8 e1 11 20 04 80 	movabs $0x80042011e1,%rax
  8004200c76:	00 00 00 
  8004200c79:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c7b:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c80:	48 b8 e1 11 20 04 80 	movabs $0x80042011e1,%rax
  8004200c87:	00 00 00 
  8004200c8a:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c8c:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c91:	48 b8 e1 11 20 04 80 	movabs $0x80042011e1,%rax
  8004200c98:	00 00 00 
  8004200c9b:	ff d0                	callq  *%rax
		break;
  8004200c9d:	eb 3c                	jmp    8004200cdb <cga_putc+0x1b8>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200c9f:	48 b8 08 20 48 04 80 	movabs $0x8004482008,%rax
  8004200ca6:	00 00 00 
  8004200ca9:	48 8b 10             	mov    (%rax),%rdx
  8004200cac:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200cb3:	00 00 00 
  8004200cb6:	0f b7 00             	movzwl (%rax),%eax
  8004200cb9:	0f b7 c8             	movzwl %ax,%ecx
  8004200cbc:	48 01 c9             	add    %rcx,%rcx
  8004200cbf:	48 01 d1             	add    %rdx,%rcx
  8004200cc2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200cc5:	66 89 11             	mov    %dx,(%rcx)
  8004200cc8:	8d 50 01             	lea    0x1(%rax),%edx
  8004200ccb:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200cd2:	00 00 00 
  8004200cd5:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200cd8:	eb 01                	jmp    8004200cdb <cga_putc+0x1b8>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
  8004200cda:	90                   	nop
		crt_buf[crt_pos++] = c;		/* write the character */
		break;
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200cdb:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200ce2:	00 00 00 
  8004200ce5:	0f b7 00             	movzwl (%rax),%eax
  8004200ce8:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200cec:	0f 86 89 00 00 00    	jbe    8004200d7b <cga_putc+0x258>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200cf2:	48 b8 08 20 48 04 80 	movabs $0x8004482008,%rax
  8004200cf9:	00 00 00 
  8004200cfc:	48 8b 00             	mov    (%rax),%rax
  8004200cff:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200d06:	48 b8 08 20 48 04 80 	movabs $0x8004482008,%rax
  8004200d0d:	00 00 00 
  8004200d10:	48 8b 00             	mov    (%rax),%rax
  8004200d13:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200d18:	48 89 ce             	mov    %rcx,%rsi
  8004200d1b:	48 89 c7             	mov    %rax,%rdi
  8004200d1e:	48 b8 d2 03 21 04 80 	movabs $0x80042103d2,%rax
  8004200d25:	00 00 00 
  8004200d28:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d2a:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d31:	eb 22                	jmp    8004200d55 <cga_putc+0x232>
			crt_buf[i] = 0x0700 | ' ';
  8004200d33:	48 b8 08 20 48 04 80 	movabs $0x8004482008,%rax
  8004200d3a:	00 00 00 
  8004200d3d:	48 8b 00             	mov    (%rax),%rax
  8004200d40:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d43:	48 63 d2             	movslq %edx,%rdx
  8004200d46:	48 01 d2             	add    %rdx,%rdx
  8004200d49:	48 01 d0             	add    %rdx,%rax
  8004200d4c:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d51:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d55:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d5c:	7e d5                	jle    8004200d33 <cga_putc+0x210>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d5e:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200d65:	00 00 00 
  8004200d68:	0f b7 00             	movzwl (%rax),%eax
  8004200d6b:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d6e:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200d75:	00 00 00 
  8004200d78:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d7b:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200d82:	00 00 00 
  8004200d85:	8b 00                	mov    (%rax),%eax
  8004200d87:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d8a:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d8e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d92:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d95:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d96:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200d9d:	00 00 00 
  8004200da0:	0f b7 00             	movzwl (%rax),%eax
  8004200da3:	66 c1 e8 08          	shr    $0x8,%ax
  8004200da7:	0f b6 c0             	movzbl %al,%eax
  8004200daa:	48 ba 04 20 48 04 80 	movabs $0x8004482004,%rdx
  8004200db1:	00 00 00 
  8004200db4:	8b 12                	mov    (%rdx),%edx
  8004200db6:	83 c2 01             	add    $0x1,%edx
  8004200db9:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200dbc:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200dbf:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200dc3:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200dc6:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200dc7:	48 b8 04 20 48 04 80 	movabs $0x8004482004,%rax
  8004200dce:	00 00 00 
  8004200dd1:	8b 00                	mov    (%rax),%eax
  8004200dd3:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200dd6:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200dda:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200dde:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200de1:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200de2:	48 b8 10 20 48 04 80 	movabs $0x8004482010,%rax
  8004200de9:	00 00 00 
  8004200dec:	0f b7 00             	movzwl (%rax),%eax
  8004200def:	0f b6 c0             	movzbl %al,%eax
  8004200df2:	48 ba 04 20 48 04 80 	movabs $0x8004482004,%rdx
  8004200df9:	00 00 00 
  8004200dfc:	8b 12                	mov    (%rdx),%edx
  8004200dfe:	83 c2 01             	add    $0x1,%edx
  8004200e01:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200e04:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200e07:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200e0b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200e0e:	ee                   	out    %al,(%dx)
}
  8004200e0f:	c9                   	leaveq 
  8004200e10:	c3                   	retq   

0000008004200e11 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200e11:	55                   	push   %rbp
  8004200e12:	48 89 e5             	mov    %rsp,%rbp
  8004200e15:	53                   	push   %rbx
  8004200e16:	48 83 ec 38          	sub    $0x38,%rsp
  8004200e1a:	c7 45 e4 64 00 00 00 	movl   $0x64,-0x1c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e21:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200e24:	89 55 cc             	mov    %edx,-0x34(%rbp)
  8004200e27:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200e2a:	ec                   	in     (%dx),%al
  8004200e2b:	89 c3                	mov    %eax,%ebx
  8004200e2d:	88 5d e3             	mov    %bl,-0x1d(%rbp)
    return data;
  8004200e30:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e34:	0f b6 c0             	movzbl %al,%eax
  8004200e37:	83 e0 01             	and    $0x1,%eax
  8004200e3a:	85 c0                	test   %eax,%eax
  8004200e3c:	75 0a                	jne    8004200e48 <kbd_proc_data+0x37>
		return -1;
  8004200e3e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e43:	e9 02 02 00 00       	jmpq   800420104a <kbd_proc_data+0x239>
  8004200e48:	c7 45 dc 60 00 00 00 	movl   $0x60,-0x24(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e4f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200e52:	89 55 cc             	mov    %edx,-0x34(%rbp)
  8004200e55:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200e58:	ec                   	in     (%dx),%al
  8004200e59:	89 c3                	mov    %eax,%ebx
  8004200e5b:	88 5d db             	mov    %bl,-0x25(%rbp)
    return data;
  8004200e5e:	0f b6 45 db          	movzbl -0x25(%rbp),%eax

	data = inb(KBDATAP);
  8004200e62:	88 45 eb             	mov    %al,-0x15(%rbp)

	if (data == 0xE0) {
  8004200e65:	80 7d eb e0          	cmpb   $0xe0,-0x15(%rbp)
  8004200e69:	75 27                	jne    8004200e92 <kbd_proc_data+0x81>
		// E0 escape character
		shift |= E0ESC;
  8004200e6b:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200e72:	00 00 00 
  8004200e75:	8b 00                	mov    (%rax),%eax
  8004200e77:	89 c2                	mov    %eax,%edx
  8004200e79:	83 ca 40             	or     $0x40,%edx
  8004200e7c:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200e83:	00 00 00 
  8004200e86:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e8d:	e9 b8 01 00 00       	jmpq   800420104a <kbd_proc_data+0x239>
	} else if (data & 0x80) {
  8004200e92:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200e96:	84 c0                	test   %al,%al
  8004200e98:	79 65                	jns    8004200eff <kbd_proc_data+0xee>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e9a:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200ea1:	00 00 00 
  8004200ea4:	8b 00                	mov    (%rax),%eax
  8004200ea6:	83 e0 40             	and    $0x40,%eax
  8004200ea9:	85 c0                	test   %eax,%eax
  8004200eab:	75 09                	jne    8004200eb6 <kbd_proc_data+0xa5>
  8004200ead:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200eb1:	83 e0 7f             	and    $0x7f,%eax
  8004200eb4:	eb 04                	jmp    8004200eba <kbd_proc_data+0xa9>
  8004200eb6:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200eba:	88 45 eb             	mov    %al,-0x15(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200ebd:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200ec1:	48 ba 60 00 23 04 80 	movabs $0x8004230060,%rdx
  8004200ec8:	00 00 00 
  8004200ecb:	48 98                	cltq   
  8004200ecd:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ed1:	83 c8 40             	or     $0x40,%eax
  8004200ed4:	0f b6 c0             	movzbl %al,%eax
  8004200ed7:	f7 d0                	not    %eax
  8004200ed9:	89 c2                	mov    %eax,%edx
  8004200edb:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200ee2:	00 00 00 
  8004200ee5:	8b 00                	mov    (%rax),%eax
  8004200ee7:	21 c2                	and    %eax,%edx
  8004200ee9:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200ef0:	00 00 00 
  8004200ef3:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200ef5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200efa:	e9 4b 01 00 00       	jmpq   800420104a <kbd_proc_data+0x239>
	} else if (shift & E0ESC) {
  8004200eff:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f06:	00 00 00 
  8004200f09:	8b 00                	mov    (%rax),%eax
  8004200f0b:	83 e0 40             	and    $0x40,%eax
  8004200f0e:	85 c0                	test   %eax,%eax
  8004200f10:	74 21                	je     8004200f33 <kbd_proc_data+0x122>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200f12:	80 4d eb 80          	orb    $0x80,-0x15(%rbp)
		shift &= ~E0ESC;
  8004200f16:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f1d:	00 00 00 
  8004200f20:	8b 00                	mov    (%rax),%eax
  8004200f22:	89 c2                	mov    %eax,%edx
  8004200f24:	83 e2 bf             	and    $0xffffffbf,%edx
  8004200f27:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f2e:	00 00 00 
  8004200f31:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f33:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200f37:	48 ba 60 00 23 04 80 	movabs $0x8004230060,%rdx
  8004200f3e:	00 00 00 
  8004200f41:	48 98                	cltq   
  8004200f43:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f47:	0f b6 d0             	movzbl %al,%edx
  8004200f4a:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f51:	00 00 00 
  8004200f54:	8b 00                	mov    (%rax),%eax
  8004200f56:	09 c2                	or     %eax,%edx
  8004200f58:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f5f:	00 00 00 
  8004200f62:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f64:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200f68:	48 ba 60 01 23 04 80 	movabs $0x8004230160,%rdx
  8004200f6f:	00 00 00 
  8004200f72:	48 98                	cltq   
  8004200f74:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f78:	0f b6 d0             	movzbl %al,%edx
  8004200f7b:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f82:	00 00 00 
  8004200f85:	8b 00                	mov    (%rax),%eax
  8004200f87:	31 c2                	xor    %eax,%edx
  8004200f89:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f90:	00 00 00 
  8004200f93:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f95:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200f9c:	00 00 00 
  8004200f9f:	8b 00                	mov    (%rax),%eax
  8004200fa1:	89 c2                	mov    %eax,%edx
  8004200fa3:	83 e2 03             	and    $0x3,%edx
  8004200fa6:	48 b8 60 05 23 04 80 	movabs $0x8004230560,%rax
  8004200fad:	00 00 00 
  8004200fb0:	89 d2                	mov    %edx,%edx
  8004200fb2:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200fb6:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200fba:	48 01 d0             	add    %rdx,%rax
  8004200fbd:	0f b6 00             	movzbl (%rax),%eax
  8004200fc0:	0f b6 c0             	movzbl %al,%eax
  8004200fc3:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (shift & CAPSLOCK) {
  8004200fc6:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004200fcd:	00 00 00 
  8004200fd0:	8b 00                	mov    (%rax),%eax
  8004200fd2:	83 e0 08             	and    $0x8,%eax
  8004200fd5:	85 c0                	test   %eax,%eax
  8004200fd7:	74 22                	je     8004200ffb <kbd_proc_data+0x1ea>
		if ('a' <= c && c <= 'z')
  8004200fd9:	83 7d ec 60          	cmpl   $0x60,-0x14(%rbp)
  8004200fdd:	7e 0c                	jle    8004200feb <kbd_proc_data+0x1da>
  8004200fdf:	83 7d ec 7a          	cmpl   $0x7a,-0x14(%rbp)
  8004200fe3:	7f 06                	jg     8004200feb <kbd_proc_data+0x1da>
			c += 'A' - 'a';
  8004200fe5:	83 6d ec 20          	subl   $0x20,-0x14(%rbp)
  8004200fe9:	eb 10                	jmp    8004200ffb <kbd_proc_data+0x1ea>
		else if ('A' <= c && c <= 'Z')
  8004200feb:	83 7d ec 40          	cmpl   $0x40,-0x14(%rbp)
  8004200fef:	7e 0a                	jle    8004200ffb <kbd_proc_data+0x1ea>
  8004200ff1:	83 7d ec 5a          	cmpl   $0x5a,-0x14(%rbp)
  8004200ff5:	7f 04                	jg     8004200ffb <kbd_proc_data+0x1ea>
			c += 'a' - 'A';
  8004200ff7:	83 45 ec 20          	addl   $0x20,-0x14(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200ffb:	48 b8 28 22 48 04 80 	movabs $0x8004482228,%rax
  8004201002:	00 00 00 
  8004201005:	8b 00                	mov    (%rax),%eax
  8004201007:	f7 d0                	not    %eax
  8004201009:	83 e0 06             	and    $0x6,%eax
  800420100c:	85 c0                	test   %eax,%eax
  800420100e:	75 37                	jne    8004201047 <kbd_proc_data+0x236>
  8004201010:	81 7d ec e9 00 00 00 	cmpl   $0xe9,-0x14(%rbp)
  8004201017:	75 2e                	jne    8004201047 <kbd_proc_data+0x236>
		cprintf("Rebooting!\n");
  8004201019:	48 bf ce c4 21 04 80 	movabs $0x800421c4ce,%rdi
  8004201020:	00 00 00 
  8004201023:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201028:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420102f:	00 00 00 
  8004201032:	ff d2                	callq  *%rdx
  8004201034:	c7 45 d4 92 00 00 00 	movl   $0x92,-0x2c(%rbp)
  800420103b:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420103f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004201043:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004201046:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
  8004201047:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  800420104a:	48 83 c4 38          	add    $0x38,%rsp
  800420104e:	5b                   	pop    %rbx
  800420104f:	5d                   	pop    %rbp
  8004201050:	c3                   	retq   

0000008004201051 <kbd_intr>:

void
kbd_intr(void)
{
  8004201051:	55                   	push   %rbp
  8004201052:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004201055:	48 bf 11 0e 20 04 80 	movabs $0x8004200e11,%rdi
  800420105c:	00 00 00 
  800420105f:	48 b8 a2 10 20 04 80 	movabs $0x80042010a2,%rax
  8004201066:	00 00 00 
  8004201069:	ff d0                	callq  *%rax
}
  800420106b:	5d                   	pop    %rbp
  800420106c:	c3                   	retq   

000000800420106d <kbd_init>:

static void
kbd_init(void)
{
  800420106d:	55                   	push   %rbp
  800420106e:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201071:	48 b8 51 10 20 04 80 	movabs $0x8004201051,%rax
  8004201078:	00 00 00 
  800420107b:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  800420107d:	48 b8 04 06 23 04 80 	movabs $0x8004230604,%rax
  8004201084:	00 00 00 
  8004201087:	0f b7 00             	movzwl (%rax),%eax
  800420108a:	0f b7 c0             	movzwl %ax,%eax
  800420108d:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201092:	89 c7                	mov    %eax,%edi
  8004201094:	48 b8 c6 8e 20 04 80 	movabs $0x8004208ec6,%rax
  800420109b:	00 00 00 
  800420109e:	ff d0                	callq  *%rax
}
  80042010a0:	5d                   	pop    %rbp
  80042010a1:	c3                   	retq   

00000080042010a2 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  80042010a2:	55                   	push   %rbp
  80042010a3:	48 89 e5             	mov    %rsp,%rbp
  80042010a6:	48 83 ec 20          	sub    $0x20,%rsp
  80042010aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  80042010ae:	eb 6c                	jmp    800420111c <cons_intr+0x7a>
		if (c == 0)
  80042010b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042010b4:	74 65                	je     800420111b <cons_intr+0x79>
			continue;
		cons.buf[cons.wpos++] = c;
  80042010b6:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  80042010bd:	00 00 00 
  80042010c0:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010c6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010c9:	89 d6                	mov    %edx,%esi
  80042010cb:	48 b9 20 20 48 04 80 	movabs $0x8004482020,%rcx
  80042010d2:	00 00 00 
  80042010d5:	89 c2                	mov    %eax,%edx
  80042010d7:	40 88 34 11          	mov    %sil,(%rcx,%rdx,1)
  80042010db:	8d 50 01             	lea    0x1(%rax),%edx
  80042010de:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  80042010e5:	00 00 00 
  80042010e8:	89 90 04 02 00 00    	mov    %edx,0x204(%rax)
		if (cons.wpos == CONSBUFSIZE)
  80042010ee:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  80042010f5:	00 00 00 
  80042010f8:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010fe:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201103:	75 17                	jne    800420111c <cons_intr+0x7a>
			cons.wpos = 0;
  8004201105:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  800420110c:	00 00 00 
  800420110f:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  8004201116:	00 00 00 
  8004201119:	eb 01                	jmp    800420111c <cons_intr+0x7a>
{
	int c;

	while ((c = (*proc)()) != -1) {
		if (c == 0)
			continue;
  800420111b:	90                   	nop
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420111c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201120:	ff d0                	callq  *%rax
  8004201122:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201125:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004201129:	75 85                	jne    80042010b0 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  800420112b:	c9                   	leaveq 
  800420112c:	c3                   	retq   

000000800420112d <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420112d:	55                   	push   %rbp
  800420112e:	48 89 e5             	mov    %rsp,%rbp
  8004201131:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201135:	48 b8 a8 07 20 04 80 	movabs $0x80042007a8,%rax
  800420113c:	00 00 00 
  800420113f:	ff d0                	callq  *%rax
	kbd_intr();
  8004201141:	48 b8 51 10 20 04 80 	movabs $0x8004201051,%rax
  8004201148:	00 00 00 
  800420114b:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  800420114d:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  8004201154:	00 00 00 
  8004201157:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  800420115d:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  8004201164:	00 00 00 
  8004201167:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420116d:	39 c2                	cmp    %eax,%edx
  800420116f:	74 69                	je     80042011da <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201171:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  8004201178:	00 00 00 
  800420117b:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201181:	48 b9 20 20 48 04 80 	movabs $0x8004482020,%rcx
  8004201188:	00 00 00 
  800420118b:	89 c2                	mov    %eax,%edx
  800420118d:	0f b6 14 11          	movzbl (%rcx,%rdx,1),%edx
  8004201191:	0f b6 d2             	movzbl %dl,%edx
  8004201194:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201197:	8d 50 01             	lea    0x1(%rax),%edx
  800420119a:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  80042011a1:	00 00 00 
  80042011a4:	89 90 00 02 00 00    	mov    %edx,0x200(%rax)
		if (cons.rpos == CONSBUFSIZE)
  80042011aa:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  80042011b1:	00 00 00 
  80042011b4:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042011ba:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042011bf:	75 14                	jne    80042011d5 <cons_getc+0xa8>
			cons.rpos = 0;
  80042011c1:	48 b8 20 20 48 04 80 	movabs $0x8004482020,%rax
  80042011c8:	00 00 00 
  80042011cb:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042011d2:	00 00 00 
		return c;
  80042011d5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011d8:	eb 05                	jmp    80042011df <cons_getc+0xb2>
	}
	return 0;
  80042011da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042011df:	c9                   	leaveq 
  80042011e0:	c3                   	retq   

00000080042011e1 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042011e1:	55                   	push   %rbp
  80042011e2:	48 89 e5             	mov    %rsp,%rbp
  80042011e5:	48 83 ec 10          	sub    $0x10,%rsp
  80042011e9:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042011ec:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011ef:	89 c7                	mov    %eax,%edi
  80042011f1:	48 b8 d5 07 20 04 80 	movabs $0x80042007d5,%rax
  80042011f8:	00 00 00 
  80042011fb:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042011fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201200:	89 c7                	mov    %eax,%edi
  8004201202:	48 b8 66 09 20 04 80 	movabs $0x8004200966,%rax
  8004201209:	00 00 00 
  800420120c:	ff d0                	callq  *%rax
	cga_putc(c);
  800420120e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201211:	89 c7                	mov    %eax,%edi
  8004201213:	48 b8 23 0b 20 04 80 	movabs $0x8004200b23,%rax
  800420121a:	00 00 00 
  800420121d:	ff d0                	callq  *%rax
}
  800420121f:	c9                   	leaveq 
  8004201220:	c3                   	retq   

0000008004201221 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201221:	55                   	push   %rbp
  8004201222:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201225:	48 b8 f7 09 20 04 80 	movabs $0x80042009f7,%rax
  800420122c:	00 00 00 
  800420122f:	ff d0                	callq  *%rax
	kbd_init();
  8004201231:	48 b8 6d 10 20 04 80 	movabs $0x800420106d,%rax
  8004201238:	00 00 00 
  800420123b:	ff d0                	callq  *%rax
	serial_init();
  800420123d:	48 b8 46 08 20 04 80 	movabs $0x8004200846,%rax
  8004201244:	00 00 00 
  8004201247:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004201249:	48 b8 00 20 48 04 80 	movabs $0x8004482000,%rax
  8004201250:	00 00 00 
  8004201253:	0f b6 00             	movzbl (%rax),%eax
  8004201256:	83 f0 01             	xor    $0x1,%eax
  8004201259:	84 c0                	test   %al,%al
  800420125b:	74 1b                	je     8004201278 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  800420125d:	48 bf da c4 21 04 80 	movabs $0x800421c4da,%rdi
  8004201264:	00 00 00 
  8004201267:	b8 00 00 00 00       	mov    $0x0,%eax
  800420126c:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004201273:	00 00 00 
  8004201276:	ff d2                	callq  *%rdx
}
  8004201278:	5d                   	pop    %rbp
  8004201279:	c3                   	retq   

000000800420127a <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420127a:	55                   	push   %rbp
  800420127b:	48 89 e5             	mov    %rsp,%rbp
  800420127e:	48 83 ec 10          	sub    $0x10,%rsp
  8004201282:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201285:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201288:	89 c7                	mov    %eax,%edi
  800420128a:	48 b8 e1 11 20 04 80 	movabs $0x80042011e1,%rax
  8004201291:	00 00 00 
  8004201294:	ff d0                	callq  *%rax
}
  8004201296:	c9                   	leaveq 
  8004201297:	c3                   	retq   

0000008004201298 <getchar>:

int
getchar(void)
{
  8004201298:	55                   	push   %rbp
  8004201299:	48 89 e5             	mov    %rsp,%rbp
  800420129c:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042012a0:	48 b8 2d 11 20 04 80 	movabs $0x800420112d,%rax
  80042012a7:	00 00 00 
  80042012aa:	ff d0                	callq  *%rax
  80042012ac:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042012af:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042012b3:	74 eb                	je     80042012a0 <getchar+0x8>
		/* do nothing */;
	return c;
  80042012b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042012b8:	c9                   	leaveq 
  80042012b9:	c3                   	retq   

00000080042012ba <iscons>:

int
iscons(int fdnum)
{
  80042012ba:	55                   	push   %rbp
  80042012bb:	48 89 e5             	mov    %rsp,%rbp
  80042012be:	48 83 ec 08          	sub    $0x8,%rsp
  80042012c2:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042012c5:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042012ca:	c9                   	leaveq 
  80042012cb:	c3                   	retq   

00000080042012cc <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012cc:	55                   	push   %rbp
  80042012cd:	48 89 e5             	mov    %rsp,%rbp
  80042012d0:	48 83 ec 30          	sub    $0x30,%rsp
  80042012d4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012d7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012db:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012e6:	eb 6c                	jmp    8004201354 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012e8:	48 b9 80 05 23 04 80 	movabs $0x8004230580,%rcx
  80042012ef:	00 00 00 
  80042012f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012f5:	48 63 d0             	movslq %eax,%rdx
  80042012f8:	48 89 d0             	mov    %rdx,%rax
  80042012fb:	48 01 c0             	add    %rax,%rax
  80042012fe:	48 01 d0             	add    %rdx,%rax
  8004201301:	48 c1 e0 03          	shl    $0x3,%rax
  8004201305:	48 01 c8             	add    %rcx,%rax
  8004201308:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420130c:	48 be 80 05 23 04 80 	movabs $0x8004230580,%rsi
  8004201313:	00 00 00 
  8004201316:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201319:	48 63 d0             	movslq %eax,%rdx
  800420131c:	48 89 d0             	mov    %rdx,%rax
  800420131f:	48 01 c0             	add    %rax,%rax
  8004201322:	48 01 d0             	add    %rdx,%rax
  8004201325:	48 c1 e0 03          	shl    $0x3,%rax
  8004201329:	48 01 f0             	add    %rsi,%rax
  800420132c:	48 8b 00             	mov    (%rax),%rax
  800420132f:	48 89 ca             	mov    %rcx,%rdx
  8004201332:	48 89 c6             	mov    %rax,%rsi
  8004201335:	48 bf 4d c5 21 04 80 	movabs $0x800421c54d,%rdi
  800420133c:	00 00 00 
  800420133f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201344:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420134b:	00 00 00 
  800420134e:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201350:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201354:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201357:	83 f8 01             	cmp    $0x1,%eax
  800420135a:	76 8c                	jbe    80042012e8 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  800420135c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201361:	c9                   	leaveq 
  8004201362:	c3                   	retq   

0000008004201363 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201363:	55                   	push   %rbp
  8004201364:	48 89 e5             	mov    %rsp,%rbp
  8004201367:	48 83 ec 30          	sub    $0x30,%rsp
  800420136b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420136e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201372:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004201376:	48 bf 56 c5 21 04 80 	movabs $0x800421c556,%rdi
  800420137d:	00 00 00 
  8004201380:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201385:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420138c:	00 00 00 
  800420138f:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201391:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  8004201398:	00 00 00 
  800420139b:	48 bf 70 c5 21 04 80 	movabs $0x800421c570,%rdi
  80042013a2:	00 00 00 
  80042013a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013aa:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042013b1:	00 00 00 
  80042013b4:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042013b6:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013bd:	00 00 00 
  80042013c0:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013c7:	00 00 00 
  80042013ca:	48 bf 98 c5 21 04 80 	movabs $0x800421c598,%rdi
  80042013d1:	00 00 00 
  80042013d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013d9:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  80042013e0:	00 00 00 
  80042013e3:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013e5:	48 ba ec c3 21 00 00 	movabs $0x21c3ec,%rdx
  80042013ec:	00 00 00 
  80042013ef:	48 be ec c3 21 04 80 	movabs $0x800421c3ec,%rsi
  80042013f6:	00 00 00 
  80042013f9:	48 bf c0 c5 21 04 80 	movabs $0x800421c5c0,%rdi
  8004201400:	00 00 00 
  8004201403:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201408:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420140f:	00 00 00 
  8004201412:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201414:	48 ba 5e 14 48 00 00 	movabs $0x48145e,%rdx
  800420141b:	00 00 00 
  800420141e:	48 be 5e 14 48 04 80 	movabs $0x800448145e,%rsi
  8004201425:	00 00 00 
  8004201428:	48 bf e8 c5 21 04 80 	movabs $0x800421c5e8,%rdi
  800420142f:	00 00 00 
  8004201432:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201437:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420143e:	00 00 00 
  8004201441:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201443:	48 ba 10 60 49 00 00 	movabs $0x496010,%rdx
  800420144a:	00 00 00 
  800420144d:	48 be 10 60 49 04 80 	movabs $0x8004496010,%rsi
  8004201454:	00 00 00 
  8004201457:	48 bf 10 c6 21 04 80 	movabs $0x800421c610,%rdi
  800420145e:	00 00 00 
  8004201461:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201466:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420146d:	00 00 00 
  8004201470:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201472:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004201479:	00 
  800420147a:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201481:	00 00 00 
  8004201484:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201488:	48 29 c2             	sub    %rax,%rdx
  800420148b:	48 b8 10 60 49 04 80 	movabs $0x8004496010,%rax
  8004201492:	00 00 00 
  8004201495:	48 83 e8 01          	sub    $0x1,%rax
  8004201499:	48 01 d0             	add    %rdx,%rax
  800420149c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042014a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042014a4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042014a9:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042014ad:	48 89 d0             	mov    %rdx,%rax
  80042014b0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014b4:	48 89 d1             	mov    %rdx,%rcx
  80042014b7:	48 29 c1             	sub    %rax,%rcx
  80042014ba:	48 89 c8             	mov    %rcx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014bd:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014c4:	48 85 c0             	test   %rax,%rax
  80042014c7:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014cb:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014cf:	48 89 c6             	mov    %rax,%rsi
  80042014d2:	48 bf 38 c6 21 04 80 	movabs $0x800421c638,%rdi
  80042014d9:	00 00 00 
  80042014dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014e1:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042014e8:	00 00 00 
  80042014eb:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014f2:	c9                   	leaveq 
  80042014f3:	c3                   	retq   

00000080042014f4 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042014f4:	55                   	push   %rbp
  80042014f5:	48 89 e5             	mov    %rsp,%rbp
  80042014f8:	48 83 ec 18          	sub    $0x18,%rsp
  80042014fc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042014ff:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004201503:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Your code here.
	return 0;
  8004201507:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420150c:	c9                   	leaveq 
  800420150d:	c3                   	retq   

000000800420150e <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420150e:	55                   	push   %rbp
  800420150f:	48 89 e5             	mov    %rsp,%rbp
  8004201512:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201519:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201520:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201527:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  800420152e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201531:	48 98                	cltq   
  8004201533:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  800420153a:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420153f:	eb 15                	jmp    8004201556 <runcmd+0x48>
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
  8004201541:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201542:	eb 12                	jmp    8004201556 <runcmd+0x48>
			*buf++ = 0;
  8004201544:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420154b:	c6 00 00             	movb   $0x0,(%rax)
  800420154e:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201555:	01 
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201556:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420155d:	0f b6 00             	movzbl (%rax),%eax
  8004201560:	84 c0                	test   %al,%al
  8004201562:	74 2a                	je     800420158e <runcmd+0x80>
  8004201564:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420156b:	0f b6 00             	movzbl (%rax),%eax
  800420156e:	0f be c0             	movsbl %al,%eax
  8004201571:	89 c6                	mov    %eax,%esi
  8004201573:	48 bf 62 c6 21 04 80 	movabs $0x800421c662,%rdi
  800420157a:	00 00 00 
  800420157d:	48 b8 d3 02 21 04 80 	movabs $0x80042102d3,%rax
  8004201584:	00 00 00 
  8004201587:	ff d0                	callq  *%rax
  8004201589:	48 85 c0             	test   %rax,%rax
  800420158c:	75 b6                	jne    8004201544 <runcmd+0x36>
			*buf++ = 0;
		if (*buf == 0)
  800420158e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201595:	0f b6 00             	movzbl (%rax),%eax
  8004201598:	84 c0                	test   %al,%al
  800420159a:	0f 84 93 00 00 00    	je     8004201633 <runcmd+0x125>
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042015a0:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042015a4:	75 2a                	jne    80042015d0 <runcmd+0xc2>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042015a6:	be 10 00 00 00       	mov    $0x10,%esi
  80042015ab:	48 bf 67 c6 21 04 80 	movabs $0x800421c667,%rdi
  80042015b2:	00 00 00 
  80042015b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015ba:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042015c1:	00 00 00 
  80042015c4:	ff d2                	callq  *%rdx
			return 0;
  80042015c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015cb:	e9 4d 01 00 00       	jmpq   800420171d <runcmd+0x20f>
		}
		argv[argc++] = buf;
  80042015d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042015d3:	48 98                	cltq   
  80042015d5:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  80042015dc:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  80042015e3:	ff 
  80042015e4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		while (*buf && !strchr(WHITESPACE, *buf))
  80042015e8:	eb 08                	jmp    80042015f2 <runcmd+0xe4>
			buf++;
  80042015ea:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  80042015f1:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  80042015f2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042015f9:	0f b6 00             	movzbl (%rax),%eax
  80042015fc:	84 c0                	test   %al,%al
  80042015fe:	0f 84 3d ff ff ff    	je     8004201541 <runcmd+0x33>
  8004201604:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420160b:	0f b6 00             	movzbl (%rax),%eax
  800420160e:	0f be c0             	movsbl %al,%eax
  8004201611:	89 c6                	mov    %eax,%esi
  8004201613:	48 bf 62 c6 21 04 80 	movabs $0x800421c662,%rdi
  800420161a:	00 00 00 
  800420161d:	48 b8 d3 02 21 04 80 	movabs $0x80042102d3,%rax
  8004201624:	00 00 00 
  8004201627:	ff d0                	callq  *%rax
  8004201629:	48 85 c0             	test   %rax,%rax
  800420162c:	74 bc                	je     80042015ea <runcmd+0xdc>
			buf++;
	}
  800420162e:	e9 0e ff ff ff       	jmpq   8004201541 <runcmd+0x33>
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
			*buf++ = 0;
		if (*buf == 0)
			break;
  8004201633:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  8004201634:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201637:	48 98                	cltq   
  8004201639:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201640:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004201645:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201649:	75 0a                	jne    8004201655 <runcmd+0x147>
		return 0;
  800420164b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201650:	e9 c8 00 00 00       	jmpq   800420171d <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201655:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420165c:	e9 86 00 00 00       	jmpq   80042016e7 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201661:	48 b9 80 05 23 04 80 	movabs $0x8004230580,%rcx
  8004201668:	00 00 00 
  800420166b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420166e:	48 63 d0             	movslq %eax,%rdx
  8004201671:	48 89 d0             	mov    %rdx,%rax
  8004201674:	48 01 c0             	add    %rax,%rax
  8004201677:	48 01 d0             	add    %rdx,%rax
  800420167a:	48 c1 e0 03          	shl    $0x3,%rax
  800420167e:	48 01 c8             	add    %rcx,%rax
  8004201681:	48 8b 10             	mov    (%rax),%rdx
  8004201684:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800420168b:	48 89 d6             	mov    %rdx,%rsi
  800420168e:	48 89 c7             	mov    %rax,%rdi
  8004201691:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004201698:	00 00 00 
  800420169b:	ff d0                	callq  *%rax
  800420169d:	85 c0                	test   %eax,%eax
  800420169f:	75 42                	jne    80042016e3 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  80042016a1:	48 b9 80 05 23 04 80 	movabs $0x8004230580,%rcx
  80042016a8:	00 00 00 
  80042016ab:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042016ae:	48 63 d0             	movslq %eax,%rdx
  80042016b1:	48 89 d0             	mov    %rdx,%rax
  80042016b4:	48 01 c0             	add    %rax,%rax
  80042016b7:	48 01 d0             	add    %rdx,%rax
  80042016ba:	48 c1 e0 03          	shl    $0x3,%rax
  80042016be:	48 01 c8             	add    %rcx,%rax
  80042016c1:	48 83 c0 10          	add    $0x10,%rax
  80042016c5:	4c 8b 00             	mov    (%rax),%r8
  80042016c8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042016cf:	48 8d 8d 70 ff ff ff 	lea    -0x90(%rbp),%rcx
  80042016d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042016d9:	48 89 ce             	mov    %rcx,%rsi
  80042016dc:	89 c7                	mov    %eax,%edi
  80042016de:	41 ff d0             	callq  *%r8
  80042016e1:	eb 3a                	jmp    800420171d <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  80042016e3:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  80042016e7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042016ea:	83 f8 01             	cmp    $0x1,%eax
  80042016ed:	0f 86 6e ff ff ff    	jbe    8004201661 <runcmd+0x153>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  80042016f3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042016fa:	48 89 c6             	mov    %rax,%rsi
  80042016fd:	48 bf 84 c6 21 04 80 	movabs $0x800421c684,%rdi
  8004201704:	00 00 00 
  8004201707:	b8 00 00 00 00       	mov    $0x0,%eax
  800420170c:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004201713:	00 00 00 
  8004201716:	ff d2                	callq  *%rdx
	return 0;
  8004201718:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420171d:	c9                   	leaveq 
  800420171e:	c3                   	retq   

000000800420171f <monitor>:

void
monitor(struct Trapframe *tf)
{
  800420171f:	55                   	push   %rbp
  8004201720:	48 89 e5             	mov    %rsp,%rbp
  8004201723:	48 83 ec 20          	sub    $0x20,%rsp
  8004201727:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  800420172b:	48 bf a0 c6 21 04 80 	movabs $0x800421c6a0,%rdi
  8004201732:	00 00 00 
  8004201735:	b8 00 00 00 00       	mov    $0x0,%eax
  800420173a:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004201741:	00 00 00 
  8004201744:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201746:	48 bf c8 c6 21 04 80 	movabs $0x800421c6c8,%rdi
  800420174d:	00 00 00 
  8004201750:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201755:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420175c:	00 00 00 
  800420175f:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201761:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201766:	74 16                	je     800420177e <monitor+0x5f>
		print_trapframe(tf);
  8004201768:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420176c:	48 89 c7             	mov    %rax,%rdi
  800420176f:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  8004201776:	00 00 00 
  8004201779:	ff d0                	callq  *%rax
  800420177b:	eb 01                	jmp    800420177e <monitor+0x5f>
	while (1) {
		buf = readline("K> ");
		if (buf != NULL)
			if (runcmd(buf, tf) < 0)
				break;
	}
  800420177d:	90                   	nop

	if (tf != NULL)
		print_trapframe(tf);

	while (1) {
		buf = readline("K> ");
  800420177e:	48 bf ed c6 21 04 80 	movabs $0x800421c6ed,%rdi
  8004201785:	00 00 00 
  8004201788:	48 b8 e8 fe 20 04 80 	movabs $0x800420fee8,%rax
  800420178f:	00 00 00 
  8004201792:	ff d0                	callq  *%rax
  8004201794:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201798:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420179d:	74 de                	je     800420177d <monitor+0x5e>
			if (runcmd(buf, tf) < 0)
  800420179f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042017a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017a7:	48 89 d6             	mov    %rdx,%rsi
  80042017aa:	48 89 c7             	mov    %rax,%rdi
  80042017ad:	48 b8 0e 15 20 04 80 	movabs $0x800420150e,%rax
  80042017b4:	00 00 00 
  80042017b7:	ff d0                	callq  *%rax
  80042017b9:	85 c0                	test   %eax,%eax
  80042017bb:	79 c0                	jns    800420177d <monitor+0x5e>
				break;
  80042017bd:	90                   	nop
	}
}
  80042017be:	c9                   	leaveq 
  80042017bf:	c3                   	retq   

00000080042017c0 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042017c0:	55                   	push   %rbp
  80042017c1:	48 89 e5             	mov    %rsp,%rbp
  80042017c4:	48 83 ec 08          	sub    $0x8,%rsp
  80042017c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042017cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042017d0:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  80042017d7:	00 00 00 
  80042017da:	48 8b 00             	mov    (%rax),%rax
  80042017dd:	48 89 d1             	mov    %rdx,%rcx
  80042017e0:	48 29 c1             	sub    %rax,%rcx
  80042017e3:	48 89 c8             	mov    %rcx,%rax
  80042017e6:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042017ea:	c9                   	leaveq 
  80042017eb:	c3                   	retq   

00000080042017ec <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042017ec:	55                   	push   %rbp
  80042017ed:	48 89 e5             	mov    %rsp,%rbp
  80042017f0:	48 83 ec 08          	sub    $0x8,%rsp
  80042017f4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042017f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017fc:	48 89 c7             	mov    %rax,%rdi
  80042017ff:	48 b8 c0 17 20 04 80 	movabs $0x80042017c0,%rax
  8004201806:	00 00 00 
  8004201809:	ff d0                	callq  *%rax
  800420180b:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420180f:	c9                   	leaveq 
  8004201810:	c3                   	retq   

0000008004201811 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201811:	55                   	push   %rbp
  8004201812:	48 89 e5             	mov    %rsp,%rbp
  8004201815:	48 83 ec 10          	sub    $0x10,%rsp
  8004201819:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420181d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201821:	48 89 c2             	mov    %rax,%rdx
  8004201824:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201828:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420182f:	00 00 00 
  8004201832:	48 8b 00             	mov    (%rax),%rax
  8004201835:	48 39 c2             	cmp    %rax,%rdx
  8004201838:	72 2a                	jb     8004201864 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420183a:	48 ba f8 c6 21 04 80 	movabs $0x800421c6f8,%rdx
  8004201841:	00 00 00 
  8004201844:	be 54 00 00 00       	mov    $0x54,%esi
  8004201849:	48 bf 17 c7 21 04 80 	movabs $0x800421c717,%rdi
  8004201850:	00 00 00 
  8004201853:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201858:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800420185f:	00 00 00 
  8004201862:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201864:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  800420186b:	00 00 00 
  800420186e:	48 8b 00             	mov    (%rax),%rax
  8004201871:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201875:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201879:	48 c1 e2 04          	shl    $0x4,%rdx
  800420187d:	48 01 d0             	add    %rdx,%rax
}
  8004201880:	c9                   	leaveq 
  8004201881:	c3                   	retq   

0000008004201882 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201882:	55                   	push   %rbp
  8004201883:	48 89 e5             	mov    %rsp,%rbp
  8004201886:	48 83 ec 20          	sub    $0x20,%rsp
  800420188a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420188e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201892:	48 89 c7             	mov    %rax,%rdi
  8004201895:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  800420189c:	00 00 00 
  800420189f:	ff d0                	callq  *%rax
  80042018a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042018a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018a9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042018ad:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042018b0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042018b3:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042018ba:	00 00 00 
  80042018bd:	48 8b 00             	mov    (%rax),%rax
  80042018c0:	48 39 c2             	cmp    %rax,%rdx
  80042018c3:	72 32                	jb     80042018f7 <page2kva+0x75>
  80042018c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018c9:	48 89 c1             	mov    %rax,%rcx
  80042018cc:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  80042018d3:	00 00 00 
  80042018d6:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042018db:	48 bf 17 c7 21 04 80 	movabs $0x800421c717,%rdi
  80042018e2:	00 00 00 
  80042018e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018ea:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042018f1:	00 00 00 
  80042018f4:	41 ff d0             	callq  *%r8
  80042018f7:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042018fe:	00 00 00 
  8004201901:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  8004201905:	c9                   	leaveq 
  8004201906:	c3                   	retq   

0000008004201907 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201907:	55                   	push   %rbp
  8004201908:	48 89 e5             	mov    %rsp,%rbp
  800420190b:	48 83 ec 08          	sub    $0x8,%rsp
  800420190f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201912:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201915:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201919:	74 06                	je     8004201921 <restrictive_type+0x1a>
  800420191b:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  800420191f:	75 07                	jne    8004201928 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201921:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201926:	eb 3e                	jmp    8004201966 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201928:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800420192c:	74 06                	je     8004201934 <restrictive_type+0x2d>
  800420192e:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201932:	75 07                	jne    800420193b <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201934:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201939:	eb 2b                	jmp    8004201966 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  800420193b:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  800420193f:	74 06                	je     8004201947 <restrictive_type+0x40>
  8004201941:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201945:	75 07                	jne    800420194e <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201947:	b8 02 00 00 00       	mov    $0x2,%eax
  800420194c:	eb 18                	jmp    8004201966 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  800420194e:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201952:	74 06                	je     800420195a <restrictive_type+0x53>
  8004201954:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201958:	75 07                	jne    8004201961 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  800420195a:	b8 03 00 00 00       	mov    $0x3,%eax
  800420195f:	eb 05                	jmp    8004201966 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201961:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201966:	c9                   	leaveq 
  8004201967:	c3                   	retq   

0000008004201968 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201968:	55                   	push   %rbp
  8004201969:	48 89 e5             	mov    %rsp,%rbp
  800420196c:	53                   	push   %rbx
  800420196d:	48 83 ec 18          	sub    $0x18,%rsp
  8004201971:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201974:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201977:	89 c7                	mov    %eax,%edi
  8004201979:	48 b8 ec 8c 20 04 80 	movabs $0x8004208cec,%rax
  8004201980:	00 00 00 
  8004201983:	ff d0                	callq  *%rax
  8004201985:	89 c3                	mov    %eax,%ebx
  8004201987:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420198a:	83 c0 01             	add    $0x1,%eax
  800420198d:	89 c7                	mov    %eax,%edi
  800420198f:	48 b8 ec 8c 20 04 80 	movabs $0x8004208cec,%rax
  8004201996:	00 00 00 
  8004201999:	ff d0                	callq  *%rax
  800420199b:	c1 e0 08             	shl    $0x8,%eax
  800420199e:	09 d8                	or     %ebx,%eax
}
  80042019a0:	48 83 c4 18          	add    $0x18,%rsp
  80042019a4:	5b                   	pop    %rbx
  80042019a5:	5d                   	pop    %rbp
  80042019a6:	c3                   	retq   

00000080042019a7 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  80042019a7:	55                   	push   %rbp
  80042019a8:	48 89 e5             	mov    %rsp,%rbp
  80042019ab:	53                   	push   %rbx
  80042019ac:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
  80042019b3:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  80042019ba:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  80042019c1:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  80042019c8:	48 89 e0             	mov    %rsp,%rax
  80042019cb:	48 89 c3             	mov    %rax,%rbx
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  80042019ce:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042019d5:	8b 40 30             	mov    0x30(%rax),%eax
  80042019d8:	89 c0                	mov    %eax,%eax
  80042019da:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  80042019de:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042019e5:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042019e8:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  80042019ee:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042019f3:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  80042019f9:	f7 e2                	mul    %edx
  80042019fb:	89 d0                	mov    %edx,%eax
  80042019fd:	c1 e8 04             	shr    $0x4,%eax
  8004201a00:	89 c0                	mov    %eax,%eax
  8004201a02:	48 89 c2             	mov    %rax,%rdx
  8004201a05:	48 83 ea 01          	sub    $0x1,%rdx
  8004201a09:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201a0d:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a11:	48 8d 50 0f          	lea    0xf(%rax),%rdx
  8004201a15:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201a1a:	48 83 e8 01          	sub    $0x1,%rax
  8004201a1e:	48 01 d0             	add    %rdx,%rax
  8004201a21:	48 c7 85 38 ff ff ff 	movq   $0x10,-0xc8(%rbp)
  8004201a28:	10 00 00 00 
  8004201a2c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201a31:	48 f7 b5 38 ff ff ff 	divq   -0xc8(%rbp)
  8004201a38:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201a3c:	48 29 c4             	sub    %rax,%rsp
  8004201a3f:	48 89 e0             	mov    %rsp,%rax
  8004201a42:	48 83 c0 0f          	add    $0xf,%rax
  8004201a46:	48 c1 e8 04          	shr    $0x4,%rax
  8004201a4a:	48 c1 e0 04          	shl    $0x4,%rax
  8004201a4e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201a52:	48 bf 4b c7 21 04 80 	movabs $0x800421c74b,%rdi
  8004201a59:	00 00 00 
  8004201a5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a61:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004201a68:	00 00 00 
  8004201a6b:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201a6d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201a74:	e9 66 01 00 00       	jmpq   8004201bdf <multiboot_read+0x238>
		memory_map_t* mmap = &mmap_base[i];
  8004201a79:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201a7c:	48 63 d0             	movslq %eax,%rdx
  8004201a7f:	48 89 d0             	mov    %rdx,%rax
  8004201a82:	48 01 c0             	add    %rax,%rax
  8004201a85:	48 01 d0             	add    %rdx,%rax
  8004201a88:	48 c1 e0 03          	shl    $0x3,%rax
  8004201a8c:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004201a90:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201a94:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a98:	8b 40 08             	mov    0x8(%rax),%eax
  8004201a9b:	89 c0                	mov    %eax,%eax
  8004201a9d:	48 89 c2             	mov    %rax,%rdx
  8004201aa0:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201aa4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201aa8:	8b 40 04             	mov    0x4(%rax),%eax
  8004201aab:	89 c0                	mov    %eax,%eax
  8004201aad:	48 01 d0             	add    %rdx,%rax
  8004201ab0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201ab4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ab8:	8b 40 10             	mov    0x10(%rax),%eax
  8004201abb:	89 c0                	mov    %eax,%eax
  8004201abd:	48 89 c2             	mov    %rax,%rdx
  8004201ac0:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201ac4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ac8:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201acb:	89 c0                	mov    %eax,%eax
  8004201acd:	48 01 d0             	add    %rdx,%rax
  8004201ad0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
			addr, len, mmap->type);
  8004201ad4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
		memory_map_t* mmap = &mmap_base[i];

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201ad8:	8b 70 14             	mov    0x14(%rax),%esi
  8004201adb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201adf:	8b 00                	mov    (%rax),%eax
  8004201ae1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201ae5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201ae9:	41 89 f0             	mov    %esi,%r8d
  8004201aec:	89 c6                	mov    %eax,%esi
  8004201aee:	48 bf 60 c7 21 04 80 	movabs $0x800421c760,%rdi
  8004201af5:	00 00 00 
  8004201af8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201afd:	49 b9 7a 90 20 04 80 	movabs $0x800420907a,%r9
  8004201b04:	00 00 00 
  8004201b07:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201b0a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b0e:	8b 40 14             	mov    0x14(%rax),%eax
  8004201b11:	83 f8 05             	cmp    $0x5,%eax
  8004201b14:	77 0b                	ja     8004201b21 <multiboot_read+0x17a>
  8004201b16:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b1a:	8b 40 14             	mov    0x14(%rax),%eax
  8004201b1d:	85 c0                	test   %eax,%eax
  8004201b1f:	75 0b                	jne    8004201b2c <multiboot_read+0x185>
			mmap->type = MB_TYPE_RESERVED;
  8004201b21:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b25:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201b2c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201b33:	e9 85 00 00 00       	jmpq   8004201bbd <multiboot_read+0x216>
			memory_map_t* this = mmap_list[j];
  8004201b38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b3c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201b3f:	48 63 d2             	movslq %edx,%rdx
  8004201b42:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201b46:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201b4a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201b4e:	8b 40 08             	mov    0x8(%rax),%eax
  8004201b51:	89 c0                	mov    %eax,%eax
  8004201b53:	48 89 c2             	mov    %rax,%rdx
  8004201b56:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201b5a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201b5e:	8b 40 04             	mov    0x4(%rax),%eax
  8004201b61:	89 c0                	mov    %eax,%eax
  8004201b63:	48 01 d0             	add    %rdx,%rax
  8004201b66:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201b6a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201b6e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201b72:	76 45                	jbe    8004201bb9 <multiboot_read+0x212>
				int last = i+1;
  8004201b74:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b77:	83 c0 01             	add    $0x1,%eax
  8004201b7a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201b7d:	eb 30                	jmp    8004201baf <multiboot_read+0x208>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201b7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b83:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201b86:	48 63 d2             	movslq %edx,%rdx
  8004201b89:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201b8d:	48 01 c2             	add    %rax,%rdx
  8004201b90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201b94:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201b97:	48 63 c9             	movslq %ecx,%rcx
  8004201b9a:	48 83 e9 01          	sub    $0x1,%rcx
  8004201b9e:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201ba2:	48 01 c8             	add    %rcx,%rax
  8004201ba5:	48 8b 00             	mov    (%rax),%rax
  8004201ba8:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201bab:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201baf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201bb2:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201bb5:	75 c8                	jne    8004201b7f <multiboot_read+0x1d8>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201bb7:	eb 10                	jmp    8004201bc9 <multiboot_read+0x222>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201bb9:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201bbd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201bc0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201bc3:	0f 8c 6f ff ff ff    	jl     8004201b38 <multiboot_read+0x191>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201bc9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201bcd:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201bd0:	48 63 d2             	movslq %edx,%rdx
  8004201bd3:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201bd7:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201bdb:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201bdf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201be2:	48 63 c8             	movslq %eax,%rcx
  8004201be5:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201bec:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201bef:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004201bf5:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201bfa:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  8004201c00:	f7 e2                	mul    %edx
  8004201c02:	89 d0                	mov    %edx,%eax
  8004201c04:	c1 e8 04             	shr    $0x4,%eax
  8004201c07:	89 c0                	mov    %eax,%eax
  8004201c09:	48 39 c1             	cmp    %rax,%rcx
  8004201c0c:	0f 82 67 fe ff ff    	jb     8004201a79 <multiboot_read+0xd2>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004201c12:	48 bf 97 c7 21 04 80 	movabs $0x800421c797,%rdi
  8004201c19:	00 00 00 
  8004201c1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c21:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004201c28:	00 00 00 
  8004201c2b:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201c2d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201c34:	e9 93 01 00 00       	jmpq   8004201dcc <multiboot_read+0x425>
		memory_map_t* prev = mmap_list[i-1];
  8004201c39:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201c3c:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201c3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201c43:	48 63 d2             	movslq %edx,%rdx
  8004201c46:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201c4a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201c4e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201c52:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201c55:	48 63 d2             	movslq %edx,%rdx
  8004201c58:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201c5c:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201c60:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c64:	8b 40 08             	mov    0x8(%rax),%eax
  8004201c67:	89 c0                	mov    %eax,%eax
  8004201c69:	48 89 c2             	mov    %rax,%rdx
  8004201c6c:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201c70:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201c74:	8b 40 04             	mov    0x4(%rax),%eax
  8004201c77:	89 c0                	mov    %eax,%eax
  8004201c79:	48 01 d0             	add    %rdx,%rax
  8004201c7c:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201c80:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c84:	8b 40 08             	mov    0x8(%rax),%eax
  8004201c87:	89 c0                	mov    %eax,%eax
  8004201c89:	48 89 c2             	mov    %rax,%rdx
  8004201c8c:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201c90:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201c94:	8b 40 04             	mov    0x4(%rax),%eax
  8004201c97:	89 c0                	mov    %eax,%eax
  8004201c99:	48 01 d0             	add    %rdx,%rax
  8004201c9c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201ca0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ca4:	8b 40 10             	mov    0x10(%rax),%eax
  8004201ca7:	89 c0                	mov    %eax,%eax
  8004201ca9:	48 89 c2             	mov    %rax,%rdx
  8004201cac:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201cb0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201cb4:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201cb7:	89 c0                	mov    %eax,%eax
  8004201cb9:	48 01 d0             	add    %rdx,%rax
  8004201cbc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201cc3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201cc7:	8b 40 10             	mov    0x10(%rax),%eax
  8004201cca:	89 c0                	mov    %eax,%eax
  8004201ccc:	48 89 c2             	mov    %rax,%rdx
  8004201ccf:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201cd3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201cd7:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201cda:	89 c0                	mov    %eax,%eax
  8004201cdc:	48 01 d0             	add    %rdx,%rax
  8004201cdf:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004201ce6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201ced:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201cf1:	48 01 d0             	add    %rdx,%rax
  8004201cf4:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201cf8:	75 7c                	jne    8004201d76 <multiboot_read+0x3cf>
  8004201cfa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201cfe:	8b 50 14             	mov    0x14(%rax),%edx
  8004201d01:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d05:	8b 40 14             	mov    0x14(%rax),%eax
  8004201d08:	39 c2                	cmp    %eax,%edx
  8004201d0a:	75 6a                	jne    8004201d76 <multiboot_read+0x3cf>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201d0c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201d13:	89 c2                	mov    %eax,%edx
  8004201d15:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201d1c:	01 c2                	add    %eax,%edx
  8004201d1e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d22:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004201d25:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201d2c:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004201d33:	48 01 d0             	add    %rdx,%rax
  8004201d36:	48 c1 e8 20          	shr    $0x20,%rax
  8004201d3a:	89 c2                	mov    %eax,%edx
  8004201d3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d40:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004201d43:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201d47:	8b 50 04             	mov    0x4(%rax),%edx
  8004201d4a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d4e:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004201d51:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201d55:	8b 50 08             	mov    0x8(%rax),%edx
  8004201d58:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d5c:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004201d5f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d62:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201d65:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d69:	48 63 d2             	movslq %edx,%rdx
  8004201d6c:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004201d73:	00 
  8004201d74:	eb 52                	jmp    8004201dc8 <multiboot_read+0x421>
		} else if(prev_addr + prev_length > this_addr) {
  8004201d76:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201d7d:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201d81:	48 01 d0             	add    %rdx,%rax
  8004201d84:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201d88:	76 3e                	jbe    8004201dc8 <multiboot_read+0x421>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004201d8a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d8e:	8b 50 14             	mov    0x14(%rax),%edx
  8004201d91:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201d95:	8b 40 14             	mov    0x14(%rax),%eax
  8004201d98:	89 d6                	mov    %edx,%esi
  8004201d9a:	89 c7                	mov    %eax,%edi
  8004201d9c:	48 b8 07 19 20 04 80 	movabs $0x8004201907,%rax
  8004201da3:	00 00 00 
  8004201da6:	ff d0                	callq  *%rax
  8004201da8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201dae:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201db2:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201db8:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201dbb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201dbf:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201dc5:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201dc8:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201dcc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201dcf:	48 63 c8             	movslq %eax,%rcx
  8004201dd2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201dd9:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201ddc:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004201de2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201de7:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  8004201ded:	f7 e2                	mul    %edx
  8004201def:	89 d0                	mov    %edx,%eax
  8004201df1:	c1 e8 04             	shr    $0x4,%eax
  8004201df4:	89 c0                	mov    %eax,%eax
  8004201df6:	48 39 c1             	cmp    %rax,%rcx
  8004201df9:	0f 82 3a fe ff ff    	jb     8004201c39 <multiboot_read+0x292>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201dff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201e06:	e9 dc 00 00 00       	jmpq   8004201ee7 <multiboot_read+0x540>
		memory_map_t* mmap = mmap_list[i];
  8004201e0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201e0f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201e12:	48 63 d2             	movslq %edx,%rdx
  8004201e15:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201e19:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004201e20:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004201e27:	00 
  8004201e28:	0f 84 b5 00 00 00    	je     8004201ee3 <multiboot_read+0x53c>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004201e2e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e35:	8b 40 14             	mov    0x14(%rax),%eax
  8004201e38:	83 f8 01             	cmp    $0x1,%eax
  8004201e3b:	74 13                	je     8004201e50 <multiboot_read+0x4a9>
  8004201e3d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e44:	8b 40 14             	mov    0x14(%rax),%eax
  8004201e47:	83 f8 03             	cmp    $0x3,%eax
  8004201e4a:	0f 85 93 00 00 00    	jne    8004201ee3 <multiboot_read+0x53c>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004201e50:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e57:	8b 40 04             	mov    0x4(%rax),%eax
  8004201e5a:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004201e5f:	77 49                	ja     8004201eaa <multiboot_read+0x503>
  8004201e61:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e68:	8b 40 08             	mov    0x8(%rax),%eax
  8004201e6b:	85 c0                	test   %eax,%eax
  8004201e6d:	75 3b                	jne    8004201eaa <multiboot_read+0x503>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201e6f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201e76:	48 8b 10             	mov    (%rax),%rdx
  8004201e79:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e80:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e83:	89 c0                	mov    %eax,%eax
  8004201e85:	48 89 c1             	mov    %rax,%rcx
  8004201e88:	48 c1 e1 20          	shl    $0x20,%rcx
  8004201e8c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201e93:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e96:	89 c0                	mov    %eax,%eax
  8004201e98:	48 01 c8             	add    %rcx,%rax
  8004201e9b:	48 01 c2             	add    %rax,%rdx
  8004201e9e:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201ea5:	48 89 10             	mov    %rdx,(%rax)
  8004201ea8:	eb 39                	jmp    8004201ee3 <multiboot_read+0x53c>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201eaa:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201eb1:	48 8b 10             	mov    (%rax),%rdx
  8004201eb4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201ebb:	8b 40 10             	mov    0x10(%rax),%eax
  8004201ebe:	89 c0                	mov    %eax,%eax
  8004201ec0:	48 89 c1             	mov    %rax,%rcx
  8004201ec3:	48 c1 e1 20          	shl    $0x20,%rcx
  8004201ec7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201ece:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201ed1:	89 c0                	mov    %eax,%eax
  8004201ed3:	48 01 c8             	add    %rcx,%rax
  8004201ed6:	48 01 c2             	add    %rax,%rdx
  8004201ed9:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201ee0:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201ee3:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201ee7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201eea:	48 63 c8             	movslq %eax,%rcx
  8004201eed:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201ef4:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201ef7:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004201efd:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f02:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  8004201f08:	f7 e2                	mul    %edx
  8004201f0a:	89 d0                	mov    %edx,%eax
  8004201f0c:	c1 e8 04             	shr    $0x4,%eax
  8004201f0f:	89 c0                	mov    %eax,%eax
  8004201f11:	48 39 c1             	cmp    %rax,%rcx
  8004201f14:	0f 82 f1 fe ff ff    	jb     8004201e0b <multiboot_read+0x464>
  8004201f1a:	48 89 dc             	mov    %rbx,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004201f1d:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  8004201f21:	c9                   	leaveq 
  8004201f22:	c3                   	retq   

0000008004201f23 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004201f23:	55                   	push   %rbp
  8004201f24:	48 89 e5             	mov    %rsp,%rbp
  8004201f27:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004201f2b:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004201f32:	00 
	size_t extmem = 0;
  8004201f33:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004201f3a:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004201f3b:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004201f42:	00 00 00 
  8004201f45:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004201f49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201f4d:	48 8b 00             	mov    (%rax),%rax
  8004201f50:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004201f54:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201f59:	74 2d                	je     8004201f88 <i386_detect_memory+0x65>
  8004201f5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f5f:	8b 00                	mov    (%rax),%eax
  8004201f61:	83 e0 40             	and    $0x40,%eax
  8004201f64:	85 c0                	test   %eax,%eax
  8004201f66:	74 20                	je     8004201f88 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004201f68:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004201f6c:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004201f70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f74:	48 89 ce             	mov    %rcx,%rsi
  8004201f77:	48 89 c7             	mov    %rax,%rdi
  8004201f7a:	48 b8 a7 19 20 04 80 	movabs $0x80042019a7,%rax
  8004201f81:	00 00 00 
  8004201f84:	ff d0                	callq  *%rax
  8004201f86:	eb 34                	jmp    8004201fbc <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004201f88:	bf 15 00 00 00       	mov    $0x15,%edi
  8004201f8d:	48 b8 68 19 20 04 80 	movabs $0x8004201968,%rax
  8004201f94:	00 00 00 
  8004201f97:	ff d0                	callq  *%rax
  8004201f99:	c1 e0 0a             	shl    $0xa,%eax
  8004201f9c:	48 98                	cltq   
  8004201f9e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004201fa2:	bf 17 00 00 00       	mov    $0x17,%edi
  8004201fa7:	48 b8 68 19 20 04 80 	movabs $0x8004201968,%rax
  8004201fae:	00 00 00 
  8004201fb1:	ff d0                	callq  *%rax
  8004201fb3:	c1 e0 0a             	shl    $0xa,%eax
  8004201fb6:	48 98                	cltq   
  8004201fb8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004201fbc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201fc0:	48 85 c0             	test   %rax,%rax
  8004201fc3:	75 35                	jne    8004201ffa <i386_detect_memory+0xd7>
  8004201fc5:	48 b9 99 c7 21 04 80 	movabs $0x800421c799,%rcx
  8004201fcc:	00 00 00 
  8004201fcf:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004201fd6:	00 00 00 
  8004201fd9:	be 86 00 00 00       	mov    $0x86,%esi
  8004201fde:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004201fe5:	00 00 00 
  8004201fe8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201fed:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004201ff4:	00 00 00 
  8004201ff7:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004201ffa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ffe:	48 89 c2             	mov    %rax,%rdx
  8004202001:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004202005:	48 b8 30 22 48 04 80 	movabs $0x8004482230,%rax
  800420200c:	00 00 00 
  800420200f:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202012:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202016:	48 c1 e8 0c          	shr    $0xc,%rax
  800420201a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420201e:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202023:	48 b8 68 19 20 04 80 	movabs $0x8004201968,%rax
  800420202a:	00 00 00 
  800420202d:	ff d0                	callq  *%rax
  800420202f:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202034:	75 2c                	jne    8004202062 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202036:	bf 34 00 00 00       	mov    $0x34,%edi
  800420203b:	48 b8 68 19 20 04 80 	movabs $0x8004201968,%rax
  8004202042:	00 00 00 
  8004202045:	ff d0                	callq  *%rax
  8004202047:	c1 e0 10             	shl    $0x10,%eax
  800420204a:	48 98                	cltq   
  800420204c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202050:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202054:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  800420205a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420205e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202062:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202067:	74 1a                	je     8004202083 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202069:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420206d:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202074:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420207b:	00 00 00 
  800420207e:	48 89 10             	mov    %rdx,(%rax)
  8004202081:	eb 1a                	jmp    800420209d <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202083:	48 b8 30 22 48 04 80 	movabs $0x8004482230,%rax
  800420208a:	00 00 00 
  800420208d:	48 8b 10             	mov    (%rax),%rdx
  8004202090:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004202097:	00 00 00 
  800420209a:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420209d:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042020a4:	00 00 00 
  80042020a7:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042020aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042020ae:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042020b2:	48 89 c1             	mov    %rax,%rcx
  80042020b5:	48 c1 e9 0a          	shr    $0xa,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042020b9:	48 b8 30 22 48 04 80 	movabs $0x8004482230,%rax
  80042020c0:	00 00 00 
  80042020c3:	48 8b 00             	mov    (%rax),%rax
  80042020c6:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042020ca:	48 89 c2             	mov    %rax,%rdx
  80042020cd:	48 c1 ea 0a          	shr    $0xa,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042020d1:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042020d8:	00 00 00 
  80042020db:	48 8b 00             	mov    (%rax),%rax
  80042020de:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042020e2:	48 c1 e8 14          	shr    $0x14,%rax
  80042020e6:	49 89 f0             	mov    %rsi,%r8
  80042020e9:	48 89 c6             	mov    %rax,%rsi
  80042020ec:	48 bf c8 c7 21 04 80 	movabs $0x800421c7c8,%rdi
  80042020f3:	00 00 00 
  80042020f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020fb:	49 b9 7a 90 20 04 80 	movabs $0x800420907a,%r9
  8004202102:	00 00 00 
  8004202105:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202108:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420210f:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202110:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202117:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202118:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420211c:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202120:	48 89 c1             	mov    %rax,%rcx
  8004202123:	48 c1 e9 14          	shr    $0x14,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202127:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420212b:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420212f:	48 89 c6             	mov    %rax,%rsi
  8004202132:	48 c1 ee 14          	shr    $0x14,%rsi
  8004202136:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420213a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420213e:	49 89 c8             	mov    %rcx,%r8
  8004202141:	48 89 d1             	mov    %rdx,%rcx
  8004202144:	48 89 f2             	mov    %rsi,%rdx
  8004202147:	48 89 c6             	mov    %rax,%rsi
  800420214a:	48 bf 18 c8 21 04 80 	movabs $0x800421c818,%rdi
  8004202151:	00 00 00 
  8004202154:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202159:	49 b9 7a 90 20 04 80 	movabs $0x800420907a,%r9
  8004202160:	00 00 00 
  8004202163:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202166:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420216a:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420216e:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202173:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202177:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420217e:	00 00 00 
  8004202181:	48 8b 00             	mov    (%rax),%rax
  8004202184:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202188:	76 3a                	jbe    80042021c4 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  800420218a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420218e:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004202195:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420219c:	00 00 00 
  800420219f:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042021a2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042021a6:	48 89 c6             	mov    %rax,%rsi
  80042021a9:	48 bf 80 c8 21 04 80 	movabs $0x800421c880,%rdi
  80042021b0:	00 00 00 
  80042021b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021b8:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042021bf:	00 00 00 
  80042021c2:	ff d2                	callq  *%rdx
	}
}
  80042021c4:	c9                   	leaveq 
  80042021c5:	c3                   	retq   

00000080042021c6 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042021c6:	55                   	push   %rbp
  80042021c7:	48 89 e5             	mov    %rsp,%rbp
  80042021ca:	48 83 ec 38          	sub    $0x38,%rsp
  80042021ce:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042021d1:	48 b8 48 22 48 04 80 	movabs $0x8004482248,%rax
  80042021d8:	00 00 00 
  80042021db:	48 8b 00             	mov    (%rax),%rax
  80042021de:	48 85 c0             	test   %rax,%rax
  80042021e1:	75 4e                	jne    8004202231 <boot_alloc+0x6b>
#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
#else
		extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  80042021e3:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042021ea:	00 
  80042021eb:	48 b8 48 37 48 04 80 	movabs $0x8004483748,%rax
  80042021f2:	00 00 00 
  80042021f5:	48 8b 00             	mov    (%rax),%rax
  80042021f8:	48 03 45 f8          	add    -0x8(%rbp),%rax
  80042021fc:	48 83 e8 01          	sub    $0x1,%rax
  8004202200:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202204:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202208:	ba 00 00 00 00       	mov    $0x0,%edx
  800420220d:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202211:	48 89 d0             	mov    %rdx,%rax
  8004202214:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004202218:	48 89 d1             	mov    %rdx,%rcx
  800420221b:	48 29 c1             	sub    %rax,%rcx
  800420221e:	48 89 c8             	mov    %rcx,%rax
  8004202221:	48 89 c2             	mov    %rax,%rdx
  8004202224:	48 b8 48 22 48 04 80 	movabs $0x8004482248,%rax
  800420222b:	00 00 00 
  800420222e:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
  8004202231:	48 b8 48 22 48 04 80 	movabs $0x8004482248,%rax
  8004202238:	00 00 00 
  800420223b:	48 8b 00             	mov    (%rax),%rax
  800420223e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (n>0) {
  8004202242:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202246:	74 57                	je     800420229f <boot_alloc+0xd9>
        uint32_t newSize = ROUNDUP(n, PGSIZE);
  8004202248:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420224f:	00 
  8004202250:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202253:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004202257:	48 83 e8 01          	sub    $0x1,%rax
  800420225b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420225f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202263:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202268:	48 f7 75 e0          	divq   -0x20(%rbp)
  800420226c:	48 89 d0             	mov    %rdx,%rax
  800420226f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202273:	48 89 d1             	mov    %rdx,%rcx
  8004202276:	48 29 c1             	sub    %rax,%rcx
  8004202279:	48 89 c8             	mov    %rcx,%rax
  800420227c:	89 45 d4             	mov    %eax,-0x2c(%rbp)
        nextfree = nextfree + newSize;
  800420227f:	48 b8 48 22 48 04 80 	movabs $0x8004482248,%rax
  8004202286:	00 00 00 
  8004202289:	48 8b 10             	mov    (%rax),%rdx
  800420228c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420228f:	48 01 c2             	add    %rax,%rdx
  8004202292:	48 b8 48 22 48 04 80 	movabs $0x8004482248,%rax
  8004202299:	00 00 00 
  800420229c:	48 89 10             	mov    %rdx,(%rax)
    }    
    return result;
  800420229f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042022a3:	c9                   	leaveq 
  80042022a4:	c3                   	retq   

00000080042022a5 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  80042022a5:	55                   	push   %rbp
  80042022a6:	48 89 e5             	mov    %rsp,%rbp
  80042022a9:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  80042022b0:	48 b8 23 1f 20 04 80 	movabs $0x8004201f23,%rax
  80042022b7:	00 00 00 
  80042022ba:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	// panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  80042022bc:	bf 00 10 00 00       	mov    $0x1000,%edi
  80042022c1:	48 b8 c6 21 20 04 80 	movabs $0x80042021c6,%rax
  80042022c8:	00 00 00 
  80042022cb:	ff d0                	callq  *%rax
  80042022cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  80042022d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042022d5:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042022da:	be 00 00 00 00       	mov    $0x0,%esi
  80042022df:	48 89 c7             	mov    %rax,%rdi
  80042022e2:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042022e9:	00 00 00 
  80042022ec:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042022ee:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042022f5:	00 00 00 
  80042022f8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042022fc:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042022ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202303:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202307:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420230e:	00 00 00 
  8004202311:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202315:	77 32                	ja     8004202349 <x64_vm_init+0xa4>
  8004202317:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420231b:	48 89 c1             	mov    %rax,%rcx
  800420231e:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004202325:	00 00 00 
  8004202328:	be 04 01 00 00       	mov    $0x104,%esi
  800420232d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202334:	00 00 00 
  8004202337:	b8 00 00 00 00       	mov    $0x0,%eax
  800420233c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202343:	00 00 00 
  8004202346:	41 ff d0             	callq  *%r8
  8004202349:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202350:	ff ff ff 
  8004202353:	48 89 c2             	mov    %rax,%rdx
  8004202356:	48 03 55 f0          	add    -0x10(%rbp),%rdx
  800420235a:	48 b8 60 37 48 04 80 	movabs $0x8004483760,%rax
  8004202361:	00 00 00 
  8004202364:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(sizeof(struct PageInfo)*npages);
  8004202367:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420236e:	00 00 00 
  8004202371:	48 8b 00             	mov    (%rax),%rax
  8004202374:	c1 e0 04             	shl    $0x4,%eax
  8004202377:	89 c7                	mov    %eax,%edi
  8004202379:	48 b8 c6 21 20 04 80 	movabs $0x80042021c6,%rax
  8004202380:	00 00 00 
  8004202383:	ff d0                	callq  *%rax
  8004202385:	48 ba 78 37 48 04 80 	movabs $0x8004483778,%rdx
  800420238c:	00 00 00 
  800420238f:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs = (struct Env*)boot_alloc(sizeof(struct Env)*NENV);
  8004202392:	bf 00 80 05 00       	mov    $0x58000,%edi
  8004202397:	48 b8 c6 21 20 04 80 	movabs $0x80042021c6,%rax
  800420239e:	00 00 00 
  80042023a1:	ff d0                	callq  *%rax
  80042023a3:	48 ba 50 22 48 04 80 	movabs $0x8004482250,%rdx
  80042023aa:	00 00 00 
  80042023ad:	48 89 02             	mov    %rax,(%rdx)
	memset(envs, 0, NENV * sizeof(struct Env));	
  80042023b0:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  80042023b7:	00 00 00 
  80042023ba:	48 8b 00             	mov    (%rax),%rax
  80042023bd:	ba 00 80 05 00       	mov    $0x58000,%edx
  80042023c2:	be 00 00 00 00       	mov    $0x0,%esi
  80042023c7:	48 89 c7             	mov    %rax,%rdi
  80042023ca:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042023d1:	00 00 00 
  80042023d4:	ff d0                	callq  *%rax
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  80042023d6:	48 b8 71 28 20 04 80 	movabs $0x8004202871,%rax
  80042023dd:	00 00 00 
  80042023e0:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:i
	size_t size = ROUNDUP(npages*(sizeof(struct PageInfo)), PGSIZE);	
  80042023e2:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042023e9:	00 
  80042023ea:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042023f1:	00 00 00 
  80042023f4:	48 8b 00             	mov    (%rax),%rax
  80042023f7:	48 c1 e0 04          	shl    $0x4,%rax
  80042023fb:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042023ff:	48 83 e8 01          	sub    $0x1,%rax
  8004202403:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202407:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420240b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202410:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004202414:	48 89 d0             	mov    %rdx,%rax
  8004202417:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420241b:	48 89 d1             	mov    %rdx,%rcx
  800420241e:	48 29 c1             	sub    %rax,%rcx
  8004202421:	48 89 c8             	mov    %rcx,%rax
  8004202424:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	boot_map_region(boot_pml4e, UPAGES, size, PADDR(pages), PTE_U|PTE_P);
  8004202428:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  800420242f:	00 00 00 
  8004202432:	48 8b 00             	mov    (%rax),%rax
  8004202435:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202439:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202440:	00 00 00 
  8004202443:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202447:	77 32                	ja     800420247b <x64_vm_init+0x1d6>
  8004202449:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420244d:	48 89 c1             	mov    %rax,%rcx
  8004202450:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004202457:	00 00 00 
  800420245a:	be 22 01 00 00       	mov    $0x122,%esi
  800420245f:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202466:	00 00 00 
  8004202469:	b8 00 00 00 00       	mov    $0x0,%eax
  800420246e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202475:	00 00 00 
  8004202478:	41 ff d0             	callq  *%r8
  800420247b:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202482:	ff ff ff 
  8004202485:	48 89 c1             	mov    %rax,%rcx
  8004202488:	48 03 4d d0          	add    -0x30(%rbp),%rcx
  800420248c:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004202493:	00 00 00 
  8004202496:	48 8b 00             	mov    (%rax),%rax
  8004202499:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420249d:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  80042024a3:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  80042024aa:	00 00 00 
  80042024ad:	48 89 c7             	mov    %rax,%rdi
  80042024b0:	48 b8 89 33 20 04 80 	movabs $0x8004203389,%rax
  80042024b7:	00 00 00 
  80042024ba:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	size_t envsize = ROUNDUP(NENV*(sizeof(struct Env)), PGSIZE);
  80042024bc:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  80042024c3:	00 
  80042024c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042024c8:	48 05 ff 7f 05 00    	add    $0x57fff,%rax
  80042024ce:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042024d2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042024d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042024db:	48 f7 75 c8          	divq   -0x38(%rbp)
  80042024df:	48 89 d0             	mov    %rdx,%rax
  80042024e2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042024e6:	48 89 d1             	mov    %rdx,%rcx
  80042024e9:	48 29 c1             	sub    %rax,%rcx
  80042024ec:	48 89 c8             	mov    %rcx,%rax
  80042024ef:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	boot_map_region(boot_pml4e, UENVS, envsize, PADDR(envs), PTE_U|PTE_P);
  80042024f3:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  80042024fa:	00 00 00 
  80042024fd:	48 8b 00             	mov    (%rax),%rax
  8004202500:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202504:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420250b:	00 00 00 
  800420250e:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  8004202512:	77 32                	ja     8004202546 <x64_vm_init+0x2a1>
  8004202514:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202518:	48 89 c1             	mov    %rax,%rcx
  800420251b:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004202522:	00 00 00 
  8004202525:	be 2c 01 00 00       	mov    $0x12c,%esi
  800420252a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202531:	00 00 00 
  8004202534:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202539:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202540:	00 00 00 
  8004202543:	41 ff d0             	callq  *%r8
  8004202546:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420254d:	ff ff ff 
  8004202550:	48 89 c1             	mov    %rax,%rcx
  8004202553:	48 03 4d b0          	add    -0x50(%rbp),%rcx
  8004202557:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420255e:	00 00 00 
  8004202561:	48 8b 00             	mov    (%rax),%rax
  8004202564:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202568:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  800420256e:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202575:	00 00 00 
  8004202578:	48 89 c7             	mov    %rax,%rdi
  800420257b:	48 b8 89 33 20 04 80 	movabs $0x8004203389,%rax
  8004202582:	00 00 00 
  8004202585:	ff d0                	callq  *%rax
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_P|PTE_W);
  8004202587:	48 b8 00 00 22 04 80 	movabs $0x8004220000,%rax
  800420258e:	00 00 00 
  8004202591:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004202595:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420259c:	00 00 00 
  800420259f:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  80042025a3:	77 32                	ja     80042025d7 <x64_vm_init+0x332>
  80042025a5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042025a9:	48 89 c1             	mov    %rax,%rcx
  80042025ac:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  80042025b3:	00 00 00 
  80042025b6:	be 39 01 00 00       	mov    $0x139,%esi
  80042025bb:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042025c2:	00 00 00 
  80042025c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025ca:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042025d1:	00 00 00 
  80042025d4:	41 ff d0             	callq  *%r8
  80042025d7:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042025de:	ff ff ff 
  80042025e1:	48 89 c2             	mov    %rax,%rdx
  80042025e4:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  80042025e8:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042025ef:	00 00 00 
  80042025f2:	48 8b 00             	mov    (%rax),%rax
  80042025f5:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042025fb:	48 89 d1             	mov    %rdx,%rcx
  80042025fe:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202603:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  800420260a:	00 00 00 
  800420260d:	48 89 c7             	mov    %rax,%rdi
  8004202610:	48 b8 89 33 20 04 80 	movabs $0x8004203389,%rax
  8004202617:	00 00 00 
  800420261a:	ff d0                	callq  *%rax
	// of physical pages to be npages.
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	boot_map_region(boot_pml4e, KERNBASE, npages*PGSIZE, (physaddr_t)0x0, PTE_P|PTE_W);
  800420261c:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004202623:	00 00 00 
  8004202626:	48 8b 00             	mov    (%rax),%rax
  8004202629:	48 89 c2             	mov    %rax,%rdx
  800420262c:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004202630:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004202637:	00 00 00 
  800420263a:	48 8b 00             	mov    (%rax),%rax
  800420263d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202643:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202648:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  800420264f:	00 00 00 
  8004202652:	48 89 c7             	mov    %rax,%rdi
  8004202655:	48 b8 89 33 20 04 80 	movabs $0x8004203389,%rax
  800420265c:	00 00 00 
  800420265f:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202661:	48 b8 7e 27 20 04 80 	movabs $0x800420277e,%rax
  8004202668:	00 00 00 
  800420266b:	ff d0                	callq  *%rax
	/* check_boot_pml4e(boot_pml4e); */

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE

	lcr3(boot_cr3);
  800420266d:	48 b8 60 37 48 04 80 	movabs $0x8004483760,%rax
  8004202674:	00 00 00 
  8004202677:	48 8b 00             	mov    (%rax),%rax
  800420267a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202681:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202688:	0f 22 d8             	mov    %rax,%cr3
	
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  800420268b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420268f:	48 83 c0 08          	add    $0x8,%rax
  8004202693:	48 8b 00             	mov    (%rax),%rax
  8004202696:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420269c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042026a0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026a4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042026a8:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042026ab:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042026ae:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042026b5:	00 00 00 
  80042026b8:	48 8b 00             	mov    (%rax),%rax
  80042026bb:	48 39 c2             	cmp    %rax,%rdx
  80042026be:	72 32                	jb     80042026f2 <x64_vm_init+0x44d>
  80042026c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042026c4:	48 89 c1             	mov    %rax,%rcx
  80042026c7:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  80042026ce:	00 00 00 
  80042026d1:	be 52 01 00 00       	mov    $0x152,%esi
  80042026d6:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042026dd:	00 00 00 
  80042026e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026e5:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042026ec:	00 00 00 
  80042026ef:	41 ff d0             	callq  *%r8
  80042026f2:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042026f9:	00 00 00 
  80042026fc:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004202700:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202704:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202708:	48 8b 00             	mov    (%rax),%rax
  800420270b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202711:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004202715:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202719:	48 c1 e8 0c          	shr    $0xc,%rax
  800420271d:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004202720:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004202723:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420272a:	00 00 00 
  800420272d:	48 8b 00             	mov    (%rax),%rax
  8004202730:	48 39 c2             	cmp    %rax,%rdx
  8004202733:	72 32                	jb     8004202767 <x64_vm_init+0x4c2>
  8004202735:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202739:	48 89 c1             	mov    %rax,%rcx
  800420273c:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004202743:	00 00 00 
  8004202746:	be 53 01 00 00       	mov    $0x153,%esi
  800420274b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202752:	00 00 00 
  8004202755:	b8 00 00 00 00       	mov    $0x0,%eax
  800420275a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202761:	00 00 00 
  8004202764:	41 ff d0             	callq  *%r8
  8004202767:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420276e:	00 00 00 
  8004202771:	48 03 45 88          	add    -0x78(%rbp),%rax
  8004202775:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

	/* check_page_free_list(1); */
	/* check_page_alloc(); */
	/* page_check(); */
	/* check_page_free_list(0); */
}
  800420277c:	c9                   	leaveq 
  800420277d:	c3                   	retq   

000000800420277e <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  800420277e:	55                   	push   %rbp
  800420277f:	48 89 e5             	mov    %rsp,%rbp
  8004202782:	48 83 ec 20          	sub    $0x20,%rsp
	//             it will fault rather than overwrite another CPU's stack.
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	size_t ncpus = 0;
  8004202786:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420278d:	00 
	for (;ncpus < NCPU ; ncpus++) {
  800420278e:	e9 d1 00 00 00       	jmpq   8004202864 <mem_init_mp+0xe6>
		size_t kstacktop_ncpus = KSTACKTOP - ncpus * (KSTKSIZE+KSTKGAP);
  8004202793:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202797:	48 89 d0             	mov    %rdx,%rax
  800420279a:	48 01 c0             	add    %rax,%rax
  800420279d:	48 01 d0             	add    %rdx,%rax
  80042027a0:	48 c1 e0 0f          	shl    $0xf,%rax
  80042027a4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042027ab:	00 00 00 
  80042027ae:	48 89 d1             	mov    %rdx,%rcx
  80042027b1:	48 29 c1             	sub    %rax,%rcx
  80042027b4:	48 89 c8             	mov    %rcx,%rax
  80042027b7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e, kstacktop_ncpus-KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[ncpus]), PTE_P|PTE_W);
  80042027bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042027bf:	48 89 c2             	mov    %rax,%rdx
  80042027c2:	48 c1 e2 10          	shl    $0x10,%rdx
  80042027c6:	48 b8 00 60 48 04 80 	movabs $0x8004486000,%rax
  80042027cd:	00 00 00 
  80042027d0:	48 01 d0             	add    %rdx,%rax
  80042027d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042027d7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042027de:	00 00 00 
  80042027e1:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042027e5:	77 32                	ja     8004202819 <mem_init_mp+0x9b>
  80042027e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042027eb:	48 89 c1             	mov    %rax,%rcx
  80042027ee:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  80042027f5:	00 00 00 
  80042027f8:	be 75 01 00 00       	mov    $0x175,%esi
  80042027fd:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202804:	00 00 00 
  8004202807:	b8 00 00 00 00       	mov    $0x0,%eax
  800420280c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202813:	00 00 00 
  8004202816:	41 ff d0             	callq  *%r8
  8004202819:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202820:	ff ff ff 
  8004202823:	48 89 c2             	mov    %rax,%rdx
  8004202826:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  800420282a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420282e:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202835:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420283c:	00 00 00 
  800420283f:	48 8b 00             	mov    (%rax),%rax
  8004202842:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202848:	48 89 d1             	mov    %rdx,%rcx
  800420284b:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202850:	48 89 c7             	mov    %rax,%rdi
  8004202853:	48 b8 89 33 20 04 80 	movabs $0x8004203389,%rax
  800420285a:	00 00 00 
  800420285d:	ff d0                	callq  *%rax
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	size_t ncpus = 0;
	for (;ncpus < NCPU ; ncpus++) {
  800420285f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202864:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202869:	0f 84 24 ff ff ff    	je     8004202793 <mem_init_mp+0x15>
		size_t kstacktop_ncpus = KSTACKTOP - ncpus * (KSTKSIZE+KSTKGAP);
		boot_map_region(boot_pml4e, kstacktop_ncpus-KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[ncpus]), PTE_P|PTE_W);
	}

}
  800420286f:	c9                   	leaveq 
  8004202870:	c3                   	retq   

0000008004202871 <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202871:	55                   	push   %rbp
  8004202872:	48 89 e5             	mov    %rsp,%rbp
  8004202875:	53                   	push   %rbx
  8004202876:	48 83 ec 28          	sub    $0x28,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

    size_t i;
    struct PageInfo* last = NULL;
  800420287a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004202881:	00 
    for (i = 0; i < npages; i++) {
  8004202882:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202889:	00 
  800420288a:	e9 be 02 00 00       	jmpq   8004202b4d <page_init+0x2dc>
        pages[i].pp_ref = 0;
  800420288f:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202896:	00 00 00 
  8004202899:	48 8b 00             	mov    (%rax),%rax
  800420289c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042028a0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042028a4:	48 01 d0             	add    %rdx,%rax
  80042028a7:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
        pages[i].pp_link = NULL;
  80042028ad:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  80042028b4:	00 00 00 
  80042028b7:	48 8b 00             	mov    (%rax),%rax
  80042028ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042028be:	48 c1 e2 04          	shl    $0x4,%rdx
  80042028c2:	48 01 d0             	add    %rdx,%rax
  80042028c5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        //For the first page.
        if (i > 1 && last)
  80042028cc:	48 83 7d e8 01       	cmpq   $0x1,-0x18(%rbp)
  80042028d1:	76 28                	jbe    80042028fb <page_init+0x8a>
  80042028d3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042028d8:	74 21                	je     80042028fb <page_init+0x8a>
            last->pp_link = &pages[i];
  80042028da:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  80042028e1:	00 00 00 
  80042028e4:	48 8b 00             	mov    (%rax),%rax
  80042028e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042028eb:	48 c1 e2 04          	shl    $0x4,%rdx
  80042028ef:	48 01 c2             	add    %rax,%rdx
  80042028f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028f6:	48 89 10             	mov    %rdx,(%rax)
  80042028f9:	eb 25                	jmp    8004202920 <page_init+0xaf>
        else
            page_free_list = &pages[i];
  80042028fb:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202902:	00 00 00 
  8004202905:	48 8b 00             	mov    (%rax),%rax
  8004202908:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420290c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202910:	48 01 c2             	add    %rax,%rdx
  8004202913:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  800420291a:	00 00 00 
  800420291d:	48 89 10             	mov    %rdx,(%rax)

        //For the IO hole.
        if (page2pa(&pages[i]) >= PADDR(KERNBASE+IOPHYSMEM) && page2pa(&pages[i]) <= PADDR(boot_alloc(0))) {
  8004202920:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202927:	00 00 00 
  800420292a:	48 8b 00             	mov    (%rax),%rax
  800420292d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202931:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202935:	48 01 d0             	add    %rdx,%rax
  8004202938:	48 89 c7             	mov    %rax,%rdi
  800420293b:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004202942:	00 00 00 
  8004202945:	ff d0                	callq  *%rax
  8004202947:	c7 45 d8 00 00 0a 04 	movl   $0x40a0000,-0x28(%rbp)
  800420294e:	c7 45 dc 80 00 00 00 	movl   $0x80,-0x24(%rbp)
  8004202955:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800420295c:	00 00 00 
  800420295f:	48 39 55 d8          	cmp    %rdx,-0x28(%rbp)
  8004202963:	77 32                	ja     8004202997 <page_init+0x126>
  8004202965:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202969:	48 89 c1             	mov    %rax,%rcx
  800420296c:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004202973:	00 00 00 
  8004202976:	be ae 01 00 00       	mov    $0x1ae,%esi
  800420297b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202982:	00 00 00 
  8004202985:	b8 00 00 00 00       	mov    $0x0,%eax
  800420298a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202991:	00 00 00 
  8004202994:	41 ff d0             	callq  *%r8
  8004202997:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420299e:	ff ff ff 
  80042029a1:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  80042029a5:	48 39 d0             	cmp    %rdx,%rax
  80042029a8:	0f 82 f3 00 00 00    	jb     8004202aa1 <page_init+0x230>
  80042029ae:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  80042029b5:	00 00 00 
  80042029b8:	48 8b 00             	mov    (%rax),%rax
  80042029bb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042029bf:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029c3:	48 01 d0             	add    %rdx,%rax
  80042029c6:	48 89 c7             	mov    %rax,%rdi
  80042029c9:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042029d0:	00 00 00 
  80042029d3:	ff d0                	callq  *%rax
  80042029d5:	48 89 c3             	mov    %rax,%rbx
  80042029d8:	bf 00 00 00 00       	mov    $0x0,%edi
  80042029dd:	48 b8 c6 21 20 04 80 	movabs $0x80042021c6,%rax
  80042029e4:	00 00 00 
  80042029e7:	ff d0                	callq  *%rax
  80042029e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042029ed:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042029f4:	00 00 00 
  80042029f7:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042029fb:	77 32                	ja     8004202a2f <page_init+0x1be>
  80042029fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202a01:	48 89 c1             	mov    %rax,%rcx
  8004202a04:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004202a0b:	00 00 00 
  8004202a0e:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004202a13:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202a1a:	00 00 00 
  8004202a1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a22:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202a29:	00 00 00 
  8004202a2c:	41 ff d0             	callq  *%r8
  8004202a2f:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202a36:	ff ff ff 
  8004202a39:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004202a3d:	48 39 c3             	cmp    %rax,%rbx
  8004202a40:	77 5f                	ja     8004202aa1 <page_init+0x230>
            pages[i].pp_link = NULL;
  8004202a42:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202a49:	00 00 00 
  8004202a4c:	48 8b 00             	mov    (%rax),%rax
  8004202a4f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202a53:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a57:	48 01 d0             	add    %rdx,%rax
  8004202a5a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
            pages[i].pp_ref += 1;
  8004202a61:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202a68:	00 00 00 
  8004202a6b:	48 8b 00             	mov    (%rax),%rax
  8004202a6e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202a72:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a76:	48 01 c2             	add    %rax,%rdx
  8004202a79:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202a80:	00 00 00 
  8004202a83:	48 8b 00             	mov    (%rax),%rax
  8004202a86:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004202a8a:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202a8e:	48 01 c8             	add    %rcx,%rax
  8004202a91:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202a95:	83 c0 01             	add    $0x1,%eax
  8004202a98:	66 89 42 08          	mov    %ax,0x8(%rdx)
  8004202a9c:	e9 a7 00 00 00       	jmpq   8004202b48 <page_init+0x2d7>
        }
	
		else if(page2pa(&pages[i]) == MPENTRY_PADDR) {
  8004202aa1:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202aa8:	00 00 00 
  8004202aab:	48 8b 00             	mov    (%rax),%rax
  8004202aae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202ab2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ab6:	48 01 d0             	add    %rdx,%rax
  8004202ab9:	48 89 c7             	mov    %rax,%rdi
  8004202abc:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004202ac3:	00 00 00 
  8004202ac6:	ff d0                	callq  *%rax
  8004202ac8:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004202ace:	75 5c                	jne    8004202b2c <page_init+0x2bb>
			pages[i].pp_link = NULL;
  8004202ad0:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202ad7:	00 00 00 
  8004202ada:	48 8b 00             	mov    (%rax),%rax
  8004202add:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202ae1:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ae5:	48 01 d0             	add    %rdx,%rax
  8004202ae8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			pages[i].pp_ref += 1;
  8004202aef:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202af6:	00 00 00 
  8004202af9:	48 8b 00             	mov    (%rax),%rax
  8004202afc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202b00:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202b04:	48 01 c2             	add    %rax,%rdx
  8004202b07:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202b0e:	00 00 00 
  8004202b11:	48 8b 00             	mov    (%rax),%rax
  8004202b14:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004202b18:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202b1c:	48 01 c8             	add    %rcx,%rax
  8004202b1f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202b23:	83 c0 01             	add    $0x1,%eax
  8004202b26:	66 89 42 08          	mov    %ax,0x8(%rdx)
  8004202b2a:	eb 1c                	jmp    8004202b48 <page_init+0x2d7>
		}
        //Keep hold of the link in free page list
        else
            last = &pages[i];
  8004202b2c:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004202b33:	00 00 00 
  8004202b36:	48 8b 00             	mov    (%rax),%rax
  8004202b39:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202b3d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202b41:	48 01 d0             	add    %rdx,%rax
  8004202b44:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

    size_t i;
    struct PageInfo* last = NULL;
    for (i = 0; i < npages; i++) {
  8004202b48:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004202b4d:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004202b54:	00 00 00 
  8004202b57:	48 8b 00             	mov    (%rax),%rax
  8004202b5a:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202b5e:	0f 82 2b fd ff ff    	jb     800420288f <page_init+0x1e>
		}
        //Keep hold of the link in free page list
        else
            last = &pages[i];
    }
}
  8004202b64:	48 83 c4 28          	add    $0x28,%rsp
  8004202b68:	5b                   	pop    %rbx
  8004202b69:	5d                   	pop    %rbp
  8004202b6a:	c3                   	retq   

0000008004202b6b <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202b6b:	55                   	push   %rbp
  8004202b6c:	48 89 e5             	mov    %rsp,%rbp
  8004202b6f:	48 83 ec 20          	sub    $0x20,%rsp
  8004202b73:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo* phypage = page_free_list;
  8004202b76:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202b7d:	00 00 00 
  8004202b80:	48 8b 00             	mov    (%rax),%rax
  8004202b83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (phypage) {
  8004202b87:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202b8c:	0f 84 ad 00 00 00    	je     8004202c3f <page_alloc+0xd4>
        if(phypage->pp_link == phypage)
  8004202b92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b96:	48 8b 00             	mov    (%rax),%rax
  8004202b99:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004202b9d:	75 13                	jne    8004202bb2 <page_alloc+0x47>
            page_free_list = NULL;
  8004202b9f:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202ba6:	00 00 00 
  8004202ba9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004202bb0:	eb 14                	jmp    8004202bc6 <page_alloc+0x5b>
        else
            page_free_list = phypage->pp_link;
  8004202bb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bb6:	48 8b 10             	mov    (%rax),%rdx
  8004202bb9:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202bc0:	00 00 00 
  8004202bc3:	48 89 10             	mov    %rdx,(%rax)
        phypage->pp_link = NULL;
  8004202bc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bca:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        if(alloc_flags & ALLOC_ZERO)
  8004202bd1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202bd4:	83 e0 01             	and    $0x1,%eax
  8004202bd7:	84 c0                	test   %al,%al
  8004202bd9:	74 2c                	je     8004202c07 <page_alloc+0x9c>
            memset(page2kva(phypage),'\0',PGSIZE);
  8004202bdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bdf:	48 89 c7             	mov    %rax,%rdi
  8004202be2:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004202be9:	00 00 00 
  8004202bec:	ff d0                	callq  *%rax
  8004202bee:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202bf3:	be 00 00 00 00       	mov    $0x0,%esi
  8004202bf8:	48 89 c7             	mov    %rax,%rdi
  8004202bfb:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004202c02:	00 00 00 
  8004202c05:	ff d0                	callq  *%rax
        if(alloc_flags == 0)
  8004202c07:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004202c0b:	75 2c                	jne    8004202c39 <page_alloc+0xce>
            memset(page2kva(phypage),0,PGSIZE);
  8004202c0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c11:	48 89 c7             	mov    %rax,%rdi
  8004202c14:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004202c1b:	00 00 00 
  8004202c1e:	ff d0                	callq  *%rax
  8004202c20:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202c25:	be 00 00 00 00       	mov    $0x0,%esi
  8004202c2a:	48 89 c7             	mov    %rax,%rdi
  8004202c2d:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004202c34:	00 00 00 
  8004202c37:	ff d0                	callq  *%rax
        return phypage;
  8004202c39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c3d:	eb 05                	jmp    8004202c44 <page_alloc+0xd9>
    }
    return NULL;
  8004202c3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004202c44:	c9                   	leaveq 
  8004202c45:	c3                   	retq   

0000008004202c46 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202c46:	55                   	push   %rbp
  8004202c47:	48 89 e5             	mov    %rsp,%rbp
  8004202c4a:	48 83 ec 10          	sub    $0x10,%rsp
  8004202c4e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202c52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c56:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202c5b:	be 00 00 00 00       	mov    $0x0,%esi
  8004202c60:	48 89 c7             	mov    %rax,%rdi
  8004202c63:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004202c6a:	00 00 00 
  8004202c6d:	ff d0                	callq  *%rax
}
  8004202c6f:	c9                   	leaveq 
  8004202c70:	c3                   	retq   

0000008004202c71 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202c71:	55                   	push   %rbp
  8004202c72:	48 89 e5             	mov    %rsp,%rbp
  8004202c75:	48 83 ec 20          	sub    $0x20,%rsp
  8004202c79:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp) {
  8004202c7d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202c82:	0f 84 9e 00 00 00    	je     8004202d26 <page_free+0xb5>
        if (pp->pp_link || pp->pp_ref)
  8004202c88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c8c:	48 8b 00             	mov    (%rax),%rax
  8004202c8f:	48 85 c0             	test   %rax,%rax
  8004202c92:	75 0d                	jne    8004202ca1 <page_free+0x30>
  8004202c94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c98:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c9c:	66 85 c0             	test   %ax,%ax
  8004202c9f:	74 2a                	je     8004202ccb <page_free+0x5a>
           	panic("Not able to free page either being used by something else or is already free");
  8004202ca1:	48 ba d8 c8 21 04 80 	movabs $0x800421c8d8,%rdx
  8004202ca8:	00 00 00 
  8004202cab:	be f3 01 00 00       	mov    $0x1f3,%esi
  8004202cb0:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202cb7:	00 00 00 
  8004202cba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202cbf:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  8004202cc6:	00 00 00 
  8004202cc9:	ff d1                	callq  *%rcx
        struct PageInfo* last = page_free_list;
  8004202ccb:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202cd2:	00 00 00 
  8004202cd5:	48 8b 00             	mov    (%rax),%rax
  8004202cd8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        if(last) {
  8004202cdc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202ce1:	74 27                	je     8004202d0a <page_free+0x99>
            pp->pp_link = page_free_list;
  8004202ce3:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202cea:	00 00 00 
  8004202ced:	48 8b 10             	mov    (%rax),%rdx
  8004202cf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202cf4:	48 89 10             	mov    %rdx,(%rax)
            page_free_list = pp;
  8004202cf7:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202cfe:	00 00 00 
  8004202d01:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d05:	48 89 10             	mov    %rdx,(%rax)
  8004202d08:	eb 1c                	jmp    8004202d26 <page_free+0xb5>
        }
        else {
            page_free_list = pp;
  8004202d0a:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004202d11:	00 00 00 
  8004202d14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d18:	48 89 10             	mov    %rdx,(%rax)
            pp->pp_link = pp;
  8004202d1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202d1f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d23:	48 89 10             	mov    %rdx,(%rax)
        }
    }
}
  8004202d26:	c9                   	leaveq 
  8004202d27:	c3                   	retq   

0000008004202d28 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202d28:	55                   	push   %rbp
  8004202d29:	48 89 e5             	mov    %rsp,%rbp
  8004202d2c:	48 83 ec 10          	sub    $0x10,%rsp
  8004202d30:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202d34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d38:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202d3c:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202d3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d43:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202d47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d4b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202d4f:	66 85 c0             	test   %ax,%ax
  8004202d52:	75 13                	jne    8004202d67 <page_decref+0x3f>
		page_free(pp);
  8004202d54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d58:	48 89 c7             	mov    %rax,%rdi
  8004202d5b:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  8004202d62:	00 00 00 
  8004202d65:	ff d0                	callq  *%rax
}
  8004202d67:	c9                   	leaveq 
  8004202d68:	c3                   	retq   

0000008004202d69 <pml4e_walk>:
// Hint 3: look at inc/mmu.h for useful macros that mainipulate page
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create) {
  8004202d69:	55                   	push   %rbp
  8004202d6a:	48 89 e5             	mov    %rsp,%rbp
  8004202d6d:	48 83 ec 60          	sub    $0x60,%rsp
  8004202d71:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004202d75:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004202d79:	89 55 ac             	mov    %edx,-0x54(%rbp)

	if (pml4e) {
  8004202d7c:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004202d81:	0f 84 21 02 00 00    	je     8004202fa8 <pml4e_walk+0x23f>
        pml4e_t* level4 = &pml4e[PML4(va)] ;
  8004202d87:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202d8b:	48 c1 e8 27          	shr    $0x27,%rax
  8004202d8f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202d94:	48 c1 e0 03          	shl    $0x3,%rax
  8004202d98:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004202d9c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        pdpe_t* level3 = NULL;
  8004202da0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202da7:	00 
		if (*level4 == 0) {
  8004202da8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202dac:	48 8b 00             	mov    (%rax),%rax
  8004202daf:	48 85 c0             	test   %rax,%rax
  8004202db2:	0f 85 54 01 00 00    	jne    8004202f0c <pml4e_walk+0x1a3>
            if (create) {
  8004202db8:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004202dbc:	0f 84 40 01 00 00    	je     8004202f02 <pml4e_walk+0x199>
                struct PageInfo* pp = page_alloc(0);
  8004202dc2:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202dc7:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004202dce:	00 00 00 
  8004202dd1:	ff d0                	callq  *%rax
  8004202dd3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                if (!pp)
  8004202dd7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202ddc:	75 0a                	jne    8004202de8 <pml4e_walk+0x7f>
                    return NULL;
  8004202dde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202de3:	e9 ea 01 00 00       	jmpq   8004202fd2 <pml4e_walk+0x269>
                pp->pp_ref++;
  8004202de8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202dec:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202df0:	8d 50 01             	lea    0x1(%rax),%edx
  8004202df3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202df7:	66 89 50 08          	mov    %dx,0x8(%rax)
                level3 = (pdpe_t*)page2kva(pp);
  8004202dfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202dff:	48 89 c7             	mov    %rax,%rdi
  8004202e02:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004202e09:	00 00 00 
  8004202e0c:	ff d0                	callq  *%rax
  8004202e0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
                *level4 = (pml4e_t)PADDR(level3);
  8004202e12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e16:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202e1a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e21:	00 00 00 
  8004202e24:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202e28:	77 32                	ja     8004202e5c <pml4e_walk+0xf3>
  8004202e2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202e2e:	48 89 c1             	mov    %rax,%rcx
  8004202e31:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004202e38:	00 00 00 
  8004202e3b:	be 31 02 00 00       	mov    $0x231,%esi
  8004202e40:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202e47:	00 00 00 
  8004202e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e4f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202e56:	00 00 00 
  8004202e59:	41 ff d0             	callq  *%r8
  8004202e5c:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202e63:	ff ff ff 
  8004202e66:	48 89 c2             	mov    %rax,%rdx
  8004202e69:	48 03 55 e0          	add    -0x20(%rbp),%rdx
  8004202e6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e71:	48 89 10             	mov    %rdx,(%rax)
                *level4 |= PTE_USER;
  8004202e74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e78:	48 8b 00             	mov    (%rax),%rax
  8004202e7b:	48 89 c2             	mov    %rax,%rdx
  8004202e7e:	48 81 ca 07 0e 00 00 	or     $0xe07,%rdx
  8004202e85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e89:	48 89 10             	mov    %rdx,(%rax)
                memset(level3, 0, PGSIZE);
  8004202e8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e90:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202e95:	be 00 00 00 00       	mov    $0x0,%esi
  8004202e9a:	48 89 c7             	mov    %rax,%rdi
  8004202e9d:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004202ea4:	00 00 00 
  8004202ea7:	ff d0                	callq  *%rax
				pte_t *level1 = pdpe_walk(level3, va, create);
  8004202ea9:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202eac:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004202eb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202eb4:	48 89 ce             	mov    %rcx,%rsi
  8004202eb7:	48 89 c7             	mov    %rax,%rdi
  8004202eba:	48 b8 d4 2f 20 04 80 	movabs $0x8004202fd4,%rax
  8004202ec1:	00 00 00 
  8004202ec4:	ff d0                	callq  *%rax
  8004202ec6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                if (!level1) {
  8004202eca:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004202ecf:	75 28                	jne    8004202ef9 <pml4e_walk+0x190>
                    page_decref(pp);
  8004202ed1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202ed5:	48 89 c7             	mov    %rax,%rdi
  8004202ed8:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004202edf:	00 00 00 
  8004202ee2:	ff d0                	callq  *%rax
                    *level4 = 0;
  8004202ee4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ee8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
                    return NULL;
  8004202eef:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ef4:	e9 d9 00 00 00       	jmpq   8004202fd2 <pml4e_walk+0x269>
                }
                return level1;
  8004202ef9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202efd:	e9 d0 00 00 00       	jmpq   8004202fd2 <pml4e_walk+0x269>
            }
            else {
                return NULL;
  8004202f02:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f07:	e9 c6 00 00 00       	jmpq   8004202fd2 <pml4e_walk+0x269>
            }
        }
        else {
            level3 = (pdpe_t*)KADDR(PTE_ADDR(*level4));
  8004202f0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f10:	48 8b 00             	mov    (%rax),%rax
  8004202f13:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202f19:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202f1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202f21:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f25:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202f28:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202f2b:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004202f32:	00 00 00 
  8004202f35:	48 8b 00             	mov    (%rax),%rax
  8004202f38:	48 39 c2             	cmp    %rax,%rdx
  8004202f3b:	72 32                	jb     8004202f6f <pml4e_walk+0x206>
  8004202f3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202f41:	48 89 c1             	mov    %rax,%rcx
  8004202f44:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004202f4b:	00 00 00 
  8004202f4e:	be 41 02 00 00       	mov    $0x241,%esi
  8004202f53:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202f5a:	00 00 00 
  8004202f5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f62:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004202f69:	00 00 00 
  8004202f6c:	41 ff d0             	callq  *%r8
  8004202f6f:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202f76:	00 00 00 
  8004202f79:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004202f7d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
            pte_t *level1 = pdpe_walk(level3, va, create);
  8004202f81:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202f84:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004202f88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f8c:	48 89 ce             	mov    %rcx,%rsi
  8004202f8f:	48 89 c7             	mov    %rax,%rdi
  8004202f92:	48 b8 d4 2f 20 04 80 	movabs $0x8004202fd4,%rax
  8004202f99:	00 00 00 
  8004202f9c:	ff d0                	callq  *%rax
  8004202f9e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            return level1;
  8004202fa2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202fa6:	eb 2a                	jmp    8004202fd2 <pml4e_walk+0x269>
        }
    }
    else
		panic("'page_free_list' is a null pointer!");
  8004202fa8:	48 ba 28 c9 21 04 80 	movabs $0x800421c928,%rdx
  8004202faf:	00 00 00 
  8004202fb2:	be 47 02 00 00       	mov    $0x247,%esi
  8004202fb7:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004202fbe:	00 00 00 
  8004202fc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fc6:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  8004202fcd:	00 00 00 
  8004202fd0:	ff d1                	callq  *%rcx
}
  8004202fd2:	c9                   	leaveq 
  8004202fd3:	c3                   	retq   

0000008004202fd4 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create) {
  8004202fd4:	55                   	push   %rbp
  8004202fd5:	48 89 e5             	mov    %rsp,%rbp
  8004202fd8:	48 83 ec 60          	sub    $0x60,%rsp
  8004202fdc:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004202fe0:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004202fe4:	89 55 ac             	mov    %edx,-0x54(%rbp)
	
	pdpe_t* level3 = &pdpe[PDPE(va)];
  8004202fe7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202feb:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202fef:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202ff4:	48 c1 e0 03          	shl    $0x3,%rax
  8004202ff8:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004202ffc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    pde_t* level2 = NULL;
  8004203000:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203007:	00 
    if (*level3 == 0) {
  8004203008:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420300c:	48 8b 00             	mov    (%rax),%rax
  800420300f:	48 85 c0             	test   %rax,%rax
  8004203012:	0f 85 54 01 00 00    	jne    800420316c <pdpe_walk+0x198>
        if (create) {
  8004203018:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800420301c:	0f 84 40 01 00 00    	je     8004203162 <pdpe_walk+0x18e>
            struct PageInfo* pp = page_alloc(0);
  8004203022:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203027:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420302e:	00 00 00 
  8004203031:	ff d0                	callq  *%rax
  8004203033:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
            if (!pp) 
  8004203037:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420303c:	75 0a                	jne    8004203048 <pdpe_walk+0x74>
                return NULL;
  800420303e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203043:	e9 be 01 00 00       	jmpq   8004203206 <pdpe_walk+0x232>
            pp->pp_ref++;
  8004203048:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420304c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203050:	8d 50 01             	lea    0x1(%rax),%edx
  8004203053:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203057:	66 89 50 08          	mov    %dx,0x8(%rax)
            level2 = (pde_t*)page2kva(pp);
  800420305b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420305f:	48 89 c7             	mov    %rax,%rdi
  8004203062:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004203069:	00 00 00 
  800420306c:	ff d0                	callq  *%rax
  800420306e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
            *level3 = (pdpe_t)PADDR(level2);
  8004203072:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203076:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420307a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203081:	00 00 00 
  8004203084:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004203088:	77 32                	ja     80042030bc <pdpe_walk+0xe8>
  800420308a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420308e:	48 89 c1             	mov    %rax,%rcx
  8004203091:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004203098:	00 00 00 
  800420309b:	be 5b 02 00 00       	mov    $0x25b,%esi
  80042030a0:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042030a7:	00 00 00 
  80042030aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030af:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042030b6:	00 00 00 
  80042030b9:	41 ff d0             	callq  *%r8
  80042030bc:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042030c3:	ff ff ff 
  80042030c6:	48 89 c2             	mov    %rax,%rdx
  80042030c9:	48 03 55 e0          	add    -0x20(%rbp),%rdx
  80042030cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030d1:	48 89 10             	mov    %rdx,(%rax)
            *level3 |= PTE_USER;
  80042030d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030d8:	48 8b 00             	mov    (%rax),%rax
  80042030db:	48 89 c2             	mov    %rax,%rdx
  80042030de:	48 81 ca 07 0e 00 00 	or     $0xe07,%rdx
  80042030e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030e9:	48 89 10             	mov    %rdx,(%rax)
			memset(level2, 0, PGSIZE);
  80042030ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042030f0:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042030f5:	be 00 00 00 00       	mov    $0x0,%esi
  80042030fa:	48 89 c7             	mov    %rax,%rdi
  80042030fd:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004203104:	00 00 00 
  8004203107:	ff d0                	callq  *%rax
			pte_t *level1 =  pgdir_walk(level2, va, create);
  8004203109:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420310c:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004203110:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203114:	48 89 ce             	mov    %rcx,%rsi
  8004203117:	48 89 c7             	mov    %rax,%rdi
  800420311a:	48 b8 08 32 20 04 80 	movabs $0x8004203208,%rax
  8004203121:	00 00 00 
  8004203124:	ff d0                	callq  *%rax
  8004203126:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
            if (!level1) {
  800420312a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420312f:	75 28                	jne    8004203159 <pdpe_walk+0x185>
                page_decref(pp);
  8004203131:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203135:	48 89 c7             	mov    %rax,%rdi
  8004203138:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  800420313f:	00 00 00 
  8004203142:	ff d0                	callq  *%rax
                *level3 = 0;
  8004203144:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203148:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
                return NULL;
  800420314f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203154:	e9 ad 00 00 00       	jmpq   8004203206 <pdpe_walk+0x232>
            }
            return level1;
  8004203159:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420315d:	e9 a4 00 00 00       	jmpq   8004203206 <pdpe_walk+0x232>
        }
        else {
            return NULL;
  8004203162:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203167:	e9 9a 00 00 00       	jmpq   8004203206 <pdpe_walk+0x232>
        }
    }
    else {
        level2 = (pde_t*)KADDR(PTE_ADDR(*level3));
  800420316c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203170:	48 8b 00             	mov    (%rax),%rax
  8004203173:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203179:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420317d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203181:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203185:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004203188:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420318b:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004203192:	00 00 00 
  8004203195:	48 8b 00             	mov    (%rax),%rax
  8004203198:	48 39 c2             	cmp    %rax,%rdx
  800420319b:	72 32                	jb     80042031cf <pdpe_walk+0x1fb>
  800420319d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042031a1:	48 89 c1             	mov    %rax,%rcx
  80042031a4:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  80042031ab:	00 00 00 
  80042031ae:	be 6b 02 00 00       	mov    $0x26b,%esi
  80042031b3:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042031ba:	00 00 00 
  80042031bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031c2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042031c9:	00 00 00 
  80042031cc:	41 ff d0             	callq  *%r8
  80042031cf:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042031d6:	00 00 00 
  80042031d9:	48 03 45 d0          	add    -0x30(%rbp),%rax
  80042031dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        pte_t *level1 =  pgdir_walk(level2, va, create);
  80042031e1:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042031e4:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042031e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031ec:	48 89 ce             	mov    %rcx,%rsi
  80042031ef:	48 89 c7             	mov    %rax,%rdi
  80042031f2:	48 b8 08 32 20 04 80 	movabs $0x8004203208,%rax
  80042031f9:	00 00 00 
  80042031fc:	ff d0                	callq  *%rax
  80042031fe:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        return level1;
  8004203202:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    }
}
  8004203206:	c9                   	leaveq 
  8004203207:	c3                   	retq   

0000008004203208 <pgdir_walk>:
// a pointer to the page table entry (PTE). 
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create) {
  8004203208:	55                   	push   %rbp
  8004203209:	48 89 e5             	mov    %rsp,%rbp
  800420320c:	48 83 ec 50          	sub    $0x50,%rsp
  8004203210:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203214:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203218:	89 55 bc             	mov    %edx,-0x44(%rbp)
	// Fill this function in
	pde_t* level2 = &pgdir[PDX(va)];
  800420321b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420321f:	48 c1 e8 15          	shr    $0x15,%rax
  8004203223:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203228:	48 c1 e0 03          	shl    $0x3,%rax
  800420322c:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004203230:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    pte_t* level1 = NULL;
  8004203234:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420323b:	00 
    if (*level2 == 0) {
  800420323c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203240:	48 8b 00             	mov    (%rax),%rax
  8004203243:	48 85 c0             	test   %rax,%rax
  8004203246:	0f 85 ad 00 00 00    	jne    80042032f9 <pgdir_walk+0xf1>
        if (create) {
  800420324c:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  8004203250:	0f 84 99 00 00 00    	je     80042032ef <pgdir_walk+0xe7>
            struct PageInfo* pp = page_alloc(0);
  8004203256:	bf 00 00 00 00       	mov    $0x0,%edi
  800420325b:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004203262:	00 00 00 
  8004203265:	ff d0                	callq  *%rax
  8004203267:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
            if (!pp)
  800420326b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203270:	75 0a                	jne    800420327c <pgdir_walk+0x74>
                return NULL;
  8004203272:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203277:	e9 0b 01 00 00       	jmpq   8004203387 <pgdir_walk+0x17f>
            pp->pp_ref++;
  800420327c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203280:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203284:	8d 50 01             	lea    0x1(%rax),%edx
  8004203287:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420328b:	66 89 50 08          	mov    %dx,0x8(%rax)
            *level2 = page2pa(pp);
  800420328f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203293:	48 89 c7             	mov    %rax,%rdi
  8004203296:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  800420329d:	00 00 00 
  80042032a0:	ff d0                	callq  *%rax
  80042032a2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042032a6:	48 89 02             	mov    %rax,(%rdx)
            *level2 |= PTE_USER;
  80042032a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032ad:	48 8b 00             	mov    (%rax),%rax
  80042032b0:	48 89 c2             	mov    %rax,%rdx
  80042032b3:	48 81 ca 07 0e 00 00 	or     $0xe07,%rdx
  80042032ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032be:	48 89 10             	mov    %rdx,(%rax)
			memset(page2kva(pp), 0, PGSIZE);
  80042032c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032c5:	48 89 c7             	mov    %rax,%rdi
  80042032c8:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  80042032cf:	00 00 00 
  80042032d2:	ff d0                	callq  *%rax
  80042032d4:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042032d9:	be 00 00 00 00       	mov    $0x0,%esi
  80042032de:	48 89 c7             	mov    %rax,%rdi
  80042032e1:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042032e8:	00 00 00 
  80042032eb:	ff d0                	callq  *%rax
  80042032ed:	eb 0a                	jmp    80042032f9 <pgdir_walk+0xf1>
        }
        else
            return NULL;
  80042032ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032f4:	e9 8e 00 00 00       	jmpq   8004203387 <pgdir_walk+0x17f>
    }
    level1 = (pte_t*)KADDR(PTE_ADDR(*level2));
  80042032f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032fd:	48 8b 00             	mov    (%rax),%rax
  8004203300:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203306:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420330a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420330e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203312:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203315:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203318:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420331f:	00 00 00 
  8004203322:	48 8b 00             	mov    (%rax),%rax
  8004203325:	48 39 c2             	cmp    %rax,%rdx
  8004203328:	72 32                	jb     800420335c <pgdir_walk+0x154>
  800420332a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420332e:	48 89 c1             	mov    %rax,%rcx
  8004203331:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004203338:	00 00 00 
  800420333b:	be 87 02 00 00       	mov    $0x287,%esi
  8004203340:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203347:	00 00 00 
  800420334a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420334f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203356:	00 00 00 
  8004203359:	41 ff d0             	callq  *%r8
  800420335c:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004203363:	00 00 00 
  8004203366:	48 03 45 e0          	add    -0x20(%rbp),%rax
  800420336a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    level1 = &level1[PTX(va)];
  800420336e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203372:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203376:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420337b:	48 c1 e0 03          	shl    $0x3,%rax
  800420337f:	48 01 45 f0          	add    %rax,-0x10(%rbp)
    return level1;
  8004203383:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004203387:	c9                   	leaveq 
  8004203388:	c3                   	retq   

0000008004203389 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203389:	55                   	push   %rbp
  800420338a:	48 89 e5             	mov    %rsp,%rbp
  800420338d:	48 83 ec 40          	sub    $0x40,%rsp
  8004203391:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203395:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203399:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420339d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042033a1:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	// Fill this function in
	size_t i;
    for(i=0; i < size; i+=PGSIZE)
  80042033a5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042033ac:	00 
  80042033ad:	eb 71                	jmp    8004203420 <boot_map_region+0x97>
    {
        pte_t* ventry = pml4e_walk(pml4e, (void*)(la+i), 1);
  80042033af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042033b3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042033b7:	48 01 d0             	add    %rdx,%rax
  80042033ba:	48 89 c1             	mov    %rax,%rcx
  80042033bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033c1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042033c6:	48 89 ce             	mov    %rcx,%rsi
  80042033c9:	48 89 c7             	mov    %rax,%rdi
  80042033cc:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  80042033d3:	00 00 00 
  80042033d6:	ff d0                	callq  *%rax
  80042033d8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        if (ventry) {
  80042033dc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042033e1:	74 35                	je     8004203418 <boot_map_region+0x8f>
            *ventry = PTE_ADDR(pa+i); //Just in case
  80042033e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042033e7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042033eb:	48 01 d0             	add    %rdx,%rax
  80042033ee:	48 89 c2             	mov    %rax,%rdx
  80042033f1:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  80042033f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042033fc:	48 89 10             	mov    %rdx,(%rax)
            *ventry |= perm|PTE_P;
  80042033ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203403:	48 8b 10             	mov    (%rax),%rdx
  8004203406:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004203409:	83 c8 01             	or     $0x1,%eax
  800420340c:	48 98                	cltq   
  800420340e:	48 09 c2             	or     %rax,%rdx
  8004203411:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203415:	48 89 10             	mov    %rdx,(%rax)
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	size_t i;
    for(i=0; i < size; i+=PGSIZE)
  8004203418:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420341f:	00 
  8004203420:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203424:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203428:	72 85                	jb     80042033af <boot_map_region+0x26>
            *ventry = PTE_ADDR(pa+i); //Just in case
            *ventry |= perm|PTE_P;
        }
    }

}
  800420342a:	c9                   	leaveq 
  800420342b:	c3                   	retq   

000000800420342c <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  800420342c:	55                   	push   %rbp
  800420342d:	48 89 e5             	mov    %rsp,%rbp
  8004203430:	53                   	push   %rbx
  8004203431:	48 83 ec 38          	sub    $0x38,%rsp
  8004203435:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203439:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420343d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203441:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	// Fill this function in
	pte_t* page_entry = pml4e_walk(pml4e, va, 1);
  8004203444:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004203448:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420344c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203451:	48 89 ce             	mov    %rcx,%rsi
  8004203454:	48 89 c7             	mov    %rax,%rdi
  8004203457:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  800420345e:	00 00 00 
  8004203461:	ff d0                	callq  *%rax
  8004203463:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (page_entry) {
  8004203467:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420346c:	0f 84 01 01 00 00    	je     8004203573 <page_insert+0x147>
        if (PTE_ADDR(*page_entry) == page2pa(pp)){
  8004203472:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203476:	48 8b 00             	mov    (%rax),%rax
  8004203479:	48 89 c3             	mov    %rax,%rbx
  800420347c:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  8004203483:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203487:	48 89 c7             	mov    %rax,%rdi
  800420348a:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203491:	00 00 00 
  8004203494:	ff d0                	callq  *%rax
  8004203496:	48 39 c3             	cmp    %rax,%rbx
  8004203499:	75 4b                	jne    80042034e6 <page_insert+0xba>
            *page_entry = PTE_ADDR(*page_entry) | perm | PTE_P;
  800420349b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420349f:	48 8b 00             	mov    (%rax),%rax
  80042034a2:	48 89 c2             	mov    %rax,%rdx
  80042034a5:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  80042034ac:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042034af:	48 98                	cltq   
  80042034b1:	48 09 d0             	or     %rdx,%rax
  80042034b4:	48 89 c2             	mov    %rax,%rdx
  80042034b7:	48 83 ca 01          	or     $0x1,%rdx
  80042034bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042034bf:	48 89 10             	mov    %rdx,(%rax)
			tlb_invalidate(pml4e, va);
  80042034c2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042034c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034ca:	48 89 d6             	mov    %rdx,%rsi
  80042034cd:	48 89 c7             	mov    %rax,%rdi
  80042034d0:	48 b8 77 36 20 04 80 	movabs $0x8004203677,%rax
  80042034d7:	00 00 00 
  80042034da:	ff d0                	callq  *%rax
            return 0;
  80042034dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034e1:	e9 92 00 00 00       	jmpq   8004203578 <page_insert+0x14c>
        }
        if(*page_entry != 0) {
  80042034e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042034ea:	48 8b 00             	mov    (%rax),%rax
  80042034ed:	48 85 c0             	test   %rax,%rax
  80042034f0:	74 34                	je     8004203526 <page_insert+0xfa>
            page_remove(pml4e, va);
  80042034f2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042034f6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034fa:	48 89 d6             	mov    %rdx,%rsi
  80042034fd:	48 89 c7             	mov    %rax,%rdi
  8004203500:	48 b8 fc 35 20 04 80 	movabs $0x80042035fc,%rax
  8004203507:	00 00 00 
  800420350a:	ff d0                	callq  *%rax
            tlb_invalidate(pml4e, va);
  800420350c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203510:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203514:	48 89 d6             	mov    %rdx,%rsi
  8004203517:	48 89 c7             	mov    %rax,%rdi
  800420351a:	48 b8 77 36 20 04 80 	movabs $0x8004203677,%rax
  8004203521:	00 00 00 
  8004203524:	ff d0                	callq  *%rax
        }
        *page_entry = page2pa(pp);
  8004203526:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420352a:	48 89 c7             	mov    %rax,%rdi
  800420352d:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203534:	00 00 00 
  8004203537:	ff d0                	callq  *%rax
  8004203539:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420353d:	48 89 02             	mov    %rax,(%rdx)
        *page_entry |= perm | PTE_P;
  8004203540:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203544:	48 8b 10             	mov    (%rax),%rdx
  8004203547:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420354a:	83 c8 01             	or     $0x1,%eax
  800420354d:	48 98                	cltq   
  800420354f:	48 09 c2             	or     %rax,%rdx
  8004203552:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203556:	48 89 10             	mov    %rdx,(%rax)
        pp->pp_ref += 1;
  8004203559:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420355d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203561:	8d 50 01             	lea    0x1(%rax),%edx
  8004203564:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203568:	66 89 50 08          	mov    %dx,0x8(%rax)
        return 0;
  800420356c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203571:	eb 05                	jmp    8004203578 <page_insert+0x14c>
    }
    return -E_NO_MEM;
  8004203573:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  8004203578:	48 83 c4 38          	add    $0x38,%rsp
  800420357c:	5b                   	pop    %rbx
  800420357d:	5d                   	pop    %rbp
  800420357e:	c3                   	retq   

000000800420357f <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  800420357f:	55                   	push   %rbp
  8004203580:	48 89 e5             	mov    %rsp,%rbp
  8004203583:	48 83 ec 30          	sub    $0x30,%rsp
  8004203587:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420358b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420358f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t* level1 = pml4e_walk(pml4e, va, 0);
  8004203593:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203597:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420359b:	ba 00 00 00 00       	mov    $0x0,%edx
  80042035a0:	48 89 ce             	mov    %rcx,%rsi
  80042035a3:	48 89 c7             	mov    %rax,%rdi
  80042035a6:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  80042035ad:	00 00 00 
  80042035b0:	ff d0                	callq  *%rax
  80042035b2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (level1) {
  80042035b6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042035bb:	74 38                	je     80042035f5 <page_lookup+0x76>
        if(pte_store)
  80042035bd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042035c2:	74 0b                	je     80042035cf <page_lookup+0x50>
            *pte_store = level1;
  80042035c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042035c8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042035cc:	48 89 10             	mov    %rdx,(%rax)
        physaddr_t pt = PTE_ADDR(*level1); //To remove permission bits
  80042035cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035d3:	48 8b 00             	mov    (%rax),%rax
  80042035d6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042035dc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        return pa2page(pt);
  80042035e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042035e4:	48 89 c7             	mov    %rax,%rdi
  80042035e7:	48 b8 11 18 20 04 80 	movabs $0x8004201811,%rax
  80042035ee:	00 00 00 
  80042035f1:	ff d0                	callq  *%rax
  80042035f3:	eb 05                	jmp    80042035fa <page_lookup+0x7b>
    }
    return NULL;
  80042035f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042035fa:	c9                   	leaveq 
  80042035fb:	c3                   	retq   

00000080042035fc <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  80042035fc:	55                   	push   %rbp
  80042035fd:	48 89 e5             	mov    %rsp,%rbp
  8004203600:	48 83 ec 20          	sub    $0x20,%rsp
  8004203604:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203608:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	pte_t* ptentry = NULL;
  800420360c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203613:	00 
    struct PageInfo *pp = page_lookup(pml4e, va, &ptentry);
  8004203614:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203618:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420361c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203620:	48 89 ce             	mov    %rcx,%rsi
  8004203623:	48 89 c7             	mov    %rax,%rdi
  8004203626:	48 b8 7f 35 20 04 80 	movabs $0x800420357f,%rax
  800420362d:	00 00 00 
  8004203630:	ff d0                	callq  *%rax
  8004203632:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(pp) {
  8004203636:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420363b:	74 38                	je     8004203675 <page_remove+0x79>
        page_decref(pp);
  800420363d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203641:	48 89 c7             	mov    %rax,%rdi
  8004203644:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  800420364b:	00 00 00 
  800420364e:	ff d0                	callq  *%rax
        *ptentry = 0;
  8004203650:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203654:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        tlb_invalidate(pml4e, va);
  800420365b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420365f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203663:	48 89 d6             	mov    %rdx,%rsi
  8004203666:	48 89 c7             	mov    %rax,%rdi
  8004203669:	48 b8 77 36 20 04 80 	movabs $0x8004203677,%rax
  8004203670:	00 00 00 
  8004203673:	ff d0                	callq  *%rax
    }
}
  8004203675:	c9                   	leaveq 
  8004203676:	c3                   	retq   

0000008004203677 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203677:	55                   	push   %rbp
  8004203678:	48 89 e5             	mov    %rsp,%rbp
  800420367b:	48 83 ec 20          	sub    $0x20,%rsp
  800420367f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203683:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203687:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420368c:	75 35                	jne    80042036c3 <tlb_invalidate+0x4c>
  800420368e:	48 b9 4c c9 21 04 80 	movabs $0x800421c94c,%rcx
  8004203695:	00 00 00 
  8004203698:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420369f:	00 00 00 
  80042036a2:	be 14 03 00 00       	mov    $0x314,%esi
  80042036a7:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042036ae:	00 00 00 
  80042036b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036b6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042036bd:	00 00 00 
  80042036c0:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  80042036c3:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042036ca:	00 00 00 
  80042036cd:	ff d0                	callq  *%rax
  80042036cf:	48 98                	cltq   
  80042036d1:	48 c1 e0 03          	shl    $0x3,%rax
  80042036d5:	48 89 c2             	mov    %rax,%rdx
  80042036d8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042036dc:	48 01 c2             	add    %rax,%rdx
  80042036df:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042036e6:	00 00 00 
  80042036e9:	48 01 d0             	add    %rdx,%rax
  80042036ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042036f0:	48 85 c0             	test   %rax,%rax
  80042036f3:	74 3a                	je     800420372f <tlb_invalidate+0xb8>
  80042036f5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042036fc:	00 00 00 
  80042036ff:	ff d0                	callq  *%rax
  8004203701:	48 98                	cltq   
  8004203703:	48 c1 e0 03          	shl    $0x3,%rax
  8004203707:	48 89 c2             	mov    %rax,%rdx
  800420370a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420370e:	48 01 c2             	add    %rax,%rdx
  8004203711:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004203718:	00 00 00 
  800420371b:	48 01 d0             	add    %rdx,%rax
  800420371e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004203722:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203729:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420372d:	75 0f                	jne    800420373e <tlb_invalidate+0xc7>
  800420372f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203733:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void 
invlpg(void *addr)
{ 
    __asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203737:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420373b:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  800420373e:	c9                   	leaveq 
  800420373f:	c3                   	retq   

0000008004203740 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203740:	55                   	push   %rbp
  8004203741:	48 89 e5             	mov    %rsp,%rbp
  8004203744:	48 83 ec 30          	sub    $0x30,%rsp
  8004203748:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420374c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	size_t newsize = ROUNDUP(size, PGSIZE);
  8004203750:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004203757:	00 
  8004203758:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420375c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203760:	48 01 d0             	add    %rdx,%rax
  8004203763:	48 83 e8 01          	sub    $0x1,%rax
  8004203767:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420376b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420376f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203774:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004203778:	48 89 d0             	mov    %rdx,%rax
  800420377b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420377f:	48 89 d1             	mov    %rdx,%rcx
  8004203782:	48 29 c1             	sub    %rax,%rcx
  8004203785:	48 89 c8             	mov    %rcx,%rax
  8004203788:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(base+newsize >= MMIOLIM) {
  800420378c:	48 b8 b0 05 23 04 80 	movabs $0x80042305b0,%rax
  8004203793:	00 00 00 
  8004203796:	48 8b 00             	mov    (%rax),%rax
  8004203799:	48 89 c2             	mov    %rax,%rdx
  800420379c:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  80042037a0:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042037a7:	00 00 00 
  80042037aa:	48 39 c2             	cmp    %rax,%rdx
  80042037ad:	76 2a                	jbe    80042037d9 <mmio_map_region+0x99>
		panic("mmio_map_region out of range");
  80042037af:	48 ba 58 c9 21 04 80 	movabs $0x800421c958,%rdx
  80042037b6:	00 00 00 
  80042037b9:	be 3b 03 00 00       	mov    $0x33b,%esi
  80042037be:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042037c5:	00 00 00 
  80042037c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037cd:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  80042037d4:	00 00 00 
  80042037d7:	ff d1                	callq  *%rcx
	}
 	boot_map_region(boot_pml4e, base, newsize, pa, PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  80042037d9:	48 b8 b0 05 23 04 80 	movabs $0x80042305b0,%rax
  80042037e0:	00 00 00 
  80042037e3:	48 8b 30             	mov    (%rax),%rsi
  80042037e6:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042037ed:	00 00 00 
  80042037f0:	48 8b 00             	mov    (%rax),%rax
  80042037f3:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042037f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042037fb:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004203801:	48 89 c7             	mov    %rax,%rdi
  8004203804:	48 b8 89 33 20 04 80 	movabs $0x8004203389,%rax
  800420380b:	00 00 00 
  800420380e:	ff d0                	callq  *%rax
	//panic("mmio_map_region not implemented");
	uintptr_t len = base;
  8004203810:	48 b8 b0 05 23 04 80 	movabs $0x80042305b0,%rax
  8004203817:	00 00 00 
  800420381a:	48 8b 00             	mov    (%rax),%rax
  800420381d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	base = base+newsize;
  8004203821:	48 b8 b0 05 23 04 80 	movabs $0x80042305b0,%rax
  8004203828:	00 00 00 
  800420382b:	48 8b 00             	mov    (%rax),%rax
  800420382e:	48 89 c2             	mov    %rax,%rdx
  8004203831:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004203835:	48 b8 b0 05 23 04 80 	movabs $0x80042305b0,%rax
  800420383c:	00 00 00 
  800420383f:	48 89 10             	mov    %rdx,(%rax)
	return (void*)len;
  8004203842:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004203846:	c9                   	leaveq 
  8004203847:	c3                   	retq   

0000008004203848 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203848:	55                   	push   %rbp
  8004203849:	48 89 e5             	mov    %rsp,%rbp
  800420384c:	48 83 ec 60          	sub    $0x60,%rsp
  8004203850:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203854:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203858:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420385c:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
	// LAB 3: Your code here.
	perm |= PTE_P;
  800420385f:	83 4d a4 01          	orl    $0x1,-0x5c(%rbp)
	uintptr_t start = ROUNDDOWN((uintptr_t)va, PGSIZE);
  8004203863:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203867:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420386b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420386f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203875:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uintptr_t end = ROUNDUP((uintptr_t)va+len, PGSIZE);
  8004203879:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203880:	00 
  8004203881:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203885:	48 03 45 a8          	add    -0x58(%rbp),%rax
  8004203889:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420388d:	48 83 e8 01          	sub    $0x1,%rax
  8004203891:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203895:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203899:	ba 00 00 00 00       	mov    $0x0,%edx
  800420389e:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042038a2:	48 89 d0             	mov    %rdx,%rax
  80042038a5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042038a9:	48 89 d1             	mov    %rdx,%rcx
  80042038ac:	48 29 c1             	sub    %rax,%rcx
  80042038af:	48 89 c8             	mov    %rcx,%rax
  80042038b2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pte_t* page;
	while (start < end) {
  80042038b6:	e9 9f 00 00 00       	jmpq   800420395a <user_mem_check+0x112>
		struct PageInfo* p = page_lookup(env->env_pml4e, (void*)start, &page);
  80042038bb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042038bf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042038c3:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042038ca:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  80042038ce:	48 89 ce             	mov    %rcx,%rsi
  80042038d1:	48 89 c7             	mov    %rax,%rdi
  80042038d4:	48 b8 7f 35 20 04 80 	movabs $0x800420357f,%rax
  80042038db:	00 00 00 
  80042038de:	ff d0                	callq  *%rax
  80042038e0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!p || (*page & perm) != perm || start >= ULIM)  {
  80042038e4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042038e9:	74 29                	je     8004203914 <user_mem_check+0xcc>
  80042038eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042038ef:	48 8b 10             	mov    (%rax),%rdx
  80042038f2:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042038f5:	48 98                	cltq   
  80042038f7:	48 21 c2             	and    %rax,%rdx
  80042038fa:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042038fd:	48 98                	cltq   
  80042038ff:	48 39 c2             	cmp    %rax,%rdx
  8004203902:	75 10                	jne    8004203914 <user_mem_check+0xcc>
  8004203904:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420390b:	00 00 00 
  800420390e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203912:	76 3e                	jbe    8004203952 <user_mem_check+0x10a>
			user_mem_check_addr = (uintptr_t) va;
  8004203914:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004203918:	48 b8 40 22 48 04 80 	movabs $0x8004482240,%rax
  800420391f:	00 00 00 
  8004203922:	48 89 10             	mov    %rdx,(%rax)
			user_mem_check_addr = (user_mem_check_addr > start) ? user_mem_check_addr : start ;
  8004203925:	48 b8 40 22 48 04 80 	movabs $0x8004482240,%rax
  800420392c:	00 00 00 
  800420392f:	48 8b 00             	mov    (%rax),%rax
  8004203932:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203936:	48 89 c2             	mov    %rax,%rdx
  8004203939:	48 0f 43 55 f8       	cmovae -0x8(%rbp),%rdx
  800420393e:	48 b8 40 22 48 04 80 	movabs $0x8004482240,%rax
  8004203945:	00 00 00 
  8004203948:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  800420394b:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203950:	eb 1b                	jmp    800420396d <user_mem_check+0x125>
		}
		start+=PGSIZE;
  8004203952:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203959:	00 
	// LAB 3: Your code here.
	perm |= PTE_P;
	uintptr_t start = ROUNDDOWN((uintptr_t)va, PGSIZE);
	uintptr_t end = ROUNDUP((uintptr_t)va+len, PGSIZE);
	pte_t* page;
	while (start < end) {
  800420395a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420395e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203962:	0f 82 53 ff ff ff    	jb     80042038bb <user_mem_check+0x73>
			user_mem_check_addr = (user_mem_check_addr > start) ? user_mem_check_addr : start ;
			return -E_FAULT;
		}
		start+=PGSIZE;
 	}
	return 0;
  8004203968:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420396d:	c9                   	leaveq 
  800420396e:	c3                   	retq   

000000800420396f <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  800420396f:	55                   	push   %rbp
  8004203970:	48 89 e5             	mov    %rsp,%rbp
  8004203973:	48 83 ec 20          	sub    $0x20,%rsp
  8004203977:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420397b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420397f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203983:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203986:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203989:	89 c1                	mov    %eax,%ecx
  800420398b:	83 c9 04             	or     $0x4,%ecx
  800420398e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203992:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203996:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420399a:	48 89 c7             	mov    %rax,%rdi
  800420399d:	48 b8 48 38 20 04 80 	movabs $0x8004203848,%rax
  80042039a4:	00 00 00 
  80042039a7:	ff d0                	callq  *%rax
  80042039a9:	85 c0                	test   %eax,%eax
  80042039ab:	79 47                	jns    80042039f4 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  80042039ad:	48 b8 40 22 48 04 80 	movabs $0x8004482240,%rax
  80042039b4:	00 00 00 
  80042039b7:	48 8b 10             	mov    (%rax),%rdx
			"va %08x\n", env->env_id, user_mem_check_addr);
  80042039ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
		cprintf("[%08x] user_mem_check assertion failure for "
  80042039be:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042039c4:	89 c6                	mov    %eax,%esi
  80042039c6:	48 bf 78 c9 21 04 80 	movabs $0x800421c978,%rdi
  80042039cd:	00 00 00 
  80042039d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042039d5:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  80042039dc:	00 00 00 
  80042039df:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  80042039e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039e5:	48 89 c7             	mov    %rax,%rdi
  80042039e8:	48 b8 59 89 20 04 80 	movabs $0x8004208959,%rax
  80042039ef:	00 00 00 
  80042039f2:	ff d0                	callq  *%rax
	}
}
  80042039f4:	c9                   	leaveq 
  80042039f5:	c3                   	retq   

00000080042039f6 <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  80042039f6:	55                   	push   %rbp
  80042039f7:	48 89 e5             	mov    %rsp,%rbp
  80042039fa:	48 83 ec 60          	sub    $0x60,%rsp
  80042039fe:	89 f8                	mov    %edi,%eax
  8004203a00:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203a03:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203a07:	74 07                	je     8004203a10 <check_page_free_list+0x1a>
  8004203a09:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203a0e:	eb 05                	jmp    8004203a15 <check_page_free_list+0x1f>
  8004203a10:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203a15:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203a18:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203a1f:	00 
  8004203a20:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203a27:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203a28:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203a2f:	00 00 00 
  8004203a32:	48 8b 00             	mov    (%rax),%rax
  8004203a35:	48 85 c0             	test   %rax,%rax
  8004203a38:	75 2a                	jne    8004203a64 <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203a3a:	48 ba 28 c9 21 04 80 	movabs $0x800421c928,%rdx
  8004203a41:	00 00 00 
  8004203a44:	be 8f 03 00 00       	mov    $0x38f,%esi
  8004203a49:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203a50:	00 00 00 
  8004203a53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a58:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  8004203a5f:	00 00 00 
  8004203a62:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203a64:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203a68:	0f 84 aa 00 00 00    	je     8004203b18 <check_page_free_list+0x122>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203a6e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203a72:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203a76:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203a7a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203a7e:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203a85:	00 00 00 
  8004203a88:	48 8b 00             	mov    (%rax),%rax
  8004203a8b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203a8f:	eb 59                	jmp    8004203aea <check_page_free_list+0xf4>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203a91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a95:	48 89 c7             	mov    %rax,%rdi
  8004203a98:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203a9f:	00 00 00 
  8004203aa2:	ff d0                	callq  *%rax
  8004203aa4:	48 c1 e8 15          	shr    $0x15,%rax
  8004203aa8:	48 89 c2             	mov    %rax,%rdx
  8004203aab:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203ab1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203ab4:	48 39 c2             	cmp    %rax,%rdx
  8004203ab7:	0f 93 c0             	setae  %al
  8004203aba:	0f b6 c0             	movzbl %al,%eax
  8004203abd:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203ac0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ac3:	48 98                	cltq   
  8004203ac5:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203aca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ace:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203ad1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ad5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ad8:	48 98                	cltq   
  8004203ada:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203adf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ae3:	48 8b 00             	mov    (%rax),%rax
  8004203ae6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203aea:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203aef:	75 a0                	jne    8004203a91 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203af1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203af5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203afc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203b00:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203b04:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203b07:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203b0b:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203b12:	00 00 00 
  8004203b15:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203b18:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203b1f:	00 00 00 
  8004203b22:	48 8b 00             	mov    (%rax),%rax
  8004203b25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b29:	eb 5f                	jmp    8004203b8a <check_page_free_list+0x194>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203b2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b2f:	48 89 c7             	mov    %rax,%rdi
  8004203b32:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203b39:	00 00 00 
  8004203b3c:	ff d0                	callq  *%rax
  8004203b3e:	48 c1 e8 15          	shr    $0x15,%rax
  8004203b42:	48 89 c2             	mov    %rax,%rdx
  8004203b45:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203b4b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203b4e:	48 39 c2             	cmp    %rax,%rdx
  8004203b51:	73 2c                	jae    8004203b7f <check_page_free_list+0x189>
			memset(page2kva(pp), 0x97, 128);
  8004203b53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b57:	48 89 c7             	mov    %rax,%rdi
  8004203b5a:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004203b61:	00 00 00 
  8004203b64:	ff d0                	callq  *%rax
  8004203b66:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203b6b:	be 97 00 00 00       	mov    $0x97,%esi
  8004203b70:	48 89 c7             	mov    %rax,%rdi
  8004203b73:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004203b7a:	00 00 00 
  8004203b7d:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203b7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b83:	48 8b 00             	mov    (%rax),%rax
  8004203b86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203b8f:	75 9a                	jne    8004203b2b <check_page_free_list+0x135>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203b91:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203b96:	48 b8 c6 21 20 04 80 	movabs $0x80042021c6,%rax
  8004203b9d:	00 00 00 
  8004203ba0:	ff d0                	callq  *%rax
  8004203ba2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ba6:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203bad:	00 00 00 
  8004203bb0:	48 8b 00             	mov    (%rax),%rax
  8004203bb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203bb7:	e9 23 03 00 00       	jmpq   8004203edf <check_page_free_list+0x4e9>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203bbc:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004203bc3:	00 00 00 
  8004203bc6:	48 8b 00             	mov    (%rax),%rax
  8004203bc9:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203bcd:	73 35                	jae    8004203c04 <check_page_free_list+0x20e>
  8004203bcf:	48 b9 ad c9 21 04 80 	movabs $0x800421c9ad,%rcx
  8004203bd6:	00 00 00 
  8004203bd9:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203be0:	00 00 00 
  8004203be3:	be a9 03 00 00       	mov    $0x3a9,%esi
  8004203be8:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203bef:	00 00 00 
  8004203bf2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203bf7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203bfe:	00 00 00 
  8004203c01:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203c04:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004203c0b:	00 00 00 
  8004203c0e:	48 8b 10             	mov    (%rax),%rdx
  8004203c11:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004203c18:	00 00 00 
  8004203c1b:	48 8b 00             	mov    (%rax),%rax
  8004203c1e:	48 c1 e0 04          	shl    $0x4,%rax
  8004203c22:	48 01 d0             	add    %rdx,%rax
  8004203c25:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203c29:	77 35                	ja     8004203c60 <check_page_free_list+0x26a>
  8004203c2b:	48 b9 b9 c9 21 04 80 	movabs $0x800421c9b9,%rcx
  8004203c32:	00 00 00 
  8004203c35:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203c3c:	00 00 00 
  8004203c3f:	be aa 03 00 00       	mov    $0x3aa,%esi
  8004203c44:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203c4b:	00 00 00 
  8004203c4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c53:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203c5a:	00 00 00 
  8004203c5d:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004203c60:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c64:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004203c6b:	00 00 00 
  8004203c6e:	48 8b 00             	mov    (%rax),%rax
  8004203c71:	48 89 d1             	mov    %rdx,%rcx
  8004203c74:	48 29 c1             	sub    %rax,%rcx
  8004203c77:	48 89 c8             	mov    %rcx,%rax
  8004203c7a:	83 e0 0f             	and    $0xf,%eax
  8004203c7d:	48 85 c0             	test   %rax,%rax
  8004203c80:	74 35                	je     8004203cb7 <check_page_free_list+0x2c1>
  8004203c82:	48 b9 d0 c9 21 04 80 	movabs $0x800421c9d0,%rcx
  8004203c89:	00 00 00 
  8004203c8c:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203c93:	00 00 00 
  8004203c96:	be ab 03 00 00       	mov    $0x3ab,%esi
  8004203c9b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203ca2:	00 00 00 
  8004203ca5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203caa:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203cb1:	00 00 00 
  8004203cb4:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004203cb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cbb:	48 89 c7             	mov    %rax,%rdi
  8004203cbe:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203cc5:	00 00 00 
  8004203cc8:	ff d0                	callq  *%rax
  8004203cca:	48 85 c0             	test   %rax,%rax
  8004203ccd:	75 35                	jne    8004203d04 <check_page_free_list+0x30e>
  8004203ccf:	48 b9 02 ca 21 04 80 	movabs $0x800421ca02,%rcx
  8004203cd6:	00 00 00 
  8004203cd9:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203ce0:	00 00 00 
  8004203ce3:	be ae 03 00 00       	mov    $0x3ae,%esi
  8004203ce8:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203cef:	00 00 00 
  8004203cf2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203cf7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203cfe:	00 00 00 
  8004203d01:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004203d04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d08:	48 89 c7             	mov    %rax,%rdi
  8004203d0b:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203d12:	00 00 00 
  8004203d15:	ff d0                	callq  *%rax
  8004203d17:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203d1d:	75 35                	jne    8004203d54 <check_page_free_list+0x35e>
  8004203d1f:	48 b9 13 ca 21 04 80 	movabs $0x800421ca13,%rcx
  8004203d26:	00 00 00 
  8004203d29:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203d30:	00 00 00 
  8004203d33:	be af 03 00 00       	mov    $0x3af,%esi
  8004203d38:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203d3f:	00 00 00 
  8004203d42:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d47:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203d4e:	00 00 00 
  8004203d51:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004203d54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d58:	48 89 c7             	mov    %rax,%rdi
  8004203d5b:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203d62:	00 00 00 
  8004203d65:	ff d0                	callq  *%rax
  8004203d67:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203d6d:	75 35                	jne    8004203da4 <check_page_free_list+0x3ae>
  8004203d6f:	48 b9 30 ca 21 04 80 	movabs $0x800421ca30,%rcx
  8004203d76:	00 00 00 
  8004203d79:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203d80:	00 00 00 
  8004203d83:	be b0 03 00 00       	mov    $0x3b0,%esi
  8004203d88:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203d8f:	00 00 00 
  8004203d92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d97:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203d9e:	00 00 00 
  8004203da1:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004203da4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203da8:	48 89 c7             	mov    %rax,%rdi
  8004203dab:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203db2:	00 00 00 
  8004203db5:	ff d0                	callq  *%rax
  8004203db7:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004203dbd:	75 35                	jne    8004203df4 <check_page_free_list+0x3fe>
  8004203dbf:	48 b9 53 ca 21 04 80 	movabs $0x800421ca53,%rcx
  8004203dc6:	00 00 00 
  8004203dc9:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203dd0:	00 00 00 
  8004203dd3:	be b1 03 00 00       	mov    $0x3b1,%esi
  8004203dd8:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203ddf:	00 00 00 
  8004203de2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203de7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203dee:	00 00 00 
  8004203df1:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004203df4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203df8:	48 89 c7             	mov    %rax,%rdi
  8004203dfb:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203e02:	00 00 00 
  8004203e05:	ff d0                	callq  *%rax
  8004203e07:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203e0d:	76 4e                	jbe    8004203e5d <check_page_free_list+0x467>
  8004203e0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e13:	48 89 c7             	mov    %rax,%rdi
  8004203e16:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004203e1d:	00 00 00 
  8004203e20:	ff d0                	callq  *%rax
  8004203e22:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203e26:	73 35                	jae    8004203e5d <check_page_free_list+0x467>
  8004203e28:	48 b9 70 ca 21 04 80 	movabs $0x800421ca70,%rcx
  8004203e2f:	00 00 00 
  8004203e32:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203e39:	00 00 00 
  8004203e3c:	be b2 03 00 00       	mov    $0x3b2,%esi
  8004203e41:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203e48:	00 00 00 
  8004203e4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e50:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203e57:	00 00 00 
  8004203e5a:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004203e5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e61:	48 89 c7             	mov    %rax,%rdi
  8004203e64:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203e6b:	00 00 00 
  8004203e6e:	ff d0                	callq  *%rax
  8004203e70:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004203e76:	75 35                	jne    8004203ead <check_page_free_list+0x4b7>
  8004203e78:	48 b9 b5 ca 21 04 80 	movabs $0x800421cab5,%rcx
  8004203e7f:	00 00 00 
  8004203e82:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203e89:	00 00 00 
  8004203e8c:	be b4 03 00 00       	mov    $0x3b4,%esi
  8004203e91:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203e98:	00 00 00 
  8004203e9b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ea0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203ea7:	00 00 00 
  8004203eaa:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004203ead:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203eb1:	48 89 c7             	mov    %rax,%rdi
  8004203eb4:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004203ebb:	00 00 00 
  8004203ebe:	ff d0                	callq  *%rax
  8004203ec0:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203ec6:	77 07                	ja     8004203ecf <check_page_free_list+0x4d9>
			++nfree_basemem;
  8004203ec8:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004203ecd:	eb 05                	jmp    8004203ed4 <check_page_free_list+0x4de>
		else
			++nfree_extmem;
  8004203ecf:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ed4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ed8:	48 8b 00             	mov    (%rax),%rax
  8004203edb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203edf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ee4:	0f 85 d2 fc ff ff    	jne    8004203bbc <check_page_free_list+0x1c6>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004203eea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203eef:	75 35                	jne    8004203f26 <check_page_free_list+0x530>
  8004203ef1:	48 b9 d2 ca 21 04 80 	movabs $0x800421cad2,%rcx
  8004203ef8:	00 00 00 
  8004203efb:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203f02:	00 00 00 
  8004203f05:	be bc 03 00 00       	mov    $0x3bc,%esi
  8004203f0a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203f11:	00 00 00 
  8004203f14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f19:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203f20:	00 00 00 
  8004203f23:	41 ff d0             	callq  *%r8
}
  8004203f26:	c9                   	leaveq 
  8004203f27:	c3                   	retq   

0000008004203f28 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  8004203f28:	55                   	push   %rbp
  8004203f29:	48 89 e5             	mov    %rsp,%rbp
  8004203f2c:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203f30:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203f37:	00 00 00 
  8004203f3a:	48 8b 00             	mov    (%rax),%rax
  8004203f3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203f48:	eb 37                	jmp    8004203f81 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  8004203f4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f4e:	48 89 c7             	mov    %rax,%rdi
  8004203f51:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004203f58:	00 00 00 
  8004203f5b:	ff d0                	callq  *%rax
  8004203f5d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203f62:	be 97 00 00 00       	mov    $0x97,%esi
  8004203f67:	48 89 c7             	mov    %rax,%rdi
  8004203f6a:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004203f71:	00 00 00 
  8004203f74:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203f76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f7a:	48 8b 00             	mov    (%rax),%rax
  8004203f7d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f81:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f86:	75 c2                	jne    8004203f4a <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004203f88:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004203f8f:	00 00 00 
  8004203f92:	48 8b 00             	mov    (%rax),%rax
  8004203f95:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f99:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004203fa0:	e9 ec 01 00 00       	jmpq   8004204191 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004203fa5:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004203fac:	00 00 00 
  8004203faf:	48 8b 00             	mov    (%rax),%rax
  8004203fb2:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203fb6:	73 35                	jae    8004203fed <check_page_alloc+0xc5>
  8004203fb8:	48 b9 e3 ca 21 04 80 	movabs $0x800421cae3,%rcx
  8004203fbf:	00 00 00 
  8004203fc2:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004203fc9:	00 00 00 
  8004203fcc:	be d6 03 00 00       	mov    $0x3d6,%esi
  8004203fd1:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004203fd8:	00 00 00 
  8004203fdb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fe0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004203fe7:	00 00 00 
  8004203fea:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004203fed:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004203ff4:	00 00 00 
  8004203ff7:	48 8b 10             	mov    (%rax),%rdx
  8004203ffa:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004204001:	00 00 00 
  8004204004:	48 8b 00             	mov    (%rax),%rax
  8004204007:	48 c1 e0 04          	shl    $0x4,%rax
  800420400b:	48 01 d0             	add    %rdx,%rax
  800420400e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204012:	77 35                	ja     8004204049 <check_page_alloc+0x121>
  8004204014:	48 b9 f0 ca 21 04 80 	movabs $0x800421caf0,%rcx
  800420401b:	00 00 00 
  800420401e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204025:	00 00 00 
  8004204028:	be d7 03 00 00       	mov    $0x3d7,%esi
  800420402d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204034:	00 00 00 
  8004204037:	b8 00 00 00 00       	mov    $0x0,%eax
  800420403c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204043:	00 00 00 
  8004204046:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  8004204049:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420404d:	48 89 c7             	mov    %rax,%rdi
  8004204050:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004204057:	00 00 00 
  800420405a:	ff d0                	callq  *%rax
  800420405c:	48 85 c0             	test   %rax,%rax
  800420405f:	75 35                	jne    8004204096 <check_page_alloc+0x16e>
  8004204061:	48 b9 05 cb 21 04 80 	movabs $0x800421cb05,%rcx
  8004204068:	00 00 00 
  800420406b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204072:	00 00 00 
  8004204075:	be da 03 00 00       	mov    $0x3da,%esi
  800420407a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204081:	00 00 00 
  8004204084:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204089:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204090:	00 00 00 
  8004204093:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004204096:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420409a:	48 89 c7             	mov    %rax,%rdi
  800420409d:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042040a4:	00 00 00 
  80042040a7:	ff d0                	callq  *%rax
  80042040a9:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042040af:	75 35                	jne    80042040e6 <check_page_alloc+0x1be>
  80042040b1:	48 b9 17 cb 21 04 80 	movabs $0x800421cb17,%rcx
  80042040b8:	00 00 00 
  80042040bb:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042040c2:	00 00 00 
  80042040c5:	be db 03 00 00       	mov    $0x3db,%esi
  80042040ca:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042040d1:	00 00 00 
  80042040d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040d9:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042040e0:	00 00 00 
  80042040e3:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042040e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040ea:	48 89 c7             	mov    %rax,%rdi
  80042040ed:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042040f4:	00 00 00 
  80042040f7:	ff d0                	callq  *%rax
  80042040f9:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042040ff:	75 35                	jne    8004204136 <check_page_alloc+0x20e>
  8004204101:	48 b9 38 cb 21 04 80 	movabs $0x800421cb38,%rcx
  8004204108:	00 00 00 
  800420410b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204112:	00 00 00 
  8004204115:	be dc 03 00 00       	mov    $0x3dc,%esi
  800420411a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204121:	00 00 00 
  8004204124:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204129:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204130:	00 00 00 
  8004204133:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420413a:	48 89 c7             	mov    %rax,%rdi
  800420413d:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004204144:	00 00 00 
  8004204147:	ff d0                	callq  *%rax
  8004204149:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  800420414f:	75 35                	jne    8004204186 <check_page_alloc+0x25e>
  8004204151:	48 b9 5c cb 21 04 80 	movabs $0x800421cb5c,%rcx
  8004204158:	00 00 00 
  800420415b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204162:	00 00 00 
  8004204165:	be dd 03 00 00       	mov    $0x3dd,%esi
  800420416a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204171:	00 00 00 
  8004204174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204179:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204180:	00 00 00 
  8004204183:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204186:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420418a:	48 8b 00             	mov    (%rax),%rax
  800420418d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204191:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204196:	0f 85 09 fe ff ff    	jne    8004203fa5 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  800420419c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042041a3:	00 
  80042041a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042041a8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042041ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042041b0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  80042041b4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042041b9:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042041c0:	00 00 00 
  80042041c3:	ff d0                	callq  *%rax
  80042041c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042041c9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042041ce:	75 35                	jne    8004204205 <check_page_alloc+0x2dd>
  80042041d0:	48 b9 77 cb 21 04 80 	movabs $0x800421cb77,%rcx
  80042041d7:	00 00 00 
  80042041da:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042041e1:	00 00 00 
  80042041e4:	be e1 03 00 00       	mov    $0x3e1,%esi
  80042041e9:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042041f0:	00 00 00 
  80042041f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041f8:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042041ff:	00 00 00 
  8004204202:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204205:	bf 00 00 00 00       	mov    $0x0,%edi
  800420420a:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004204211:	00 00 00 
  8004204214:	ff d0                	callq  *%rax
  8004204216:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420421a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420421f:	75 35                	jne    8004204256 <check_page_alloc+0x32e>
  8004204221:	48 b9 8d cb 21 04 80 	movabs $0x800421cb8d,%rcx
  8004204228:	00 00 00 
  800420422b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204232:	00 00 00 
  8004204235:	be e2 03 00 00       	mov    $0x3e2,%esi
  800420423a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204241:	00 00 00 
  8004204244:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204249:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204250:	00 00 00 
  8004204253:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204256:	bf 00 00 00 00       	mov    $0x0,%edi
  800420425b:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004204262:	00 00 00 
  8004204265:	ff d0                	callq  *%rax
  8004204267:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420426b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204270:	75 35                	jne    80042042a7 <check_page_alloc+0x37f>
  8004204272:	48 b9 a3 cb 21 04 80 	movabs $0x800421cba3,%rcx
  8004204279:	00 00 00 
  800420427c:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204283:	00 00 00 
  8004204286:	be e3 03 00 00       	mov    $0x3e3,%esi
  800420428b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204292:	00 00 00 
  8004204295:	b8 00 00 00 00       	mov    $0x0,%eax
  800420429a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042042a1:	00 00 00 
  80042042a4:	41 ff d0             	callq  *%r8
	assert(pp0);
  80042042a7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042ac:	75 35                	jne    80042042e3 <check_page_alloc+0x3bb>
  80042042ae:	48 b9 b9 cb 21 04 80 	movabs $0x800421cbb9,%rcx
  80042042b5:	00 00 00 
  80042042b8:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042042bf:	00 00 00 
  80042042c2:	be e4 03 00 00       	mov    $0x3e4,%esi
  80042042c7:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042042ce:	00 00 00 
  80042042d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042d6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042042dd:	00 00 00 
  80042042e0:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042042e3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042042e8:	74 0a                	je     80042042f4 <check_page_alloc+0x3cc>
  80042042ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042042ee:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042042f2:	75 35                	jne    8004204329 <check_page_alloc+0x401>
  80042042f4:	48 b9 bd cb 21 04 80 	movabs $0x800421cbbd,%rcx
  80042042fb:	00 00 00 
  80042042fe:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204305:	00 00 00 
  8004204308:	be e5 03 00 00       	mov    $0x3e5,%esi
  800420430d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204314:	00 00 00 
  8004204317:	b8 00 00 00 00       	mov    $0x0,%eax
  800420431c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204323:	00 00 00 
  8004204326:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204329:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420432e:	74 14                	je     8004204344 <check_page_alloc+0x41c>
  8004204330:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204334:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204338:	74 0a                	je     8004204344 <check_page_alloc+0x41c>
  800420433a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420433e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204342:	75 35                	jne    8004204379 <check_page_alloc+0x451>
  8004204344:	48 b9 d0 cb 21 04 80 	movabs $0x800421cbd0,%rcx
  800420434b:	00 00 00 
  800420434e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204355:	00 00 00 
  8004204358:	be e6 03 00 00       	mov    $0x3e6,%esi
  800420435d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204364:	00 00 00 
  8004204367:	b8 00 00 00 00       	mov    $0x0,%eax
  800420436c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204373:	00 00 00 
  8004204376:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204379:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420437d:	48 89 c7             	mov    %rax,%rdi
  8004204380:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004204387:	00 00 00 
  800420438a:	ff d0                	callq  *%rax
  800420438c:	48 ba 70 37 48 04 80 	movabs $0x8004483770,%rdx
  8004204393:	00 00 00 
  8004204396:	48 8b 12             	mov    (%rdx),%rdx
  8004204399:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420439d:	48 39 d0             	cmp    %rdx,%rax
  80042043a0:	72 35                	jb     80042043d7 <check_page_alloc+0x4af>
  80042043a2:	48 b9 f0 cb 21 04 80 	movabs $0x800421cbf0,%rcx
  80042043a9:	00 00 00 
  80042043ac:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042043b3:	00 00 00 
  80042043b6:	be e7 03 00 00       	mov    $0x3e7,%esi
  80042043bb:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042043c2:	00 00 00 
  80042043c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043ca:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042043d1:	00 00 00 
  80042043d4:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042043d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042043db:	48 89 c7             	mov    %rax,%rdi
  80042043de:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042043e5:	00 00 00 
  80042043e8:	ff d0                	callq  *%rax
  80042043ea:	48 ba 70 37 48 04 80 	movabs $0x8004483770,%rdx
  80042043f1:	00 00 00 
  80042043f4:	48 8b 12             	mov    (%rdx),%rdx
  80042043f7:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042043fb:	48 39 d0             	cmp    %rdx,%rax
  80042043fe:	72 35                	jb     8004204435 <check_page_alloc+0x50d>
  8004204400:	48 b9 0d cc 21 04 80 	movabs $0x800421cc0d,%rcx
  8004204407:	00 00 00 
  800420440a:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204411:	00 00 00 
  8004204414:	be e8 03 00 00       	mov    $0x3e8,%esi
  8004204419:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204420:	00 00 00 
  8004204423:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204428:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420442f:	00 00 00 
  8004204432:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204435:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204439:	48 89 c7             	mov    %rax,%rdi
  800420443c:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004204443:	00 00 00 
  8004204446:	ff d0                	callq  *%rax
  8004204448:	48 ba 70 37 48 04 80 	movabs $0x8004483770,%rdx
  800420444f:	00 00 00 
  8004204452:	48 8b 12             	mov    (%rdx),%rdx
  8004204455:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204459:	48 39 d0             	cmp    %rdx,%rax
  800420445c:	72 35                	jb     8004204493 <check_page_alloc+0x56b>
  800420445e:	48 b9 2a cc 21 04 80 	movabs $0x800421cc2a,%rcx
  8004204465:	00 00 00 
  8004204468:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420446f:	00 00 00 
  8004204472:	be e9 03 00 00       	mov    $0x3e9,%esi
  8004204477:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420447e:	00 00 00 
  8004204481:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204486:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420448d:	00 00 00 
  8004204490:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204493:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  800420449a:	00 00 00 
  800420449d:	48 8b 00             	mov    (%rax),%rax
  80042044a0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  80042044a4:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  80042044ab:	00 00 00 
  80042044ae:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  80042044b5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042044ba:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042044c1:	00 00 00 
  80042044c4:	ff d0                	callq  *%rax
  80042044c6:	48 85 c0             	test   %rax,%rax
  80042044c9:	74 35                	je     8004204500 <check_page_alloc+0x5d8>
  80042044cb:	48 b9 47 cc 21 04 80 	movabs $0x800421cc47,%rcx
  80042044d2:	00 00 00 
  80042044d5:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042044dc:	00 00 00 
  80042044df:	be f0 03 00 00       	mov    $0x3f0,%esi
  80042044e4:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042044eb:	00 00 00 
  80042044ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044f3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042044fa:	00 00 00 
  80042044fd:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204500:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204504:	48 89 c7             	mov    %rax,%rdi
  8004204507:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  800420450e:	00 00 00 
  8004204511:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204513:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204517:	48 89 c7             	mov    %rax,%rdi
  800420451a:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  8004204521:	00 00 00 
  8004204524:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420452a:	48 89 c7             	mov    %rax,%rdi
  800420452d:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  8004204534:	00 00 00 
  8004204537:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204539:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204540:	00 
  8004204541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204545:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204549:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420454d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204551:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204556:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420455d:	00 00 00 
  8004204560:	ff d0                	callq  *%rax
  8004204562:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204566:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420456b:	75 35                	jne    80042045a2 <check_page_alloc+0x67a>
  800420456d:	48 b9 77 cb 21 04 80 	movabs $0x800421cb77,%rcx
  8004204574:	00 00 00 
  8004204577:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420457e:	00 00 00 
  8004204581:	be f7 03 00 00       	mov    $0x3f7,%esi
  8004204586:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420458d:	00 00 00 
  8004204590:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204595:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420459c:	00 00 00 
  800420459f:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042045a2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045a7:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042045ae:	00 00 00 
  80042045b1:	ff d0                	callq  *%rax
  80042045b3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042045b7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042045bc:	75 35                	jne    80042045f3 <check_page_alloc+0x6cb>
  80042045be:	48 b9 8d cb 21 04 80 	movabs $0x800421cb8d,%rcx
  80042045c5:	00 00 00 
  80042045c8:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042045cf:	00 00 00 
  80042045d2:	be f8 03 00 00       	mov    $0x3f8,%esi
  80042045d7:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042045de:	00 00 00 
  80042045e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045e6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042045ed:	00 00 00 
  80042045f0:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042045f3:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045f8:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042045ff:	00 00 00 
  8004204602:	ff d0                	callq  *%rax
  8004204604:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204608:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420460d:	75 35                	jne    8004204644 <check_page_alloc+0x71c>
  800420460f:	48 b9 a3 cb 21 04 80 	movabs $0x800421cba3,%rcx
  8004204616:	00 00 00 
  8004204619:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204620:	00 00 00 
  8004204623:	be f9 03 00 00       	mov    $0x3f9,%esi
  8004204628:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420462f:	00 00 00 
  8004204632:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204637:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420463e:	00 00 00 
  8004204641:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204644:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204649:	75 35                	jne    8004204680 <check_page_alloc+0x758>
  800420464b:	48 b9 b9 cb 21 04 80 	movabs $0x800421cbb9,%rcx
  8004204652:	00 00 00 
  8004204655:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420465c:	00 00 00 
  800420465f:	be fa 03 00 00       	mov    $0x3fa,%esi
  8004204664:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420466b:	00 00 00 
  800420466e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204673:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420467a:	00 00 00 
  800420467d:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204680:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204685:	74 0a                	je     8004204691 <check_page_alloc+0x769>
  8004204687:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420468b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420468f:	75 35                	jne    80042046c6 <check_page_alloc+0x79e>
  8004204691:	48 b9 bd cb 21 04 80 	movabs $0x800421cbbd,%rcx
  8004204698:	00 00 00 
  800420469b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042046a2:	00 00 00 
  80042046a5:	be fb 03 00 00       	mov    $0x3fb,%esi
  80042046aa:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042046b1:	00 00 00 
  80042046b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046b9:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042046c0:	00 00 00 
  80042046c3:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042046c6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042046cb:	74 14                	je     80042046e1 <check_page_alloc+0x7b9>
  80042046cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046d1:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042046d5:	74 0a                	je     80042046e1 <check_page_alloc+0x7b9>
  80042046d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046db:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042046df:	75 35                	jne    8004204716 <check_page_alloc+0x7ee>
  80042046e1:	48 b9 d0 cb 21 04 80 	movabs $0x800421cbd0,%rcx
  80042046e8:	00 00 00 
  80042046eb:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042046f2:	00 00 00 
  80042046f5:	be fc 03 00 00       	mov    $0x3fc,%esi
  80042046fa:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204701:	00 00 00 
  8004204704:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204709:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204710:	00 00 00 
  8004204713:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204716:	bf 00 00 00 00       	mov    $0x0,%edi
  800420471b:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004204722:	00 00 00 
  8004204725:	ff d0                	callq  *%rax
  8004204727:	48 85 c0             	test   %rax,%rax
  800420472a:	74 35                	je     8004204761 <check_page_alloc+0x839>
  800420472c:	48 b9 47 cc 21 04 80 	movabs $0x800421cc47,%rcx
  8004204733:	00 00 00 
  8004204736:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420473d:	00 00 00 
  8004204740:	be fd 03 00 00       	mov    $0x3fd,%esi
  8004204745:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420474c:	00 00 00 
  800420474f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204754:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420475b:	00 00 00 
  800420475e:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204761:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204765:	48 89 c7             	mov    %rax,%rdi
  8004204768:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  800420476f:	00 00 00 
  8004204772:	ff d0                	callq  *%rax
  8004204774:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204779:	be 01 00 00 00       	mov    $0x1,%esi
  800420477e:	48 89 c7             	mov    %rax,%rdi
  8004204781:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004204788:	00 00 00 
  800420478b:	ff d0                	callq  *%rax
	page_free(pp0);
  800420478d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204791:	48 89 c7             	mov    %rax,%rdi
  8004204794:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  800420479b:	00 00 00 
  800420479e:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  80042047a0:	bf 01 00 00 00       	mov    $0x1,%edi
  80042047a5:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042047ac:	00 00 00 
  80042047af:	ff d0                	callq  *%rax
  80042047b1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042047b5:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042047ba:	75 35                	jne    80042047f1 <check_page_alloc+0x8c9>
  80042047bc:	48 b9 56 cc 21 04 80 	movabs $0x800421cc56,%rcx
  80042047c3:	00 00 00 
  80042047c6:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042047cd:	00 00 00 
  80042047d0:	be 02 04 00 00       	mov    $0x402,%esi
  80042047d5:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042047dc:	00 00 00 
  80042047df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047e4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042047eb:	00 00 00 
  80042047ee:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  80042047f1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042047f6:	74 0a                	je     8004204802 <check_page_alloc+0x8da>
  80042047f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047fc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204800:	74 35                	je     8004204837 <check_page_alloc+0x90f>
  8004204802:	48 b9 74 cc 21 04 80 	movabs $0x800421cc74,%rcx
  8004204809:	00 00 00 
  800420480c:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204813:	00 00 00 
  8004204816:	be 03 04 00 00       	mov    $0x403,%esi
  800420481b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204822:	00 00 00 
  8004204825:	b8 00 00 00 00       	mov    $0x0,%eax
  800420482a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204831:	00 00 00 
  8004204834:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204837:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420483b:	48 89 c7             	mov    %rax,%rdi
  800420483e:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004204845:	00 00 00 
  8004204848:	ff d0                	callq  *%rax
  800420484a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  800420484e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204855:	eb 49                	jmp    80042048a0 <check_page_alloc+0x978>
		assert(c[i] == 0);
  8004204857:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420485a:	48 98                	cltq   
  800420485c:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004204860:	0f b6 00             	movzbl (%rax),%eax
  8004204863:	84 c0                	test   %al,%al
  8004204865:	74 35                	je     800420489c <check_page_alloc+0x974>
  8004204867:	48 b9 84 cc 21 04 80 	movabs $0x800421cc84,%rcx
  800420486e:	00 00 00 
  8004204871:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204878:	00 00 00 
  800420487b:	be 06 04 00 00       	mov    $0x406,%esi
  8004204880:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204887:	00 00 00 
  800420488a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420488f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204896:	00 00 00 
  8004204899:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  800420489c:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042048a0:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042048a7:	7e ae                	jle    8004204857 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  80042048a9:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  80042048b0:	00 00 00 
  80042048b3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042048b7:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042048ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048be:	48 89 c7             	mov    %rax,%rdi
  80042048c1:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  80042048c8:	00 00 00 
  80042048cb:	ff d0                	callq  *%rax
	page_free(pp1);
  80042048cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048d1:	48 89 c7             	mov    %rax,%rdi
  80042048d4:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  80042048db:	00 00 00 
  80042048de:	ff d0                	callq  *%rax
	page_free(pp2);
  80042048e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042048e4:	48 89 c7             	mov    %rax,%rdi
  80042048e7:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  80042048ee:	00 00 00 
  80042048f1:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  80042048f3:	48 bf 90 cc 21 04 80 	movabs $0x800421cc90,%rdi
  80042048fa:	00 00 00 
  80042048fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204902:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004204909:	00 00 00 
  800420490c:	ff d2                	callq  *%rdx
}
  800420490e:	c9                   	leaveq 
  800420490f:	c3                   	retq   

0000008004204910 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204910:	55                   	push   %rbp
  8004204911:	48 89 e5             	mov    %rsp,%rbp
  8004204914:	53                   	push   %rbx
  8004204915:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  800420491c:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204923:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420492a:	00 00 00 
  800420492d:	48 8b 00             	mov    (%rax),%rax
  8004204930:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204934:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  800420493b:	00 
  800420493c:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004204943:	00 00 00 
  8004204946:	48 8b 00             	mov    (%rax),%rax
  8004204949:	48 c1 e0 04          	shl    $0x4,%rax
  800420494d:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004204951:	48 83 e8 01          	sub    $0x1,%rax
  8004204955:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204959:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420495d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204962:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004204966:	48 89 d0             	mov    %rdx,%rax
  8004204969:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420496d:	48 89 d1             	mov    %rdx,%rcx
  8004204970:	48 29 c1             	sub    %rax,%rcx
  8004204973:	48 89 c8             	mov    %rcx,%rax
  8004204976:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  800420497a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204981:	00 
  8004204982:	e9 ce 00 00 00       	jmpq   8004204a55 <check_boot_pml4e+0x145>
		//cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204987:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  800420498e:	00 00 00 
  8004204991:	48 89 c2             	mov    %rax,%rdx
  8004204994:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204998:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420499c:	48 89 d6             	mov    %rdx,%rsi
  800420499f:	48 89 c7             	mov    %rax,%rdi
  80042049a2:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  80042049a9:	00 00 00 
  80042049ac:	ff d0                	callq  *%rax
  80042049ae:	48 ba 78 37 48 04 80 	movabs $0x8004483778,%rdx
  80042049b5:	00 00 00 
  80042049b8:	48 8b 12             	mov    (%rdx),%rdx
  80042049bb:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80042049bf:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042049c6:	00 00 00 
  80042049c9:	48 39 55 c0          	cmp    %rdx,-0x40(%rbp)
  80042049cd:	77 32                	ja     8004204a01 <check_boot_pml4e+0xf1>
  80042049cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042049d3:	48 89 c1             	mov    %rax,%rcx
  80042049d6:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  80042049dd:	00 00 00 
  80042049e0:	be 26 04 00 00       	mov    $0x426,%esi
  80042049e5:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042049ec:	00 00 00 
  80042049ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049f4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042049fb:	00 00 00 
  80042049fe:	41 ff d0             	callq  *%r8
  8004204a01:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204a08:	ff ff ff 
  8004204a0b:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  8004204a0f:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204a13:	48 39 d0             	cmp    %rdx,%rax
  8004204a16:	74 35                	je     8004204a4d <check_boot_pml4e+0x13d>
  8004204a18:	48 b9 b0 cc 21 04 80 	movabs $0x800421ccb0,%rcx
  8004204a1f:	00 00 00 
  8004204a22:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204a29:	00 00 00 
  8004204a2c:	be 26 04 00 00       	mov    $0x426,%esi
  8004204a31:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204a38:	00 00 00 
  8004204a3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a40:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204a47:	00 00 00 
  8004204a4a:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204a4d:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204a54:	00 
  8004204a55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a59:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204a5d:	0f 82 24 ff ff ff    	jb     8004204987 <check_boot_pml4e+0x77>
		//cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204a63:	48 c7 45 b8 00 10 00 	movq   $0x1000,-0x48(%rbp)
  8004204a6a:	00 
  8004204a6b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204a6f:	48 05 ff 7f 05 00    	add    $0x57fff,%rax
  8004204a75:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204a79:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204a7d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204a82:	48 f7 75 b8          	divq   -0x48(%rbp)
  8004204a86:	48 89 d0             	mov    %rdx,%rax
  8004204a89:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204a8d:	48 89 d3             	mov    %rdx,%rbx
  8004204a90:	48 29 c3             	sub    %rax,%rbx
  8004204a93:	48 89 d8             	mov    %rbx,%rax
  8004204a96:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204a9a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204aa1:	00 
  8004204aa2:	e9 ce 00 00 00       	jmpq   8004204b75 <check_boot_pml4e+0x265>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204aa7:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8004204aae:	00 00 00 
  8004204ab1:	48 89 c2             	mov    %rax,%rdx
  8004204ab4:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204ab8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204abc:	48 89 d6             	mov    %rdx,%rsi
  8004204abf:	48 89 c7             	mov    %rax,%rdi
  8004204ac2:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004204ac9:	00 00 00 
  8004204acc:	ff d0                	callq  *%rax
  8004204ace:	48 ba 50 22 48 04 80 	movabs $0x8004482250,%rdx
  8004204ad5:	00 00 00 
  8004204ad8:	48 8b 12             	mov    (%rdx),%rdx
  8004204adb:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004204adf:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204ae6:	00 00 00 
  8004204ae9:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004204aed:	77 32                	ja     8004204b21 <check_boot_pml4e+0x211>
  8004204aef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204af3:	48 89 c1             	mov    %rax,%rcx
  8004204af6:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004204afd:	00 00 00 
  8004204b00:	be 2c 04 00 00       	mov    $0x42c,%esi
  8004204b05:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204b0c:	00 00 00 
  8004204b0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b14:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204b1b:	00 00 00 
  8004204b1e:	41 ff d0             	callq  *%r8
  8004204b21:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204b28:	ff ff ff 
  8004204b2b:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  8004204b2f:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204b33:	48 39 d0             	cmp    %rdx,%rax
  8004204b36:	74 35                	je     8004204b6d <check_boot_pml4e+0x25d>
  8004204b38:	48 b9 e8 cc 21 04 80 	movabs $0x800421cce8,%rcx
  8004204b3f:	00 00 00 
  8004204b42:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204b49:	00 00 00 
  8004204b4c:	be 2c 04 00 00       	mov    $0x42c,%esi
  8004204b51:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204b58:	00 00 00 
  8004204b5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b60:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204b67:	00 00 00 
  8004204b6a:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204b6d:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204b74:	00 
  8004204b75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204b79:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204b7d:	0f 82 24 ff ff ff    	jb     8004204aa7 <check_boot_pml4e+0x197>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204b83:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204b8a:	00 
  8004204b8b:	eb 6a                	jmp    8004204bf7 <check_boot_pml4e+0x2e7>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204b8d:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004204b94:	00 00 00 
  8004204b97:	48 89 c2             	mov    %rax,%rdx
  8004204b9a:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204b9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204ba2:	48 89 d6             	mov    %rdx,%rsi
  8004204ba5:	48 89 c7             	mov    %rax,%rdi
  8004204ba8:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004204baf:	00 00 00 
  8004204bb2:	ff d0                	callq  *%rax
  8004204bb4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204bb8:	74 35                	je     8004204bef <check_boot_pml4e+0x2df>
  8004204bba:	48 b9 20 cd 21 04 80 	movabs $0x800421cd20,%rcx
  8004204bc1:	00 00 00 
  8004204bc4:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204bcb:	00 00 00 
  8004204bce:	be 30 04 00 00       	mov    $0x430,%esi
  8004204bd3:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204bda:	00 00 00 
  8004204bdd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204be2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204be9:	00 00 00 
  8004204bec:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204bef:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204bf6:	00 
  8004204bf7:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004204bfe:	00 00 00 
  8004204c01:	48 8b 00             	mov    (%rax),%rax
  8004204c04:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204c08:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204c0c:	0f 87 7b ff ff ff    	ja     8004204b8d <check_boot_pml4e+0x27d>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204c12:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004204c19:	00 
  8004204c1a:	e9 9e 01 00 00       	jmpq   8004204dbd <check_boot_pml4e+0x4ad>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004204c1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204c23:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004204c27:	48 89 d0             	mov    %rdx,%rax
  8004204c2a:	48 01 c0             	add    %rax,%rax
  8004204c2d:	48 01 d0             	add    %rdx,%rax
  8004204c30:	48 c1 e0 0f          	shl    $0xf,%rax
  8004204c34:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204c3b:	00 00 00 
  8004204c3e:	48 89 d1             	mov    %rdx,%rcx
  8004204c41:	48 29 c1             	sub    %rax,%rcx
  8004204c44:	48 89 c8             	mov    %rcx,%rax
  8004204c47:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204c4b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204c52:	00 
  8004204c53:	e9 da 00 00 00       	jmpq   8004204d32 <check_boot_pml4e+0x422>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004204c58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204c5c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004204c60:	48 01 d0             	add    %rdx,%rax
  8004204c63:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004204c6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204c6e:	48 89 d6             	mov    %rdx,%rsi
  8004204c71:	48 89 c7             	mov    %rax,%rdi
  8004204c74:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004204c7b:	00 00 00 
  8004204c7e:	ff d0                	callq  *%rax
  8004204c80:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004204c84:	48 89 d1             	mov    %rdx,%rcx
  8004204c87:	48 c1 e1 10          	shl    $0x10,%rcx
  8004204c8b:	48 ba 00 60 48 04 80 	movabs $0x8004486000,%rdx
  8004204c92:	00 00 00 
  8004204c95:	48 01 ca             	add    %rcx,%rdx
  8004204c98:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004204c9c:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204ca3:	00 00 00 
  8004204ca6:	48 39 55 98          	cmp    %rdx,-0x68(%rbp)
  8004204caa:	77 32                	ja     8004204cde <check_boot_pml4e+0x3ce>
  8004204cac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004204cb0:	48 89 c1             	mov    %rax,%rcx
  8004204cb3:	48 ba b0 c8 21 04 80 	movabs $0x800421c8b0,%rdx
  8004204cba:	00 00 00 
  8004204cbd:	be 38 04 00 00       	mov    $0x438,%esi
  8004204cc2:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204cc9:	00 00 00 
  8004204ccc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cd1:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204cd8:	00 00 00 
  8004204cdb:	41 ff d0             	callq  *%r8
  8004204cde:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204ce5:	ff ff ff 
  8004204ce8:	48 03 55 98          	add    -0x68(%rbp),%rdx
  8004204cec:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204cf0:	48 39 d0             	cmp    %rdx,%rax
  8004204cf3:	74 35                	je     8004204d2a <check_boot_pml4e+0x41a>
  8004204cf5:	48 b9 48 cd 21 04 80 	movabs $0x800421cd48,%rcx
  8004204cfc:	00 00 00 
  8004204cff:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204d06:	00 00 00 
  8004204d09:	be 38 04 00 00       	mov    $0x438,%esi
  8004204d0e:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204d15:	00 00 00 
  8004204d18:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d1d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204d24:	00 00 00 
  8004204d27:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204d2a:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204d31:	00 
  8004204d32:	48 81 7d e8 ff ff 00 	cmpq   $0xffff,-0x18(%rbp)
  8004204d39:	00 
  8004204d3a:	0f 86 18 ff ff ff    	jbe    8004204c58 <check_boot_pml4e+0x348>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204d40:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204d47:	00 
  8004204d48:	eb 64                	jmp    8004204dae <check_boot_pml4e+0x49e>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004204d4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d4e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004204d52:	48 01 c2             	add    %rax,%rdx
  8004204d55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d59:	48 89 d6             	mov    %rdx,%rsi
  8004204d5c:	48 89 c7             	mov    %rax,%rdi
  8004204d5f:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004204d66:	00 00 00 
  8004204d69:	ff d0                	callq  *%rax
  8004204d6b:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004204d6f:	74 35                	je     8004204da6 <check_boot_pml4e+0x496>
  8004204d71:	48 b9 90 cd 21 04 80 	movabs $0x800421cd90,%rcx
  8004204d78:	00 00 00 
  8004204d7b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204d82:	00 00 00 
  8004204d85:	be 3a 04 00 00       	mov    $0x43a,%esi
  8004204d8a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204d91:	00 00 00 
  8004204d94:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d99:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204da0:	00 00 00 
  8004204da3:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204da6:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204dad:	00 
  8004204dae:	48 81 7d e8 ff 7f 00 	cmpq   $0x7fff,-0x18(%rbp)
  8004204db5:	00 
  8004204db6:	76 92                	jbe    8004204d4a <check_boot_pml4e+0x43a>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204db8:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  8004204dbd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204dc2:	0f 84 57 fe ff ff    	je     8004204c1f <check_boot_pml4e+0x30f>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004204dc8:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004204dcf:	00 00 00 
  8004204dd2:	48 8b 00             	mov    (%rax),%rax
  8004204dd5:	48 83 c0 08          	add    $0x8,%rax
  8004204dd9:	48 8b 00             	mov    (%rax),%rax
  8004204ddc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204de2:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004204de6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204dea:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204dee:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004204df1:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004204df4:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004204dfb:	00 00 00 
  8004204dfe:	48 8b 00             	mov    (%rax),%rax
  8004204e01:	48 39 c2             	cmp    %rax,%rdx
  8004204e04:	72 32                	jb     8004204e38 <check_boot_pml4e+0x528>
  8004204e06:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204e0a:	48 89 c1             	mov    %rax,%rcx
  8004204e0d:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004204e14:	00 00 00 
  8004204e17:	be 3d 04 00 00       	mov    $0x43d,%esi
  8004204e1c:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204e23:	00 00 00 
  8004204e26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e2b:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204e32:	00 00 00 
  8004204e35:	41 ff d0             	callq  *%r8
  8004204e38:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004204e3f:	00 00 00 
  8004204e42:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004204e46:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004204e4a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004204e4e:	48 8b 00             	mov    (%rax),%rax
  8004204e51:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204e57:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004204e5e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204e65:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204e69:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004204e6f:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004204e75:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004204e7c:	00 00 00 
  8004204e7f:	48 8b 00             	mov    (%rax),%rax
  8004204e82:	48 39 c2             	cmp    %rax,%rdx
  8004204e85:	72 35                	jb     8004204ebc <check_boot_pml4e+0x5ac>
  8004204e87:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204e8e:	48 89 c1             	mov    %rax,%rcx
  8004204e91:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004204e98:	00 00 00 
  8004204e9b:	be 3e 04 00 00       	mov    $0x43e,%esi
  8004204ea0:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204ea7:	00 00 00 
  8004204eaa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eaf:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204eb6:	00 00 00 
  8004204eb9:	41 ff d0             	callq  *%r8
  8004204ebc:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004204ec3:	00 00 00 
  8004204ec6:	48 03 85 78 ff ff ff 	add    -0x88(%rbp),%rax
  8004204ecd:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204ed4:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204edb:	00 
  8004204edc:	e9 44 01 00 00       	jmpq   8004205025 <check_boot_pml4e+0x715>
		switch (i) {
  8004204ee1:	48 83 7d e8 1f       	cmpq   $0x1f,-0x18(%rbp)
  8004204ee6:	77 71                	ja     8004204f59 <check_boot_pml4e+0x649>
  8004204ee8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204eec:	ba 01 00 00 00       	mov    $0x1,%edx
  8004204ef1:	48 89 d3             	mov    %rdx,%rbx
  8004204ef4:	89 c1                	mov    %eax,%ecx
  8004204ef6:	48 d3 e3             	shl    %cl,%rbx
  8004204ef9:	48 89 d8             	mov    %rbx,%rax
  8004204efc:	25 30 00 00 80       	and    $0x80000030,%eax
  8004204f01:	48 85 c0             	test   %rax,%rax
  8004204f04:	74 53                	je     8004204f59 <check_boot_pml4e+0x649>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004204f06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f0a:	48 c1 e0 03          	shl    $0x3,%rax
  8004204f0e:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  8004204f15:	48 8b 00             	mov    (%rax),%rax
  8004204f18:	83 e0 01             	and    $0x1,%eax
  8004204f1b:	48 85 c0             	test   %rax,%rax
  8004204f1e:	0f 85 f8 00 00 00    	jne    800420501c <check_boot_pml4e+0x70c>
  8004204f24:	48 b9 b3 cd 21 04 80 	movabs $0x800421cdb3,%rcx
  8004204f2b:	00 00 00 
  8004204f2e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204f35:	00 00 00 
  8004204f38:	be 46 04 00 00       	mov    $0x446,%esi
  8004204f3d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204f44:	00 00 00 
  8004204f47:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f4c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204f53:	00 00 00 
  8004204f56:	41 ff d0             	callq  *%r8
			break;
		default:
			if (i >= PDX(KERNBASE)) {
  8004204f59:	48 83 7d e8 1f       	cmpq   $0x1f,-0x18(%rbp)
  8004204f5e:	0f 86 bb 00 00 00    	jbe    800420501f <check_boot_pml4e+0x70f>
				if (pgdir[i] & PTE_P)
  8004204f64:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f68:	48 c1 e0 03          	shl    $0x3,%rax
  8004204f6c:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  8004204f73:	48 8b 00             	mov    (%rax),%rax
  8004204f76:	83 e0 01             	and    $0x1,%eax
  8004204f79:	84 c0                	test   %al,%al
  8004204f7b:	74 53                	je     8004204fd0 <check_boot_pml4e+0x6c0>
					assert(pgdir[i] & PTE_W);
  8004204f7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f81:	48 c1 e0 03          	shl    $0x3,%rax
  8004204f85:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  8004204f8c:	48 8b 00             	mov    (%rax),%rax
  8004204f8f:	83 e0 02             	and    $0x2,%eax
  8004204f92:	48 85 c0             	test   %rax,%rax
  8004204f95:	0f 85 84 00 00 00    	jne    800420501f <check_boot_pml4e+0x70f>
  8004204f9b:	48 b9 c4 cd 21 04 80 	movabs $0x800421cdc4,%rcx
  8004204fa2:	00 00 00 
  8004204fa5:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204fac:	00 00 00 
  8004204faf:	be 4b 04 00 00       	mov    $0x44b,%esi
  8004204fb4:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004204fbb:	00 00 00 
  8004204fbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fc3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004204fca:	00 00 00 
  8004204fcd:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004204fd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204fd4:	48 c1 e0 03          	shl    $0x3,%rax
  8004204fd8:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  8004204fdf:	48 8b 00             	mov    (%rax),%rax
  8004204fe2:	48 85 c0             	test   %rax,%rax
  8004204fe5:	74 38                	je     800420501f <check_boot_pml4e+0x70f>
  8004204fe7:	48 b9 d5 cd 21 04 80 	movabs $0x800421cdd5,%rcx
  8004204fee:	00 00 00 
  8004204ff1:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004204ff8:	00 00 00 
  8004204ffb:	be 4d 04 00 00       	mov    $0x44d,%esi
  8004205000:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205007:	00 00 00 
  800420500a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420500f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205016:	00 00 00 
  8004205019:	41 ff d0             	callq  *%r8
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
			break;
  800420501c:	90                   	nop
  800420501d:	eb 01                	jmp    8004205020 <check_boot_pml4e+0x710>
				if (pgdir[i] & PTE_P)
					assert(pgdir[i] & PTE_W);
				else
					assert(pgdir[i] == 0);
			} 
			break;
  800420501f:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205020:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004205025:	48 81 7d e8 ff 01 00 	cmpq   $0x1ff,-0x18(%rbp)
  800420502c:	00 
  800420502d:	0f 86 ae fe ff ff    	jbe    8004204ee1 <check_boot_pml4e+0x5d1>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205033:	48 bf e8 cd 21 04 80 	movabs $0x800421cde8,%rdi
  800420503a:	00 00 00 
  800420503d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205042:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004205049:	00 00 00 
  800420504c:	ff d2                	callq  *%rdx
}
  800420504e:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  8004205055:	5b                   	pop    %rbx
  8004205056:	5d                   	pop    %rbp
  8004205057:	c3                   	retq   

0000008004205058 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205058:	55                   	push   %rbp
  8004205059:	48 89 e5             	mov    %rsp,%rbp
  800420505c:	48 83 ec 60          	sub    $0x60,%rsp
  8004205060:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205064:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004205068:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420506c:	48 c1 e8 27          	shr    $0x27,%rax
  8004205070:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205075:	48 c1 e0 03          	shl    $0x3,%rax
  8004205079:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  800420507d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205081:	48 8b 00             	mov    (%rax),%rax
  8004205084:	83 e0 01             	and    $0x1,%eax
  8004205087:	48 85 c0             	test   %rax,%rax
  800420508a:	75 0c                	jne    8004205098 <check_va2pa+0x40>
		return ~0;
  800420508c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205093:	e9 13 02 00 00       	jmpq   80042052ab <check_va2pa+0x253>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205098:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420509c:	48 8b 00             	mov    (%rax),%rax
  800420509f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042050a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042050a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050ad:	48 c1 e8 0c          	shr    $0xc,%rax
  80042050b1:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042050b4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042050b7:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042050be:	00 00 00 
  80042050c1:	48 8b 00             	mov    (%rax),%rax
  80042050c4:	48 39 c2             	cmp    %rax,%rdx
  80042050c7:	72 32                	jb     80042050fb <check_va2pa+0xa3>
  80042050c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050cd:	48 89 c1             	mov    %rax,%rcx
  80042050d0:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  80042050d7:	00 00 00 
  80042050da:	be 65 04 00 00       	mov    $0x465,%esi
  80042050df:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042050e6:	00 00 00 
  80042050e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050ee:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042050f5:	00 00 00 
  80042050f8:	41 ff d0             	callq  *%r8
  80042050fb:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205102:	00 00 00 
  8004205105:	48 03 45 f8          	add    -0x8(%rbp),%rax
  8004205109:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  800420510d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205111:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205115:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420511a:	48 c1 e0 03          	shl    $0x3,%rax
  800420511e:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004205122:	48 8b 00             	mov    (%rax),%rax
  8004205125:	83 e0 01             	and    $0x1,%eax
  8004205128:	48 85 c0             	test   %rax,%rax
  800420512b:	75 0c                	jne    8004205139 <check_va2pa+0xe1>
		return ~0;
  800420512d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205134:	e9 72 01 00 00       	jmpq   80042052ab <check_va2pa+0x253>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205139:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420513d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205141:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205146:	48 c1 e0 03          	shl    $0x3,%rax
  800420514a:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420514e:	48 8b 00             	mov    (%rax),%rax
  8004205151:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205157:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420515b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420515f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205163:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205166:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205169:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004205170:	00 00 00 
  8004205173:	48 8b 00             	mov    (%rax),%rax
  8004205176:	48 39 c2             	cmp    %rax,%rdx
  8004205179:	72 32                	jb     80042051ad <check_va2pa+0x155>
  800420517b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420517f:	48 89 c1             	mov    %rax,%rcx
  8004205182:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004205189:	00 00 00 
  800420518c:	be 69 04 00 00       	mov    $0x469,%esi
  8004205191:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205198:	00 00 00 
  800420519b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051a0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042051a7:	00 00 00 
  80042051aa:	41 ff d0             	callq  *%r8
  80042051ad:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042051b4:	00 00 00 
  80042051b7:	48 03 45 e0          	add    -0x20(%rbp),%rax
  80042051bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  80042051bf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051c3:	48 c1 e8 15          	shr    $0x15,%rax
  80042051c7:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042051cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042051d0:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042051d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051d8:	48 8b 00             	mov    (%rax),%rax
  80042051db:	83 e0 01             	and    $0x1,%eax
  80042051de:	48 85 c0             	test   %rax,%rax
  80042051e1:	75 0c                	jne    80042051ef <check_va2pa+0x197>
		return ~0;
  80042051e3:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042051ea:	e9 bc 00 00 00       	jmpq   80042052ab <check_va2pa+0x253>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  80042051ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042051f3:	48 8b 00             	mov    (%rax),%rax
  80042051f6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042051fc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205200:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205204:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205208:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420520b:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420520e:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004205215:	00 00 00 
  8004205218:	48 8b 00             	mov    (%rax),%rax
  800420521b:	48 39 c2             	cmp    %rax,%rdx
  800420521e:	72 32                	jb     8004205252 <check_va2pa+0x1fa>
  8004205220:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205224:	48 89 c1             	mov    %rax,%rcx
  8004205227:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  800420522e:	00 00 00 
  8004205231:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004205236:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420523d:	00 00 00 
  8004205240:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205245:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420524c:	00 00 00 
  800420524f:	41 ff d0             	callq  *%r8
  8004205252:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205259:	00 00 00 
  800420525c:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004205260:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205264:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205268:	48 c1 e8 0c          	shr    $0xc,%rax
  800420526c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205271:	48 c1 e0 03          	shl    $0x3,%rax
  8004205275:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004205279:	48 8b 00             	mov    (%rax),%rax
  800420527c:	83 e0 01             	and    $0x1,%eax
  800420527f:	48 85 c0             	test   %rax,%rax
  8004205282:	75 09                	jne    800420528d <check_va2pa+0x235>
		return ~0;
  8004205284:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420528b:	eb 1e                	jmp    80042052ab <check_va2pa+0x253>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  800420528d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205291:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205295:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420529a:	48 c1 e0 03          	shl    $0x3,%rax
  800420529e:	48 03 45 b8          	add    -0x48(%rbp),%rax
  80042052a2:	48 8b 00             	mov    (%rax),%rax
  80042052a5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042052ab:	c9                   	leaveq 
  80042052ac:	c3                   	retq   

00000080042052ad <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042052ad:	55                   	push   %rbp
  80042052ae:	48 89 e5             	mov    %rsp,%rbp
  80042052b1:	53                   	push   %rbx
  80042052b2:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042052b9:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042052c0:	00 
  80042052c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052c5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042052c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042052cd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042052d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042052d5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042052d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042052dd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042052e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042052e5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  80042052e9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042052ee:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042052f5:	00 00 00 
  80042052f8:	ff d0                	callq  *%rax
  80042052fa:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042052fe:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205303:	75 35                	jne    800420533a <page_check+0x8d>
  8004205305:	48 b9 07 ce 21 04 80 	movabs $0x800421ce07,%rcx
  800420530c:	00 00 00 
  800420530f:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205316:	00 00 00 
  8004205319:	be 84 04 00 00       	mov    $0x484,%esi
  800420531e:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205325:	00 00 00 
  8004205328:	b8 00 00 00 00       	mov    $0x0,%eax
  800420532d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205334:	00 00 00 
  8004205337:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  800420533a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420533f:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205346:	00 00 00 
  8004205349:	ff d0                	callq  *%rax
  800420534b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420534f:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205354:	75 35                	jne    800420538b <page_check+0xde>
  8004205356:	48 b9 1b ce 21 04 80 	movabs $0x800421ce1b,%rcx
  800420535d:	00 00 00 
  8004205360:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205367:	00 00 00 
  800420536a:	be 85 04 00 00       	mov    $0x485,%esi
  800420536f:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205376:	00 00 00 
  8004205379:	b8 00 00 00 00       	mov    $0x0,%eax
  800420537e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205385:	00 00 00 
  8004205388:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  800420538b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205390:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205397:	00 00 00 
  800420539a:	ff d0                	callq  *%rax
  800420539c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042053a0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042053a5:	75 35                	jne    80042053dc <page_check+0x12f>
  80042053a7:	48 b9 2f ce 21 04 80 	movabs $0x800421ce2f,%rcx
  80042053ae:	00 00 00 
  80042053b1:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042053b8:	00 00 00 
  80042053bb:	be 86 04 00 00       	mov    $0x486,%esi
  80042053c0:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042053c7:	00 00 00 
  80042053ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053cf:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042053d6:	00 00 00 
  80042053d9:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  80042053dc:	bf 00 00 00 00       	mov    $0x0,%edi
  80042053e1:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042053e8:	00 00 00 
  80042053eb:	ff d0                	callq  *%rax
  80042053ed:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042053f1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042053f6:	75 35                	jne    800420542d <page_check+0x180>
  80042053f8:	48 b9 43 ce 21 04 80 	movabs $0x800421ce43,%rcx
  80042053ff:	00 00 00 
  8004205402:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205409:	00 00 00 
  800420540c:	be 87 04 00 00       	mov    $0x487,%esi
  8004205411:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205418:	00 00 00 
  800420541b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205420:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205427:	00 00 00 
  800420542a:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  800420542d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205432:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205439:	00 00 00 
  800420543c:	ff d0                	callq  *%rax
  800420543e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205442:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205447:	75 35                	jne    800420547e <page_check+0x1d1>
  8004205449:	48 b9 57 ce 21 04 80 	movabs $0x800421ce57,%rcx
  8004205450:	00 00 00 
  8004205453:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420545a:	00 00 00 
  800420545d:	be 88 04 00 00       	mov    $0x488,%esi
  8004205462:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205469:	00 00 00 
  800420546c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205471:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205478:	00 00 00 
  800420547b:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  800420547e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205483:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420548a:	00 00 00 
  800420548d:	ff d0                	callq  *%rax
  800420548f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205493:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205498:	75 35                	jne    80042054cf <page_check+0x222>
  800420549a:	48 b9 6b ce 21 04 80 	movabs $0x800421ce6b,%rcx
  80042054a1:	00 00 00 
  80042054a4:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042054ab:	00 00 00 
  80042054ae:	be 89 04 00 00       	mov    $0x489,%esi
  80042054b3:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042054ba:	00 00 00 
  80042054bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054c2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042054c9:	00 00 00 
  80042054cc:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042054cf:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042054d4:	75 35                	jne    800420550b <page_check+0x25e>
  80042054d6:	48 b9 b9 cb 21 04 80 	movabs $0x800421cbb9,%rcx
  80042054dd:	00 00 00 
  80042054e0:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042054e7:	00 00 00 
  80042054ea:	be 8b 04 00 00       	mov    $0x48b,%esi
  80042054ef:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042054f6:	00 00 00 
  80042054f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054fe:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205505:	00 00 00 
  8004205508:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  800420550b:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205510:	74 0a                	je     800420551c <page_check+0x26f>
  8004205512:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205516:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420551a:	75 35                	jne    8004205551 <page_check+0x2a4>
  800420551c:	48 b9 bd cb 21 04 80 	movabs $0x800421cbbd,%rcx
  8004205523:	00 00 00 
  8004205526:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420552d:	00 00 00 
  8004205530:	be 8c 04 00 00       	mov    $0x48c,%esi
  8004205535:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420553c:	00 00 00 
  800420553f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205544:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420554b:	00 00 00 
  800420554e:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205551:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205556:	74 14                	je     800420556c <page_check+0x2bf>
  8004205558:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420555c:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205560:	74 0a                	je     800420556c <page_check+0x2bf>
  8004205562:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205566:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420556a:	75 35                	jne    80042055a1 <page_check+0x2f4>
  800420556c:	48 b9 d0 cb 21 04 80 	movabs $0x800421cbd0,%rcx
  8004205573:	00 00 00 
  8004205576:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420557d:	00 00 00 
  8004205580:	be 8d 04 00 00       	mov    $0x48d,%esi
  8004205585:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420558c:	00 00 00 
  800420558f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205594:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420559b:	00 00 00 
  800420559e:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  80042055a1:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042055a6:	74 1e                	je     80042055c6 <page_check+0x319>
  80042055a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055ac:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042055b0:	74 14                	je     80042055c6 <page_check+0x319>
  80042055b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055b6:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042055ba:	74 0a                	je     80042055c6 <page_check+0x319>
  80042055bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055c0:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042055c4:	75 35                	jne    80042055fb <page_check+0x34e>
  80042055c6:	48 b9 80 ce 21 04 80 	movabs $0x800421ce80,%rcx
  80042055cd:	00 00 00 
  80042055d0:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042055d7:	00 00 00 
  80042055da:	be 8e 04 00 00       	mov    $0x48e,%esi
  80042055df:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042055e6:	00 00 00 
  80042055e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055ee:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042055f5:	00 00 00 
  80042055f8:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  80042055fb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205600:	74 28                	je     800420562a <page_check+0x37d>
  8004205602:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205606:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420560a:	74 1e                	je     800420562a <page_check+0x37d>
  800420560c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205610:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205614:	74 14                	je     800420562a <page_check+0x37d>
  8004205616:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420561a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420561e:	74 0a                	je     800420562a <page_check+0x37d>
  8004205620:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205624:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205628:	75 35                	jne    800420565f <page_check+0x3b2>
  800420562a:	48 b9 b0 ce 21 04 80 	movabs $0x800421ceb0,%rcx
  8004205631:	00 00 00 
  8004205634:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420563b:	00 00 00 
  800420563e:	be 8f 04 00 00       	mov    $0x48f,%esi
  8004205643:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420564a:	00 00 00 
  800420564d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205652:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205659:	00 00 00 
  800420565c:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  800420565f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205664:	74 32                	je     8004205698 <page_check+0x3eb>
  8004205666:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420566a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420566e:	74 28                	je     8004205698 <page_check+0x3eb>
  8004205670:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205674:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205678:	74 1e                	je     8004205698 <page_check+0x3eb>
  800420567a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420567e:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205682:	74 14                	je     8004205698 <page_check+0x3eb>
  8004205684:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205688:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420568c:	74 0a                	je     8004205698 <page_check+0x3eb>
  800420568e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205692:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205696:	75 35                	jne    80042056cd <page_check+0x420>
  8004205698:	48 b9 f0 ce 21 04 80 	movabs $0x800421cef0,%rcx
  800420569f:	00 00 00 
  80042056a2:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042056a9:	00 00 00 
  80042056ac:	be 90 04 00 00       	mov    $0x490,%esi
  80042056b1:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042056b8:	00 00 00 
  80042056bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056c0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042056c7:	00 00 00 
  80042056ca:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  80042056cd:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  80042056d4:	00 00 00 
  80042056d7:	48 8b 00             	mov    (%rax),%rax
  80042056da:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  80042056de:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  80042056e5:	00 00 00 
  80042056e8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  80042056ef:	bf 00 00 00 00       	mov    $0x0,%edi
  80042056f4:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042056fb:	00 00 00 
  80042056fe:	ff d0                	callq  *%rax
  8004205700:	48 85 c0             	test   %rax,%rax
  8004205703:	74 35                	je     800420573a <page_check+0x48d>
  8004205705:	48 b9 47 cc 21 04 80 	movabs $0x800421cc47,%rcx
  800420570c:	00 00 00 
  800420570f:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205716:	00 00 00 
  8004205719:	be 97 04 00 00       	mov    $0x497,%esi
  800420571e:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205725:	00 00 00 
  8004205728:	b8 00 00 00 00       	mov    $0x0,%eax
  800420572d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205734:	00 00 00 
  8004205737:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  800420573a:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205741:	00 00 00 
  8004205744:	48 8b 00             	mov    (%rax),%rax
  8004205747:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  800420574e:	be 00 00 00 00       	mov    $0x0,%esi
  8004205753:	48 89 c7             	mov    %rax,%rdi
  8004205756:	48 b8 7f 35 20 04 80 	movabs $0x800420357f,%rax
  800420575d:	00 00 00 
  8004205760:	ff d0                	callq  *%rax
  8004205762:	48 85 c0             	test   %rax,%rax
  8004205765:	74 35                	je     800420579c <page_check+0x4ef>
  8004205767:	48 b9 40 cf 21 04 80 	movabs $0x800421cf40,%rcx
  800420576e:	00 00 00 
  8004205771:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205778:	00 00 00 
  800420577b:	be 9a 04 00 00       	mov    $0x49a,%esi
  8004205780:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205787:	00 00 00 
  800420578a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420578f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205796:	00 00 00 
  8004205799:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420579c:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042057a3:	00 00 00 
  80042057a6:	48 8b 00             	mov    (%rax),%rax
  80042057a9:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042057ad:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042057b2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042057b7:	48 89 c7             	mov    %rax,%rdi
  80042057ba:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  80042057c1:	00 00 00 
  80042057c4:	ff d0                	callq  *%rax
  80042057c6:	85 c0                	test   %eax,%eax
  80042057c8:	78 35                	js     80042057ff <page_check+0x552>
  80042057ca:	48 b9 78 cf 21 04 80 	movabs $0x800421cf78,%rcx
  80042057d1:	00 00 00 
  80042057d4:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042057db:	00 00 00 
  80042057de:	be 9d 04 00 00       	mov    $0x49d,%esi
  80042057e3:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042057ea:	00 00 00 
  80042057ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057f2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042057f9:	00 00 00 
  80042057fc:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  80042057ff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205803:	48 89 c7             	mov    %rax,%rdi
  8004205806:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  800420580d:	00 00 00 
  8004205810:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205812:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205819:	00 00 00 
  800420581c:	48 8b 00             	mov    (%rax),%rax
  800420581f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205823:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205828:	ba 00 00 00 00       	mov    $0x0,%edx
  800420582d:	48 89 c7             	mov    %rax,%rdi
  8004205830:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  8004205837:	00 00 00 
  800420583a:	ff d0                	callq  *%rax
  800420583c:	85 c0                	test   %eax,%eax
  800420583e:	78 35                	js     8004205875 <page_check+0x5c8>
  8004205840:	48 b9 78 cf 21 04 80 	movabs $0x800421cf78,%rcx
  8004205847:	00 00 00 
  800420584a:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205851:	00 00 00 
  8004205854:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004205859:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205860:	00 00 00 
  8004205863:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205868:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420586f:	00 00 00 
  8004205872:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205875:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205879:	48 89 c7             	mov    %rax,%rdi
  800420587c:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  8004205883:	00 00 00 
  8004205886:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205888:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420588c:	48 89 c7             	mov    %rax,%rdi
  800420588f:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  8004205896:	00 00 00 
  8004205899:	ff d0                	callq  *%rax
	
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  800420589b:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042058a2:	00 00 00 
  80042058a5:	48 8b 00             	mov    (%rax),%rax
  80042058a8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042058ac:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042058b1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042058b6:	48 89 c7             	mov    %rax,%rdi
  80042058b9:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  80042058c0:	00 00 00 
  80042058c3:	ff d0                	callq  *%rax
  80042058c5:	85 c0                	test   %eax,%eax
  80042058c7:	74 35                	je     80042058fe <page_check+0x651>
  80042058c9:	48 b9 a8 cf 21 04 80 	movabs $0x800421cfa8,%rcx
  80042058d0:	00 00 00 
  80042058d3:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042058da:	00 00 00 
  80042058dd:	be a7 04 00 00       	mov    $0x4a7,%esi
  80042058e2:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042058e9:	00 00 00 
  80042058ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058f1:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042058f8:	00 00 00 
  80042058fb:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  80042058fe:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205905:	00 00 00 
  8004205908:	48 8b 00             	mov    (%rax),%rax
  800420590b:	48 8b 00             	mov    (%rax),%rax
  800420590e:	48 89 c3             	mov    %rax,%rbx
  8004205911:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  8004205918:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420591c:	48 89 c7             	mov    %rax,%rdi
  800420591f:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004205926:	00 00 00 
  8004205929:	ff d0                	callq  *%rax
  800420592b:	48 39 c3             	cmp    %rax,%rbx
  800420592e:	0f 84 99 00 00 00    	je     80042059cd <page_check+0x720>
  8004205934:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420593b:	00 00 00 
  800420593e:	48 8b 00             	mov    (%rax),%rax
  8004205941:	48 8b 00             	mov    (%rax),%rax
  8004205944:	48 89 c3             	mov    %rax,%rbx
  8004205947:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  800420594e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205952:	48 89 c7             	mov    %rax,%rdi
  8004205955:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  800420595c:	00 00 00 
  800420595f:	ff d0                	callq  *%rax
  8004205961:	48 39 c3             	cmp    %rax,%rbx
  8004205964:	74 67                	je     80042059cd <page_check+0x720>
  8004205966:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420596d:	00 00 00 
  8004205970:	48 8b 00             	mov    (%rax),%rax
  8004205973:	48 8b 00             	mov    (%rax),%rax
  8004205976:	48 89 c3             	mov    %rax,%rbx
  8004205979:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  8004205980:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205984:	48 89 c7             	mov    %rax,%rdi
  8004205987:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  800420598e:	00 00 00 
  8004205991:	ff d0                	callq  *%rax
  8004205993:	48 39 c3             	cmp    %rax,%rbx
  8004205996:	74 35                	je     80042059cd <page_check+0x720>
  8004205998:	48 b9 d8 cf 21 04 80 	movabs $0x800421cfd8,%rcx
  800420599f:	00 00 00 
  80042059a2:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042059a9:	00 00 00 
  80042059ac:	be a8 04 00 00       	mov    $0x4a8,%esi
  80042059b1:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042059b8:	00 00 00 
  80042059bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059c0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042059c7:	00 00 00 
  80042059ca:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  80042059cd:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042059d4:	00 00 00 
  80042059d7:	48 8b 00             	mov    (%rax),%rax
  80042059da:	be 00 00 00 00       	mov    $0x0,%esi
  80042059df:	48 89 c7             	mov    %rax,%rdi
  80042059e2:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  80042059e9:	00 00 00 
  80042059ec:	ff d0                	callq  *%rax
  80042059ee:	48 89 c3             	mov    %rax,%rbx
  80042059f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042059f5:	48 89 c7             	mov    %rax,%rdi
  80042059f8:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042059ff:	00 00 00 
  8004205a02:	ff d0                	callq  *%rax
  8004205a04:	48 39 c3             	cmp    %rax,%rbx
  8004205a07:	74 35                	je     8004205a3e <page_check+0x791>
  8004205a09:	48 b9 60 d0 21 04 80 	movabs $0x800421d060,%rcx
  8004205a10:	00 00 00 
  8004205a13:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205a1a:	00 00 00 
  8004205a1d:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004205a22:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205a29:	00 00 00 
  8004205a2c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a31:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205a38:	00 00 00 
  8004205a3b:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205a3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205a42:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205a46:	66 83 f8 01          	cmp    $0x1,%ax
  8004205a4a:	74 35                	je     8004205a81 <page_check+0x7d4>
  8004205a4c:	48 b9 8d d0 21 04 80 	movabs $0x800421d08d,%rcx
  8004205a53:	00 00 00 
  8004205a56:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205a5d:	00 00 00 
  8004205a60:	be aa 04 00 00       	mov    $0x4aa,%esi
  8004205a65:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205a6c:	00 00 00 
  8004205a6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a74:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205a7b:	00 00 00 
  8004205a7e:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205a81:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205a85:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205a89:	66 83 f8 01          	cmp    $0x1,%ax
  8004205a8d:	74 35                	je     8004205ac4 <page_check+0x817>
  8004205a8f:	48 b9 9e d0 21 04 80 	movabs $0x800421d09e,%rcx
  8004205a96:	00 00 00 
  8004205a99:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205aa0:	00 00 00 
  8004205aa3:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004205aa8:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205aaf:	00 00 00 
  8004205ab2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ab7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205abe:	00 00 00 
  8004205ac1:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205ac4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ac8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205acc:	66 83 f8 01          	cmp    $0x1,%ax
  8004205ad0:	74 35                	je     8004205b07 <page_check+0x85a>
  8004205ad2:	48 b9 af d0 21 04 80 	movabs $0x800421d0af,%rcx
  8004205ad9:	00 00 00 
  8004205adc:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205ae3:	00 00 00 
  8004205ae6:	be ac 04 00 00       	mov    $0x4ac,%esi
  8004205aeb:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205af2:	00 00 00 
  8004205af5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205afa:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205b01:	00 00 00 
  8004205b04:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205b07:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205b0e:	00 00 00 
  8004205b11:	48 8b 00             	mov    (%rax),%rax
  8004205b14:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205b18:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205b1d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205b22:	48 89 c7             	mov    %rax,%rdi
  8004205b25:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  8004205b2c:	00 00 00 
  8004205b2f:	ff d0                	callq  *%rax
  8004205b31:	85 c0                	test   %eax,%eax
  8004205b33:	74 35                	je     8004205b6a <page_check+0x8bd>
  8004205b35:	48 b9 c0 d0 21 04 80 	movabs $0x800421d0c0,%rcx
  8004205b3c:	00 00 00 
  8004205b3f:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205b46:	00 00 00 
  8004205b49:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205b4e:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205b55:	00 00 00 
  8004205b58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b5d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205b64:	00 00 00 
  8004205b67:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205b6a:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205b71:	00 00 00 
  8004205b74:	48 8b 00             	mov    (%rax),%rax
  8004205b77:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205b7c:	48 89 c7             	mov    %rax,%rdi
  8004205b7f:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004205b86:	00 00 00 
  8004205b89:	ff d0                	callq  *%rax
  8004205b8b:	48 89 c3             	mov    %rax,%rbx
  8004205b8e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b92:	48 89 c7             	mov    %rax,%rdi
  8004205b95:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004205b9c:	00 00 00 
  8004205b9f:	ff d0                	callq  *%rax
  8004205ba1:	48 39 c3             	cmp    %rax,%rbx
  8004205ba4:	74 35                	je     8004205bdb <page_check+0x92e>
  8004205ba6:	48 b9 f8 d0 21 04 80 	movabs $0x800421d0f8,%rcx
  8004205bad:	00 00 00 
  8004205bb0:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205bb7:	00 00 00 
  8004205bba:	be af 04 00 00       	mov    $0x4af,%esi
  8004205bbf:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205bc6:	00 00 00 
  8004205bc9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bce:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205bd5:	00 00 00 
  8004205bd8:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205bdb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205bdf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205be3:	66 83 f8 02          	cmp    $0x2,%ax
  8004205be7:	74 35                	je     8004205c1e <page_check+0x971>
  8004205be9:	48 b9 28 d1 21 04 80 	movabs $0x800421d128,%rcx
  8004205bf0:	00 00 00 
  8004205bf3:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205bfa:	00 00 00 
  8004205bfd:	be b0 04 00 00       	mov    $0x4b0,%esi
  8004205c02:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205c09:	00 00 00 
  8004205c0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c11:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205c18:	00 00 00 
  8004205c1b:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004205c1e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c23:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205c2a:	00 00 00 
  8004205c2d:	ff d0                	callq  *%rax
  8004205c2f:	48 85 c0             	test   %rax,%rax
  8004205c32:	74 35                	je     8004205c69 <page_check+0x9bc>
  8004205c34:	48 b9 47 cc 21 04 80 	movabs $0x800421cc47,%rcx
  8004205c3b:	00 00 00 
  8004205c3e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205c45:	00 00 00 
  8004205c48:	be b3 04 00 00       	mov    $0x4b3,%esi
  8004205c4d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205c54:	00 00 00 
  8004205c57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c5c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205c63:	00 00 00 
  8004205c66:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205c69:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205c70:	00 00 00 
  8004205c73:	48 8b 00             	mov    (%rax),%rax
  8004205c76:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205c7a:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205c7f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205c84:	48 89 c7             	mov    %rax,%rdi
  8004205c87:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  8004205c8e:	00 00 00 
  8004205c91:	ff d0                	callq  *%rax
  8004205c93:	85 c0                	test   %eax,%eax
  8004205c95:	74 35                	je     8004205ccc <page_check+0xa1f>
  8004205c97:	48 b9 c0 d0 21 04 80 	movabs $0x800421d0c0,%rcx
  8004205c9e:	00 00 00 
  8004205ca1:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205ca8:	00 00 00 
  8004205cab:	be b6 04 00 00       	mov    $0x4b6,%esi
  8004205cb0:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205cb7:	00 00 00 
  8004205cba:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cbf:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205cc6:	00 00 00 
  8004205cc9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205ccc:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205cd3:	00 00 00 
  8004205cd6:	48 8b 00             	mov    (%rax),%rax
  8004205cd9:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205cde:	48 89 c7             	mov    %rax,%rdi
  8004205ce1:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004205ce8:	00 00 00 
  8004205ceb:	ff d0                	callq  *%rax
  8004205ced:	48 89 c3             	mov    %rax,%rbx
  8004205cf0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205cf4:	48 89 c7             	mov    %rax,%rdi
  8004205cf7:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004205cfe:	00 00 00 
  8004205d01:	ff d0                	callq  *%rax
  8004205d03:	48 39 c3             	cmp    %rax,%rbx
  8004205d06:	74 35                	je     8004205d3d <page_check+0xa90>
  8004205d08:	48 b9 f8 d0 21 04 80 	movabs $0x800421d0f8,%rcx
  8004205d0f:	00 00 00 
  8004205d12:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205d19:	00 00 00 
  8004205d1c:	be b7 04 00 00       	mov    $0x4b7,%esi
  8004205d21:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205d28:	00 00 00 
  8004205d2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d30:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205d37:	00 00 00 
  8004205d3a:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205d3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d41:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205d45:	66 83 f8 02          	cmp    $0x2,%ax
  8004205d49:	74 35                	je     8004205d80 <page_check+0xad3>
  8004205d4b:	48 b9 28 d1 21 04 80 	movabs $0x800421d128,%rcx
  8004205d52:	00 00 00 
  8004205d55:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205d5c:	00 00 00 
  8004205d5f:	be b8 04 00 00       	mov    $0x4b8,%esi
  8004205d64:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205d6b:	00 00 00 
  8004205d6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d73:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205d7a:	00 00 00 
  8004205d7d:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004205d80:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d85:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004205d8c:	00 00 00 
  8004205d8f:	ff d0                	callq  *%rax
  8004205d91:	48 85 c0             	test   %rax,%rax
  8004205d94:	74 35                	je     8004205dcb <page_check+0xb1e>
  8004205d96:	48 b9 47 cc 21 04 80 	movabs $0x800421cc47,%rcx
  8004205d9d:	00 00 00 
  8004205da0:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205da7:	00 00 00 
  8004205daa:	be bc 04 00 00       	mov    $0x4bc,%esi
  8004205daf:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205db6:	00 00 00 
  8004205db9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dbe:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205dc5:	00 00 00 
  8004205dc8:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004205dcb:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205dd2:	00 00 00 
  8004205dd5:	48 8b 00             	mov    (%rax),%rax
  8004205dd8:	48 8b 00             	mov    (%rax),%rax
  8004205ddb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205de1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205de5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205de9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205ded:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205df0:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205df3:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004205dfa:	00 00 00 
  8004205dfd:	48 8b 00             	mov    (%rax),%rax
  8004205e00:	48 39 c2             	cmp    %rax,%rdx
  8004205e03:	72 32                	jb     8004205e37 <page_check+0xb8a>
  8004205e05:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205e09:	48 89 c1             	mov    %rax,%rcx
  8004205e0c:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004205e13:	00 00 00 
  8004205e16:	be be 04 00 00       	mov    $0x4be,%esi
  8004205e1b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205e22:	00 00 00 
  8004205e25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e2a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205e31:	00 00 00 
  8004205e34:	41 ff d0             	callq  *%r8
  8004205e37:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205e3e:	00 00 00 
  8004205e41:	48 03 45 a8          	add    -0x58(%rbp),%rax
  8004205e45:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004205e49:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205e4d:	48 8b 00             	mov    (%rax),%rax
  8004205e50:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205e56:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205e5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205e5e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205e62:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205e65:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004205e68:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004205e6f:	00 00 00 
  8004205e72:	48 8b 00             	mov    (%rax),%rax
  8004205e75:	48 39 c2             	cmp    %rax,%rdx
  8004205e78:	72 32                	jb     8004205eac <page_check+0xbff>
  8004205e7a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205e7e:	48 89 c1             	mov    %rax,%rcx
  8004205e81:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004205e88:	00 00 00 
  8004205e8b:	be bf 04 00 00       	mov    $0x4bf,%esi
  8004205e90:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205e97:	00 00 00 
  8004205e9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e9f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205ea6:	00 00 00 
  8004205ea9:	41 ff d0             	callq  *%r8
  8004205eac:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205eb3:	00 00 00 
  8004205eb6:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004205eba:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004205ebe:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205ec2:	48 8b 00             	mov    (%rax),%rax
  8004205ec5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205ecb:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004205ed2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205ed9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205edd:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004205ee3:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004205ee9:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004205ef0:	00 00 00 
  8004205ef3:	48 8b 00             	mov    (%rax),%rax
  8004205ef6:	48 39 c2             	cmp    %rax,%rdx
  8004205ef9:	72 35                	jb     8004205f30 <page_check+0xc83>
  8004205efb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205f02:	48 89 c1             	mov    %rax,%rcx
  8004205f05:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004205f0c:	00 00 00 
  8004205f0f:	be c0 04 00 00       	mov    $0x4c0,%esi
  8004205f14:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205f1b:	00 00 00 
  8004205f1e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f23:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205f2a:	00 00 00 
  8004205f2d:	41 ff d0             	callq  *%r8
  8004205f30:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205f37:	00 00 00 
  8004205f3a:	48 03 85 78 ff ff ff 	add    -0x88(%rbp),%rax
  8004205f41:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004205f48:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205f4f:	00 00 00 
  8004205f52:	48 8b 00             	mov    (%rax),%rax
  8004205f55:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205f5a:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f5f:	48 89 c7             	mov    %rax,%rdi
  8004205f62:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  8004205f69:	00 00 00 
  8004205f6c:	ff d0                	callq  *%rax
  8004205f6e:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004205f75:	48 83 c2 08          	add    $0x8,%rdx
  8004205f79:	48 39 d0             	cmp    %rdx,%rax
  8004205f7c:	74 35                	je     8004205fb3 <page_check+0xd06>
  8004205f7e:	48 b9 40 d1 21 04 80 	movabs $0x800421d140,%rcx
  8004205f85:	00 00 00 
  8004205f88:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205f8f:	00 00 00 
  8004205f92:	be c1 04 00 00       	mov    $0x4c1,%esi
  8004205f97:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004205f9e:	00 00 00 
  8004205fa1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fa6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004205fad:	00 00 00 
  8004205fb0:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004205fb3:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004205fba:	00 00 00 
  8004205fbd:	48 8b 00             	mov    (%rax),%rax
  8004205fc0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205fc4:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004205fc9:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205fce:	48 89 c7             	mov    %rax,%rdi
  8004205fd1:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  8004205fd8:	00 00 00 
  8004205fdb:	ff d0                	callq  *%rax
  8004205fdd:	85 c0                	test   %eax,%eax
  8004205fdf:	74 35                	je     8004206016 <page_check+0xd69>
  8004205fe1:	48 b9 80 d1 21 04 80 	movabs $0x800421d180,%rcx
  8004205fe8:	00 00 00 
  8004205feb:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004205ff2:	00 00 00 
  8004205ff5:	be c4 04 00 00       	mov    $0x4c4,%esi
  8004205ffa:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206001:	00 00 00 
  8004206004:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206009:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206010:	00 00 00 
  8004206013:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206016:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420601d:	00 00 00 
  8004206020:	48 8b 00             	mov    (%rax),%rax
  8004206023:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206028:	48 89 c7             	mov    %rax,%rdi
  800420602b:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004206032:	00 00 00 
  8004206035:	ff d0                	callq  *%rax
  8004206037:	48 89 c3             	mov    %rax,%rbx
  800420603a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420603e:	48 89 c7             	mov    %rax,%rdi
  8004206041:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  8004206048:	00 00 00 
  800420604b:	ff d0                	callq  *%rax
  800420604d:	48 39 c3             	cmp    %rax,%rbx
  8004206050:	74 35                	je     8004206087 <page_check+0xdda>
  8004206052:	48 b9 f8 d0 21 04 80 	movabs $0x800421d0f8,%rcx
  8004206059:	00 00 00 
  800420605c:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206063:	00 00 00 
  8004206066:	be c5 04 00 00       	mov    $0x4c5,%esi
  800420606b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206072:	00 00 00 
  8004206075:	b8 00 00 00 00       	mov    $0x0,%eax
  800420607a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206081:	00 00 00 
  8004206084:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206087:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420608b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420608f:	66 83 f8 02          	cmp    $0x2,%ax
  8004206093:	74 35                	je     80042060ca <page_check+0xe1d>
  8004206095:	48 b9 28 d1 21 04 80 	movabs $0x800421d128,%rcx
  800420609c:	00 00 00 
  800420609f:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042060a6:	00 00 00 
  80042060a9:	be c6 04 00 00       	mov    $0x4c6,%esi
  80042060ae:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042060b5:	00 00 00 
  80042060b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060bd:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042060c4:	00 00 00 
  80042060c7:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  80042060ca:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042060d1:	00 00 00 
  80042060d4:	48 8b 00             	mov    (%rax),%rax
  80042060d7:	ba 00 00 00 00       	mov    $0x0,%edx
  80042060dc:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060e1:	48 89 c7             	mov    %rax,%rdi
  80042060e4:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  80042060eb:	00 00 00 
  80042060ee:	ff d0                	callq  *%rax
  80042060f0:	48 8b 00             	mov    (%rax),%rax
  80042060f3:	83 e0 04             	and    $0x4,%eax
  80042060f6:	48 85 c0             	test   %rax,%rax
  80042060f9:	75 35                	jne    8004206130 <page_check+0xe83>
  80042060fb:	48 b9 c0 d1 21 04 80 	movabs $0x800421d1c0,%rcx
  8004206102:	00 00 00 
  8004206105:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420610c:	00 00 00 
  800420610f:	be c7 04 00 00       	mov    $0x4c7,%esi
  8004206114:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420611b:	00 00 00 
  800420611e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206123:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420612a:	00 00 00 
  800420612d:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206130:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206137:	00 00 00 
  800420613a:	48 8b 00             	mov    (%rax),%rax
  800420613d:	48 8b 00             	mov    (%rax),%rax
  8004206140:	83 e0 04             	and    $0x4,%eax
  8004206143:	48 85 c0             	test   %rax,%rax
  8004206146:	75 35                	jne    800420617d <page_check+0xed0>
  8004206148:	48 b9 f3 d1 21 04 80 	movabs $0x800421d1f3,%rcx
  800420614f:	00 00 00 
  8004206152:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206159:	00 00 00 
  800420615c:	be c8 04 00 00       	mov    $0x4c8,%esi
  8004206161:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206168:	00 00 00 
  800420616b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206170:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206177:	00 00 00 
  800420617a:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  800420617d:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206184:	00 00 00 
  8004206187:	48 8b 00             	mov    (%rax),%rax
  800420618a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800420618e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206193:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206198:	48 89 c7             	mov    %rax,%rdi
  800420619b:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  80042061a2:	00 00 00 
  80042061a5:	ff d0                	callq  *%rax
  80042061a7:	85 c0                	test   %eax,%eax
  80042061a9:	78 35                	js     80042061e0 <page_check+0xf33>
  80042061ab:	48 b9 10 d2 21 04 80 	movabs $0x800421d210,%rcx
  80042061b2:	00 00 00 
  80042061b5:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042061bc:	00 00 00 
  80042061bf:	be cc 04 00 00       	mov    $0x4cc,%esi
  80042061c4:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042061cb:	00 00 00 
  80042061ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061d3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042061da:	00 00 00 
  80042061dd:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042061e0:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042061e7:	00 00 00 
  80042061ea:	48 8b 00             	mov    (%rax),%rax
  80042061ed:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042061f1:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042061f6:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042061fb:	48 89 c7             	mov    %rax,%rdi
  80042061fe:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  8004206205:	00 00 00 
  8004206208:	ff d0                	callq  *%rax
  800420620a:	85 c0                	test   %eax,%eax
  800420620c:	74 35                	je     8004206243 <page_check+0xf96>
  800420620e:	48 b9 48 d2 21 04 80 	movabs $0x800421d248,%rcx
  8004206215:	00 00 00 
  8004206218:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420621f:	00 00 00 
  8004206222:	be cf 04 00 00       	mov    $0x4cf,%esi
  8004206227:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420622e:	00 00 00 
  8004206231:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206236:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420623d:	00 00 00 
  8004206240:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  8004206243:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420624a:	00 00 00 
  800420624d:	48 8b 00             	mov    (%rax),%rax
  8004206250:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206255:	be 00 10 00 00       	mov    $0x1000,%esi
  800420625a:	48 89 c7             	mov    %rax,%rdi
  800420625d:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  8004206264:	00 00 00 
  8004206267:	ff d0                	callq  *%rax
  8004206269:	48 8b 00             	mov    (%rax),%rax
  800420626c:	83 e0 04             	and    $0x4,%eax
  800420626f:	48 85 c0             	test   %rax,%rax
  8004206272:	74 35                	je     80042062a9 <page_check+0xffc>
  8004206274:	48 b9 80 d2 21 04 80 	movabs $0x800421d280,%rcx
  800420627b:	00 00 00 
  800420627e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206285:	00 00 00 
  8004206288:	be d0 04 00 00       	mov    $0x4d0,%esi
  800420628d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206294:	00 00 00 
  8004206297:	b8 00 00 00 00       	mov    $0x0,%eax
  800420629c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042062a3:	00 00 00 
  80042062a6:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042062a9:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042062b0:	00 00 00 
  80042062b3:	48 8b 00             	mov    (%rax),%rax
  80042062b6:	be 00 00 00 00       	mov    $0x0,%esi
  80042062bb:	48 89 c7             	mov    %rax,%rdi
  80042062be:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  80042062c5:	00 00 00 
  80042062c8:	ff d0                	callq  *%rax
  80042062ca:	48 89 c3             	mov    %rax,%rbx
  80042062cd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042062d1:	48 89 c7             	mov    %rax,%rdi
  80042062d4:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042062db:	00 00 00 
  80042062de:	ff d0                	callq  *%rax
  80042062e0:	48 39 c3             	cmp    %rax,%rbx
  80042062e3:	74 35                	je     800420631a <page_check+0x106d>
  80042062e5:	48 b9 b8 d2 21 04 80 	movabs $0x800421d2b8,%rcx
  80042062ec:	00 00 00 
  80042062ef:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042062f6:	00 00 00 
  80042062f9:	be d3 04 00 00       	mov    $0x4d3,%esi
  80042062fe:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206305:	00 00 00 
  8004206308:	b8 00 00 00 00       	mov    $0x0,%eax
  800420630d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206314:	00 00 00 
  8004206317:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  800420631a:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206321:	00 00 00 
  8004206324:	48 8b 00             	mov    (%rax),%rax
  8004206327:	be 00 10 00 00       	mov    $0x1000,%esi
  800420632c:	48 89 c7             	mov    %rax,%rdi
  800420632f:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004206336:	00 00 00 
  8004206339:	ff d0                	callq  *%rax
  800420633b:	48 89 c3             	mov    %rax,%rbx
  800420633e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206342:	48 89 c7             	mov    %rax,%rdi
  8004206345:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  800420634c:	00 00 00 
  800420634f:	ff d0                	callq  *%rax
  8004206351:	48 39 c3             	cmp    %rax,%rbx
  8004206354:	74 35                	je     800420638b <page_check+0x10de>
  8004206356:	48 b9 e8 d2 21 04 80 	movabs $0x800421d2e8,%rcx
  800420635d:	00 00 00 
  8004206360:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206367:	00 00 00 
  800420636a:	be d4 04 00 00       	mov    $0x4d4,%esi
  800420636f:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206376:	00 00 00 
  8004206379:	b8 00 00 00 00       	mov    $0x0,%eax
  800420637e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206385:	00 00 00 
  8004206388:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  800420638b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420638f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206393:	66 83 f8 02          	cmp    $0x2,%ax
  8004206397:	74 35                	je     80042063ce <page_check+0x1121>
  8004206399:	48 b9 18 d3 21 04 80 	movabs $0x800421d318,%rcx
  80042063a0:	00 00 00 
  80042063a3:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042063aa:	00 00 00 
  80042063ad:	be d6 04 00 00       	mov    $0x4d6,%esi
  80042063b2:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042063b9:	00 00 00 
  80042063bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063c1:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042063c8:	00 00 00 
  80042063cb:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042063ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042063d2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042063d6:	66 83 f8 01          	cmp    $0x1,%ax
  80042063da:	74 35                	je     8004206411 <page_check+0x1164>
  80042063dc:	48 b9 29 d3 21 04 80 	movabs $0x800421d329,%rcx
  80042063e3:	00 00 00 
  80042063e6:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042063ed:	00 00 00 
  80042063f0:	be d7 04 00 00       	mov    $0x4d7,%esi
  80042063f5:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042063fc:	00 00 00 
  80042063ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206404:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420640b:	00 00 00 
  800420640e:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206411:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206418:	00 00 00 
  800420641b:	48 8b 00             	mov    (%rax),%rax
  800420641e:	be 00 00 00 00       	mov    $0x0,%esi
  8004206423:	48 89 c7             	mov    %rax,%rdi
  8004206426:	48 b8 fc 35 20 04 80 	movabs $0x80042035fc,%rax
  800420642d:	00 00 00 
  8004206430:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206432:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206439:	00 00 00 
  800420643c:	48 8b 00             	mov    (%rax),%rax
  800420643f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206444:	48 89 c7             	mov    %rax,%rdi
  8004206447:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  800420644e:	00 00 00 
  8004206451:	ff d0                	callq  *%rax
  8004206453:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206457:	74 35                	je     800420648e <page_check+0x11e1>
  8004206459:	48 b9 40 d3 21 04 80 	movabs $0x800421d340,%rcx
  8004206460:	00 00 00 
  8004206463:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420646a:	00 00 00 
  800420646d:	be dc 04 00 00       	mov    $0x4dc,%esi
  8004206472:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206479:	00 00 00 
  800420647c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206481:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206488:	00 00 00 
  800420648b:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  800420648e:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206495:	00 00 00 
  8004206498:	48 8b 00             	mov    (%rax),%rax
  800420649b:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064a0:	48 89 c7             	mov    %rax,%rdi
  80042064a3:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  80042064aa:	00 00 00 
  80042064ad:	ff d0                	callq  *%rax
  80042064af:	48 89 c3             	mov    %rax,%rbx
  80042064b2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042064b6:	48 89 c7             	mov    %rax,%rdi
  80042064b9:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042064c0:	00 00 00 
  80042064c3:	ff d0                	callq  *%rax
  80042064c5:	48 39 c3             	cmp    %rax,%rbx
  80042064c8:	74 35                	je     80042064ff <page_check+0x1252>
  80042064ca:	48 b9 e8 d2 21 04 80 	movabs $0x800421d2e8,%rcx
  80042064d1:	00 00 00 
  80042064d4:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042064db:	00 00 00 
  80042064de:	be dd 04 00 00       	mov    $0x4dd,%esi
  80042064e3:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042064ea:	00 00 00 
  80042064ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064f2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042064f9:	00 00 00 
  80042064fc:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  80042064ff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206503:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206507:	66 83 f8 01          	cmp    $0x1,%ax
  800420650b:	74 35                	je     8004206542 <page_check+0x1295>
  800420650d:	48 b9 8d d0 21 04 80 	movabs $0x800421d08d,%rcx
  8004206514:	00 00 00 
  8004206517:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420651e:	00 00 00 
  8004206521:	be de 04 00 00       	mov    $0x4de,%esi
  8004206526:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420652d:	00 00 00 
  8004206530:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206535:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420653c:	00 00 00 
  800420653f:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206542:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206546:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420654a:	66 83 f8 01          	cmp    $0x1,%ax
  800420654e:	74 35                	je     8004206585 <page_check+0x12d8>
  8004206550:	48 b9 29 d3 21 04 80 	movabs $0x800421d329,%rcx
  8004206557:	00 00 00 
  800420655a:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206561:	00 00 00 
  8004206564:	be df 04 00 00       	mov    $0x4df,%esi
  8004206569:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206570:	00 00 00 
  8004206573:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206578:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420657f:	00 00 00 
  8004206582:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206585:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420658c:	00 00 00 
  800420658f:	48 8b 00             	mov    (%rax),%rax
  8004206592:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206596:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420659b:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042065a0:	48 89 c7             	mov    %rax,%rdi
  80042065a3:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  80042065aa:	00 00 00 
  80042065ad:	ff d0                	callq  *%rax
  80042065af:	85 c0                	test   %eax,%eax
  80042065b1:	74 35                	je     80042065e8 <page_check+0x133b>
  80042065b3:	48 b9 48 d2 21 04 80 	movabs $0x800421d248,%rcx
  80042065ba:	00 00 00 
  80042065bd:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042065c4:	00 00 00 
  80042065c7:	be e3 04 00 00       	mov    $0x4e3,%esi
  80042065cc:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042065d3:	00 00 00 
  80042065d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065db:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042065e2:	00 00 00 
  80042065e5:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  80042065e8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042065ec:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042065f0:	66 85 c0             	test   %ax,%ax
  80042065f3:	75 35                	jne    800420662a <page_check+0x137d>
  80042065f5:	48 b9 63 d3 21 04 80 	movabs $0x800421d363,%rcx
  80042065fc:	00 00 00 
  80042065ff:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206606:	00 00 00 
  8004206609:	be e4 04 00 00       	mov    $0x4e4,%esi
  800420660e:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206615:	00 00 00 
  8004206618:	b8 00 00 00 00       	mov    $0x0,%eax
  800420661d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206624:	00 00 00 
  8004206627:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  800420662a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420662e:	48 8b 00             	mov    (%rax),%rax
  8004206631:	48 85 c0             	test   %rax,%rax
  8004206634:	74 35                	je     800420666b <page_check+0x13be>
  8004206636:	48 b9 6f d3 21 04 80 	movabs $0x800421d36f,%rcx
  800420663d:	00 00 00 
  8004206640:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206647:	00 00 00 
  800420664a:	be e5 04 00 00       	mov    $0x4e5,%esi
  800420664f:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206656:	00 00 00 
  8004206659:	b8 00 00 00 00       	mov    $0x0,%eax
  800420665e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206665:	00 00 00 
  8004206668:	41 ff d0             	callq  *%r8


	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  800420666b:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206672:	00 00 00 
  8004206675:	48 8b 00             	mov    (%rax),%rax
  8004206678:	be 00 10 00 00       	mov    $0x1000,%esi
  800420667d:	48 89 c7             	mov    %rax,%rdi
  8004206680:	48 b8 fc 35 20 04 80 	movabs $0x80042035fc,%rax
  8004206687:	00 00 00 
  800420668a:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  800420668c:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206693:	00 00 00 
  8004206696:	48 8b 00             	mov    (%rax),%rax
  8004206699:	be 00 00 00 00       	mov    $0x0,%esi
  800420669e:	48 89 c7             	mov    %rax,%rdi
  80042066a1:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  80042066a8:	00 00 00 
  80042066ab:	ff d0                	callq  *%rax
  80042066ad:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042066b1:	74 35                	je     80042066e8 <page_check+0x143b>
  80042066b3:	48 b9 40 d3 21 04 80 	movabs $0x800421d340,%rcx
  80042066ba:	00 00 00 
  80042066bd:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042066c4:	00 00 00 
  80042066c7:	be ea 04 00 00       	mov    $0x4ea,%esi
  80042066cc:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042066d3:	00 00 00 
  80042066d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066db:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042066e2:	00 00 00 
  80042066e5:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  80042066e8:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042066ef:	00 00 00 
  80042066f2:	48 8b 00             	mov    (%rax),%rax
  80042066f5:	be 00 10 00 00       	mov    $0x1000,%esi
  80042066fa:	48 89 c7             	mov    %rax,%rdi
  80042066fd:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004206704:	00 00 00 
  8004206707:	ff d0                	callq  *%rax
  8004206709:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420670d:	74 35                	je     8004206744 <page_check+0x1497>
  800420670f:	48 b9 88 d3 21 04 80 	movabs $0x800421d388,%rcx
  8004206716:	00 00 00 
  8004206719:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206720:	00 00 00 
  8004206723:	be eb 04 00 00       	mov    $0x4eb,%esi
  8004206728:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420672f:	00 00 00 
  8004206732:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206737:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420673e:	00 00 00 
  8004206741:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206744:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206748:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420674c:	66 85 c0             	test   %ax,%ax
  800420674f:	74 35                	je     8004206786 <page_check+0x14d9>
  8004206751:	48 b9 ae d3 21 04 80 	movabs $0x800421d3ae,%rcx
  8004206758:	00 00 00 
  800420675b:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206762:	00 00 00 
  8004206765:	be ec 04 00 00       	mov    $0x4ec,%esi
  800420676a:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206771:	00 00 00 
  8004206774:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206779:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206780:	00 00 00 
  8004206783:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206786:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420678a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420678e:	66 83 f8 01          	cmp    $0x1,%ax
  8004206792:	74 35                	je     80042067c9 <page_check+0x151c>
  8004206794:	48 b9 29 d3 21 04 80 	movabs $0x800421d329,%rcx
  800420679b:	00 00 00 
  800420679e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042067a5:	00 00 00 
  80042067a8:	be ed 04 00 00       	mov    $0x4ed,%esi
  80042067ad:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042067b4:	00 00 00 
  80042067b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067bc:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042067c3:	00 00 00 
  80042067c6:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  80042067c9:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042067d0:	00 00 00 
  80042067d3:	48 8b 00             	mov    (%rax),%rax
  80042067d6:	48 8b 00             	mov    (%rax),%rax
  80042067d9:	48 89 c3             	mov    %rax,%rbx
  80042067dc:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  80042067e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067e7:	48 89 c7             	mov    %rax,%rdi
  80042067ea:	48 b8 ec 17 20 04 80 	movabs $0x80042017ec,%rax
  80042067f1:	00 00 00 
  80042067f4:	ff d0                	callq  *%rax
  80042067f6:	48 39 c3             	cmp    %rax,%rbx
  80042067f9:	74 35                	je     8004206830 <page_check+0x1583>
  80042067fb:	48 b9 c0 d3 21 04 80 	movabs $0x800421d3c0,%rcx
  8004206802:	00 00 00 
  8004206805:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420680c:	00 00 00 
  800420680f:	be 01 05 00 00       	mov    $0x501,%esi
  8004206814:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420681b:	00 00 00 
  800420681e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206823:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420682a:	00 00 00 
  800420682d:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  8004206830:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206837:	00 00 00 
  800420683a:	48 8b 00             	mov    (%rax),%rax
  800420683d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206844:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206848:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420684c:	66 83 f8 01          	cmp    $0x1,%ax
  8004206850:	74 35                	je     8004206887 <page_check+0x15da>
  8004206852:	48 b9 29 d3 21 04 80 	movabs $0x800421d329,%rcx
  8004206859:	00 00 00 
  800420685c:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206863:	00 00 00 
  8004206866:	be 03 05 00 00       	mov    $0x503,%esi
  800420686b:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206872:	00 00 00 
  8004206875:	b8 00 00 00 00       	mov    $0x0,%eax
  800420687a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206881:	00 00 00 
  8004206884:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  8004206887:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420688b:	48 89 c7             	mov    %rax,%rdi
  800420688e:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004206895:	00 00 00 
  8004206898:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  800420689a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420689e:	48 89 c7             	mov    %rax,%rdi
  80042068a1:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042068a8:	00 00 00 
  80042068ab:	ff d0                	callq  *%rax
	page_decref(pp2);
  80042068ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042068b1:	48 89 c7             	mov    %rax,%rdi
  80042068b4:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042068bb:	00 00 00 
  80042068be:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  80042068c0:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  80042068c7:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  80042068cb:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042068d2:	00 00 00 
  80042068d5:	48 8b 00             	mov    (%rax),%rax
  80042068d8:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  80042068df:	ba 01 00 00 00       	mov    $0x1,%edx
  80042068e4:	48 89 ce             	mov    %rcx,%rsi
  80042068e7:	48 89 c7             	mov    %rax,%rdi
  80042068ea:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  80042068f1:	00 00 00 
  80042068f4:	ff d0                	callq  *%rax
  80042068f6:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  80042068fd:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206904:	00 00 00 
  8004206907:	48 8b 00             	mov    (%rax),%rax
  800420690a:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206911:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206915:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  800420691b:	48 c1 e2 03          	shl    $0x3,%rdx
  800420691f:	48 01 d0             	add    %rdx,%rax
  8004206922:	48 8b 00             	mov    (%rax),%rax
  8004206925:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420692b:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206932:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206939:	48 c1 e8 0c          	shr    $0xc,%rax
  800420693d:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206943:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206949:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004206950:	00 00 00 
  8004206953:	48 8b 00             	mov    (%rax),%rax
  8004206956:	48 39 c2             	cmp    %rax,%rdx
  8004206959:	72 35                	jb     8004206990 <page_check+0x16e3>
  800420695b:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206962:	48 89 c1             	mov    %rax,%rcx
  8004206965:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  800420696c:	00 00 00 
  800420696f:	be 0a 05 00 00       	mov    $0x50a,%esi
  8004206974:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420697b:	00 00 00 
  800420697e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206983:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420698a:	00 00 00 
  800420698d:	41 ff d0             	callq  *%r8
  8004206990:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206997:	00 00 00 
  800420699a:	48 03 85 60 ff ff ff 	add    -0xa0(%rbp),%rax
  80042069a1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042069a5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042069ac:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042069b0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042069b5:	48 c1 e0 03          	shl    $0x3,%rax
  80042069b9:	48 03 45 98          	add    -0x68(%rbp),%rax
  80042069bd:	48 8b 00             	mov    (%rax),%rax
  80042069c0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042069c6:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  80042069cd:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042069d4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042069d8:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  80042069de:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  80042069e4:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042069eb:	00 00 00 
  80042069ee:	48 8b 00             	mov    (%rax),%rax
  80042069f1:	48 39 c2             	cmp    %rax,%rdx
  80042069f4:	72 35                	jb     8004206a2b <page_check+0x177e>
  80042069f6:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042069fd:	48 89 c1             	mov    %rax,%rcx
  8004206a00:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004206a07:	00 00 00 
  8004206a0a:	be 0b 05 00 00       	mov    $0x50b,%esi
  8004206a0f:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206a16:	00 00 00 
  8004206a19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a1e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206a25:	00 00 00 
  8004206a28:	41 ff d0             	callq  *%r8
  8004206a2b:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206a32:	00 00 00 
  8004206a35:	48 03 85 50 ff ff ff 	add    -0xb0(%rbp),%rax
  8004206a3c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206a40:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206a47:	48 c1 e8 15          	shr    $0x15,%rax
  8004206a4b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206a50:	48 c1 e0 03          	shl    $0x3,%rax
  8004206a54:	48 03 45 80          	add    -0x80(%rbp),%rax
  8004206a58:	48 8b 00             	mov    (%rax),%rax
  8004206a5b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206a61:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206a68:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206a6f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206a73:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206a79:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206a7f:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004206a86:	00 00 00 
  8004206a89:	48 8b 00             	mov    (%rax),%rax
  8004206a8c:	48 39 c2             	cmp    %rax,%rdx
  8004206a8f:	72 35                	jb     8004206ac6 <page_check+0x1819>
  8004206a91:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206a98:	48 89 c1             	mov    %rax,%rcx
  8004206a9b:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004206aa2:	00 00 00 
  8004206aa5:	be 0c 05 00 00       	mov    $0x50c,%esi
  8004206aaa:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206ab1:	00 00 00 
  8004206ab4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ab9:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206ac0:	00 00 00 
  8004206ac3:	41 ff d0             	callq  *%r8
  8004206ac6:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206acd:	00 00 00 
  8004206ad0:	48 03 85 40 ff ff ff 	add    -0xc0(%rbp),%rax
  8004206ad7:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206ade:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206ae5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206ae9:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206aee:	48 c1 e0 03          	shl    $0x3,%rax
  8004206af2:	48 89 c2             	mov    %rax,%rdx
  8004206af5:	48 03 95 30 ff ff ff 	add    -0xd0(%rbp),%rdx
  8004206afc:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206b03:	48 39 c2             	cmp    %rax,%rdx
  8004206b06:	74 35                	je     8004206b3d <page_check+0x1890>
  8004206b08:	48 b9 e8 d3 21 04 80 	movabs $0x800421d3e8,%rcx
  8004206b0f:	00 00 00 
  8004206b12:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206b19:	00 00 00 
  8004206b1c:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004206b21:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206b28:	00 00 00 
  8004206b2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b30:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206b37:	00 00 00 
  8004206b3a:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	page_decref(pp4);
  8004206b3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206b41:	48 89 c7             	mov    %rax,%rdi
  8004206b44:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004206b4b:	00 00 00 
  8004206b4e:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206b50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206b54:	48 89 c7             	mov    %rax,%rdi
  8004206b57:	48 b8 82 18 20 04 80 	movabs $0x8004201882,%rax
  8004206b5e:	00 00 00 
  8004206b61:	ff d0                	callq  *%rax
  8004206b63:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206b68:	be ff 00 00 00       	mov    $0xff,%esi
  8004206b6d:	48 89 c7             	mov    %rax,%rdi
  8004206b70:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004206b77:	00 00 00 
  8004206b7a:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206b7c:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206b83:	00 00 00 
  8004206b86:	48 8b 00             	mov    (%rax),%rax
  8004206b89:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206b8e:	be 00 00 00 00       	mov    $0x0,%esi
  8004206b93:	48 89 c7             	mov    %rax,%rdi
  8004206b96:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  8004206b9d:	00 00 00 
  8004206ba0:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206ba2:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206ba9:	00 00 00 
  8004206bac:	48 8b 00             	mov    (%rax),%rax
  8004206baf:	48 8b 00             	mov    (%rax),%rax
  8004206bb2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bb8:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206bbf:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206bc6:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206bca:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004206bd0:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004206bd6:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004206bdd:	00 00 00 
  8004206be0:	48 8b 00             	mov    (%rax),%rax
  8004206be3:	48 39 c2             	cmp    %rax,%rdx
  8004206be6:	72 35                	jb     8004206c1d <page_check+0x1970>
  8004206be8:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206bef:	48 89 c1             	mov    %rax,%rcx
  8004206bf2:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004206bf9:	00 00 00 
  8004206bfc:	be 13 05 00 00       	mov    $0x513,%esi
  8004206c01:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206c08:	00 00 00 
  8004206c0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c10:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206c17:	00 00 00 
  8004206c1a:	41 ff d0             	callq  *%r8
  8004206c1d:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206c24:	00 00 00 
  8004206c27:	48 03 85 28 ff ff ff 	add    -0xd8(%rbp),%rax
  8004206c2e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004206c32:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206c36:	48 8b 00             	mov    (%rax),%rax
  8004206c39:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206c3f:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004206c46:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206c4d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206c51:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  8004206c57:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004206c5d:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004206c64:	00 00 00 
  8004206c67:	48 8b 00             	mov    (%rax),%rax
  8004206c6a:	48 39 c2             	cmp    %rax,%rdx
  8004206c6d:	72 35                	jb     8004206ca4 <page_check+0x19f7>
  8004206c6f:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206c76:	48 89 c1             	mov    %rax,%rcx
  8004206c79:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004206c80:	00 00 00 
  8004206c83:	be 14 05 00 00       	mov    $0x514,%esi
  8004206c88:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206c8f:	00 00 00 
  8004206c92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c97:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206c9e:	00 00 00 
  8004206ca1:	41 ff d0             	callq  *%r8
  8004206ca4:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206cab:	00 00 00 
  8004206cae:	48 03 85 18 ff ff ff 	add    -0xe8(%rbp),%rax
  8004206cb5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004206cb9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206cbd:	48 8b 00             	mov    (%rax),%rax
  8004206cc0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206cc6:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004206ccd:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206cd4:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206cd8:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004206cde:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004206ce4:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004206ceb:	00 00 00 
  8004206cee:	48 8b 00             	mov    (%rax),%rax
  8004206cf1:	48 39 c2             	cmp    %rax,%rdx
  8004206cf4:	72 35                	jb     8004206d2b <page_check+0x1a7e>
  8004206cf6:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206cfd:	48 89 c1             	mov    %rax,%rcx
  8004206d00:	48 ba 28 c7 21 04 80 	movabs $0x800421c728,%rdx
  8004206d07:	00 00 00 
  8004206d0a:	be 15 05 00 00       	mov    $0x515,%esi
  8004206d0f:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206d16:	00 00 00 
  8004206d19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d1e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206d25:	00 00 00 
  8004206d28:	41 ff d0             	callq  *%r8
  8004206d2b:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206d32:	00 00 00 
  8004206d35:	48 03 85 08 ff ff ff 	add    -0xf8(%rbp),%rax
  8004206d3c:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  8004206d43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004206d4a:	eb 57                	jmp    8004206da3 <page_check+0x1af6>
		assert((ptep[i] & PTE_P) == 0);
  8004206d4c:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206d53:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004206d56:	48 63 d2             	movslq %edx,%rdx
  8004206d59:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206d5d:	48 01 d0             	add    %rdx,%rax
  8004206d60:	48 8b 00             	mov    (%rax),%rax
  8004206d63:	83 e0 01             	and    $0x1,%eax
  8004206d66:	84 c0                	test   %al,%al
  8004206d68:	74 35                	je     8004206d9f <page_check+0x1af2>
  8004206d6a:	48 b9 00 d4 21 04 80 	movabs $0x800421d400,%rcx
  8004206d71:	00 00 00 
  8004206d74:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206d7b:	00 00 00 
  8004206d7e:	be 17 05 00 00       	mov    $0x517,%esi
  8004206d83:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206d8a:	00 00 00 
  8004206d8d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d92:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206d99:	00 00 00 
  8004206d9c:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004206d9f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004206da3:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004206daa:	7e a0                	jle    8004206d4c <page_check+0x1a9f>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004206dac:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206db3:	00 00 00 
  8004206db6:	48 8b 00             	mov    (%rax),%rax
  8004206db9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004206dc0:	48 b8 38 22 48 04 80 	movabs $0x8004482238,%rax
  8004206dc7:	00 00 00 
  8004206dca:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004206dce:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004206dd1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206dd5:	48 89 c7             	mov    %rax,%rdi
  8004206dd8:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004206ddf:	00 00 00 
  8004206de2:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004206de4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206de8:	48 89 c7             	mov    %rax,%rdi
  8004206deb:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004206df2:	00 00 00 
  8004206df5:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206df7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206dfb:	48 89 c7             	mov    %rax,%rdi
  8004206dfe:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004206e05:	00 00 00 
  8004206e08:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004206e0a:	be 01 10 00 00       	mov    $0x1001,%esi
  8004206e0f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206e14:	48 b8 40 37 20 04 80 	movabs $0x8004203740,%rax
  8004206e1b:	00 00 00 
  8004206e1e:	ff d0                	callq  *%rax
  8004206e20:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004206e27:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206e2c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206e31:	48 b8 40 37 20 04 80 	movabs $0x8004203740,%rax
  8004206e38:	00 00 00 
  8004206e3b:	ff d0                	callq  *%rax
  8004206e3d:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004206e44:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206e4b:	00 00 00 
  8004206e4e:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004206e55:	76 1d                	jbe    8004206e74 <page_check+0x1bc7>
  8004206e57:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206e5e:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206e65:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206e6c:	00 00 00 
  8004206e6f:	48 39 c2             	cmp    %rax,%rdx
  8004206e72:	76 35                	jbe    8004206ea9 <page_check+0x1bfc>
  8004206e74:	48 b9 18 d4 21 04 80 	movabs $0x800421d418,%rcx
  8004206e7b:	00 00 00 
  8004206e7e:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206e85:	00 00 00 
  8004206e88:	be 26 05 00 00       	mov    $0x526,%esi
  8004206e8d:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206e94:	00 00 00 
  8004206e97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e9c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206ea3:	00 00 00 
  8004206ea6:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004206ea9:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206eb0:	00 00 00 
  8004206eb3:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004206eba:	76 1d                	jbe    8004206ed9 <page_check+0x1c2c>
  8004206ebc:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206ec3:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206eca:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004206ed1:	00 00 00 
  8004206ed4:	48 39 c2             	cmp    %rax,%rdx
  8004206ed7:	76 35                	jbe    8004206f0e <page_check+0x1c61>
  8004206ed9:	48 b9 40 d4 21 04 80 	movabs $0x800421d440,%rcx
  8004206ee0:	00 00 00 
  8004206ee3:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206eea:	00 00 00 
  8004206eed:	be 27 05 00 00       	mov    $0x527,%esi
  8004206ef2:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206ef9:	00 00 00 
  8004206efc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f01:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206f08:	00 00 00 
  8004206f0b:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004206f0e:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206f15:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206f1a:	48 85 c0             	test   %rax,%rax
  8004206f1d:	75 11                	jne    8004206f30 <page_check+0x1c83>
  8004206f1f:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004206f26:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004206f2b:	48 85 c0             	test   %rax,%rax
  8004206f2e:	74 35                	je     8004206f65 <page_check+0x1cb8>
  8004206f30:	48 b9 68 d4 21 04 80 	movabs $0x800421d468,%rcx
  8004206f37:	00 00 00 
  8004206f3a:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206f41:	00 00 00 
  8004206f44:	be 29 05 00 00       	mov    $0x529,%esi
  8004206f49:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206f50:	00 00 00 
  8004206f53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f58:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206f5f:	00 00 00 
  8004206f62:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004206f65:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206f6c:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004206f72:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  8004206f79:	76 35                	jbe    8004206fb0 <page_check+0x1d03>
  8004206f7b:	48 b9 8f d4 21 04 80 	movabs $0x800421d48f,%rcx
  8004206f82:	00 00 00 
  8004206f85:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206f8c:	00 00 00 
  8004206f8f:	be 2b 05 00 00       	mov    $0x52b,%esi
  8004206f94:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206f9b:	00 00 00 
  8004206f9e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fa3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004206faa:	00 00 00 
  8004206fad:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004206fb0:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004206fb7:	00 00 00 
  8004206fba:	48 8b 00             	mov    (%rax),%rax
  8004206fbd:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004206fc4:	48 89 d6             	mov    %rdx,%rsi
  8004206fc7:	48 89 c7             	mov    %rax,%rdi
  8004206fca:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004206fd1:	00 00 00 
  8004206fd4:	ff d0                	callq  *%rax
  8004206fd6:	48 85 c0             	test   %rax,%rax
  8004206fd9:	74 35                	je     8004207010 <page_check+0x1d63>
  8004206fdb:	48 b9 a8 d4 21 04 80 	movabs $0x800421d4a8,%rcx
  8004206fe2:	00 00 00 
  8004206fe5:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004206fec:	00 00 00 
  8004206fef:	be 2e 05 00 00       	mov    $0x52e,%esi
  8004206ff4:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004206ffb:	00 00 00 
  8004206ffe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207003:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420700a:	00 00 00 
  800420700d:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207010:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207017:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  800420701e:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004207025:	00 00 00 
  8004207028:	48 8b 00             	mov    (%rax),%rax
  800420702b:	48 89 d6             	mov    %rdx,%rsi
  800420702e:	48 89 c7             	mov    %rax,%rdi
  8004207031:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004207038:	00 00 00 
  800420703b:	ff d0                	callq  *%rax
  800420703d:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207043:	74 35                	je     800420707a <page_check+0x1dcd>
  8004207045:	48 b9 d0 d4 21 04 80 	movabs $0x800421d4d0,%rcx
  800420704c:	00 00 00 
  800420704f:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004207056:	00 00 00 
  8004207059:	be 2f 05 00 00       	mov    $0x52f,%esi
  800420705e:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004207065:	00 00 00 
  8004207068:	b8 00 00 00 00       	mov    $0x0,%eax
  800420706d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207074:	00 00 00 
  8004207077:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  800420707a:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004207081:	00 00 00 
  8004207084:	48 8b 00             	mov    (%rax),%rax
  8004207087:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  800420708e:	48 89 d6             	mov    %rdx,%rsi
  8004207091:	48 89 c7             	mov    %rax,%rdi
  8004207094:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  800420709b:	00 00 00 
  800420709e:	ff d0                	callq  *%rax
  80042070a0:	48 85 c0             	test   %rax,%rax
  80042070a3:	74 35                	je     80042070da <page_check+0x1e2d>
  80042070a5:	48 b9 00 d5 21 04 80 	movabs $0x800421d500,%rcx
  80042070ac:	00 00 00 
  80042070af:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042070b6:	00 00 00 
  80042070b9:	be 30 05 00 00       	mov    $0x530,%esi
  80042070be:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042070c5:	00 00 00 
  80042070c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070cd:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042070d4:	00 00 00 
  80042070d7:	41 ff d0             	callq  *%r8
	cprintf("failing %x %x\n", mm2+PGSIZE, check_va2pa(boot_pml4e, mm2+PGSIZE));
  80042070da:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042070e1:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  80042070e8:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042070ef:	00 00 00 
  80042070f2:	48 8b 00             	mov    (%rax),%rax
  80042070f5:	48 89 d6             	mov    %rdx,%rsi
  80042070f8:	48 89 c7             	mov    %rax,%rdi
  80042070fb:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  8004207102:	00 00 00 
  8004207105:	ff d0                	callq  *%rax
  8004207107:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  800420710e:	48 8d 8a 00 10 00 00 	lea    0x1000(%rdx),%rcx
  8004207115:	48 89 c2             	mov    %rax,%rdx
  8004207118:	48 89 ce             	mov    %rcx,%rsi
  800420711b:	48 bf 22 d5 21 04 80 	movabs $0x800421d522,%rdi
  8004207122:	00 00 00 
  8004207125:	b8 00 00 00 00       	mov    $0x0,%eax
  800420712a:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  8004207131:	00 00 00 
  8004207134:	ff d1                	callq  *%rcx
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207136:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420713d:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207144:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420714b:	00 00 00 
  800420714e:	48 8b 00             	mov    (%rax),%rax
  8004207151:	48 89 d6             	mov    %rdx,%rsi
  8004207154:	48 89 c7             	mov    %rax,%rdi
  8004207157:	48 b8 58 50 20 04 80 	movabs $0x8004205058,%rax
  800420715e:	00 00 00 
  8004207161:	ff d0                	callq  *%rax
  8004207163:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207167:	74 35                	je     800420719e <page_check+0x1ef1>
  8004207169:	48 b9 38 d5 21 04 80 	movabs $0x800421d538,%rcx
  8004207170:	00 00 00 
  8004207173:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  800420717a:	00 00 00 
  800420717d:	be 32 05 00 00       	mov    $0x532,%esi
  8004207182:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  8004207189:	00 00 00 
  800420718c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207191:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207198:	00 00 00 
  800420719b:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  800420719e:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042071a5:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042071ac:	00 00 00 
  80042071af:	48 8b 00             	mov    (%rax),%rax
  80042071b2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042071b7:	48 89 ce             	mov    %rcx,%rsi
  80042071ba:	48 89 c7             	mov    %rax,%rdi
  80042071bd:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  80042071c4:	00 00 00 
  80042071c7:	ff d0                	callq  *%rax
  80042071c9:	48 8b 00             	mov    (%rax),%rax
  80042071cc:	83 e0 1a             	and    $0x1a,%eax
  80042071cf:	48 85 c0             	test   %rax,%rax
  80042071d2:	75 35                	jne    8004207209 <page_check+0x1f5c>
  80042071d4:	48 b9 68 d5 21 04 80 	movabs $0x800421d568,%rcx
  80042071db:	00 00 00 
  80042071de:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  80042071e5:	00 00 00 
  80042071e8:	be 34 05 00 00       	mov    $0x534,%esi
  80042071ed:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  80042071f4:	00 00 00 
  80042071f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071fc:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207203:	00 00 00 
  8004207206:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207209:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207210:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004207217:	00 00 00 
  800420721a:	48 8b 00             	mov    (%rax),%rax
  800420721d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207222:	48 89 ce             	mov    %rcx,%rsi
  8004207225:	48 89 c7             	mov    %rax,%rdi
  8004207228:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  800420722f:	00 00 00 
  8004207232:	ff d0                	callq  *%rax
  8004207234:	48 8b 00             	mov    (%rax),%rax
  8004207237:	83 e0 04             	and    $0x4,%eax
  800420723a:	48 85 c0             	test   %rax,%rax
  800420723d:	74 35                	je     8004207274 <page_check+0x1fc7>
  800420723f:	48 b9 b0 d5 21 04 80 	movabs $0x800421d5b0,%rcx
  8004207246:	00 00 00 
  8004207249:	48 ba a1 c7 21 04 80 	movabs $0x800421c7a1,%rdx
  8004207250:	00 00 00 
  8004207253:	be 35 05 00 00       	mov    $0x535,%esi
  8004207258:	48 bf b6 c7 21 04 80 	movabs $0x800421c7b6,%rdi
  800420725f:	00 00 00 
  8004207262:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207267:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420726e:	00 00 00 
  8004207271:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207274:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420727b:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004207282:	00 00 00 
  8004207285:	48 8b 00             	mov    (%rax),%rax
  8004207288:	ba 00 00 00 00       	mov    $0x0,%edx
  800420728d:	48 89 ce             	mov    %rcx,%rsi
  8004207290:	48 89 c7             	mov    %rax,%rdi
  8004207293:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  800420729a:	00 00 00 
  800420729d:	ff d0                	callq  *%rax
  800420729f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  80042072a6:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042072ad:	48 05 00 10 00 00    	add    $0x1000,%rax
  80042072b3:	48 89 c1             	mov    %rax,%rcx
  80042072b6:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042072bd:	00 00 00 
  80042072c0:	48 8b 00             	mov    (%rax),%rax
  80042072c3:	ba 00 00 00 00       	mov    $0x0,%edx
  80042072c8:	48 89 ce             	mov    %rcx,%rsi
  80042072cb:	48 89 c7             	mov    %rax,%rdi
  80042072ce:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  80042072d5:	00 00 00 
  80042072d8:	ff d0                	callq  *%rax
  80042072da:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  80042072e1:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042072e8:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  80042072ef:	00 00 00 
  80042072f2:	48 8b 00             	mov    (%rax),%rax
  80042072f5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042072fa:	48 89 ce             	mov    %rcx,%rsi
  80042072fd:	48 89 c7             	mov    %rax,%rdi
  8004207300:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  8004207307:	00 00 00 
  800420730a:	ff d0                	callq  *%rax
  800420730c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207313:	48 bf e3 d5 21 04 80 	movabs $0x800421d5e3,%rdi
  800420731a:	00 00 00 
  800420731d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207322:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004207329:	00 00 00 
  800420732c:	ff d2                	callq  *%rdx
}
  800420732e:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207335:	5b                   	pop    %rbx
  8004207336:	5d                   	pop    %rbp
  8004207337:	c3                   	retq   

0000008004207338 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207338:	55                   	push   %rbp
  8004207339:	48 89 e5             	mov    %rsp,%rbp
  800420733c:	48 83 ec 08          	sub    $0x8,%rsp
  8004207340:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207344:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207348:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  800420734f:	00 00 00 
  8004207352:	48 8b 00             	mov    (%rax),%rax
  8004207355:	48 89 d1             	mov    %rdx,%rcx
  8004207358:	48 29 c1             	sub    %rax,%rcx
  800420735b:	48 89 c8             	mov    %rcx,%rax
  800420735e:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207362:	c9                   	leaveq 
  8004207363:	c3                   	retq   

0000008004207364 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207364:	55                   	push   %rbp
  8004207365:	48 89 e5             	mov    %rsp,%rbp
  8004207368:	48 83 ec 08          	sub    $0x8,%rsp
  800420736c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004207370:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207374:	48 89 c7             	mov    %rax,%rdi
  8004207377:	48 b8 38 73 20 04 80 	movabs $0x8004207338,%rax
  800420737e:	00 00 00 
  8004207381:	ff d0                	callq  *%rax
  8004207383:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207387:	c9                   	leaveq 
  8004207388:	c3                   	retq   

0000008004207389 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207389:	55                   	push   %rbp
  800420738a:	48 89 e5             	mov    %rsp,%rbp
  800420738d:	48 83 ec 10          	sub    $0x10,%rsp
  8004207391:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207399:	48 89 c2             	mov    %rax,%rdx
  800420739c:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042073a0:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042073a7:	00 00 00 
  80042073aa:	48 8b 00             	mov    (%rax),%rax
  80042073ad:	48 39 c2             	cmp    %rax,%rdx
  80042073b0:	72 2a                	jb     80042073dc <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042073b2:	48 ba 00 d6 21 04 80 	movabs $0x800421d600,%rdx
  80042073b9:	00 00 00 
  80042073bc:	be 54 00 00 00       	mov    $0x54,%esi
  80042073c1:	48 bf 1f d6 21 04 80 	movabs $0x800421d61f,%rdi
  80042073c8:	00 00 00 
  80042073cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073d0:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  80042073d7:	00 00 00 
  80042073da:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042073dc:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  80042073e3:	00 00 00 
  80042073e6:	48 8b 00             	mov    (%rax),%rax
  80042073e9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042073ed:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042073f1:	48 c1 e2 04          	shl    $0x4,%rdx
  80042073f5:	48 01 d0             	add    %rdx,%rax
}
  80042073f8:	c9                   	leaveq 
  80042073f9:	c3                   	retq   

00000080042073fa <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042073fa:	55                   	push   %rbp
  80042073fb:	48 89 e5             	mov    %rsp,%rbp
  80042073fe:	48 83 ec 20          	sub    $0x20,%rsp
  8004207402:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207406:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420740a:	48 89 c7             	mov    %rax,%rdi
  800420740d:	48 b8 64 73 20 04 80 	movabs $0x8004207364,%rax
  8004207414:	00 00 00 
  8004207417:	ff d0                	callq  *%rax
  8004207419:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420741d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207421:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207425:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207428:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420742b:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004207432:	00 00 00 
  8004207435:	48 8b 00             	mov    (%rax),%rax
  8004207438:	48 39 c2             	cmp    %rax,%rdx
  800420743b:	72 32                	jb     800420746f <page2kva+0x75>
  800420743d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207441:	48 89 c1             	mov    %rax,%rcx
  8004207444:	48 ba 30 d6 21 04 80 	movabs $0x800421d630,%rdx
  800420744b:	00 00 00 
  800420744e:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207453:	48 bf 1f d6 21 04 80 	movabs $0x800421d61f,%rdi
  800420745a:	00 00 00 
  800420745d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207462:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207469:	00 00 00 
  800420746c:	41 ff d0             	callq  *%r8
  800420746f:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004207476:	00 00 00 
  8004207479:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  800420747d:	c9                   	leaveq 
  800420747e:	c3                   	retq   

000000800420747f <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420747f:	55                   	push   %rbp
  8004207480:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207483:	48 bf 00 07 23 04 80 	movabs $0x8004230700,%rdi
  800420748a:	00 00 00 
  800420748d:	48 b8 91 77 21 04 80 	movabs $0x8004217791,%rax
  8004207494:	00 00 00 
  8004207497:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207499:	f3 90                	pause  
}
  800420749b:	5d                   	pop    %rbp
  800420749c:	c3                   	retq   

000000800420749d <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  800420749d:	55                   	push   %rbp
  800420749e:	48 89 e5             	mov    %rsp,%rbp
  80042074a1:	53                   	push   %rbx
  80042074a2:	48 83 ec 28          	sub    $0x28,%rsp
  80042074a6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042074a9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042074ad:	89 d0                	mov    %edx,%eax
  80042074af:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  80042074b2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042074b6:	75 3e                	jne    80042074f6 <envid2env+0x59>
		*env_store = curenv;
  80042074b8:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042074bf:	00 00 00 
  80042074c2:	ff d0                	callq  *%rax
  80042074c4:	48 98                	cltq   
  80042074c6:	48 c1 e0 03          	shl    $0x3,%rax
  80042074ca:	48 89 c2             	mov    %rax,%rdx
  80042074cd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042074d1:	48 01 c2             	add    %rax,%rdx
  80042074d4:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042074db:	00 00 00 
  80042074de:	48 01 d0             	add    %rdx,%rax
  80042074e1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042074e5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042074e9:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042074ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074f1:	e9 08 01 00 00       	jmpq   80042075fe <envid2env+0x161>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042074f6:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  80042074fd:	00 00 00 
  8004207500:	48 8b 08             	mov    (%rax),%rcx
  8004207503:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207506:	48 98                	cltq   
  8004207508:	48 89 c2             	mov    %rax,%rdx
  800420750b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  8004207511:	48 89 d0             	mov    %rdx,%rax
  8004207514:	48 c1 e0 02          	shl    $0x2,%rax
  8004207518:	48 01 d0             	add    %rdx,%rax
  800420751b:	48 01 c0             	add    %rax,%rax
  800420751e:	48 01 d0             	add    %rdx,%rax
  8004207521:	48 c1 e0 05          	shl    $0x5,%rax
  8004207525:	48 01 c8             	add    %rcx,%rax
  8004207528:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  800420752c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207530:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207536:	85 c0                	test   %eax,%eax
  8004207538:	74 0f                	je     8004207549 <envid2env+0xac>
  800420753a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420753e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207544:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207547:	74 15                	je     800420755e <envid2env+0xc1>
		*env_store = 0;
  8004207549:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420754d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207554:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207559:	e9 a0 00 00 00       	jmpq   80042075fe <envid2env+0x161>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  800420755e:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207562:	0f 84 86 00 00 00    	je     80042075ee <envid2env+0x151>
  8004207568:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420756f:	00 00 00 
  8004207572:	ff d0                	callq  *%rax
  8004207574:	48 98                	cltq   
  8004207576:	48 c1 e0 03          	shl    $0x3,%rax
  800420757a:	48 89 c2             	mov    %rax,%rdx
  800420757d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207581:	48 01 c2             	add    %rax,%rdx
  8004207584:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420758b:	00 00 00 
  800420758e:	48 01 d0             	add    %rdx,%rax
  8004207591:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207595:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207599:	74 53                	je     80042075ee <envid2env+0x151>
  800420759b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420759f:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  80042075a5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042075ac:	00 00 00 
  80042075af:	ff d0                	callq  *%rax
  80042075b1:	48 98                	cltq   
  80042075b3:	48 c1 e0 03          	shl    $0x3,%rax
  80042075b7:	48 89 c2             	mov    %rax,%rdx
  80042075ba:	48 c1 e2 04          	shl    $0x4,%rdx
  80042075be:	48 01 c2             	add    %rax,%rdx
  80042075c1:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042075c8:	00 00 00 
  80042075cb:	48 01 d0             	add    %rdx,%rax
  80042075ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042075d2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042075d8:	39 c3                	cmp    %eax,%ebx
  80042075da:	74 12                	je     80042075ee <envid2env+0x151>
		*env_store = 0;
  80042075dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042075e0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042075e7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042075ec:	eb 10                	jmp    80042075fe <envid2env+0x161>
	}

	*env_store = e;
  80042075ee:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042075f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042075f6:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80042075f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042075fe:	48 83 c4 28          	add    $0x28,%rsp
  8004207602:	5b                   	pop    %rbx
  8004207603:	5d                   	pop    %rbp
  8004207604:	c3                   	retq   

0000008004207605 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004207605:	55                   	push   %rbp
  8004207606:	48 89 e5             	mov    %rsp,%rbp
  8004207609:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	struct Env *env = NULL;
  800420760d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207614:	00 
	size_t i = 0;
  8004207615:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420761c:	00 
	for (; i < NENV; i++) {
  800420761d:	e9 08 01 00 00       	jmpq   800420772a <env_init+0x125>
		envs[i].env_type = ENV_FREE;
  8004207622:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  8004207629:	00 00 00 
  800420762c:	48 8b 08             	mov    (%rax),%rcx
  800420762f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207633:	48 89 d0             	mov    %rdx,%rax
  8004207636:	48 c1 e0 02          	shl    $0x2,%rax
  800420763a:	48 01 d0             	add    %rdx,%rax
  800420763d:	48 01 c0             	add    %rax,%rax
  8004207640:	48 01 d0             	add    %rdx,%rax
  8004207643:	48 c1 e0 05          	shl    $0x5,%rax
  8004207647:	48 01 c8             	add    %rcx,%rax
  800420764a:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207651:	00 00 00 
		envs[i].env_id = 0;
  8004207654:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420765b:	00 00 00 
  800420765e:	48 8b 08             	mov    (%rax),%rcx
  8004207661:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207665:	48 89 d0             	mov    %rdx,%rax
  8004207668:	48 c1 e0 02          	shl    $0x2,%rax
  800420766c:	48 01 d0             	add    %rdx,%rax
  800420766f:	48 01 c0             	add    %rax,%rax
  8004207672:	48 01 d0             	add    %rdx,%rax
  8004207675:	48 c1 e0 05          	shl    $0x5,%rax
  8004207679:	48 01 c8             	add    %rcx,%rax
  800420767c:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  8004207683:	00 00 00 
		if(env) {
  8004207686:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420768b:	74 36                	je     80042076c3 <env_init+0xbe>
			env->env_link = &envs[i];
  800420768d:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  8004207694:	00 00 00 
  8004207697:	48 8b 08             	mov    (%rax),%rcx
  800420769a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420769e:	48 89 d0             	mov    %rdx,%rax
  80042076a1:	48 c1 e0 02          	shl    $0x2,%rax
  80042076a5:	48 01 d0             	add    %rdx,%rax
  80042076a8:	48 01 c0             	add    %rax,%rax
  80042076ab:	48 01 d0             	add    %rdx,%rax
  80042076ae:	48 c1 e0 05          	shl    $0x5,%rax
  80042076b2:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042076b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042076ba:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  80042076c1:	eb 36                	jmp    80042076f9 <env_init+0xf4>
		}
		else {
			env_free_list = &envs[i];
  80042076c3:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  80042076ca:	00 00 00 
  80042076cd:	48 8b 08             	mov    (%rax),%rcx
  80042076d0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042076d4:	48 89 d0             	mov    %rdx,%rax
  80042076d7:	48 c1 e0 02          	shl    $0x2,%rax
  80042076db:	48 01 d0             	add    %rdx,%rax
  80042076de:	48 01 c0             	add    %rax,%rax
  80042076e1:	48 01 d0             	add    %rdx,%rax
  80042076e4:	48 c1 e0 05          	shl    $0x5,%rax
  80042076e8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042076ec:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  80042076f3:	00 00 00 
  80042076f6:	48 89 10             	mov    %rdx,(%rax)
		}
		env = &envs[i];
  80042076f9:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  8004207700:	00 00 00 
  8004207703:	48 8b 08             	mov    (%rax),%rcx
  8004207706:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420770a:	48 89 d0             	mov    %rdx,%rax
  800420770d:	48 c1 e0 02          	shl    $0x2,%rax
  8004207711:	48 01 d0             	add    %rdx,%rax
  8004207714:	48 01 c0             	add    %rax,%rax
  8004207717:	48 01 d0             	add    %rdx,%rax
  800420771a:	48 c1 e0 05          	shl    $0x5,%rax
  800420771e:	48 01 c8             	add    %rcx,%rax
  8004207721:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	// Set up envs array
	// LAB 3: Your code here.
	struct Env *env = NULL;
	size_t i = 0;
	for (; i < NENV; i++) {
  8004207725:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  800420772a:	48 81 7d f0 ff 03 00 	cmpq   $0x3ff,-0x10(%rbp)
  8004207731:	00 
  8004207732:	0f 86 ea fe ff ff    	jbe    8004207622 <env_init+0x1d>
		env = &envs[i];
	}
	//Not sure whether this is needed, but anyway
	//env->env_link = env;
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207738:	48 b8 46 77 20 04 80 	movabs $0x8004207746,%rax
  800420773f:	00 00 00 
  8004207742:	ff d0                	callq  *%rax
}
  8004207744:	c9                   	leaveq 
  8004207745:	c3                   	retq   

0000008004207746 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207746:	55                   	push   %rbp
  8004207747:	48 89 e5             	mov    %rsp,%rbp
  800420774a:	53                   	push   %rbx
  800420774b:	48 83 ec 10          	sub    $0x10,%rsp
  800420774f:	48 b8 f8 05 23 04 80 	movabs $0x80042305f8,%rax
  8004207756:	00 00 00 
  8004207759:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

    static __inline void
lgdt(void *p)
{
    __asm __volatile("lgdt (%0)" : : "r" (p));
  800420775d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207761:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207764:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207769:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  800420776b:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207770:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207772:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207777:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207779:	b8 10 00 00 00       	mov    $0x10,%eax
  800420777e:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207780:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207785:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207787:	b8 08 00 00 00       	mov    $0x8,%eax
  800420778c:	89 c3                	mov    %eax,%ebx
  800420778e:	53                   	push   %rbx
  800420778f:	48 b8 9c 77 20 04 80 	movabs $0x800420779c,%rax
  8004207796:	00 00 00 
  8004207799:	50                   	push   %rax
  800420779a:	48 cb                	lretq  
  800420779c:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

    static __inline void
lldt(uint16_t sel)
{
    __asm __volatile("lldt %0" : : "r" (sel));
  80042077a2:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042077a6:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  80042077a9:	48 83 c4 10          	add    $0x10,%rsp
  80042077ad:	5b                   	pop    %rbx
  80042077ae:	5d                   	pop    %rbp
  80042077af:	c3                   	retq   

00000080042077b0 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  80042077b0:	55                   	push   %rbp
  80042077b1:	48 89 e5             	mov    %rsp,%rbp
  80042077b4:	48 83 ec 20          	sub    $0x20,%rsp
  80042077b8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042077bc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042077c3:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(0)))
  80042077c4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042077c9:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  80042077d0:	00 00 00 
  80042077d3:	ff d0                	callq  *%rax
  80042077d5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042077d9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042077de:	75 0a                	jne    80042077ea <env_setup_vm+0x3a>
		return -E_NO_MEM;
  80042077e0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042077e5:	e9 cd 00 00 00       	jmpq   80042078b7 <env_setup_vm+0x107>
	//    - Note: In general, pp_ref is not maintained for
	//	physical pages mapped only above UTOP, but env_pml4e
	//	is an exception -- you need to increment env_pml4e's
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.
	e->env_pml4e = (pml4e_t*)page2kva(p);
  80042077ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042077ee:	48 89 c7             	mov    %rax,%rdi
  80042077f1:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  80042077f8:	00 00 00 
  80042077fb:	ff d0                	callq  *%rax
  80042077fd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207801:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3 = page2pa(p);
  8004207808:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420780c:	48 89 c7             	mov    %rax,%rdi
  800420780f:	48 b8 64 73 20 04 80 	movabs $0x8004207364,%rax
  8004207816:	00 00 00 
  8004207819:	ff d0                	callq  *%rax
  800420781b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420781f:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)
	p->pp_ref++;
  8004207826:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420782a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420782e:	8d 50 01             	lea    0x1(%rax),%edx
  8004207831:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207835:	66 89 50 08          	mov    %dx,0x8(%rax)
	size_t pml4e_map = 0;
  8004207839:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207840:	00 
	for ( ;pml4e_map < NPMLENTRIES ; pml4e_map++) {
  8004207841:	eb 44                	jmp    8004207887 <env_setup_vm+0xd7>
			if (pml4e_map >= PML4(UTOP)) {
  8004207843:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207848:	74 38                	je     8004207882 <env_setup_vm+0xd2>
				e->env_pml4e[pml4e_map] = boot_pml4e[pml4e_map] | (PTE_P & ~(PTE_W | PTE_U));
  800420784a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420784e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207855:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207859:	48 c1 e2 03          	shl    $0x3,%rdx
  800420785d:	48 01 c2             	add    %rax,%rdx
  8004207860:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  8004207867:	00 00 00 
  800420786a:	48 8b 00             	mov    (%rax),%rax
  800420786d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004207871:	48 c1 e1 03          	shl    $0x3,%rcx
  8004207875:	48 01 c8             	add    %rcx,%rax
  8004207878:	48 8b 00             	mov    (%rax),%rax
  800420787b:	48 83 c8 01          	or     $0x1,%rax
  800420787f:	48 89 02             	mov    %rax,(%rdx)
	//    - The functions in kern/pmap.h are handy.
	e->env_pml4e = (pml4e_t*)page2kva(p);
	e->env_cr3 = page2pa(p);
	p->pp_ref++;
	size_t pml4e_map = 0;
	for ( ;pml4e_map < NPMLENTRIES ; pml4e_map++) {
  8004207882:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207887:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  800420788e:	00 
  800420788f:	76 b2                	jbe    8004207843 <env_setup_vm+0x93>
	}
	// LAB 3: Your code here.
	
	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  8004207891:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207895:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420789c:	48 8d 50 10          	lea    0x10(%rax),%rdx
  80042078a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042078a4:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042078ab:	48 83 c8 05          	or     $0x5,%rax
  80042078af:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  80042078b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042078b7:	c9                   	leaveq 
  80042078b8:	c3                   	retq   

00000080042078b9 <env_guest_alloc>:

int
env_guest_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042078b9:	55                   	push   %rbp
  80042078ba:	48 89 e5             	mov    %rsp,%rbp
  80042078bd:	48 83 ec 50          	sub    $0x50,%rsp
  80042078c1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042078c5:	89 75 b4             	mov    %esi,-0x4c(%rbp)
	int32_t generation;
	struct Env *e;

	if (!(e = env_free_list))
  80042078c8:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  80042078cf:	00 00 00 
  80042078d2:	48 8b 00             	mov    (%rax),%rax
  80042078d5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042078d9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042078de:	75 0a                	jne    80042078ea <env_guest_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042078e0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042078e5:	e9 0c 04 00 00       	jmpq   8004207cf6 <env_guest_alloc+0x43d>

	memset(&e->env_vmxinfo, 0, sizeof(struct VmxGuestInfo));
  80042078ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042078ee:	48 05 20 01 00 00    	add    $0x120,%rax
  80042078f4:	ba 40 00 00 00       	mov    $0x40,%edx
  80042078f9:	be 00 00 00 00       	mov    $0x0,%esi
  80042078fe:	48 89 c7             	mov    %rax,%rdi
  8004207901:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004207908:	00 00 00 
  800420790b:	ff d0                	callq  *%rax

	// allocate a page for the EPT PML4..
	struct PageInfo *p = NULL;
  800420790d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004207914:	00 

	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207915:	bf 01 00 00 00       	mov    $0x1,%edi
  800420791a:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004207921:	00 00 00 
  8004207924:	ff d0                	callq  *%rax
  8004207926:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420792a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420792f:	75 0a                	jne    800420793b <env_guest_alloc+0x82>
		return -E_NO_MEM;
  8004207931:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207936:	e9 bb 03 00 00       	jmpq   8004207cf6 <env_guest_alloc+0x43d>

	memset(p, 0, sizeof(struct PageInfo));
  800420793b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420793f:	ba 10 00 00 00       	mov    $0x10,%edx
  8004207944:	be 00 00 00 00       	mov    $0x0,%esi
  8004207949:	48 89 c7             	mov    %rax,%rdi
  800420794c:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004207953:	00 00 00 
  8004207956:	ff d0                	callq  *%rax
	p->pp_ref       += 1;
  8004207958:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420795c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207960:	8d 50 01             	lea    0x1(%rax),%edx
  8004207963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207967:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  800420796b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420796f:	48 89 c7             	mov    %rax,%rdi
  8004207972:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  8004207979:	00 00 00 
  800420797c:	ff d0                	callq  *%rax
  800420797e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207982:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3      = page2pa(p);
  8004207989:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420798d:	48 89 c7             	mov    %rax,%rdi
  8004207990:	48 b8 64 73 20 04 80 	movabs $0x8004207364,%rax
  8004207997:	00 00 00 
  800420799a:	ff d0                	callq  *%rax
  800420799c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042079a0:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	// Allocate a VMCS.
	struct PageInfo *q = vmx_init_vmcs();
  80042079a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079ac:	48 ba ed 92 21 04 80 	movabs $0x80042192ed,%rdx
  80042079b3:	00 00 00 
  80042079b6:	ff d2                	callq  *%rdx
  80042079b8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (!q) {
  80042079bc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042079c1:	75 1d                	jne    80042079e0 <env_guest_alloc+0x127>
		page_decref(p);
  80042079c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042079c7:	48 89 c7             	mov    %rax,%rdi
  80042079ca:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042079d1:	00 00 00 
  80042079d4:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  80042079d6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042079db:	e9 16 03 00 00       	jmpq   8004207cf6 <env_guest_alloc+0x43d>
	}
	q->pp_ref += 1;
  80042079e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042079e4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042079e8:	8d 50 01             	lea    0x1(%rax),%edx
  80042079eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042079ef:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.vmcs = page2kva(q);
  80042079f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042079f7:	48 89 c7             	mov    %rax,%rdi
  80042079fa:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  8004207a01:	00 00 00 
  8004207a04:	ff d0                	callq  *%rax
  8004207a06:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207a0a:	48 89 82 28 01 00 00 	mov    %rax,0x128(%rdx)

	// Allocate a page for msr load/store area.
	struct PageInfo *r = NULL;
  8004207a11:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004207a18:	00 
	if (!(r = page_alloc(ALLOC_ZERO))) {
  8004207a19:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207a1e:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004207a25:	00 00 00 
  8004207a28:	ff d0                	callq  *%rax
  8004207a2a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207a2e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004207a33:	75 30                	jne    8004207a65 <env_guest_alloc+0x1ac>
		page_decref(p);
  8004207a35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207a39:	48 89 c7             	mov    %rax,%rdi
  8004207a3c:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207a43:	00 00 00 
  8004207a46:	ff d0                	callq  *%rax
		page_decref(q);
  8004207a48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207a4c:	48 89 c7             	mov    %rax,%rdi
  8004207a4f:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207a56:	00 00 00 
  8004207a59:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207a5b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207a60:	e9 91 02 00 00       	jmpq   8004207cf6 <env_guest_alloc+0x43d>
	}
	r->pp_ref += 1;
  8004207a65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a69:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207a6d:	8d 50 01             	lea    0x1(%rax),%edx
  8004207a70:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a74:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.msr_host_area = page2kva(r);
  8004207a78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a7c:	48 89 c7             	mov    %rax,%rdi
  8004207a7f:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  8004207a86:	00 00 00 
  8004207a89:	ff d0                	callq  *%rax
  8004207a8b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207a8f:	48 89 82 50 01 00 00 	mov    %rax,0x150(%rdx)
	e->env_vmxinfo.msr_guest_area = page2kva(r) + PGSIZE / 2;
  8004207a96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207a9a:	48 89 c7             	mov    %rax,%rdi
  8004207a9d:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  8004207aa4:	00 00 00 
  8004207aa7:	ff d0                	callq  *%rax
  8004207aa9:	48 8d 90 00 08 00 00 	lea    0x800(%rax),%rdx
  8004207ab0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ab4:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)

	// Allocate pages for IO bitmaps.
	struct PageInfo *s = NULL;
  8004207abb:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004207ac2:	00 
	if (!(s = page_alloc(ALLOC_ZERO))) {
  8004207ac3:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207ac8:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004207acf:	00 00 00 
  8004207ad2:	ff d0                	callq  *%rax
  8004207ad4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004207ad8:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004207add:	75 43                	jne    8004207b22 <env_guest_alloc+0x269>
		page_decref(p);
  8004207adf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ae3:	48 89 c7             	mov    %rax,%rdi
  8004207ae6:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207aed:	00 00 00 
  8004207af0:	ff d0                	callq  *%rax
		page_decref(q);
  8004207af2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207af6:	48 89 c7             	mov    %rax,%rdi
  8004207af9:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207b00:	00 00 00 
  8004207b03:	ff d0                	callq  *%rax
		page_decref(r);
  8004207b05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207b09:	48 89 c7             	mov    %rax,%rdi
  8004207b0c:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207b13:	00 00 00 
  8004207b16:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207b18:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207b1d:	e9 d4 01 00 00       	jmpq   8004207cf6 <env_guest_alloc+0x43d>
	}
	s->pp_ref += 1;
  8004207b22:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207b26:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207b2a:	8d 50 01             	lea    0x1(%rax),%edx
  8004207b2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207b31:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_a = page2kva(s);
  8004207b35:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207b39:	48 89 c7             	mov    %rax,%rdi
  8004207b3c:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  8004207b43:	00 00 00 
  8004207b46:	ff d0                	callq  *%rax
  8004207b48:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207b4c:	48 89 82 38 01 00 00 	mov    %rax,0x138(%rdx)

	struct PageInfo *t = NULL;
  8004207b53:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004207b5a:	00 
	if (!(t = page_alloc(ALLOC_ZERO))) {
  8004207b5b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207b60:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004207b67:	00 00 00 
  8004207b6a:	ff d0                	callq  *%rax
  8004207b6c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004207b70:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004207b75:	75 56                	jne    8004207bcd <env_guest_alloc+0x314>
		page_decref(p);
  8004207b77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207b7b:	48 89 c7             	mov    %rax,%rdi
  8004207b7e:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207b85:	00 00 00 
  8004207b88:	ff d0                	callq  *%rax
		page_decref(q);
  8004207b8a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b8e:	48 89 c7             	mov    %rax,%rdi
  8004207b91:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207b98:	00 00 00 
  8004207b9b:	ff d0                	callq  *%rax
		page_decref(r);
  8004207b9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207ba1:	48 89 c7             	mov    %rax,%rdi
  8004207ba4:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207bab:	00 00 00 
  8004207bae:	ff d0                	callq  *%rax
		page_decref(s);
  8004207bb0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207bb4:	48 89 c7             	mov    %rax,%rdi
  8004207bb7:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207bbe:	00 00 00 
  8004207bc1:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207bc3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207bc8:	e9 29 01 00 00       	jmpq   8004207cf6 <env_guest_alloc+0x43d>
	}
	t->pp_ref += 1;
  8004207bcd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207bd1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207bd5:	8d 50 01             	lea    0x1(%rax),%edx
  8004207bd8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207bdc:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_b = page2kva(t);
  8004207be0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207be4:	48 89 c7             	mov    %rax,%rdi
  8004207be7:	48 b8 fa 73 20 04 80 	movabs $0x80042073fa,%rax
  8004207bee:	00 00 00 
  8004207bf1:	ff d0                	callq  *%rax
  8004207bf3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207bf7:	48 89 82 40 01 00 00 	mov    %rax,0x140(%rdx)

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207bfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c02:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207c08:	05 00 10 00 00       	add    $0x1000,%eax
  8004207c0d:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207c12:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207c15:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207c19:	7f 07                	jg     8004207c22 <env_guest_alloc+0x369>
		generation = 1 << ENVGENSHIFT;
  8004207c1b:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207c22:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207c26:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  8004207c2d:	00 00 00 
  8004207c30:	48 8b 00             	mov    (%rax),%rax
  8004207c33:	48 89 d1             	mov    %rdx,%rcx
  8004207c36:	48 29 c1             	sub    %rax,%rcx
  8004207c39:	48 89 c8             	mov    %rcx,%rax
  8004207c3c:	48 89 c2             	mov    %rax,%rdx
  8004207c3f:	48 c1 fa 05          	sar    $0x5,%rdx
  8004207c43:	48 b8 a3 8b 2e ba e8 	movabs $0x2e8ba2e8ba2e8ba3,%rax
  8004207c4a:	a2 8b 2e 
  8004207c4d:	48 0f af c2          	imul   %rdx,%rax
  8004207c51:	89 c2                	mov    %eax,%edx
  8004207c53:	0b 55 fc             	or     -0x4(%rbp),%edx
  8004207c56:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c5a:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207c60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c64:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004207c67:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_GUEST;
  8004207c6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c71:	c7 80 d0 00 00 00 03 	movl   $0x3,0xd0(%rax)
  8004207c78:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207c7b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c7f:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207c86:	00 00 00 
	e->env_runs = 0;
  8004207c89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c8d:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207c94:	00 00 00 

	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207c97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c9b:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207ca0:	be 00 00 00 00       	mov    $0x0,%esi
  8004207ca5:	48 89 c7             	mov    %rax,%rdi
  8004207ca8:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004207caf:	00 00 00 
  8004207cb2:	ff d0                	callq  *%rax

	e->env_pgfault_upcall = 0;
  8004207cb4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cb8:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207cbf:	00 00 00 00 
	e->env_ipc_recving = 0;
  8004207cc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cc7:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207cce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cd2:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207cd9:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  8004207ce0:	00 00 00 
  8004207ce3:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207ce6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207cea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207cee:	48 89 10             	mov    %rdx,(%rax)

	return 0;
  8004207cf1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207cf6:	c9                   	leaveq 
  8004207cf7:	c3                   	retq   

0000008004207cf8 <env_guest_free>:

void env_guest_free(struct Env *e) {
  8004207cf8:	55                   	push   %rbp
  8004207cf9:	48 89 e5             	mov    %rsp,%rbp
  8004207cfc:	53                   	push   %rbx
  8004207cfd:	48 83 ec 38          	sub    $0x38,%rsp
  8004207d01:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	// Free the VMCS.
	page_decref(pa2page(PADDR(e->env_vmxinfo.vmcs)));
  8004207d05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207d09:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  8004207d10:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004207d14:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004207d1b:	00 00 00 
  8004207d1e:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004207d22:	77 32                	ja     8004207d56 <env_guest_free+0x5e>
  8004207d24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d28:	48 89 c1             	mov    %rax,%rcx
  8004207d2b:	48 ba 58 d6 21 04 80 	movabs $0x800421d658,%rdx
  8004207d32:	00 00 00 
  8004207d35:	be 3a 01 00 00       	mov    $0x13a,%esi
  8004207d3a:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  8004207d41:	00 00 00 
  8004207d44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d49:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207d50:	00 00 00 
  8004207d53:	41 ff d0             	callq  *%r8
  8004207d56:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004207d5d:	ff ff ff 
  8004207d60:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004207d64:	48 89 c7             	mov    %rax,%rdi
  8004207d67:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004207d6e:	00 00 00 
  8004207d71:	ff d0                	callq  *%rax
  8004207d73:	48 89 c7             	mov    %rax,%rdi
  8004207d76:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207d7d:	00 00 00 
  8004207d80:	ff d0                	callq  *%rax
	// Free msr load/store area.
	page_decref(pa2page(PADDR(e->env_vmxinfo.msr_host_area)));
  8004207d82:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207d86:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  8004207d8d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207d91:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004207d98:	00 00 00 
  8004207d9b:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004207d9f:	77 32                	ja     8004207dd3 <env_guest_free+0xdb>
  8004207da1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207da5:	48 89 c1             	mov    %rax,%rcx
  8004207da8:	48 ba 58 d6 21 04 80 	movabs $0x800421d658,%rdx
  8004207daf:	00 00 00 
  8004207db2:	be 3c 01 00 00       	mov    $0x13c,%esi
  8004207db7:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  8004207dbe:	00 00 00 
  8004207dc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207dc6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207dcd:	00 00 00 
  8004207dd0:	41 ff d0             	callq  *%r8
  8004207dd3:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004207dda:	ff ff ff 
  8004207ddd:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004207de1:	48 89 c7             	mov    %rax,%rdi
  8004207de4:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004207deb:	00 00 00 
  8004207dee:	ff d0                	callq  *%rax
  8004207df0:	48 89 c7             	mov    %rax,%rdi
  8004207df3:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207dfa:	00 00 00 
  8004207dfd:	ff d0                	callq  *%rax
	// Free IO bitmaps page.
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_a)));
  8004207dff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207e03:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  8004207e0a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207e0e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004207e15:	00 00 00 
  8004207e18:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004207e1c:	77 32                	ja     8004207e50 <env_guest_free+0x158>
  8004207e1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207e22:	48 89 c1             	mov    %rax,%rcx
  8004207e25:	48 ba 58 d6 21 04 80 	movabs $0x800421d658,%rdx
  8004207e2c:	00 00 00 
  8004207e2f:	be 3e 01 00 00       	mov    $0x13e,%esi
  8004207e34:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  8004207e3b:	00 00 00 
  8004207e3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e43:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207e4a:	00 00 00 
  8004207e4d:	41 ff d0             	callq  *%r8
  8004207e50:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004207e57:	ff ff ff 
  8004207e5a:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004207e5e:	48 89 c7             	mov    %rax,%rdi
  8004207e61:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004207e68:	00 00 00 
  8004207e6b:	ff d0                	callq  *%rax
  8004207e6d:	48 89 c7             	mov    %rax,%rdi
  8004207e70:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207e77:	00 00 00 
  8004207e7a:	ff d0                	callq  *%rax
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_b)));
  8004207e7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207e80:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  8004207e87:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004207e8b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004207e92:	00 00 00 
  8004207e95:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004207e99:	77 32                	ja     8004207ecd <env_guest_free+0x1d5>
  8004207e9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e9f:	48 89 c1             	mov    %rax,%rcx
  8004207ea2:	48 ba 58 d6 21 04 80 	movabs $0x800421d658,%rdx
  8004207ea9:	00 00 00 
  8004207eac:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004207eb1:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  8004207eb8:	00 00 00 
  8004207ebb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ec0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004207ec7:	00 00 00 
  8004207eca:	41 ff d0             	callq  *%r8
  8004207ecd:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004207ed4:	ff ff ff 
  8004207ed7:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004207edb:	48 89 c7             	mov    %rax,%rdi
  8004207ede:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004207ee5:	00 00 00 
  8004207ee8:	ff d0                	callq  *%rax
  8004207eea:	48 89 c7             	mov    %rax,%rdi
  8004207eed:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207ef4:	00 00 00 
  8004207ef7:	ff d0                	callq  *%rax
    
	// Free the host pages that were allocated for the guest and 
	// the EPT tables itself.
	free_guest_mem(e->env_pml4e);
  8004207ef9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207efd:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207f04:	48 89 c7             	mov    %rax,%rdi
  8004207f07:	48 b8 9f 8b 21 04 80 	movabs $0x8004218b9f,%rax
  8004207f0e:	00 00 00 
  8004207f11:	ff d0                	callq  *%rax

	// Free the EPT PML4 page.
	page_decref(pa2page(e->env_cr3));
  8004207f13:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f17:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207f1e:	48 89 c7             	mov    %rax,%rdi
  8004207f21:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004207f28:	00 00 00 
  8004207f2b:	ff d0                	callq  *%rax
  8004207f2d:	48 89 c7             	mov    %rax,%rdi
  8004207f30:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004207f37:	00 00 00 
  8004207f3a:	ff d0                	callq  *%rax
	e->env_pml4e = 0;
  8004207f3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f40:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004207f47:	00 00 00 00 
	e->env_cr3 = 0;
  8004207f4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f4f:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004207f56:	00 00 00 00 

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004207f5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f5e:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004207f65:	00 00 00 
	e->env_link = env_free_list;
  8004207f68:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  8004207f6f:	00 00 00 
  8004207f72:	48 8b 10             	mov    (%rax),%rdx
  8004207f75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f79:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004207f80:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  8004207f87:	00 00 00 
  8004207f8a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004207f8e:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] free vmx guest env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004207f91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f95:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004207f9b:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004207fa2:	00 00 00 
  8004207fa5:	ff d0                	callq  *%rax
  8004207fa7:	48 98                	cltq   
  8004207fa9:	48 c1 e0 03          	shl    $0x3,%rax
  8004207fad:	48 89 c2             	mov    %rax,%rdx
  8004207fb0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207fb4:	48 01 c2             	add    %rax,%rdx
  8004207fb7:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004207fbe:	00 00 00 
  8004207fc1:	48 01 d0             	add    %rdx,%rax
  8004207fc4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207fc8:	48 85 c0             	test   %rax,%rax
  8004207fcb:	74 35                	je     8004208002 <env_guest_free+0x30a>
  8004207fcd:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004207fd4:	00 00 00 
  8004207fd7:	ff d0                	callq  *%rax
  8004207fd9:	48 98                	cltq   
  8004207fdb:	48 c1 e0 03          	shl    $0x3,%rax
  8004207fdf:	48 89 c2             	mov    %rax,%rdx
  8004207fe2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207fe6:	48 01 c2             	add    %rax,%rdx
  8004207fe9:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004207ff0:	00 00 00 
  8004207ff3:	48 01 d0             	add    %rdx,%rax
  8004207ff6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207ffa:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208000:	eb 05                	jmp    8004208007 <env_guest_free+0x30f>
  8004208002:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208007:	89 da                	mov    %ebx,%edx
  8004208009:	89 c6                	mov    %eax,%esi
  800420800b:	48 bf 88 d6 21 04 80 	movabs $0x800421d688,%rdi
  8004208012:	00 00 00 
  8004208015:	b8 00 00 00 00       	mov    $0x0,%eax
  800420801a:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  8004208021:	00 00 00 
  8004208024:	ff d1                	callq  *%rcx
}
  8004208026:	48 83 c4 38          	add    $0x38,%rsp
  800420802a:	5b                   	pop    %rbx
  800420802b:	5d                   	pop    %rbp
  800420802c:	c3                   	retq   

000000800420802d <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  800420802d:	55                   	push   %rbp
  800420802e:	48 89 e5             	mov    %rsp,%rbp
  8004208031:	48 83 ec 30          	sub    $0x30,%rsp
  8004208035:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208039:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  800420803c:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  8004208043:	00 00 00 
  8004208046:	48 8b 00             	mov    (%rax),%rax
  8004208049:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420804d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004208052:	75 0a                	jne    800420805e <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004208054:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004208059:	e9 81 01 00 00       	jmpq   80042081df <env_alloc+0x1b2>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  800420805e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208062:	48 89 c7             	mov    %rax,%rdi
  8004208065:	48 b8 b0 77 20 04 80 	movabs $0x80042077b0,%rax
  800420806c:	00 00 00 
  800420806f:	ff d0                	callq  *%rax
  8004208071:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004208074:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004208078:	79 08                	jns    8004208082 <env_alloc+0x55>
		return r;
  800420807a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420807d:	e9 5d 01 00 00       	jmpq   80042081df <env_alloc+0x1b2>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004208082:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208086:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420808c:	05 00 10 00 00       	add    $0x1000,%eax
  8004208091:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004208096:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208099:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420809d:	7f 07                	jg     80042080a6 <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  800420809f:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  80042080a6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042080aa:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  80042080b1:	00 00 00 
  80042080b4:	48 8b 00             	mov    (%rax),%rax
  80042080b7:	48 89 d1             	mov    %rdx,%rcx
  80042080ba:	48 29 c1             	sub    %rax,%rcx
  80042080bd:	48 89 c8             	mov    %rcx,%rax
  80042080c0:	48 89 c2             	mov    %rax,%rdx
  80042080c3:	48 c1 fa 05          	sar    $0x5,%rdx
  80042080c7:	48 b8 a3 8b 2e ba e8 	movabs $0x2e8ba2e8ba2e8ba3,%rax
  80042080ce:	a2 8b 2e 
  80042080d1:	48 0f af c2          	imul   %rdx,%rax
  80042080d5:	89 c2                	mov    %eax,%edx
  80042080d7:	0b 55 fc             	or     -0x4(%rbp),%edx
  80042080da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080de:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  80042080e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080e8:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042080eb:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  80042080f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080f5:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  80042080fc:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  80042080ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208103:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420810a:	00 00 00 
	e->env_runs = 0;
  800420810d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208111:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004208118:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  800420811b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420811f:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208124:	be 00 00 00 00       	mov    $0x0,%esi
  8004208129:	48 89 c7             	mov    %rax,%rdi
  800420812c:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004208133:	00 00 00 
  8004208136:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004208138:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420813c:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004208143:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004208145:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208149:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  800420814f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208153:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  800420815a:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  800420815c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208160:	c7 80 b0 00 00 00 00 	movl   $0xef7fe000,0xb0(%rax)
  8004208167:	e0 7f ef 
  800420816a:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%rax)
  8004208171:	00 00 00 
	e->env_tf.tf_cs = GD_UT | 3;
  8004208174:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208178:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  800420817f:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF; 
  8004208181:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208185:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420818c:	48 89 c2             	mov    %rax,%rdx
  800420818f:	80 ce 02             	or     $0x2,%dh
  8004208192:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208196:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  800420819d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081a1:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  80042081a8:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  80042081ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081b0:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  80042081b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081bb:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  80042081c2:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  80042081c9:	00 00 00 
  80042081cc:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  80042081cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042081d3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042081d7:	48 89 10             	mov    %rdx,(%rax)

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  80042081da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042081df:	c9                   	leaveq 
  80042081e0:	c3                   	retq   

00000080042081e1 <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  80042081e1:	55                   	push   %rbp
  80042081e2:	48 89 e5             	mov    %rsp,%rbp
  80042081e5:	48 83 ec 50          	sub    $0x50,%rsp
  80042081e9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042081ed:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042081f1:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	size_t start = ROUNDDOWN((uint64_t)va, PGSIZE);
  80042081f5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042081f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042081fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208201:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208207:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t end = ROUNDUP((uint64_t)(va+len), PGSIZE);
  800420820b:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004208212:	00 
  8004208213:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208217:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420821b:	48 01 d0             	add    %rdx,%rax
  800420821e:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004208222:	48 83 e8 01          	sub    $0x1,%rax
  8004208226:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420822a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420822e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004208233:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004208237:	48 89 d0             	mov    %rdx,%rax
  800420823a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420823e:	48 89 d1             	mov    %rdx,%rcx
  8004208241:	48 29 c1             	sub    %rax,%rcx
  8004208244:	48 89 c8             	mov    %rcx,%rax
  8004208247:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	while (start < end) {
  800420824b:	e9 a3 00 00 00       	jmpq   80042082f3 <region_alloc+0x112>
		struct PageInfo* p = page_alloc(0);
  8004208250:	bf 00 00 00 00       	mov    $0x0,%edi
  8004208255:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420825c:	00 00 00 
  800420825f:	ff d0                	callq  *%rax
  8004208261:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!p)
  8004208265:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420826a:	75 2a                	jne    8004208296 <region_alloc+0xb5>
			panic("No memory available for allocation to environment");
  800420826c:	48 ba a8 d6 21 04 80 	movabs $0x800421d6a8,%rdx
  8004208273:	00 00 00 
  8004208276:	be b0 01 00 00       	mov    $0x1b0,%esi
  800420827b:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  8004208282:	00 00 00 
  8004208285:	b8 00 00 00 00       	mov    $0x0,%eax
  800420828a:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  8004208291:	00 00 00 
  8004208294:	ff d1                	callq  *%rcx
		if(page_insert(e->env_pml4e, p, (void*) start, PTE_U|PTE_P|PTE_W) < 0)
  8004208296:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420829a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420829e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042082a5:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042082a9:	b9 07 00 00 00       	mov    $0x7,%ecx
  80042082ae:	48 89 c7             	mov    %rax,%rdi
  80042082b1:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  80042082b8:	00 00 00 
  80042082bb:	ff d0                	callq  *%rax
  80042082bd:	85 c0                	test   %eax,%eax
  80042082bf:	79 2a                	jns    80042082eb <region_alloc+0x10a>
			panic("CAnnot allocate any memory for page directory allocation");
  80042082c1:	48 ba e0 d6 21 04 80 	movabs $0x800421d6e0,%rdx
  80042082c8:	00 00 00 
  80042082cb:	be b2 01 00 00       	mov    $0x1b2,%esi
  80042082d0:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  80042082d7:	00 00 00 
  80042082da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082df:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  80042082e6:	00 00 00 
  80042082e9:	ff d1                	callq  *%rcx
		start += PGSIZE;
  80042082eb:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042082f2:	00 
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	size_t start = ROUNDDOWN((uint64_t)va, PGSIZE);
	size_t end = ROUNDUP((uint64_t)(va+len), PGSIZE);
	while (start < end) {
  80042082f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042082f7:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042082fb:	0f 82 4f ff ff ff    	jb     8004208250 <region_alloc+0x6f>
			panic("No memory available for allocation to environment");
		if(page_insert(e->env_pml4e, p, (void*) start, PTE_U|PTE_P|PTE_W) < 0)
			panic("CAnnot allocate any memory for page directory allocation");
		start += PGSIZE;
	}
}
  8004208301:	c9                   	leaveq 
  8004208302:	c3                   	retq   

0000008004208303 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004208303:	55                   	push   %rbp
  8004208304:	48 89 e5             	mov    %rsp,%rbp
  8004208307:	48 83 ec 30          	sub    $0x30,%rsp
  800420830b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420830f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	//  this function?
	//
	//  You must also do something with the program's entry point,
	//  to make sure that the environment starts executing there.
	//  What?  (See env_run() and env_pop_tf() below.)
	struct Elf *elfhdr = (struct Elf*)binary;
  8004208313:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208317:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	struct Proghdr *ph, *eph;
    // is this a valid ELF?
    if (elfhdr->e_magic != ELF_MAGIC)
  800420831b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420831f:	8b 00                	mov    (%rax),%eax
  8004208321:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004208326:	74 2a                	je     8004208352 <load_icode+0x4f>
        panic("Bad ELF");
  8004208328:	48 ba 19 d7 21 04 80 	movabs $0x800421d719,%rdx
  800420832f:	00 00 00 
  8004208332:	be ef 01 00 00       	mov    $0x1ef,%esi
  8004208337:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  800420833e:	00 00 00 
  8004208341:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208346:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800420834d:	00 00 00 
  8004208350:	ff d1                	callq  *%rcx

	lcr3(e->env_cr3);
  8004208352:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208356:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800420835d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004208361:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208365:	0f 22 d8             	mov    %rax,%cr3
    // load each program segment (ignores ph flags)
    // test whether this has written to 0x100000
    ph = (struct Proghdr *) ((uint8_t *) elfhdr + elfhdr->e_phoff);
  8004208368:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420836c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208370:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004208374:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    eph = ph + elfhdr->e_phnum;
  8004208378:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420837c:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004208380:	0f b7 c0             	movzwl %ax,%eax
  8004208383:	48 c1 e0 03          	shl    $0x3,%rax
  8004208387:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420838e:	00 
  800420838f:	48 89 d1             	mov    %rdx,%rcx
  8004208392:	48 29 c1             	sub    %rax,%rcx
  8004208395:	48 89 c8             	mov    %rcx,%rax
  8004208398:	48 03 45 f8          	add    -0x8(%rbp),%rax
  800420839c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    for (; ph < eph; ph++) {
  80042083a0:	e9 a8 00 00 00       	jmpq   800420844d <load_icode+0x14a>
		if (ph->p_type == ELF_PROG_LOAD) {
  80042083a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083a9:	8b 00                	mov    (%rax),%eax
  80042083ab:	83 f8 01             	cmp    $0x1,%eax
  80042083ae:	0f 85 94 00 00 00    	jne    8004208448 <load_icode+0x145>
			region_alloc(e,(void*)ph->p_va, ph->p_memsz);
  80042083b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083b8:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042083bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083c0:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042083c4:	48 89 c1             	mov    %rax,%rcx
  80042083c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042083cb:	48 89 ce             	mov    %rcx,%rsi
  80042083ce:	48 89 c7             	mov    %rax,%rdi
  80042083d1:	48 b8 e1 81 20 04 80 	movabs $0x80042081e1,%rax
  80042083d8:	00 00 00 
  80042083db:	ff d0                	callq  *%rax
			memcpy((void*)ph->p_va,(void*)(binary+ph->p_offset), ph->p_filesz);
  80042083dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083e1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042083e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042083ed:	48 89 c1             	mov    %rax,%rcx
  80042083f0:	48 03 4d d0          	add    -0x30(%rbp),%rcx
  80042083f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042083f8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042083fc:	48 89 ce             	mov    %rcx,%rsi
  80042083ff:	48 89 c7             	mov    %rax,%rdi
  8004208402:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  8004208409:	00 00 00 
  800420840c:	ff d0                	callq  *%rax
			memset((void*)(ph->p_va+ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
  800420840e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208412:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208416:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420841a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420841e:	48 29 c2             	sub    %rax,%rdx
  8004208421:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208425:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004208429:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420842d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004208431:	48 01 c8             	add    %rcx,%rax
  8004208434:	be 00 00 00 00       	mov    $0x0,%esi
  8004208439:	48 89 c7             	mov    %rax,%rdi
  800420843c:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004208443:	00 00 00 
  8004208446:	ff d0                	callq  *%rax
	lcr3(e->env_cr3);
    // load each program segment (ignores ph flags)
    // test whether this has written to 0x100000
    ph = (struct Proghdr *) ((uint8_t *) elfhdr + elfhdr->e_phoff);
    eph = ph + elfhdr->e_phnum;
    for (; ph < eph; ph++) {
  8004208448:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  800420844d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208451:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208455:	0f 82 4a ff ff ff    	jb     80042083a5 <load_icode+0xa2>
			memcpy((void*)ph->p_va,(void*)(binary+ph->p_offset), ph->p_filesz);
			memset((void*)(ph->p_va+ph->p_filesz), 0, ph->p_memsz-ph->p_filesz);
		}
	}

	e->env_tf.tf_rip = elfhdr->e_entry;	
  800420845b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420845f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208463:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208467:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	// LAB 3: Your code here
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.
	region_alloc(e, (void*)(USTACKTOP-PGSIZE), PGSIZE);
  800420846e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208472:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208477:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  800420847c:	48 89 c7             	mov    %rax,%rdi
  800420847f:	48 b8 e1 81 20 04 80 	movabs $0x80042081e1,%rax
  8004208486:	00 00 00 
  8004208489:	ff d0                	callq  *%rax
	// LAB 3: Your code here.
	e->elf = binary;
  800420848b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420848f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208493:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  800420849a:	c9                   	leaveq 
  800420849b:	c3                   	retq   

000000800420849c <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  800420849c:	55                   	push   %rbp
  800420849d:	48 89 e5             	mov    %rsp,%rbp
  80042084a0:	48 83 ec 20          	sub    $0x20,%rsp
  80042084a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042084a8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.

	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
	struct Env* e;
	uint32_t r = env_alloc(&e, 0);
  80042084ab:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80042084af:	be 00 00 00 00       	mov    $0x0,%esi
  80042084b4:	48 89 c7             	mov    %rax,%rdi
  80042084b7:	48 b8 2d 80 20 04 80 	movabs $0x800420802d,%rax
  80042084be:	00 00 00 
  80042084c1:	ff d0                	callq  *%rax
  80042084c3:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(r < 0) {
		panic("env alloc: %e",r);
	}
	load_icode(e, binary);
  80042084c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042084ce:	48 89 d6             	mov    %rdx,%rsi
  80042084d1:	48 89 c7             	mov    %rax,%rdi
  80042084d4:	48 b8 03 83 20 04 80 	movabs $0x8004208303,%rax
  80042084db:	00 00 00 
  80042084de:	ff d0                	callq  *%rax
	e->env_type = type;
  80042084e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084e4:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042084e7:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS) {
  80042084ed:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042084f1:	75 19                	jne    800420850c <env_create+0x70>
		e->env_tf.tf_eflags |= FL_IOPL_MASK;
  80042084f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084f7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042084fb:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004208502:	80 ce 30             	or     $0x30,%dh
  8004208505:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	}
}
  800420850c:	c9                   	leaveq 
  800420850d:	c3                   	retq   

000000800420850e <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  800420850e:	55                   	push   %rbp
  800420850f:	48 89 e5             	mov    %rsp,%rbp
  8004208512:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004208519:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	physaddr_t pa;

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208520:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208527:	00 00 00 
  800420852a:	ff d0                	callq  *%rax
  800420852c:	48 98                	cltq   
  800420852e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208532:	48 89 c2             	mov    %rax,%rdx
  8004208535:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208539:	48 01 c2             	add    %rax,%rdx
  800420853c:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208543:	00 00 00 
  8004208546:	48 01 d0             	add    %rdx,%rax
  8004208549:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420854d:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004208554:	75 18                	jne    800420856e <env_free+0x60>
		lcr3(boot_cr3);
  8004208556:	48 b8 60 37 48 04 80 	movabs $0x8004483760,%rax
  800420855d:	00 00 00 
  8004208560:	48 8b 00             	mov    (%rax),%rax
  8004208563:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004208567:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800420856b:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  800420856e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208575:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420857c:	48 8b 00             	mov    (%rax),%rax
  800420857f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208585:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208589:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420858d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208591:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004208594:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208597:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420859e:	00 00 00 
  80042085a1:	48 8b 00             	mov    (%rax),%rax
  80042085a4:	48 39 c2             	cmp    %rax,%rdx
  80042085a7:	72 32                	jb     80042085db <env_free+0xcd>
  80042085a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042085ad:	48 89 c1             	mov    %rax,%rcx
  80042085b0:	48 ba 30 d6 21 04 80 	movabs $0x800421d630,%rdx
  80042085b7:	00 00 00 
  80042085ba:	be 35 02 00 00       	mov    $0x235,%esi
  80042085bf:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  80042085c6:	00 00 00 
  80042085c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042085ce:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042085d5:	00 00 00 
  80042085d8:	41 ff d0             	callq  *%r8
  80042085db:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042085e2:	00 00 00 
  80042085e5:	48 03 45 e0          	add    -0x20(%rbp),%rax
  80042085e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042085ed:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042085f4:	00 
  80042085f5:	e9 70 02 00 00       	jmpq   800420886a <env_free+0x35c>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  80042085fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042085fe:	48 c1 e0 03          	shl    $0x3,%rax
  8004208602:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004208606:	48 8b 00             	mov    (%rax),%rax
  8004208609:	83 e0 01             	and    $0x1,%eax
  800420860c:	48 85 c0             	test   %rax,%rax
  800420860f:	0f 84 4f 02 00 00    	je     8004208864 <env_free+0x356>
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208619:	48 c1 e0 03          	shl    $0x3,%rax
  800420861d:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004208621:	48 8b 00             	mov    (%rax),%rax
  8004208624:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420862a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420862e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208632:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208636:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208639:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420863c:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004208643:	00 00 00 
  8004208646:	48 8b 00             	mov    (%rax),%rax
  8004208649:	48 39 c2             	cmp    %rax,%rdx
  800420864c:	72 32                	jb     8004208680 <env_free+0x172>
  800420864e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208652:	48 89 c1             	mov    %rax,%rcx
  8004208655:	48 ba 30 d6 21 04 80 	movabs $0x800421d630,%rdx
  800420865c:	00 00 00 
  800420865f:	be 3d 02 00 00       	mov    $0x23d,%esi
  8004208664:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  800420866b:	00 00 00 
  800420866e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208673:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420867a:	00 00 00 
  800420867d:	41 ff d0             	callq  *%r8
  8004208680:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004208687:	00 00 00 
  800420868a:	48 03 45 c8          	add    -0x38(%rbp),%rax
  800420868e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208692:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208697:	75 07                	jne    80042086a0 <env_free+0x192>
  8004208699:	b8 04 00 00 00       	mov    $0x4,%eax
  800420869e:	eb 05                	jmp    80042086a5 <env_free+0x197>
  80042086a0:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  80042086a5:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042086a8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042086af:	00 
  80042086b0:	e9 50 01 00 00       	jmpq   8004208805 <env_free+0x2f7>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  80042086b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086b9:	48 c1 e0 03          	shl    $0x3,%rax
  80042086bd:	48 03 45 b8          	add    -0x48(%rbp),%rax
  80042086c1:	48 8b 00             	mov    (%rax),%rax
  80042086c4:	83 e0 01             	and    $0x1,%eax
  80042086c7:	48 85 c0             	test   %rax,%rax
  80042086ca:	0f 84 2f 01 00 00    	je     80042087ff <env_free+0x2f1>
				continue;
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  80042086d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042086d8:	48 03 45 b8          	add    -0x48(%rbp),%rax
  80042086dc:	48 8b 00             	mov    (%rax),%rax
  80042086df:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042086e5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  80042086e9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042086ed:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042086f1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042086f5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042086f9:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042086fc:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042086ff:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004208706:	00 00 00 
  8004208709:	48 8b 00             	mov    (%rax),%rax
  800420870c:	48 39 c2             	cmp    %rax,%rdx
  800420870f:	72 32                	jb     8004208743 <env_free+0x235>
  8004208711:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208715:	48 89 c1             	mov    %rax,%rcx
  8004208718:	48 ba 30 d6 21 04 80 	movabs $0x800421d630,%rdx
  800420871f:	00 00 00 
  8004208722:	be 47 02 00 00       	mov    $0x247,%esi
  8004208727:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  800420872e:	00 00 00 
  8004208731:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208736:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420873d:	00 00 00 
  8004208740:	41 ff d0             	callq  *%r8
  8004208743:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420874a:	00 00 00 
  800420874d:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004208751:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208755:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420875c:	00 
  800420875d:	eb 5f                	jmp    80042087be <env_free+0x2b0>
				if (pt[pteno] & PTE_P){
  800420875f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208763:	48 c1 e0 03          	shl    $0x3,%rax
  8004208767:	48 03 45 90          	add    -0x70(%rbp),%rax
  800420876b:	48 8b 00             	mov    (%rax),%rax
  800420876e:	83 e0 01             	and    $0x1,%eax
  8004208771:	84 c0                	test   %al,%al
  8004208773:	74 44                	je     80042087b9 <env_free+0x2ab>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208775:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208779:	48 89 c2             	mov    %rax,%rdx
  800420877c:	48 c1 e2 1e          	shl    $0x1e,%rdx
  8004208780:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208784:	48 c1 e0 15          	shl    $0x15,%rax
  8004208788:	48 09 c2             	or     %rax,%rdx
  800420878b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420878f:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208793:	48 09 d0             	or     %rdx,%rax
  8004208796:	48 89 c2             	mov    %rax,%rdx
  8004208799:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042087a0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042087a7:	48 89 d6             	mov    %rdx,%rsi
  80042087aa:	48 89 c7             	mov    %rax,%rdi
  80042087ad:	48 b8 fc 35 20 04 80 	movabs $0x80042035fc,%rax
  80042087b4:	00 00 00 
  80042087b7:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042087b9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042087be:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  80042087c5:	00 
  80042087c6:	76 97                	jbe    800420875f <env_free+0x251>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  80042087c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042087d0:	48 03 45 b8          	add    -0x48(%rbp),%rax
  80042087d4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  80042087db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042087df:	48 89 c7             	mov    %rax,%rdi
  80042087e2:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  80042087e9:	00 00 00 
  80042087ec:	ff d0                	callq  *%rax
  80042087ee:	48 89 c7             	mov    %rax,%rdi
  80042087f1:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042087f8:	00 00 00 
  80042087fb:	ff d0                	callq  *%rax
  80042087fd:	eb 01                	jmp    8004208800 <env_free+0x2f2>
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
				continue;
  80042087ff:	90                   	nop
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208800:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208805:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208808:	48 98                	cltq   
  800420880a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420880e:	0f 87 a1 fe ff ff    	ja     80042086b5 <env_free+0x1a7>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208818:	48 c1 e0 03          	shl    $0x3,%rax
  800420881c:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004208820:	48 8b 00             	mov    (%rax),%rax
  8004208823:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208829:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  800420882d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208831:	48 c1 e0 03          	shl    $0x3,%rax
  8004208835:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004208839:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004208840:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208844:	48 89 c7             	mov    %rax,%rdi
  8004208847:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  800420884e:	00 00 00 
  8004208851:	ff d0                	callq  *%rax
  8004208853:	48 89 c7             	mov    %rax,%rdi
  8004208856:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  800420885d:	00 00 00 
  8004208860:	ff d0                	callq  *%rax
  8004208862:	eb 01                	jmp    8004208865 <env_free+0x357>
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
  8004208864:	90                   	nop
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208865:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420886a:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  800420886f:	0f 86 85 fd ff ff    	jbe    80042085fa <env_free+0xec>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208875:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420887c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208883:	48 8b 00             	mov    (%rax),%rax
  8004208886:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420888c:	48 89 c7             	mov    %rax,%rdi
  800420888f:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004208896:	00 00 00 
  8004208899:	ff d0                	callq  *%rax
  800420889b:	48 89 c7             	mov    %rax,%rdi
  800420889e:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042088a5:	00 00 00 
  80042088a8:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  80042088aa:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042088b1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042088b8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  80042088bf:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042088c6:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042088cd:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  80042088d1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042088d8:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  80042088df:	00 00 00 00 
	e->env_cr3 = 0;
  80042088e3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042088ea:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  80042088f1:	00 00 00 00 
	page_decref(pa2page(pa));
  80042088f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042088f9:	48 89 c7             	mov    %rax,%rdi
  80042088fc:	48 b8 89 73 20 04 80 	movabs $0x8004207389,%rax
  8004208903:	00 00 00 
  8004208906:	ff d0                	callq  *%rax
  8004208908:	48 89 c7             	mov    %rax,%rdi
  800420890b:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004208912:	00 00 00 
  8004208915:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208917:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420891e:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208925:	00 00 00 
	e->env_link = env_free_list;
  8004208928:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  800420892f:	00 00 00 
  8004208932:	48 8b 10             	mov    (%rax),%rdx
  8004208935:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420893c:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208943:	48 b8 58 22 48 04 80 	movabs $0x8004482258,%rax
  800420894a:	00 00 00 
  800420894d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004208954:	48 89 10             	mov    %rdx,(%rax)
}
  8004208957:	c9                   	leaveq 
  8004208958:	c3                   	retq   

0000008004208959 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004208959:	55                   	push   %rbp
  800420895a:	48 89 e5             	mov    %rsp,%rbp
  800420895d:	48 83 ec 10          	sub    $0x10,%rsp
  8004208961:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208965:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208969:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420896f:	83 f8 03             	cmp    $0x3,%eax
  8004208972:	75 46                	jne    80042089ba <env_destroy+0x61>
  8004208974:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420897b:	00 00 00 
  800420897e:	ff d0                	callq  *%rax
  8004208980:	48 98                	cltq   
  8004208982:	48 c1 e0 03          	shl    $0x3,%rax
  8004208986:	48 89 c2             	mov    %rax,%rdx
  8004208989:	48 c1 e2 04          	shl    $0x4,%rdx
  800420898d:	48 01 c2             	add    %rax,%rdx
  8004208990:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208997:	00 00 00 
  800420899a:	48 01 d0             	add    %rdx,%rax
  800420899d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042089a1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042089a5:	74 13                	je     80042089ba <env_destroy+0x61>
		e->env_status = ENV_DYING;
  80042089a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042089ab:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  80042089b2:	00 00 00 
		return;
  80042089b5:	e9 a7 00 00 00       	jmpq   8004208a61 <env_destroy+0x108>
	}

	if(e->env_type == ENV_TYPE_GUEST) 
  80042089ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042089be:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80042089c4:	83 f8 03             	cmp    $0x3,%eax
  80042089c7:	75 15                	jne    80042089de <env_destroy+0x85>
		env_guest_free(e);
  80042089c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042089cd:	48 89 c7             	mov    %rax,%rdi
  80042089d0:	48 b8 f8 7c 20 04 80 	movabs $0x8004207cf8,%rax
  80042089d7:	00 00 00 
  80042089da:	ff d0                	callq  *%rax
  80042089dc:	eb 13                	jmp    80042089f1 <env_destroy+0x98>
	else
		env_free(e);
  80042089de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042089e2:	48 89 c7             	mov    %rax,%rdi
  80042089e5:	48 b8 0e 85 20 04 80 	movabs $0x800420850e,%rax
  80042089ec:	00 00 00 
  80042089ef:	ff d0                	callq  *%rax

	if (curenv == e) {
  80042089f1:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042089f8:	00 00 00 
  80042089fb:	ff d0                	callq  *%rax
  80042089fd:	48 98                	cltq   
  80042089ff:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a03:	48 89 c2             	mov    %rax,%rdx
  8004208a06:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a0a:	48 01 c2             	add    %rax,%rdx
  8004208a0d:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208a14:	00 00 00 
  8004208a17:	48 01 d0             	add    %rdx,%rax
  8004208a1a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208a1e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208a22:	75 3d                	jne    8004208a61 <env_destroy+0x108>
		curenv = NULL;
  8004208a24:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208a2b:	00 00 00 
  8004208a2e:	ff d0                	callq  *%rax
  8004208a30:	48 98                	cltq   
  8004208a32:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a36:	48 89 c2             	mov    %rax,%rdx
  8004208a39:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a3d:	48 01 c2             	add    %rax,%rdx
  8004208a40:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208a47:	00 00 00 
  8004208a4a:	48 01 d0             	add    %rdx,%rax
  8004208a4d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004208a54:	00 
		sched_yield();
  8004208a55:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  8004208a5c:	00 00 00 
  8004208a5f:	ff d0                	callq  *%rax
	}
}
  8004208a61:	c9                   	leaveq 
  8004208a62:	c3                   	retq   

0000008004208a63 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004208a63:	55                   	push   %rbp
  8004208a64:	48 89 e5             	mov    %rsp,%rbp
  8004208a67:	53                   	push   %rbx
  8004208a68:	48 83 ec 18          	sub    $0x18,%rsp
  8004208a6c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208a70:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208a77:	00 00 00 
  8004208a7a:	ff d0                	callq  *%rax
  8004208a7c:	48 98                	cltq   
  8004208a7e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a82:	48 89 c2             	mov    %rax,%rdx
  8004208a85:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208a89:	48 01 c2             	add    %rax,%rdx
  8004208a8c:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208a93:	00 00 00 
  8004208a96:	48 01 d0             	add    %rdx,%rax
  8004208a99:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004208a9d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208aa4:	00 00 00 
  8004208aa7:	ff d0                	callq  *%rax
  8004208aa9:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  8004208aaf:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208ab3:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208ab7:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208abc:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208ac1:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208ac6:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208acb:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208ad0:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208ad5:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208ada:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208adf:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208ae4:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208ae9:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208aee:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208af3:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208af8:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208afd:	48 83 c4 78          	add    $0x78,%rsp
  8004208b01:	8e 04 24             	mov    (%rsp),%es
  8004208b04:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208b08:	48 83 c4 10          	add    $0x10,%rsp
  8004208b0c:	48 83 c4 10          	add    $0x10,%rsp
  8004208b10:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208b12:	48 ba 21 d7 21 04 80 	movabs $0x800421d721,%rdx
  8004208b19:	00 00 00 
  8004208b1c:	be 97 02 00 00       	mov    $0x297,%esi
  8004208b21:	48 bf 7c d6 21 04 80 	movabs $0x800421d67c,%rdi
  8004208b28:	00 00 00 
  8004208b2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208b30:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  8004208b37:	00 00 00 
  8004208b3a:	ff d1                	callq  *%rcx

0000008004208b3c <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004208b3c:	55                   	push   %rbp
  8004208b3d:	48 89 e5             	mov    %rsp,%rbp
  8004208b40:	48 83 ec 20          	sub    $0x20,%rsp
  8004208b44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// Hint: This function loads the new environment's state from
	//	e->env_tf.  Go back through the code you wrote above
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.
	if (curenv && curenv->env_status == ENV_RUNNING) {
  8004208b48:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208b4f:	00 00 00 
  8004208b52:	ff d0                	callq  *%rax
  8004208b54:	48 98                	cltq   
  8004208b56:	48 c1 e0 03          	shl    $0x3,%rax
  8004208b5a:	48 89 c2             	mov    %rax,%rdx
  8004208b5d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208b61:	48 01 c2             	add    %rax,%rdx
  8004208b64:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208b6b:	00 00 00 
  8004208b6e:	48 01 d0             	add    %rdx,%rax
  8004208b71:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208b75:	48 85 c0             	test   %rax,%rax
  8004208b78:	74 6f                	je     8004208be9 <env_run+0xad>
  8004208b7a:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208b81:	00 00 00 
  8004208b84:	ff d0                	callq  *%rax
  8004208b86:	48 98                	cltq   
  8004208b88:	48 c1 e0 03          	shl    $0x3,%rax
  8004208b8c:	48 89 c2             	mov    %rax,%rdx
  8004208b8f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208b93:	48 01 c2             	add    %rax,%rdx
  8004208b96:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208b9d:	00 00 00 
  8004208ba0:	48 01 d0             	add    %rdx,%rax
  8004208ba3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208ba7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208bad:	83 f8 03             	cmp    $0x3,%eax
  8004208bb0:	75 37                	jne    8004208be9 <env_run+0xad>
		curenv->env_status = ENV_RUNNABLE;
  8004208bb2:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208bb9:	00 00 00 
  8004208bbc:	ff d0                	callq  *%rax
  8004208bbe:	48 98                	cltq   
  8004208bc0:	48 c1 e0 03          	shl    $0x3,%rax
  8004208bc4:	48 89 c2             	mov    %rax,%rdx
  8004208bc7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208bcb:	48 01 c2             	add    %rax,%rdx
  8004208bce:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208bd5:	00 00 00 
  8004208bd8:	48 01 d0             	add    %rdx,%rax
  8004208bdb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208bdf:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208be6:	00 00 00 
	}
	curenv = e;
  8004208be9:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208bf0:	00 00 00 
  8004208bf3:	ff d0                	callq  *%rax
  8004208bf5:	48 98                	cltq   
  8004208bf7:	48 c1 e0 03          	shl    $0x3,%rax
  8004208bfb:	48 89 c2             	mov    %rax,%rdx
  8004208bfe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208c02:	48 01 c2             	add    %rax,%rdx
  8004208c05:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208c0c:	00 00 00 
  8004208c0f:	48 01 c2             	add    %rax,%rdx
  8004208c12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c16:	48 89 42 08          	mov    %rax,0x8(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004208c1a:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208c21:	00 00 00 
  8004208c24:	ff d0                	callq  *%rax
  8004208c26:	48 98                	cltq   
  8004208c28:	48 c1 e0 03          	shl    $0x3,%rax
  8004208c2c:	48 89 c2             	mov    %rax,%rdx
  8004208c2f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208c33:	48 01 c2             	add    %rax,%rdx
  8004208c36:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208c3d:	00 00 00 
  8004208c40:	48 01 d0             	add    %rdx,%rax
  8004208c43:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208c47:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004208c4e:	00 00 00 
	curenv->env_runs++;
  8004208c51:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208c58:	00 00 00 
  8004208c5b:	ff d0                	callq  *%rax
  8004208c5d:	48 98                	cltq   
  8004208c5f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208c63:	48 89 c2             	mov    %rax,%rdx
  8004208c66:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208c6a:	48 01 c2             	add    %rax,%rdx
  8004208c6d:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208c74:	00 00 00 
  8004208c77:	48 01 d0             	add    %rdx,%rax
  8004208c7a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208c7e:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208c84:	83 c2 01             	add    $0x1,%edx
  8004208c87:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	lcr3(curenv->env_cr3);	
  8004208c8d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004208c94:	00 00 00 
  8004208c97:	ff d0                	callq  *%rax
  8004208c99:	48 98                	cltq   
  8004208c9b:	48 c1 e0 03          	shl    $0x3,%rax
  8004208c9f:	48 89 c2             	mov    %rax,%rdx
  8004208ca2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208ca6:	48 01 c2             	add    %rax,%rdx
  8004208ca9:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004208cb0:	00 00 00 
  8004208cb3:	48 01 d0             	add    %rdx,%rax
  8004208cb6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208cba:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208cc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208cc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208cc9:	0f 22 d8             	mov    %rax,%cr3
	unlock_kernel();
  8004208ccc:	48 b8 7f 74 20 04 80 	movabs $0x800420747f,%rax
  8004208cd3:	00 00 00 
  8004208cd6:	ff d0                	callq  *%rax
	env_pop_tf(&e->env_tf);
  8004208cd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208cdc:	48 89 c7             	mov    %rax,%rdi
  8004208cdf:	48 b8 63 8a 20 04 80 	movabs $0x8004208a63,%rax
  8004208ce6:	00 00 00 
  8004208ce9:	ff d0                	callq  *%rax
	...

0000008004208cec <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208cec:	55                   	push   %rbp
  8004208ced:	48 89 e5             	mov    %rsp,%rbp
  8004208cf0:	53                   	push   %rbx
  8004208cf1:	48 83 ec 18          	sub    $0x18,%rsp
  8004208cf5:	89 7d e4             	mov    %edi,-0x1c(%rbp)
	outb(IO_RTC, reg);
  8004208cf8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208cfb:	0f b6 c0             	movzbl %al,%eax
  8004208cfe:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%rbp)
  8004208d05:	88 45 f3             	mov    %al,-0xd(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208d08:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208d0c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208d0f:	ee                   	out    %al,(%dx)
  8004208d10:	c7 45 ec 71 00 00 00 	movl   $0x71,-0x14(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208d17:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208d1a:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004208d1d:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004208d20:	ec                   	in     (%dx),%al
  8004208d21:	89 c3                	mov    %eax,%ebx
  8004208d23:	88 5d eb             	mov    %bl,-0x15(%rbp)
    return data;
  8004208d26:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
	return inb(IO_RTC+1);
  8004208d2a:	0f b6 c0             	movzbl %al,%eax
}
  8004208d2d:	48 83 c4 18          	add    $0x18,%rsp
  8004208d31:	5b                   	pop    %rbx
  8004208d32:	5d                   	pop    %rbp
  8004208d33:	c3                   	retq   

0000008004208d34 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208d34:	55                   	push   %rbp
  8004208d35:	48 89 e5             	mov    %rsp,%rbp
  8004208d38:	48 83 ec 18          	sub    $0x18,%rsp
  8004208d3c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208d3f:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208d42:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208d45:	0f b6 c0             	movzbl %al,%eax
  8004208d48:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208d4f:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208d52:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208d56:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208d59:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208d5a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208d5d:	0f b6 c0             	movzbl %al,%eax
  8004208d60:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004208d67:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208d6a:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208d6e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208d71:	ee                   	out    %al,(%dx)
}
  8004208d72:	c9                   	leaveq 
  8004208d73:	c3                   	retq   

0000008004208d74 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208d74:	55                   	push   %rbp
  8004208d75:	48 89 e5             	mov    %rsp,%rbp
  8004208d78:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208d7c:	48 b8 60 22 48 04 80 	movabs $0x8004482260,%rax
  8004208d83:	00 00 00 
  8004208d86:	c6 00 01             	movb   $0x1,(%rax)
  8004208d89:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208d90:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208d94:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208d98:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208d9b:	ee                   	out    %al,(%dx)
  8004208d9c:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208da3:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208da7:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208dab:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208dae:	ee                   	out    %al,(%dx)
  8004208daf:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208db6:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208dba:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208dbe:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208dc1:	ee                   	out    %al,(%dx)
  8004208dc2:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208dc9:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208dcd:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208dd1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208dd4:	ee                   	out    %al,(%dx)
  8004208dd5:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208ddc:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208de0:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208de4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208de7:	ee                   	out    %al,(%dx)
  8004208de8:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208def:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208df3:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208df7:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208dfa:	ee                   	out    %al,(%dx)
  8004208dfb:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208e02:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208e06:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208e0a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208e0d:	ee                   	out    %al,(%dx)
  8004208e0e:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208e15:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208e19:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208e1d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208e20:	ee                   	out    %al,(%dx)
  8004208e21:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004208e28:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208e2c:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208e30:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208e33:	ee                   	out    %al,(%dx)
  8004208e34:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004208e3b:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004208e3f:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004208e43:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208e46:	ee                   	out    %al,(%dx)
  8004208e47:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004208e4e:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004208e52:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004208e56:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004208e59:	ee                   	out    %al,(%dx)
  8004208e5a:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208e61:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004208e65:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004208e69:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004208e6c:	ee                   	out    %al,(%dx)
  8004208e6d:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004208e74:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004208e78:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004208e7c:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208e7f:	ee                   	out    %al,(%dx)
  8004208e80:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004208e87:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208e8b:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208e8f:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208e92:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208e93:	48 b8 04 06 23 04 80 	movabs $0x8004230604,%rax
  8004208e9a:	00 00 00 
  8004208e9d:	0f b7 00             	movzwl (%rax),%eax
  8004208ea0:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208ea4:	74 1e                	je     8004208ec4 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208ea6:	48 b8 04 06 23 04 80 	movabs $0x8004230604,%rax
  8004208ead:	00 00 00 
  8004208eb0:	0f b7 00             	movzwl (%rax),%eax
  8004208eb3:	0f b7 c0             	movzwl %ax,%eax
  8004208eb6:	89 c7                	mov    %eax,%edi
  8004208eb8:	48 b8 c6 8e 20 04 80 	movabs $0x8004208ec6,%rax
  8004208ebf:	00 00 00 
  8004208ec2:	ff d0                	callq  *%rax
}
  8004208ec4:	c9                   	leaveq 
  8004208ec5:	c3                   	retq   

0000008004208ec6 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208ec6:	55                   	push   %rbp
  8004208ec7:	48 89 e5             	mov    %rsp,%rbp
  8004208eca:	53                   	push   %rbx
  8004208ecb:	48 83 ec 38          	sub    $0x38,%rsp
  8004208ecf:	89 f8                	mov    %edi,%eax
  8004208ed1:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208ed5:	48 b8 04 06 23 04 80 	movabs $0x8004230604,%rax
  8004208edc:	00 00 00 
  8004208edf:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  8004208ee3:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208ee6:	48 b8 60 22 48 04 80 	movabs $0x8004482260,%rax
  8004208eed:	00 00 00 
  8004208ef0:	0f b6 00             	movzbl (%rax),%eax
  8004208ef3:	83 f0 01             	xor    $0x1,%eax
  8004208ef6:	84 c0                	test   %al,%al
  8004208ef8:	0f 85 bb 00 00 00    	jne    8004208fb9 <irq_setmask_8259A+0xf3>
		return;
	outb(IO_PIC1+1, (char)mask);
  8004208efe:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  8004208f02:	0f b6 c0             	movzbl %al,%eax
  8004208f05:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%rbp)
  8004208f0c:	88 45 e7             	mov    %al,-0x19(%rbp)
  8004208f0f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004208f13:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004208f16:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208f17:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  8004208f1b:	66 c1 e8 08          	shr    $0x8,%ax
  8004208f1f:	0f b6 c0             	movzbl %al,%eax
  8004208f22:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%rbp)
  8004208f29:	88 45 df             	mov    %al,-0x21(%rbp)
  8004208f2c:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004208f30:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004208f33:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004208f34:	48 bf 2d d7 21 04 80 	movabs $0x800421d72d,%rdi
  8004208f3b:	00 00 00 
  8004208f3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208f43:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004208f4a:	00 00 00 
  8004208f4d:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208f4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004208f56:	eb 3e                	jmp    8004208f96 <irq_setmask_8259A+0xd0>
		if (~mask & (1<<i))
  8004208f58:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  8004208f5c:	89 c2                	mov    %eax,%edx
  8004208f5e:	f7 d2                	not    %edx
  8004208f60:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208f63:	89 d3                	mov    %edx,%ebx
  8004208f65:	89 c1                	mov    %eax,%ecx
  8004208f67:	d3 fb                	sar    %cl,%ebx
  8004208f69:	89 d8                	mov    %ebx,%eax
  8004208f6b:	83 e0 01             	and    $0x1,%eax
  8004208f6e:	84 c0                	test   %al,%al
  8004208f70:	74 20                	je     8004208f92 <irq_setmask_8259A+0xcc>
			cprintf(" %d", i);
  8004208f72:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208f75:	89 c6                	mov    %eax,%esi
  8004208f77:	48 bf 41 d7 21 04 80 	movabs $0x800421d741,%rdi
  8004208f7e:	00 00 00 
  8004208f81:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208f86:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004208f8d:	00 00 00 
  8004208f90:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208f92:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004208f96:	83 7d ec 0f          	cmpl   $0xf,-0x14(%rbp)
  8004208f9a:	7e bc                	jle    8004208f58 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208f9c:	48 bf 45 d7 21 04 80 	movabs $0x800421d745,%rdi
  8004208fa3:	00 00 00 
  8004208fa6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208fab:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004208fb2:	00 00 00 
  8004208fb5:	ff d2                	callq  *%rdx
  8004208fb7:	eb 01                	jmp    8004208fba <irq_setmask_8259A+0xf4>
irq_setmask_8259A(uint16_t mask)
{
	int i;
	irq_mask_8259A = mask;
	if (!didinit)
		return;
  8004208fb9:	90                   	nop
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
}
  8004208fba:	48 83 c4 38          	add    $0x38,%rsp
  8004208fbe:	5b                   	pop    %rbx
  8004208fbf:	5d                   	pop    %rbp
  8004208fc0:	c3                   	retq   

0000008004208fc1 <irq_eoi>:

void
irq_eoi(void)
{
  8004208fc1:	55                   	push   %rbp
  8004208fc2:	48 89 e5             	mov    %rsp,%rbp
  8004208fc5:	48 83 ec 10          	sub    $0x10,%rsp
  8004208fc9:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004208fd0:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  8004208fd4:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208fd8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208fdb:	ee                   	out    %al,(%dx)
  8004208fdc:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  8004208fe3:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  8004208fe7:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208feb:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208fee:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004208fef:	c9                   	leaveq 
  8004208ff0:	c3                   	retq   
  8004208ff1:	00 00                	add    %al,(%rax)
	...

0000008004208ff4 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208ff4:	55                   	push   %rbp
  8004208ff5:	48 89 e5             	mov    %rsp,%rbp
  8004208ff8:	48 83 ec 10          	sub    $0x10,%rsp
  8004208ffc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208fff:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209003:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209006:	89 c7                	mov    %eax,%edi
  8004209008:	48 b8 7a 12 20 04 80 	movabs $0x800420127a,%rax
  800420900f:	00 00 00 
  8004209012:	ff d0                	callq  *%rax
	*cnt++;
  8004209014:	48 83 45 f0 04       	addq   $0x4,-0x10(%rbp)
}
  8004209019:	c9                   	leaveq 
  800420901a:	c3                   	retq   

000000800420901b <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  800420901b:	55                   	push   %rbp
  800420901c:	48 89 e5             	mov    %rsp,%rbp
  800420901f:	48 83 ec 30          	sub    $0x30,%rsp
  8004209023:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004209027:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  800420902b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209032:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004209036:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420903a:	48 8b 0a             	mov    (%rdx),%rcx
  800420903d:	48 89 08             	mov    %rcx,(%rax)
  8004209040:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209044:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209048:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420904c:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004209050:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004209054:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004209058:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  800420905c:	48 89 c6             	mov    %rax,%rsi
  800420905f:	48 bf f4 8f 20 04 80 	movabs $0x8004208ff4,%rdi
  8004209066:	00 00 00 
  8004209069:	48 b8 34 f7 20 04 80 	movabs $0x800420f734,%rax
  8004209070:	00 00 00 
  8004209073:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004209075:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004209078:	c9                   	leaveq 
  8004209079:	c3                   	retq   

000000800420907a <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800420907a:	55                   	push   %rbp
  800420907b:	48 89 e5             	mov    %rsp,%rbp
  800420907e:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004209085:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  800420908c:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209093:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420909a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042090a1:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042090a8:	84 c0                	test   %al,%al
  80042090aa:	74 20                	je     80042090cc <cprintf+0x52>
  80042090ac:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042090b0:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042090b4:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042090b8:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042090bc:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042090c0:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042090c4:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042090c8:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042090cc:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  80042090d3:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  80042090da:	00 00 00 
  80042090dd:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80042090e4:	00 00 00 
  80042090e7:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042090eb:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042090f2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042090f9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209100:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004209107:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420910e:	48 8b 0a             	mov    (%rdx),%rcx
  8004209111:	48 89 08             	mov    %rcx,(%rax)
  8004209114:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209118:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420911c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209120:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004209124:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  800420912b:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209132:	48 89 d6             	mov    %rdx,%rsi
  8004209135:	48 89 c7             	mov    %rax,%rdi
  8004209138:	48 b8 1b 90 20 04 80 	movabs $0x800420901b,%rax
  800420913f:	00 00 00 
  8004209142:	ff d0                	callq  *%rax
  8004209144:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  800420914a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209150:	c9                   	leaveq 
  8004209151:	c3                   	retq   
	...

0000008004209154 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209154:	55                   	push   %rbp
  8004209155:	48 89 e5             	mov    %rsp,%rbp
  8004209158:	53                   	push   %rbx
  8004209159:	48 83 ec 20          	sub    $0x20,%rsp
  800420915d:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  8004209161:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
			 "+m" (*addr), "=a" (result):
  8004209164:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209168:	8b 45 dc             	mov    -0x24(%rbp),%eax
			 "+m" (*addr), "=a" (result):
  800420916b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420916f:	89 c3                	mov    %eax,%ebx
  8004209171:	89 d8                	mov    %ebx,%eax
  8004209173:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209176:	89 c3                	mov    %eax,%ebx
  8004209178:	89 5d f4             	mov    %ebx,-0xc(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420917b:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  800420917e:	48 83 c4 20          	add    $0x20,%rsp
  8004209182:	5b                   	pop    %rbx
  8004209183:	5d                   	pop    %rbp
  8004209184:	c3                   	retq   

0000008004209185 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004209185:	55                   	push   %rbp
  8004209186:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209189:	48 bf 00 07 23 04 80 	movabs $0x8004230700,%rdi
  8004209190:	00 00 00 
  8004209193:	48 b8 b9 76 21 04 80 	movabs $0x80042176b9,%rax
  800420919a:	00 00 00 
  800420919d:	ff d0                	callq  *%rax
}
  800420919f:	5d                   	pop    %rbp
  80042091a0:	c3                   	retq   

00000080042091a1 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  80042091a1:	55                   	push   %rbp
  80042091a2:	48 89 e5             	mov    %rsp,%rbp
  80042091a5:	48 83 ec 08          	sub    $0x8,%rsp
  80042091a9:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  80042091ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042091af:	83 f8 13             	cmp    $0x13,%eax
  80042091b2:	77 16                	ja     80042091ca <trapname+0x29>
		return excnames[trapno];
  80042091b4:	48 b8 60 db 21 04 80 	movabs $0x800421db60,%rax
  80042091bb:	00 00 00 
  80042091be:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042091c1:	48 63 d2             	movslq %edx,%rdx
  80042091c4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042091c8:	eb 34                	jmp    80042091fe <trapname+0x5d>
	if (trapno == T_SYSCALL)
  80042091ca:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  80042091ce:	75 0c                	jne    80042091dc <trapname+0x3b>
		return "System call";
  80042091d0:	48 b8 60 d7 21 04 80 	movabs $0x800421d760,%rax
  80042091d7:	00 00 00 
  80042091da:	eb 22                	jmp    80042091fe <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  80042091dc:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80042091e0:	7e 12                	jle    80042091f4 <trapname+0x53>
  80042091e2:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  80042091e6:	7f 0c                	jg     80042091f4 <trapname+0x53>
		return "Hardware Interrupt";
  80042091e8:	48 b8 6c d7 21 04 80 	movabs $0x800421d76c,%rax
  80042091ef:	00 00 00 
  80042091f2:	eb 0a                	jmp    80042091fe <trapname+0x5d>
	return "(unknown trap)";
  80042091f4:	48 b8 7f d7 21 04 80 	movabs $0x800421d77f,%rax
  80042091fb:	00 00 00 
}
  80042091fe:	c9                   	leaveq 
  80042091ff:	c3                   	retq   

0000008004209200 <trap_init>:


void
trap_init(void)
{
  8004209200:	55                   	push   %rbp
  8004209201:	48 89 e5             	mov    %rsp,%rbp
  8004209204:	48 83 ec 10          	sub    $0x10,%rsp
	extern struct Segdesc gdt[];
	uint32_t istrap = 0;
  8004209208:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	uint32_t dpl = 0;
  800420920f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	uint32_t upl = 3;
  8004209216:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%rbp)
	extern void CSE_IRQ12();
	extern void CSE_IRQ13();
	extern void CSE_IRQ14();
	extern void CSE_IRQ15();
		
	SETGATE(idt[0], istrap, GD_KT, CSE_DIVIDE, dpl);
  800420921d:	48 b8 b8 cf 20 04 80 	movabs $0x800420cfb8,%rax
  8004209224:	00 00 00 
  8004209227:	89 c2                	mov    %eax,%edx
  8004209229:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209230:	00 00 00 
  8004209233:	66 89 10             	mov    %dx,(%rax)
  8004209236:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420923d:	00 00 00 
  8004209240:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004209246:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420924d:	00 00 00 
  8004209250:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209254:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209257:	88 50 04             	mov    %dl,0x4(%rax)
  800420925a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209261:	00 00 00 
  8004209264:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209268:	83 e2 07             	and    $0x7,%edx
  800420926b:	88 50 04             	mov    %dl,0x4(%rax)
  800420926e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209272:	74 07                	je     800420927b <trap_init+0x7b>
  8004209274:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209279:	eb 05                	jmp    8004209280 <trap_init+0x80>
  800420927b:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209280:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209287:	00 00 00 
  800420928a:	89 d1                	mov    %edx,%ecx
  800420928c:	83 e1 0f             	and    $0xf,%ecx
  800420928f:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209293:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209296:	09 ca                	or     %ecx,%edx
  8004209298:	88 50 05             	mov    %dl,0x5(%rax)
  800420929b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042092a2:	00 00 00 
  80042092a5:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042092a9:	83 e2 ef             	and    $0xffffffef,%edx
  80042092ac:	88 50 05             	mov    %dl,0x5(%rax)
  80042092af:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042092b2:	89 c2                	mov    %eax,%edx
  80042092b4:	83 e2 03             	and    $0x3,%edx
  80042092b7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042092be:	00 00 00 
  80042092c1:	83 e2 03             	and    $0x3,%edx
  80042092c4:	89 d1                	mov    %edx,%ecx
  80042092c6:	c1 e1 05             	shl    $0x5,%ecx
  80042092c9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042092cd:	83 e2 9f             	and    $0xffffff9f,%edx
  80042092d0:	09 ca                	or     %ecx,%edx
  80042092d2:	88 50 05             	mov    %dl,0x5(%rax)
  80042092d5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042092dc:	00 00 00 
  80042092df:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042092e3:	83 ca 80             	or     $0xffffff80,%edx
  80042092e6:	88 50 05             	mov    %dl,0x5(%rax)
  80042092e9:	48 b8 b8 cf 20 04 80 	movabs $0x800420cfb8,%rax
  80042092f0:	00 00 00 
  80042092f3:	48 c1 e8 10          	shr    $0x10,%rax
  80042092f7:	89 c2                	mov    %eax,%edx
  80042092f9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209300:	00 00 00 
  8004209303:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004209307:	48 b8 b8 cf 20 04 80 	movabs $0x800420cfb8,%rax
  800420930e:	00 00 00 
  8004209311:	48 c1 e8 20          	shr    $0x20,%rax
  8004209315:	89 c2                	mov    %eax,%edx
  8004209317:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420931e:	00 00 00 
  8004209321:	89 50 08             	mov    %edx,0x8(%rax)
  8004209324:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420932b:	00 00 00 
  800420932e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[1], istrap, GD_KT, CSE_DEBUG, dpl);
  8004209335:	48 b8 c2 cf 20 04 80 	movabs $0x800420cfc2,%rax
  800420933c:	00 00 00 
  800420933f:	89 c2                	mov    %eax,%edx
  8004209341:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209348:	00 00 00 
  800420934b:	66 89 50 10          	mov    %dx,0x10(%rax)
  800420934f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209356:	00 00 00 
  8004209359:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  800420935f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209366:	00 00 00 
  8004209369:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  800420936d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209370:	88 50 14             	mov    %dl,0x14(%rax)
  8004209373:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420937a:	00 00 00 
  800420937d:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209381:	83 e2 07             	and    $0x7,%edx
  8004209384:	88 50 14             	mov    %dl,0x14(%rax)
  8004209387:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420938b:	74 07                	je     8004209394 <trap_init+0x194>
  800420938d:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209392:	eb 05                	jmp    8004209399 <trap_init+0x199>
  8004209394:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209399:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042093a0:	00 00 00 
  80042093a3:	89 d1                	mov    %edx,%ecx
  80042093a5:	83 e1 0f             	and    $0xf,%ecx
  80042093a8:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042093ac:	83 e2 f0             	and    $0xfffffff0,%edx
  80042093af:	09 ca                	or     %ecx,%edx
  80042093b1:	88 50 15             	mov    %dl,0x15(%rax)
  80042093b4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042093bb:	00 00 00 
  80042093be:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042093c2:	83 e2 ef             	and    $0xffffffef,%edx
  80042093c5:	88 50 15             	mov    %dl,0x15(%rax)
  80042093c8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042093cb:	89 c2                	mov    %eax,%edx
  80042093cd:	83 e2 03             	and    $0x3,%edx
  80042093d0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042093d7:	00 00 00 
  80042093da:	83 e2 03             	and    $0x3,%edx
  80042093dd:	89 d1                	mov    %edx,%ecx
  80042093df:	c1 e1 05             	shl    $0x5,%ecx
  80042093e2:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042093e6:	83 e2 9f             	and    $0xffffff9f,%edx
  80042093e9:	09 ca                	or     %ecx,%edx
  80042093eb:	88 50 15             	mov    %dl,0x15(%rax)
  80042093ee:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042093f5:	00 00 00 
  80042093f8:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042093fc:	83 ca 80             	or     $0xffffff80,%edx
  80042093ff:	88 50 15             	mov    %dl,0x15(%rax)
  8004209402:	48 b8 c2 cf 20 04 80 	movabs $0x800420cfc2,%rax
  8004209409:	00 00 00 
  800420940c:	48 c1 e8 10          	shr    $0x10,%rax
  8004209410:	89 c2                	mov    %eax,%edx
  8004209412:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209419:	00 00 00 
  800420941c:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004209420:	48 b8 c2 cf 20 04 80 	movabs $0x800420cfc2,%rax
  8004209427:	00 00 00 
  800420942a:	48 c1 e8 20          	shr    $0x20,%rax
  800420942e:	89 c2                	mov    %eax,%edx
  8004209430:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209437:	00 00 00 
  800420943a:	89 50 18             	mov    %edx,0x18(%rax)
  800420943d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209444:	00 00 00 
  8004209447:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[2], istrap, GD_KT, CSE_NMI, dpl);
  800420944e:	48 b8 cc cf 20 04 80 	movabs $0x800420cfcc,%rax
  8004209455:	00 00 00 
  8004209458:	89 c2                	mov    %eax,%edx
  800420945a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209461:	00 00 00 
  8004209464:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209468:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420946f:	00 00 00 
  8004209472:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004209478:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420947f:	00 00 00 
  8004209482:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209486:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209489:	88 50 24             	mov    %dl,0x24(%rax)
  800420948c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209493:	00 00 00 
  8004209496:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  800420949a:	83 e2 07             	and    $0x7,%edx
  800420949d:	88 50 24             	mov    %dl,0x24(%rax)
  80042094a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042094a4:	74 07                	je     80042094ad <trap_init+0x2ad>
  80042094a6:	ba 0f 00 00 00       	mov    $0xf,%edx
  80042094ab:	eb 05                	jmp    80042094b2 <trap_init+0x2b2>
  80042094ad:	ba 0e 00 00 00       	mov    $0xe,%edx
  80042094b2:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042094b9:	00 00 00 
  80042094bc:	89 d1                	mov    %edx,%ecx
  80042094be:	83 e1 0f             	and    $0xf,%ecx
  80042094c1:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042094c5:	83 e2 f0             	and    $0xfffffff0,%edx
  80042094c8:	09 ca                	or     %ecx,%edx
  80042094ca:	88 50 25             	mov    %dl,0x25(%rax)
  80042094cd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042094d4:	00 00 00 
  80042094d7:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042094db:	83 e2 ef             	and    $0xffffffef,%edx
  80042094de:	88 50 25             	mov    %dl,0x25(%rax)
  80042094e1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042094e4:	89 c2                	mov    %eax,%edx
  80042094e6:	83 e2 03             	and    $0x3,%edx
  80042094e9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042094f0:	00 00 00 
  80042094f3:	83 e2 03             	and    $0x3,%edx
  80042094f6:	89 d1                	mov    %edx,%ecx
  80042094f8:	c1 e1 05             	shl    $0x5,%ecx
  80042094fb:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042094ff:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209502:	09 ca                	or     %ecx,%edx
  8004209504:	88 50 25             	mov    %dl,0x25(%rax)
  8004209507:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420950e:	00 00 00 
  8004209511:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209515:	83 ca 80             	or     $0xffffff80,%edx
  8004209518:	88 50 25             	mov    %dl,0x25(%rax)
  800420951b:	48 b8 cc cf 20 04 80 	movabs $0x800420cfcc,%rax
  8004209522:	00 00 00 
  8004209525:	48 c1 e8 10          	shr    $0x10,%rax
  8004209529:	89 c2                	mov    %eax,%edx
  800420952b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209532:	00 00 00 
  8004209535:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004209539:	48 b8 cc cf 20 04 80 	movabs $0x800420cfcc,%rax
  8004209540:	00 00 00 
  8004209543:	48 c1 e8 20          	shr    $0x20,%rax
  8004209547:	89 c2                	mov    %eax,%edx
  8004209549:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209550:	00 00 00 
  8004209553:	89 50 28             	mov    %edx,0x28(%rax)
  8004209556:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420955d:	00 00 00 
  8004209560:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[3], istrap, GD_KT, CSE_BRKPT, upl);
  8004209567:	48 b8 d6 cf 20 04 80 	movabs $0x800420cfd6,%rax
  800420956e:	00 00 00 
  8004209571:	89 c2                	mov    %eax,%edx
  8004209573:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420957a:	00 00 00 
  800420957d:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209581:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209588:	00 00 00 
  800420958b:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209591:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209598:	00 00 00 
  800420959b:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  800420959f:	83 e2 f8             	and    $0xfffffff8,%edx
  80042095a2:	88 50 34             	mov    %dl,0x34(%rax)
  80042095a5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042095ac:	00 00 00 
  80042095af:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  80042095b3:	83 e2 07             	and    $0x7,%edx
  80042095b6:	88 50 34             	mov    %dl,0x34(%rax)
  80042095b9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042095bd:	74 07                	je     80042095c6 <trap_init+0x3c6>
  80042095bf:	ba 0f 00 00 00       	mov    $0xf,%edx
  80042095c4:	eb 05                	jmp    80042095cb <trap_init+0x3cb>
  80042095c6:	ba 0e 00 00 00       	mov    $0xe,%edx
  80042095cb:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042095d2:	00 00 00 
  80042095d5:	89 d1                	mov    %edx,%ecx
  80042095d7:	83 e1 0f             	and    $0xf,%ecx
  80042095da:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042095de:	83 e2 f0             	and    $0xfffffff0,%edx
  80042095e1:	09 ca                	or     %ecx,%edx
  80042095e3:	88 50 35             	mov    %dl,0x35(%rax)
  80042095e6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042095ed:	00 00 00 
  80042095f0:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042095f4:	83 e2 ef             	and    $0xffffffef,%edx
  80042095f7:	88 50 35             	mov    %dl,0x35(%rax)
  80042095fa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042095fd:	89 c2                	mov    %eax,%edx
  80042095ff:	83 e2 03             	and    $0x3,%edx
  8004209602:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209609:	00 00 00 
  800420960c:	83 e2 03             	and    $0x3,%edx
  800420960f:	89 d1                	mov    %edx,%ecx
  8004209611:	c1 e1 05             	shl    $0x5,%ecx
  8004209614:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209618:	83 e2 9f             	and    $0xffffff9f,%edx
  800420961b:	09 ca                	or     %ecx,%edx
  800420961d:	88 50 35             	mov    %dl,0x35(%rax)
  8004209620:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209627:	00 00 00 
  800420962a:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420962e:	83 ca 80             	or     $0xffffff80,%edx
  8004209631:	88 50 35             	mov    %dl,0x35(%rax)
  8004209634:	48 b8 d6 cf 20 04 80 	movabs $0x800420cfd6,%rax
  800420963b:	00 00 00 
  800420963e:	48 c1 e8 10          	shr    $0x10,%rax
  8004209642:	89 c2                	mov    %eax,%edx
  8004209644:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420964b:	00 00 00 
  800420964e:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004209652:	48 b8 d6 cf 20 04 80 	movabs $0x800420cfd6,%rax
  8004209659:	00 00 00 
  800420965c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209660:	89 c2                	mov    %eax,%edx
  8004209662:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209669:	00 00 00 
  800420966c:	89 50 38             	mov    %edx,0x38(%rax)
  800420966f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209676:	00 00 00 
  8004209679:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[4], istrap, GD_KT, CSE_OFLOW, dpl);
  8004209680:	48 b8 e0 cf 20 04 80 	movabs $0x800420cfe0,%rax
  8004209687:	00 00 00 
  800420968a:	89 c2                	mov    %eax,%edx
  800420968c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209693:	00 00 00 
  8004209696:	66 89 50 40          	mov    %dx,0x40(%rax)
  800420969a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042096a1:	00 00 00 
  80042096a4:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  80042096aa:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042096b1:	00 00 00 
  80042096b4:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  80042096b8:	83 e2 f8             	and    $0xfffffff8,%edx
  80042096bb:	88 50 44             	mov    %dl,0x44(%rax)
  80042096be:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042096c5:	00 00 00 
  80042096c8:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  80042096cc:	83 e2 07             	and    $0x7,%edx
  80042096cf:	88 50 44             	mov    %dl,0x44(%rax)
  80042096d2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042096d6:	74 07                	je     80042096df <trap_init+0x4df>
  80042096d8:	ba 0f 00 00 00       	mov    $0xf,%edx
  80042096dd:	eb 05                	jmp    80042096e4 <trap_init+0x4e4>
  80042096df:	ba 0e 00 00 00       	mov    $0xe,%edx
  80042096e4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042096eb:	00 00 00 
  80042096ee:	89 d1                	mov    %edx,%ecx
  80042096f0:	83 e1 0f             	and    $0xf,%ecx
  80042096f3:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042096f7:	83 e2 f0             	and    $0xfffffff0,%edx
  80042096fa:	09 ca                	or     %ecx,%edx
  80042096fc:	88 50 45             	mov    %dl,0x45(%rax)
  80042096ff:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209706:	00 00 00 
  8004209709:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420970d:	83 e2 ef             	and    $0xffffffef,%edx
  8004209710:	88 50 45             	mov    %dl,0x45(%rax)
  8004209713:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209716:	89 c2                	mov    %eax,%edx
  8004209718:	83 e2 03             	and    $0x3,%edx
  800420971b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209722:	00 00 00 
  8004209725:	83 e2 03             	and    $0x3,%edx
  8004209728:	89 d1                	mov    %edx,%ecx
  800420972a:	c1 e1 05             	shl    $0x5,%ecx
  800420972d:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209731:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209734:	09 ca                	or     %ecx,%edx
  8004209736:	88 50 45             	mov    %dl,0x45(%rax)
  8004209739:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209740:	00 00 00 
  8004209743:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209747:	83 ca 80             	or     $0xffffff80,%edx
  800420974a:	88 50 45             	mov    %dl,0x45(%rax)
  800420974d:	48 b8 e0 cf 20 04 80 	movabs $0x800420cfe0,%rax
  8004209754:	00 00 00 
  8004209757:	48 c1 e8 10          	shr    $0x10,%rax
  800420975b:	89 c2                	mov    %eax,%edx
  800420975d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209764:	00 00 00 
  8004209767:	66 89 50 46          	mov    %dx,0x46(%rax)
  800420976b:	48 b8 e0 cf 20 04 80 	movabs $0x800420cfe0,%rax
  8004209772:	00 00 00 
  8004209775:	48 c1 e8 20          	shr    $0x20,%rax
  8004209779:	89 c2                	mov    %eax,%edx
  800420977b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209782:	00 00 00 
  8004209785:	89 50 48             	mov    %edx,0x48(%rax)
  8004209788:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420978f:	00 00 00 
  8004209792:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[5], istrap, GD_KT, CSE_BOUND, dpl);
  8004209799:	48 b8 ea cf 20 04 80 	movabs $0x800420cfea,%rax
  80042097a0:	00 00 00 
  80042097a3:	89 c2                	mov    %eax,%edx
  80042097a5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042097ac:	00 00 00 
  80042097af:	66 89 50 50          	mov    %dx,0x50(%rax)
  80042097b3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042097ba:	00 00 00 
  80042097bd:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  80042097c3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042097ca:	00 00 00 
  80042097cd:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  80042097d1:	83 e2 f8             	and    $0xfffffff8,%edx
  80042097d4:	88 50 54             	mov    %dl,0x54(%rax)
  80042097d7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042097de:	00 00 00 
  80042097e1:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  80042097e5:	83 e2 07             	and    $0x7,%edx
  80042097e8:	88 50 54             	mov    %dl,0x54(%rax)
  80042097eb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042097ef:	74 07                	je     80042097f8 <trap_init+0x5f8>
  80042097f1:	ba 0f 00 00 00       	mov    $0xf,%edx
  80042097f6:	eb 05                	jmp    80042097fd <trap_init+0x5fd>
  80042097f8:	ba 0e 00 00 00       	mov    $0xe,%edx
  80042097fd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209804:	00 00 00 
  8004209807:	89 d1                	mov    %edx,%ecx
  8004209809:	83 e1 0f             	and    $0xf,%ecx
  800420980c:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209810:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209813:	09 ca                	or     %ecx,%edx
  8004209815:	88 50 55             	mov    %dl,0x55(%rax)
  8004209818:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420981f:	00 00 00 
  8004209822:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209826:	83 e2 ef             	and    $0xffffffef,%edx
  8004209829:	88 50 55             	mov    %dl,0x55(%rax)
  800420982c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420982f:	89 c2                	mov    %eax,%edx
  8004209831:	83 e2 03             	and    $0x3,%edx
  8004209834:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420983b:	00 00 00 
  800420983e:	83 e2 03             	and    $0x3,%edx
  8004209841:	89 d1                	mov    %edx,%ecx
  8004209843:	c1 e1 05             	shl    $0x5,%ecx
  8004209846:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420984a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420984d:	09 ca                	or     %ecx,%edx
  800420984f:	88 50 55             	mov    %dl,0x55(%rax)
  8004209852:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209859:	00 00 00 
  800420985c:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209860:	83 ca 80             	or     $0xffffff80,%edx
  8004209863:	88 50 55             	mov    %dl,0x55(%rax)
  8004209866:	48 b8 ea cf 20 04 80 	movabs $0x800420cfea,%rax
  800420986d:	00 00 00 
  8004209870:	48 c1 e8 10          	shr    $0x10,%rax
  8004209874:	89 c2                	mov    %eax,%edx
  8004209876:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420987d:	00 00 00 
  8004209880:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004209884:	48 b8 ea cf 20 04 80 	movabs $0x800420cfea,%rax
  800420988b:	00 00 00 
  800420988e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209892:	89 c2                	mov    %eax,%edx
  8004209894:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420989b:	00 00 00 
  800420989e:	89 50 58             	mov    %edx,0x58(%rax)
  80042098a1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042098a8:	00 00 00 
  80042098ab:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[6], istrap, GD_KT, CSE_ILLOP, dpl);
  80042098b2:	48 b8 f4 cf 20 04 80 	movabs $0x800420cff4,%rax
  80042098b9:	00 00 00 
  80042098bc:	89 c2                	mov    %eax,%edx
  80042098be:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042098c5:	00 00 00 
  80042098c8:	66 89 50 60          	mov    %dx,0x60(%rax)
  80042098cc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042098d3:	00 00 00 
  80042098d6:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  80042098dc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042098e3:	00 00 00 
  80042098e6:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042098ea:	83 e2 f8             	and    $0xfffffff8,%edx
  80042098ed:	88 50 64             	mov    %dl,0x64(%rax)
  80042098f0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042098f7:	00 00 00 
  80042098fa:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042098fe:	83 e2 07             	and    $0x7,%edx
  8004209901:	88 50 64             	mov    %dl,0x64(%rax)
  8004209904:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209908:	74 07                	je     8004209911 <trap_init+0x711>
  800420990a:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420990f:	eb 05                	jmp    8004209916 <trap_init+0x716>
  8004209911:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209916:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420991d:	00 00 00 
  8004209920:	89 d1                	mov    %edx,%ecx
  8004209922:	83 e1 0f             	and    $0xf,%ecx
  8004209925:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209929:	83 e2 f0             	and    $0xfffffff0,%edx
  800420992c:	09 ca                	or     %ecx,%edx
  800420992e:	88 50 65             	mov    %dl,0x65(%rax)
  8004209931:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209938:	00 00 00 
  800420993b:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420993f:	83 e2 ef             	and    $0xffffffef,%edx
  8004209942:	88 50 65             	mov    %dl,0x65(%rax)
  8004209945:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209948:	89 c2                	mov    %eax,%edx
  800420994a:	83 e2 03             	and    $0x3,%edx
  800420994d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209954:	00 00 00 
  8004209957:	83 e2 03             	and    $0x3,%edx
  800420995a:	89 d1                	mov    %edx,%ecx
  800420995c:	c1 e1 05             	shl    $0x5,%ecx
  800420995f:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209963:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209966:	09 ca                	or     %ecx,%edx
  8004209968:	88 50 65             	mov    %dl,0x65(%rax)
  800420996b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209972:	00 00 00 
  8004209975:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209979:	83 ca 80             	or     $0xffffff80,%edx
  800420997c:	88 50 65             	mov    %dl,0x65(%rax)
  800420997f:	48 b8 f4 cf 20 04 80 	movabs $0x800420cff4,%rax
  8004209986:	00 00 00 
  8004209989:	48 c1 e8 10          	shr    $0x10,%rax
  800420998d:	89 c2                	mov    %eax,%edx
  800420998f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209996:	00 00 00 
  8004209999:	66 89 50 66          	mov    %dx,0x66(%rax)
  800420999d:	48 b8 f4 cf 20 04 80 	movabs $0x800420cff4,%rax
  80042099a4:	00 00 00 
  80042099a7:	48 c1 e8 20          	shr    $0x20,%rax
  80042099ab:	89 c2                	mov    %eax,%edx
  80042099ad:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042099b4:	00 00 00 
  80042099b7:	89 50 68             	mov    %edx,0x68(%rax)
  80042099ba:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042099c1:	00 00 00 
  80042099c4:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[7], istrap, GD_KT, CSE_DEVICE, dpl);
  80042099cb:	48 b8 fe cf 20 04 80 	movabs $0x800420cffe,%rax
  80042099d2:	00 00 00 
  80042099d5:	89 c2                	mov    %eax,%edx
  80042099d7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042099de:	00 00 00 
  80042099e1:	66 89 50 70          	mov    %dx,0x70(%rax)
  80042099e5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042099ec:	00 00 00 
  80042099ef:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  80042099f5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  80042099fc:	00 00 00 
  80042099ff:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209a03:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a06:	88 50 74             	mov    %dl,0x74(%rax)
  8004209a09:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209a10:	00 00 00 
  8004209a13:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209a17:	83 e2 07             	and    $0x7,%edx
  8004209a1a:	88 50 74             	mov    %dl,0x74(%rax)
  8004209a1d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209a21:	74 07                	je     8004209a2a <trap_init+0x82a>
  8004209a23:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209a28:	eb 05                	jmp    8004209a2f <trap_init+0x82f>
  8004209a2a:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209a2f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209a36:	00 00 00 
  8004209a39:	89 d1                	mov    %edx,%ecx
  8004209a3b:	83 e1 0f             	and    $0xf,%ecx
  8004209a3e:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209a42:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209a45:	09 ca                	or     %ecx,%edx
  8004209a47:	88 50 75             	mov    %dl,0x75(%rax)
  8004209a4a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209a51:	00 00 00 
  8004209a54:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209a58:	83 e2 ef             	and    $0xffffffef,%edx
  8004209a5b:	88 50 75             	mov    %dl,0x75(%rax)
  8004209a5e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209a61:	89 c2                	mov    %eax,%edx
  8004209a63:	83 e2 03             	and    $0x3,%edx
  8004209a66:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209a6d:	00 00 00 
  8004209a70:	83 e2 03             	and    $0x3,%edx
  8004209a73:	89 d1                	mov    %edx,%ecx
  8004209a75:	c1 e1 05             	shl    $0x5,%ecx
  8004209a78:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209a7c:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a7f:	09 ca                	or     %ecx,%edx
  8004209a81:	88 50 75             	mov    %dl,0x75(%rax)
  8004209a84:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209a8b:	00 00 00 
  8004209a8e:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209a92:	83 ca 80             	or     $0xffffff80,%edx
  8004209a95:	88 50 75             	mov    %dl,0x75(%rax)
  8004209a98:	48 b8 fe cf 20 04 80 	movabs $0x800420cffe,%rax
  8004209a9f:	00 00 00 
  8004209aa2:	48 c1 e8 10          	shr    $0x10,%rax
  8004209aa6:	89 c2                	mov    %eax,%edx
  8004209aa8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209aaf:	00 00 00 
  8004209ab2:	66 89 50 76          	mov    %dx,0x76(%rax)
  8004209ab6:	48 b8 fe cf 20 04 80 	movabs $0x800420cffe,%rax
  8004209abd:	00 00 00 
  8004209ac0:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ac4:	89 c2                	mov    %eax,%edx
  8004209ac6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209acd:	00 00 00 
  8004209ad0:	89 50 78             	mov    %edx,0x78(%rax)
  8004209ad3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209ada:	00 00 00 
  8004209add:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[8], istrap, GD_KT, CSE_DBLFLT, dpl);
  8004209ae4:	48 b8 08 d0 20 04 80 	movabs $0x800420d008,%rax
  8004209aeb:	00 00 00 
  8004209aee:	89 c2                	mov    %eax,%edx
  8004209af0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209af7:	00 00 00 
  8004209afa:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  8004209b01:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209b08:	00 00 00 
  8004209b0b:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  8004209b12:	08 00 
  8004209b14:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209b1b:	00 00 00 
  8004209b1e:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209b25:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b28:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209b2e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209b35:	00 00 00 
  8004209b38:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209b3f:	83 e2 07             	and    $0x7,%edx
  8004209b42:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209b48:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209b4c:	74 07                	je     8004209b55 <trap_init+0x955>
  8004209b4e:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209b53:	eb 05                	jmp    8004209b5a <trap_init+0x95a>
  8004209b55:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209b5a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209b61:	00 00 00 
  8004209b64:	89 d1                	mov    %edx,%ecx
  8004209b66:	83 e1 0f             	and    $0xf,%ecx
  8004209b69:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209b70:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209b73:	09 ca                	or     %ecx,%edx
  8004209b75:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209b7b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209b82:	00 00 00 
  8004209b85:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209b8c:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b8f:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209b95:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209b98:	89 c2                	mov    %eax,%edx
  8004209b9a:	83 e2 03             	and    $0x3,%edx
  8004209b9d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209ba4:	00 00 00 
  8004209ba7:	83 e2 03             	and    $0x3,%edx
  8004209baa:	89 d1                	mov    %edx,%ecx
  8004209bac:	c1 e1 05             	shl    $0x5,%ecx
  8004209baf:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209bb6:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209bb9:	09 ca                	or     %ecx,%edx
  8004209bbb:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209bc1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209bc8:	00 00 00 
  8004209bcb:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209bd2:	83 ca 80             	or     $0xffffff80,%edx
  8004209bd5:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209bdb:	48 b8 08 d0 20 04 80 	movabs $0x800420d008,%rax
  8004209be2:	00 00 00 
  8004209be5:	48 c1 e8 10          	shr    $0x10,%rax
  8004209be9:	89 c2                	mov    %eax,%edx
  8004209beb:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209bf2:	00 00 00 
  8004209bf5:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  8004209bfc:	48 b8 08 d0 20 04 80 	movabs $0x800420d008,%rax
  8004209c03:	00 00 00 
  8004209c06:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c0a:	89 c2                	mov    %eax,%edx
  8004209c0c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209c13:	00 00 00 
  8004209c16:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  8004209c1c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209c23:	00 00 00 
  8004209c26:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  8004209c2d:	00 00 00 
	SETGATE(idt[10], istrap, GD_KT, CSE_TSS, dpl);
  8004209c30:	48 b8 10 d0 20 04 80 	movabs $0x800420d010,%rax
  8004209c37:	00 00 00 
  8004209c3a:	89 c2                	mov    %eax,%edx
  8004209c3c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209c43:	00 00 00 
  8004209c46:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  8004209c4d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209c54:	00 00 00 
  8004209c57:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004209c5e:	08 00 
  8004209c60:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209c67:	00 00 00 
  8004209c6a:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209c71:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c74:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209c7a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209c81:	00 00 00 
  8004209c84:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209c8b:	83 e2 07             	and    $0x7,%edx
  8004209c8e:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209c94:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209c98:	74 07                	je     8004209ca1 <trap_init+0xaa1>
  8004209c9a:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209c9f:	eb 05                	jmp    8004209ca6 <trap_init+0xaa6>
  8004209ca1:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209ca6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209cad:	00 00 00 
  8004209cb0:	89 d1                	mov    %edx,%ecx
  8004209cb2:	83 e1 0f             	and    $0xf,%ecx
  8004209cb5:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209cbc:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209cbf:	09 ca                	or     %ecx,%edx
  8004209cc1:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209cc7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209cce:	00 00 00 
  8004209cd1:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209cd8:	83 e2 ef             	and    $0xffffffef,%edx
  8004209cdb:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209ce1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209ce4:	89 c2                	mov    %eax,%edx
  8004209ce6:	83 e2 03             	and    $0x3,%edx
  8004209ce9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209cf0:	00 00 00 
  8004209cf3:	83 e2 03             	and    $0x3,%edx
  8004209cf6:	89 d1                	mov    %edx,%ecx
  8004209cf8:	c1 e1 05             	shl    $0x5,%ecx
  8004209cfb:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209d02:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209d05:	09 ca                	or     %ecx,%edx
  8004209d07:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209d0d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209d14:	00 00 00 
  8004209d17:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209d1e:	83 ca 80             	or     $0xffffff80,%edx
  8004209d21:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209d27:	48 b8 10 d0 20 04 80 	movabs $0x800420d010,%rax
  8004209d2e:	00 00 00 
  8004209d31:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d35:	89 c2                	mov    %eax,%edx
  8004209d37:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209d3e:	00 00 00 
  8004209d41:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209d48:	48 b8 10 d0 20 04 80 	movabs $0x800420d010,%rax
  8004209d4f:	00 00 00 
  8004209d52:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d56:	89 c2                	mov    %eax,%edx
  8004209d58:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209d5f:	00 00 00 
  8004209d62:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209d68:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209d6f:	00 00 00 
  8004209d72:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209d79:	00 00 00 
	SETGATE(idt[11], istrap, GD_KT, CSE_SEGNP, dpl);
  8004209d7c:	48 b8 18 d0 20 04 80 	movabs $0x800420d018,%rax
  8004209d83:	00 00 00 
  8004209d86:	89 c2                	mov    %eax,%edx
  8004209d88:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209d8f:	00 00 00 
  8004209d92:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209d99:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209da0:	00 00 00 
  8004209da3:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209daa:	08 00 
  8004209dac:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209db3:	00 00 00 
  8004209db6:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209dbd:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209dc0:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209dc6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209dcd:	00 00 00 
  8004209dd0:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209dd7:	83 e2 07             	and    $0x7,%edx
  8004209dda:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209de0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209de4:	74 07                	je     8004209ded <trap_init+0xbed>
  8004209de6:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209deb:	eb 05                	jmp    8004209df2 <trap_init+0xbf2>
  8004209ded:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209df2:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209df9:	00 00 00 
  8004209dfc:	89 d1                	mov    %edx,%ecx
  8004209dfe:	83 e1 0f             	and    $0xf,%ecx
  8004209e01:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209e08:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e0b:	09 ca                	or     %ecx,%edx
  8004209e0d:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209e13:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209e1a:	00 00 00 
  8004209e1d:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209e24:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e27:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209e2d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209e30:	89 c2                	mov    %eax,%edx
  8004209e32:	83 e2 03             	and    $0x3,%edx
  8004209e35:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209e3c:	00 00 00 
  8004209e3f:	83 e2 03             	and    $0x3,%edx
  8004209e42:	89 d1                	mov    %edx,%ecx
  8004209e44:	c1 e1 05             	shl    $0x5,%ecx
  8004209e47:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209e4e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e51:	09 ca                	or     %ecx,%edx
  8004209e53:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209e59:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209e60:	00 00 00 
  8004209e63:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209e6a:	83 ca 80             	or     $0xffffff80,%edx
  8004209e6d:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209e73:	48 b8 18 d0 20 04 80 	movabs $0x800420d018,%rax
  8004209e7a:	00 00 00 
  8004209e7d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e81:	89 c2                	mov    %eax,%edx
  8004209e83:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209e8a:	00 00 00 
  8004209e8d:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  8004209e94:	48 b8 18 d0 20 04 80 	movabs $0x800420d018,%rax
  8004209e9b:	00 00 00 
  8004209e9e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ea2:	89 c2                	mov    %eax,%edx
  8004209ea4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209eab:	00 00 00 
  8004209eae:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004209eb4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209ebb:	00 00 00 
  8004209ebe:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209ec5:	00 00 00 
	SETGATE(idt[12], istrap, GD_KT, CSE_STACK, dpl);
  8004209ec8:	48 b8 20 d0 20 04 80 	movabs $0x800420d020,%rax
  8004209ecf:	00 00 00 
  8004209ed2:	89 c2                	mov    %eax,%edx
  8004209ed4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209edb:	00 00 00 
  8004209ede:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209ee5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209eec:	00 00 00 
  8004209eef:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209ef6:	08 00 
  8004209ef8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209eff:	00 00 00 
  8004209f02:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209f09:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f0c:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209f12:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209f19:	00 00 00 
  8004209f1c:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209f23:	83 e2 07             	and    $0x7,%edx
  8004209f26:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209f2c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004209f30:	74 07                	je     8004209f39 <trap_init+0xd39>
  8004209f32:	ba 0f 00 00 00       	mov    $0xf,%edx
  8004209f37:	eb 05                	jmp    8004209f3e <trap_init+0xd3e>
  8004209f39:	ba 0e 00 00 00       	mov    $0xe,%edx
  8004209f3e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209f45:	00 00 00 
  8004209f48:	89 d1                	mov    %edx,%ecx
  8004209f4a:	83 e1 0f             	and    $0xf,%ecx
  8004209f4d:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209f54:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f57:	09 ca                	or     %ecx,%edx
  8004209f59:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209f5f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209f66:	00 00 00 
  8004209f69:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209f70:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f73:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209f79:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004209f7c:	89 c2                	mov    %eax,%edx
  8004209f7e:	83 e2 03             	and    $0x3,%edx
  8004209f81:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209f88:	00 00 00 
  8004209f8b:	83 e2 03             	and    $0x3,%edx
  8004209f8e:	89 d1                	mov    %edx,%ecx
  8004209f90:	c1 e1 05             	shl    $0x5,%ecx
  8004209f93:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209f9a:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f9d:	09 ca                	or     %ecx,%edx
  8004209f9f:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209fa5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209fac:	00 00 00 
  8004209faf:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209fb6:	83 ca 80             	or     $0xffffff80,%edx
  8004209fb9:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209fbf:	48 b8 20 d0 20 04 80 	movabs $0x800420d020,%rax
  8004209fc6:	00 00 00 
  8004209fc9:	48 c1 e8 10          	shr    $0x10,%rax
  8004209fcd:	89 c2                	mov    %eax,%edx
  8004209fcf:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209fd6:	00 00 00 
  8004209fd9:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209fe0:	48 b8 20 d0 20 04 80 	movabs $0x800420d020,%rax
  8004209fe7:	00 00 00 
  8004209fea:	48 c1 e8 20          	shr    $0x20,%rax
  8004209fee:	89 c2                	mov    %eax,%edx
  8004209ff0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  8004209ff7:	00 00 00 
  8004209ffa:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420a000:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a007:	00 00 00 
  800420a00a:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420a011:	00 00 00 
	SETGATE(idt[13], istrap, GD_KT, CSE_GPFLT, dpl);
  800420a014:	48 b8 28 d0 20 04 80 	movabs $0x800420d028,%rax
  800420a01b:	00 00 00 
  800420a01e:	89 c2                	mov    %eax,%edx
  800420a020:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a027:	00 00 00 
  800420a02a:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420a031:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a038:	00 00 00 
  800420a03b:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420a042:	08 00 
  800420a044:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a04b:	00 00 00 
  800420a04e:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a055:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a058:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a05e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a065:	00 00 00 
  800420a068:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a06f:	83 e2 07             	and    $0x7,%edx
  800420a072:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a078:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a07c:	74 07                	je     800420a085 <trap_init+0xe85>
  800420a07e:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a083:	eb 05                	jmp    800420a08a <trap_init+0xe8a>
  800420a085:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a08a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a091:	00 00 00 
  800420a094:	89 d1                	mov    %edx,%ecx
  800420a096:	83 e1 0f             	and    $0xf,%ecx
  800420a099:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a0a0:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0a3:	09 ca                	or     %ecx,%edx
  800420a0a5:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a0ab:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a0b2:	00 00 00 
  800420a0b5:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a0bc:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0bf:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a0c5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a0c8:	89 c2                	mov    %eax,%edx
  800420a0ca:	83 e2 03             	and    $0x3,%edx
  800420a0cd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a0d4:	00 00 00 
  800420a0d7:	83 e2 03             	and    $0x3,%edx
  800420a0da:	89 d1                	mov    %edx,%ecx
  800420a0dc:	c1 e1 05             	shl    $0x5,%ecx
  800420a0df:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a0e6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0e9:	09 ca                	or     %ecx,%edx
  800420a0eb:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a0f1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a0f8:	00 00 00 
  800420a0fb:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a102:	83 ca 80             	or     $0xffffff80,%edx
  800420a105:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a10b:	48 b8 28 d0 20 04 80 	movabs $0x800420d028,%rax
  800420a112:	00 00 00 
  800420a115:	48 c1 e8 10          	shr    $0x10,%rax
  800420a119:	89 c2                	mov    %eax,%edx
  800420a11b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a122:	00 00 00 
  800420a125:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420a12c:	48 b8 28 d0 20 04 80 	movabs $0x800420d028,%rax
  800420a133:	00 00 00 
  800420a136:	48 c1 e8 20          	shr    $0x20,%rax
  800420a13a:	89 c2                	mov    %eax,%edx
  800420a13c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a143:	00 00 00 
  800420a146:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420a14c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a153:	00 00 00 
  800420a156:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420a15d:	00 00 00 
	SETGATE(idt[14], istrap, GD_KT, CSE_PGFLT, dpl);
  800420a160:	48 b8 30 d0 20 04 80 	movabs $0x800420d030,%rax
  800420a167:	00 00 00 
  800420a16a:	89 c2                	mov    %eax,%edx
  800420a16c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a173:	00 00 00 
  800420a176:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420a17d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a184:	00 00 00 
  800420a187:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420a18e:	08 00 
  800420a190:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a197:	00 00 00 
  800420a19a:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a1a1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a1a4:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a1aa:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a1b1:	00 00 00 
  800420a1b4:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a1bb:	83 e2 07             	and    $0x7,%edx
  800420a1be:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a1c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a1c8:	74 07                	je     800420a1d1 <trap_init+0xfd1>
  800420a1ca:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a1cf:	eb 05                	jmp    800420a1d6 <trap_init+0xfd6>
  800420a1d1:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a1d6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a1dd:	00 00 00 
  800420a1e0:	89 d1                	mov    %edx,%ecx
  800420a1e2:	83 e1 0f             	and    $0xf,%ecx
  800420a1e5:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a1ec:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1ef:	09 ca                	or     %ecx,%edx
  800420a1f1:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a1f7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a1fe:	00 00 00 
  800420a201:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a208:	83 e2 ef             	and    $0xffffffef,%edx
  800420a20b:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a211:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a214:	89 c2                	mov    %eax,%edx
  800420a216:	83 e2 03             	and    $0x3,%edx
  800420a219:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a220:	00 00 00 
  800420a223:	83 e2 03             	and    $0x3,%edx
  800420a226:	89 d1                	mov    %edx,%ecx
  800420a228:	c1 e1 05             	shl    $0x5,%ecx
  800420a22b:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a232:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a235:	09 ca                	or     %ecx,%edx
  800420a237:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a23d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a244:	00 00 00 
  800420a247:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a24e:	83 ca 80             	or     $0xffffff80,%edx
  800420a251:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a257:	48 b8 30 d0 20 04 80 	movabs $0x800420d030,%rax
  800420a25e:	00 00 00 
  800420a261:	48 c1 e8 10          	shr    $0x10,%rax
  800420a265:	89 c2                	mov    %eax,%edx
  800420a267:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a26e:	00 00 00 
  800420a271:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  800420a278:	48 b8 30 d0 20 04 80 	movabs $0x800420d030,%rax
  800420a27f:	00 00 00 
  800420a282:	48 c1 e8 20          	shr    $0x20,%rax
  800420a286:	89 c2                	mov    %eax,%edx
  800420a288:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a28f:	00 00 00 
  800420a292:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  800420a298:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a29f:	00 00 00 
  800420a2a2:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  800420a2a9:	00 00 00 
	SETGATE(idt[16], istrap, GD_KT, CSE_FPERR, dpl);
  800420a2ac:	48 b8 38 d0 20 04 80 	movabs $0x800420d038,%rax
  800420a2b3:	00 00 00 
  800420a2b6:	89 c2                	mov    %eax,%edx
  800420a2b8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a2bf:	00 00 00 
  800420a2c2:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  800420a2c9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a2d0:	00 00 00 
  800420a2d3:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420a2da:	08 00 
  800420a2dc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a2e3:	00 00 00 
  800420a2e6:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a2ed:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a2f0:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a2f6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a2fd:	00 00 00 
  800420a300:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a307:	83 e2 07             	and    $0x7,%edx
  800420a30a:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a310:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a314:	74 07                	je     800420a31d <trap_init+0x111d>
  800420a316:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a31b:	eb 05                	jmp    800420a322 <trap_init+0x1122>
  800420a31d:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a322:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a329:	00 00 00 
  800420a32c:	89 d1                	mov    %edx,%ecx
  800420a32e:	83 e1 0f             	and    $0xf,%ecx
  800420a331:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a338:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a33b:	09 ca                	or     %ecx,%edx
  800420a33d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a343:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a34a:	00 00 00 
  800420a34d:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a354:	83 e2 ef             	and    $0xffffffef,%edx
  800420a357:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a35d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a360:	89 c2                	mov    %eax,%edx
  800420a362:	83 e2 03             	and    $0x3,%edx
  800420a365:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a36c:	00 00 00 
  800420a36f:	83 e2 03             	and    $0x3,%edx
  800420a372:	89 d1                	mov    %edx,%ecx
  800420a374:	c1 e1 05             	shl    $0x5,%ecx
  800420a377:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a37e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a381:	09 ca                	or     %ecx,%edx
  800420a383:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a389:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a390:	00 00 00 
  800420a393:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a39a:	83 ca 80             	or     $0xffffff80,%edx
  800420a39d:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a3a3:	48 b8 38 d0 20 04 80 	movabs $0x800420d038,%rax
  800420a3aa:	00 00 00 
  800420a3ad:	48 c1 e8 10          	shr    $0x10,%rax
  800420a3b1:	89 c2                	mov    %eax,%edx
  800420a3b3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a3ba:	00 00 00 
  800420a3bd:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420a3c4:	48 b8 38 d0 20 04 80 	movabs $0x800420d038,%rax
  800420a3cb:	00 00 00 
  800420a3ce:	48 c1 e8 20          	shr    $0x20,%rax
  800420a3d2:	89 c2                	mov    %eax,%edx
  800420a3d4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a3db:	00 00 00 
  800420a3de:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420a3e4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a3eb:	00 00 00 
  800420a3ee:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420a3f5:	00 00 00 
	SETGATE(idt[17], istrap, GD_KT, CSE_ALIGN, dpl);
  800420a3f8:	48 b8 42 d0 20 04 80 	movabs $0x800420d042,%rax
  800420a3ff:	00 00 00 
  800420a402:	89 c2                	mov    %eax,%edx
  800420a404:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a40b:	00 00 00 
  800420a40e:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420a415:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a41c:	00 00 00 
  800420a41f:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420a426:	08 00 
  800420a428:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a42f:	00 00 00 
  800420a432:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a439:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a43c:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a442:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a449:	00 00 00 
  800420a44c:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a453:	83 e2 07             	and    $0x7,%edx
  800420a456:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a45c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a460:	74 07                	je     800420a469 <trap_init+0x1269>
  800420a462:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a467:	eb 05                	jmp    800420a46e <trap_init+0x126e>
  800420a469:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a46e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a475:	00 00 00 
  800420a478:	89 d1                	mov    %edx,%ecx
  800420a47a:	83 e1 0f             	and    $0xf,%ecx
  800420a47d:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a484:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a487:	09 ca                	or     %ecx,%edx
  800420a489:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a48f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a496:	00 00 00 
  800420a499:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a4a0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a4a3:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a4a9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a4ac:	89 c2                	mov    %eax,%edx
  800420a4ae:	83 e2 03             	and    $0x3,%edx
  800420a4b1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a4b8:	00 00 00 
  800420a4bb:	83 e2 03             	and    $0x3,%edx
  800420a4be:	89 d1                	mov    %edx,%ecx
  800420a4c0:	c1 e1 05             	shl    $0x5,%ecx
  800420a4c3:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a4ca:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a4cd:	09 ca                	or     %ecx,%edx
  800420a4cf:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a4d5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a4dc:	00 00 00 
  800420a4df:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a4e6:	83 ca 80             	or     $0xffffff80,%edx
  800420a4e9:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a4ef:	48 b8 42 d0 20 04 80 	movabs $0x800420d042,%rax
  800420a4f6:	00 00 00 
  800420a4f9:	48 c1 e8 10          	shr    $0x10,%rax
  800420a4fd:	89 c2                	mov    %eax,%edx
  800420a4ff:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a506:	00 00 00 
  800420a509:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420a510:	48 b8 42 d0 20 04 80 	movabs $0x800420d042,%rax
  800420a517:	00 00 00 
  800420a51a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a51e:	89 c2                	mov    %eax,%edx
  800420a520:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a527:	00 00 00 
  800420a52a:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420a530:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a537:	00 00 00 
  800420a53a:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420a541:	00 00 00 
	SETGATE(idt[18], istrap, GD_KT, CSE_MCHK, dpl);
  800420a544:	48 b8 4c d0 20 04 80 	movabs $0x800420d04c,%rax
  800420a54b:	00 00 00 
  800420a54e:	89 c2                	mov    %eax,%edx
  800420a550:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a557:	00 00 00 
  800420a55a:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a561:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a568:	00 00 00 
  800420a56b:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a572:	08 00 
  800420a574:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a57b:	00 00 00 
  800420a57e:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a585:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a588:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a58e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a595:	00 00 00 
  800420a598:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a59f:	83 e2 07             	and    $0x7,%edx
  800420a5a2:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a5a8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a5ac:	74 07                	je     800420a5b5 <trap_init+0x13b5>
  800420a5ae:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a5b3:	eb 05                	jmp    800420a5ba <trap_init+0x13ba>
  800420a5b5:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a5ba:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a5c1:	00 00 00 
  800420a5c4:	89 d1                	mov    %edx,%ecx
  800420a5c6:	83 e1 0f             	and    $0xf,%ecx
  800420a5c9:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a5d0:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a5d3:	09 ca                	or     %ecx,%edx
  800420a5d5:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a5db:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a5e2:	00 00 00 
  800420a5e5:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a5ec:	83 e2 ef             	and    $0xffffffef,%edx
  800420a5ef:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a5f5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a5f8:	89 c2                	mov    %eax,%edx
  800420a5fa:	83 e2 03             	and    $0x3,%edx
  800420a5fd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a604:	00 00 00 
  800420a607:	83 e2 03             	and    $0x3,%edx
  800420a60a:	89 d1                	mov    %edx,%ecx
  800420a60c:	c1 e1 05             	shl    $0x5,%ecx
  800420a60f:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a616:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a619:	09 ca                	or     %ecx,%edx
  800420a61b:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a621:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a628:	00 00 00 
  800420a62b:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a632:	83 ca 80             	or     $0xffffff80,%edx
  800420a635:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a63b:	48 b8 4c d0 20 04 80 	movabs $0x800420d04c,%rax
  800420a642:	00 00 00 
  800420a645:	48 c1 e8 10          	shr    $0x10,%rax
  800420a649:	89 c2                	mov    %eax,%edx
  800420a64b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a652:	00 00 00 
  800420a655:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a65c:	48 b8 4c d0 20 04 80 	movabs $0x800420d04c,%rax
  800420a663:	00 00 00 
  800420a666:	48 c1 e8 20          	shr    $0x20,%rax
  800420a66a:	89 c2                	mov    %eax,%edx
  800420a66c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a673:	00 00 00 
  800420a676:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a67c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a683:	00 00 00 
  800420a686:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a68d:	00 00 00 
	SETGATE(idt[19], istrap, GD_KT, CSE_SIMDERR, dpl);
  800420a690:	48 b8 56 d0 20 04 80 	movabs $0x800420d056,%rax
  800420a697:	00 00 00 
  800420a69a:	89 c2                	mov    %eax,%edx
  800420a69c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a6a3:	00 00 00 
  800420a6a6:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a6ad:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a6b4:	00 00 00 
  800420a6b7:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a6be:	08 00 
  800420a6c0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a6c7:	00 00 00 
  800420a6ca:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a6d1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a6d4:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a6da:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a6e1:	00 00 00 
  800420a6e4:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a6eb:	83 e2 07             	and    $0x7,%edx
  800420a6ee:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a6f4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a6f8:	74 07                	je     800420a701 <trap_init+0x1501>
  800420a6fa:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a6ff:	eb 05                	jmp    800420a706 <trap_init+0x1506>
  800420a701:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a706:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a70d:	00 00 00 
  800420a710:	89 d1                	mov    %edx,%ecx
  800420a712:	83 e1 0f             	and    $0xf,%ecx
  800420a715:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a71c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a71f:	09 ca                	or     %ecx,%edx
  800420a721:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a727:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a72e:	00 00 00 
  800420a731:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a738:	83 e2 ef             	and    $0xffffffef,%edx
  800420a73b:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a741:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a744:	89 c2                	mov    %eax,%edx
  800420a746:	83 e2 03             	and    $0x3,%edx
  800420a749:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a750:	00 00 00 
  800420a753:	83 e2 03             	and    $0x3,%edx
  800420a756:	89 d1                	mov    %edx,%ecx
  800420a758:	c1 e1 05             	shl    $0x5,%ecx
  800420a75b:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a762:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a765:	09 ca                	or     %ecx,%edx
  800420a767:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a76d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a774:	00 00 00 
  800420a777:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a77e:	83 ca 80             	or     $0xffffff80,%edx
  800420a781:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a787:	48 b8 56 d0 20 04 80 	movabs $0x800420d056,%rax
  800420a78e:	00 00 00 
  800420a791:	48 c1 e8 10          	shr    $0x10,%rax
  800420a795:	89 c2                	mov    %eax,%edx
  800420a797:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a79e:	00 00 00 
  800420a7a1:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420a7a8:	48 b8 56 d0 20 04 80 	movabs $0x800420d056,%rax
  800420a7af:	00 00 00 
  800420a7b2:	48 c1 e8 20          	shr    $0x20,%rax
  800420a7b6:	89 c2                	mov    %eax,%edx
  800420a7b8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a7bf:	00 00 00 
  800420a7c2:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420a7c8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a7cf:	00 00 00 
  800420a7d2:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420a7d9:	00 00 00 
	
	SETGATE(idt[48], istrap, GD_KT, CSE_SYSCALL, upl);
  800420a7dc:	48 b8 60 d0 20 04 80 	movabs $0x800420d060,%rax
  800420a7e3:	00 00 00 
  800420a7e6:	89 c2                	mov    %eax,%edx
  800420a7e8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a7ef:	00 00 00 
  800420a7f2:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420a7f9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a800:	00 00 00 
  800420a803:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420a80a:	08 00 
  800420a80c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a813:	00 00 00 
  800420a816:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a81d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a820:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a826:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a82d:	00 00 00 
  800420a830:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a837:	83 e2 07             	and    $0x7,%edx
  800420a83a:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a840:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a844:	74 07                	je     800420a84d <trap_init+0x164d>
  800420a846:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a84b:	eb 05                	jmp    800420a852 <trap_init+0x1652>
  800420a84d:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a852:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a859:	00 00 00 
  800420a85c:	89 d1                	mov    %edx,%ecx
  800420a85e:	83 e1 0f             	and    $0xf,%ecx
  800420a861:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a868:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a86b:	09 ca                	or     %ecx,%edx
  800420a86d:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a873:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a87a:	00 00 00 
  800420a87d:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a884:	83 e2 ef             	and    $0xffffffef,%edx
  800420a887:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a88d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420a890:	89 c2                	mov    %eax,%edx
  800420a892:	83 e2 03             	and    $0x3,%edx
  800420a895:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a89c:	00 00 00 
  800420a89f:	83 e2 03             	and    $0x3,%edx
  800420a8a2:	89 d1                	mov    %edx,%ecx
  800420a8a4:	c1 e1 05             	shl    $0x5,%ecx
  800420a8a7:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a8ae:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8b1:	09 ca                	or     %ecx,%edx
  800420a8b3:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a8b9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a8c0:	00 00 00 
  800420a8c3:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a8ca:	83 ca 80             	or     $0xffffff80,%edx
  800420a8cd:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a8d3:	48 b8 60 d0 20 04 80 	movabs $0x800420d060,%rax
  800420a8da:	00 00 00 
  800420a8dd:	48 c1 e8 10          	shr    $0x10,%rax
  800420a8e1:	89 c2                	mov    %eax,%edx
  800420a8e3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a8ea:	00 00 00 
  800420a8ed:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420a8f4:	48 b8 60 d0 20 04 80 	movabs $0x800420d060,%rax
  800420a8fb:	00 00 00 
  800420a8fe:	48 c1 e8 20          	shr    $0x20,%rax
  800420a902:	89 c2                	mov    %eax,%edx
  800420a904:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a90b:	00 00 00 
  800420a90e:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420a914:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a91b:	00 00 00 
  800420a91e:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a925:	00 00 00 

	
	SETGATE(idt[32], istrap, GD_KT, CSE_IRQ0, dpl);
  800420a928:	48 b8 6a d0 20 04 80 	movabs $0x800420d06a,%rax
  800420a92f:	00 00 00 
  800420a932:	89 c2                	mov    %eax,%edx
  800420a934:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a93b:	00 00 00 
  800420a93e:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a945:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a94c:	00 00 00 
  800420a94f:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a956:	08 00 
  800420a958:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a95f:	00 00 00 
  800420a962:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a969:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a96c:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a972:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a979:	00 00 00 
  800420a97c:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a983:	83 e2 07             	and    $0x7,%edx
  800420a986:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a98c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420a990:	74 07                	je     800420a999 <trap_init+0x1799>
  800420a992:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420a997:	eb 05                	jmp    800420a99e <trap_init+0x179e>
  800420a999:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420a99e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a9a5:	00 00 00 
  800420a9a8:	89 d1                	mov    %edx,%ecx
  800420a9aa:	83 e1 0f             	and    $0xf,%ecx
  800420a9ad:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a9b4:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9b7:	09 ca                	or     %ecx,%edx
  800420a9b9:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a9bf:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a9c6:	00 00 00 
  800420a9c9:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a9d0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9d3:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a9d9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420a9dc:	89 c2                	mov    %eax,%edx
  800420a9de:	83 e2 03             	and    $0x3,%edx
  800420a9e1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420a9e8:	00 00 00 
  800420a9eb:	83 e2 03             	and    $0x3,%edx
  800420a9ee:	89 d1                	mov    %edx,%ecx
  800420a9f0:	c1 e1 05             	shl    $0x5,%ecx
  800420a9f3:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a9fa:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a9fd:	09 ca                	or     %ecx,%edx
  800420a9ff:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420aa05:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aa0c:	00 00 00 
  800420aa0f:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420aa16:	83 ca 80             	or     $0xffffff80,%edx
  800420aa19:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420aa1f:	48 b8 6a d0 20 04 80 	movabs $0x800420d06a,%rax
  800420aa26:	00 00 00 
  800420aa29:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa2d:	89 c2                	mov    %eax,%edx
  800420aa2f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aa36:	00 00 00 
  800420aa39:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420aa40:	48 b8 6a d0 20 04 80 	movabs $0x800420d06a,%rax
  800420aa47:	00 00 00 
  800420aa4a:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa4e:	89 c2                	mov    %eax,%edx
  800420aa50:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aa57:	00 00 00 
  800420aa5a:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420aa60:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aa67:	00 00 00 
  800420aa6a:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420aa71:	00 00 00 
	SETGATE(idt[33], istrap, GD_KT, CSE_IRQ1, dpl);
  800420aa74:	48 b8 74 d0 20 04 80 	movabs $0x800420d074,%rax
  800420aa7b:	00 00 00 
  800420aa7e:	89 c2                	mov    %eax,%edx
  800420aa80:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aa87:	00 00 00 
  800420aa8a:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420aa91:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aa98:	00 00 00 
  800420aa9b:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420aaa2:	08 00 
  800420aaa4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aaab:	00 00 00 
  800420aaae:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420aab5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aab8:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420aabe:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aac5:	00 00 00 
  800420aac8:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420aacf:	83 e2 07             	and    $0x7,%edx
  800420aad2:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420aad8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420aadc:	74 07                	je     800420aae5 <trap_init+0x18e5>
  800420aade:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420aae3:	eb 05                	jmp    800420aaea <trap_init+0x18ea>
  800420aae5:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420aaea:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aaf1:	00 00 00 
  800420aaf4:	89 d1                	mov    %edx,%ecx
  800420aaf6:	83 e1 0f             	and    $0xf,%ecx
  800420aaf9:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ab00:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ab03:	09 ca                	or     %ecx,%edx
  800420ab05:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ab0b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ab12:	00 00 00 
  800420ab15:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ab1c:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab1f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ab25:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420ab28:	89 c2                	mov    %eax,%edx
  800420ab2a:	83 e2 03             	and    $0x3,%edx
  800420ab2d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ab34:	00 00 00 
  800420ab37:	83 e2 03             	and    $0x3,%edx
  800420ab3a:	89 d1                	mov    %edx,%ecx
  800420ab3c:	c1 e1 05             	shl    $0x5,%ecx
  800420ab3f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ab46:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ab49:	09 ca                	or     %ecx,%edx
  800420ab4b:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ab51:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ab58:	00 00 00 
  800420ab5b:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ab62:	83 ca 80             	or     $0xffffff80,%edx
  800420ab65:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ab6b:	48 b8 74 d0 20 04 80 	movabs $0x800420d074,%rax
  800420ab72:	00 00 00 
  800420ab75:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab79:	89 c2                	mov    %eax,%edx
  800420ab7b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ab82:	00 00 00 
  800420ab85:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420ab8c:	48 b8 74 d0 20 04 80 	movabs $0x800420d074,%rax
  800420ab93:	00 00 00 
  800420ab96:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab9a:	89 c2                	mov    %eax,%edx
  800420ab9c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aba3:	00 00 00 
  800420aba6:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420abac:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420abb3:	00 00 00 
  800420abb6:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420abbd:	00 00 00 
	SETGATE(idt[34], istrap, GD_KT, CSE_IRQ2, dpl);
  800420abc0:	48 b8 7e d0 20 04 80 	movabs $0x800420d07e,%rax
  800420abc7:	00 00 00 
  800420abca:	89 c2                	mov    %eax,%edx
  800420abcc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420abd3:	00 00 00 
  800420abd6:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420abdd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420abe4:	00 00 00 
  800420abe7:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420abee:	08 00 
  800420abf0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420abf7:	00 00 00 
  800420abfa:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420ac01:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac04:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420ac0a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ac11:	00 00 00 
  800420ac14:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420ac1b:	83 e2 07             	and    $0x7,%edx
  800420ac1e:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420ac24:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ac28:	74 07                	je     800420ac31 <trap_init+0x1a31>
  800420ac2a:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420ac2f:	eb 05                	jmp    800420ac36 <trap_init+0x1a36>
  800420ac31:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420ac36:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ac3d:	00 00 00 
  800420ac40:	89 d1                	mov    %edx,%ecx
  800420ac42:	83 e1 0f             	and    $0xf,%ecx
  800420ac45:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ac4c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ac4f:	09 ca                	or     %ecx,%edx
  800420ac51:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ac57:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ac5e:	00 00 00 
  800420ac61:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ac68:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac6b:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ac71:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420ac74:	89 c2                	mov    %eax,%edx
  800420ac76:	83 e2 03             	and    $0x3,%edx
  800420ac79:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ac80:	00 00 00 
  800420ac83:	83 e2 03             	and    $0x3,%edx
  800420ac86:	89 d1                	mov    %edx,%ecx
  800420ac88:	c1 e1 05             	shl    $0x5,%ecx
  800420ac8b:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420ac92:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac95:	09 ca                	or     %ecx,%edx
  800420ac97:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420ac9d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aca4:	00 00 00 
  800420aca7:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420acae:	83 ca 80             	or     $0xffffff80,%edx
  800420acb1:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420acb7:	48 b8 7e d0 20 04 80 	movabs $0x800420d07e,%rax
  800420acbe:	00 00 00 
  800420acc1:	48 c1 e8 10          	shr    $0x10,%rax
  800420acc5:	89 c2                	mov    %eax,%edx
  800420acc7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420acce:	00 00 00 
  800420acd1:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420acd8:	48 b8 7e d0 20 04 80 	movabs $0x800420d07e,%rax
  800420acdf:	00 00 00 
  800420ace2:	48 c1 e8 20          	shr    $0x20,%rax
  800420ace6:	89 c2                	mov    %eax,%edx
  800420ace8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420acef:	00 00 00 
  800420acf2:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420acf8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420acff:	00 00 00 
  800420ad02:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420ad09:	00 00 00 
	SETGATE(idt[35], istrap, GD_KT, CSE_IRQ3, dpl);
  800420ad0c:	48 b8 88 d0 20 04 80 	movabs $0x800420d088,%rax
  800420ad13:	00 00 00 
  800420ad16:	89 c2                	mov    %eax,%edx
  800420ad18:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ad1f:	00 00 00 
  800420ad22:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420ad29:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ad30:	00 00 00 
  800420ad33:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420ad3a:	08 00 
  800420ad3c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ad43:	00 00 00 
  800420ad46:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420ad4d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ad50:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420ad56:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ad5d:	00 00 00 
  800420ad60:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420ad67:	83 e2 07             	and    $0x7,%edx
  800420ad6a:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420ad70:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ad74:	74 07                	je     800420ad7d <trap_init+0x1b7d>
  800420ad76:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420ad7b:	eb 05                	jmp    800420ad82 <trap_init+0x1b82>
  800420ad7d:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420ad82:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ad89:	00 00 00 
  800420ad8c:	89 d1                	mov    %edx,%ecx
  800420ad8e:	83 e1 0f             	and    $0xf,%ecx
  800420ad91:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420ad98:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad9b:	09 ca                	or     %ecx,%edx
  800420ad9d:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420ada3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420adaa:	00 00 00 
  800420adad:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420adb4:	83 e2 ef             	and    $0xffffffef,%edx
  800420adb7:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420adbd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420adc0:	89 c2                	mov    %eax,%edx
  800420adc2:	83 e2 03             	and    $0x3,%edx
  800420adc5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420adcc:	00 00 00 
  800420adcf:	83 e2 03             	and    $0x3,%edx
  800420add2:	89 d1                	mov    %edx,%ecx
  800420add4:	c1 e1 05             	shl    $0x5,%ecx
  800420add7:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420adde:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ade1:	09 ca                	or     %ecx,%edx
  800420ade3:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420ade9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420adf0:	00 00 00 
  800420adf3:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420adfa:	83 ca 80             	or     $0xffffff80,%edx
  800420adfd:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420ae03:	48 b8 88 d0 20 04 80 	movabs $0x800420d088,%rax
  800420ae0a:	00 00 00 
  800420ae0d:	48 c1 e8 10          	shr    $0x10,%rax
  800420ae11:	89 c2                	mov    %eax,%edx
  800420ae13:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ae1a:	00 00 00 
  800420ae1d:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420ae24:	48 b8 88 d0 20 04 80 	movabs $0x800420d088,%rax
  800420ae2b:	00 00 00 
  800420ae2e:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae32:	89 c2                	mov    %eax,%edx
  800420ae34:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ae3b:	00 00 00 
  800420ae3e:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420ae44:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ae4b:	00 00 00 
  800420ae4e:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420ae55:	00 00 00 
	SETGATE(idt[36], istrap, GD_KT, CSE_IRQ4, dpl);
  800420ae58:	48 b8 92 d0 20 04 80 	movabs $0x800420d092,%rax
  800420ae5f:	00 00 00 
  800420ae62:	89 c2                	mov    %eax,%edx
  800420ae64:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ae6b:	00 00 00 
  800420ae6e:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420ae75:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ae7c:	00 00 00 
  800420ae7f:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420ae86:	08 00 
  800420ae88:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ae8f:	00 00 00 
  800420ae92:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420ae99:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ae9c:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420aea2:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aea9:	00 00 00 
  800420aeac:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420aeb3:	83 e2 07             	and    $0x7,%edx
  800420aeb6:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420aebc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420aec0:	74 07                	je     800420aec9 <trap_init+0x1cc9>
  800420aec2:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420aec7:	eb 05                	jmp    800420aece <trap_init+0x1cce>
  800420aec9:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420aece:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aed5:	00 00 00 
  800420aed8:	89 d1                	mov    %edx,%ecx
  800420aeda:	83 e1 0f             	and    $0xf,%ecx
  800420aedd:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420aee4:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aee7:	09 ca                	or     %ecx,%edx
  800420aee9:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420aeef:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aef6:	00 00 00 
  800420aef9:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420af00:	83 e2 ef             	and    $0xffffffef,%edx
  800420af03:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420af09:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420af0c:	89 c2                	mov    %eax,%edx
  800420af0e:	83 e2 03             	and    $0x3,%edx
  800420af11:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420af18:	00 00 00 
  800420af1b:	83 e2 03             	and    $0x3,%edx
  800420af1e:	89 d1                	mov    %edx,%ecx
  800420af20:	c1 e1 05             	shl    $0x5,%ecx
  800420af23:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420af2a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420af2d:	09 ca                	or     %ecx,%edx
  800420af2f:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420af35:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420af3c:	00 00 00 
  800420af3f:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420af46:	83 ca 80             	or     $0xffffff80,%edx
  800420af49:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420af4f:	48 b8 92 d0 20 04 80 	movabs $0x800420d092,%rax
  800420af56:	00 00 00 
  800420af59:	48 c1 e8 10          	shr    $0x10,%rax
  800420af5d:	89 c2                	mov    %eax,%edx
  800420af5f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420af66:	00 00 00 
  800420af69:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420af70:	48 b8 92 d0 20 04 80 	movabs $0x800420d092,%rax
  800420af77:	00 00 00 
  800420af7a:	48 c1 e8 20          	shr    $0x20,%rax
  800420af7e:	89 c2                	mov    %eax,%edx
  800420af80:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420af87:	00 00 00 
  800420af8a:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420af90:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420af97:	00 00 00 
  800420af9a:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420afa1:	00 00 00 
	SETGATE(idt[37], istrap, GD_KT, CSE_IRQ5, dpl);
  800420afa4:	48 b8 9c d0 20 04 80 	movabs $0x800420d09c,%rax
  800420afab:	00 00 00 
  800420afae:	89 c2                	mov    %eax,%edx
  800420afb0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420afb7:	00 00 00 
  800420afba:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420afc1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420afc8:	00 00 00 
  800420afcb:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420afd2:	08 00 
  800420afd4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420afdb:	00 00 00 
  800420afde:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420afe5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420afe8:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420afee:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420aff5:	00 00 00 
  800420aff8:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420afff:	83 e2 07             	and    $0x7,%edx
  800420b002:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b008:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b00c:	74 07                	je     800420b015 <trap_init+0x1e15>
  800420b00e:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b013:	eb 05                	jmp    800420b01a <trap_init+0x1e1a>
  800420b015:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b01a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b021:	00 00 00 
  800420b024:	89 d1                	mov    %edx,%ecx
  800420b026:	83 e1 0f             	and    $0xf,%ecx
  800420b029:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b030:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b033:	09 ca                	or     %ecx,%edx
  800420b035:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b03b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b042:	00 00 00 
  800420b045:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b04c:	83 e2 ef             	and    $0xffffffef,%edx
  800420b04f:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b055:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b058:	89 c2                	mov    %eax,%edx
  800420b05a:	83 e2 03             	and    $0x3,%edx
  800420b05d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b064:	00 00 00 
  800420b067:	83 e2 03             	and    $0x3,%edx
  800420b06a:	89 d1                	mov    %edx,%ecx
  800420b06c:	c1 e1 05             	shl    $0x5,%ecx
  800420b06f:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b076:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b079:	09 ca                	or     %ecx,%edx
  800420b07b:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b081:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b088:	00 00 00 
  800420b08b:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b092:	83 ca 80             	or     $0xffffff80,%edx
  800420b095:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b09b:	48 b8 9c d0 20 04 80 	movabs $0x800420d09c,%rax
  800420b0a2:	00 00 00 
  800420b0a5:	48 c1 e8 10          	shr    $0x10,%rax
  800420b0a9:	89 c2                	mov    %eax,%edx
  800420b0ab:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b0b2:	00 00 00 
  800420b0b5:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420b0bc:	48 b8 9c d0 20 04 80 	movabs $0x800420d09c,%rax
  800420b0c3:	00 00 00 
  800420b0c6:	48 c1 e8 20          	shr    $0x20,%rax
  800420b0ca:	89 c2                	mov    %eax,%edx
  800420b0cc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b0d3:	00 00 00 
  800420b0d6:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420b0dc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b0e3:	00 00 00 
  800420b0e6:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420b0ed:	00 00 00 
	SETGATE(idt[38], istrap, GD_KT, CSE_IRQ6, dpl);
  800420b0f0:	48 b8 a6 d0 20 04 80 	movabs $0x800420d0a6,%rax
  800420b0f7:	00 00 00 
  800420b0fa:	89 c2                	mov    %eax,%edx
  800420b0fc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b103:	00 00 00 
  800420b106:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420b10d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b114:	00 00 00 
  800420b117:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420b11e:	08 00 
  800420b120:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b127:	00 00 00 
  800420b12a:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b131:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b134:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b13a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b141:	00 00 00 
  800420b144:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b14b:	83 e2 07             	and    $0x7,%edx
  800420b14e:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b154:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b158:	74 07                	je     800420b161 <trap_init+0x1f61>
  800420b15a:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b15f:	eb 05                	jmp    800420b166 <trap_init+0x1f66>
  800420b161:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b166:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b16d:	00 00 00 
  800420b170:	89 d1                	mov    %edx,%ecx
  800420b172:	83 e1 0f             	and    $0xf,%ecx
  800420b175:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b17c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b17f:	09 ca                	or     %ecx,%edx
  800420b181:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b187:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b18e:	00 00 00 
  800420b191:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b198:	83 e2 ef             	and    $0xffffffef,%edx
  800420b19b:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b1a1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b1a4:	89 c2                	mov    %eax,%edx
  800420b1a6:	83 e2 03             	and    $0x3,%edx
  800420b1a9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b1b0:	00 00 00 
  800420b1b3:	83 e2 03             	and    $0x3,%edx
  800420b1b6:	89 d1                	mov    %edx,%ecx
  800420b1b8:	c1 e1 05             	shl    $0x5,%ecx
  800420b1bb:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b1c2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b1c5:	09 ca                	or     %ecx,%edx
  800420b1c7:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b1cd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b1d4:	00 00 00 
  800420b1d7:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b1de:	83 ca 80             	or     $0xffffff80,%edx
  800420b1e1:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b1e7:	48 b8 a6 d0 20 04 80 	movabs $0x800420d0a6,%rax
  800420b1ee:	00 00 00 
  800420b1f1:	48 c1 e8 10          	shr    $0x10,%rax
  800420b1f5:	89 c2                	mov    %eax,%edx
  800420b1f7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b1fe:	00 00 00 
  800420b201:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420b208:	48 b8 a6 d0 20 04 80 	movabs $0x800420d0a6,%rax
  800420b20f:	00 00 00 
  800420b212:	48 c1 e8 20          	shr    $0x20,%rax
  800420b216:	89 c2                	mov    %eax,%edx
  800420b218:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b21f:	00 00 00 
  800420b222:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420b228:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b22f:	00 00 00 
  800420b232:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420b239:	00 00 00 
	SETGATE(idt[39], istrap, GD_KT, CSE_IRQ7, dpl);
  800420b23c:	48 b8 b0 d0 20 04 80 	movabs $0x800420d0b0,%rax
  800420b243:	00 00 00 
  800420b246:	89 c2                	mov    %eax,%edx
  800420b248:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b24f:	00 00 00 
  800420b252:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420b259:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b260:	00 00 00 
  800420b263:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420b26a:	08 00 
  800420b26c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b273:	00 00 00 
  800420b276:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b27d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b280:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b286:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b28d:	00 00 00 
  800420b290:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b297:	83 e2 07             	and    $0x7,%edx
  800420b29a:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b2a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b2a4:	74 07                	je     800420b2ad <trap_init+0x20ad>
  800420b2a6:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b2ab:	eb 05                	jmp    800420b2b2 <trap_init+0x20b2>
  800420b2ad:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b2b2:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b2b9:	00 00 00 
  800420b2bc:	89 d1                	mov    %edx,%ecx
  800420b2be:	83 e1 0f             	and    $0xf,%ecx
  800420b2c1:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b2c8:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b2cb:	09 ca                	or     %ecx,%edx
  800420b2cd:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b2d3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b2da:	00 00 00 
  800420b2dd:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b2e4:	83 e2 ef             	and    $0xffffffef,%edx
  800420b2e7:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b2ed:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b2f0:	89 c2                	mov    %eax,%edx
  800420b2f2:	83 e2 03             	and    $0x3,%edx
  800420b2f5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b2fc:	00 00 00 
  800420b2ff:	83 e2 03             	and    $0x3,%edx
  800420b302:	89 d1                	mov    %edx,%ecx
  800420b304:	c1 e1 05             	shl    $0x5,%ecx
  800420b307:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b30e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b311:	09 ca                	or     %ecx,%edx
  800420b313:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b319:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b320:	00 00 00 
  800420b323:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b32a:	83 ca 80             	or     $0xffffff80,%edx
  800420b32d:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b333:	48 b8 b0 d0 20 04 80 	movabs $0x800420d0b0,%rax
  800420b33a:	00 00 00 
  800420b33d:	48 c1 e8 10          	shr    $0x10,%rax
  800420b341:	89 c2                	mov    %eax,%edx
  800420b343:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b34a:	00 00 00 
  800420b34d:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420b354:	48 b8 b0 d0 20 04 80 	movabs $0x800420d0b0,%rax
  800420b35b:	00 00 00 
  800420b35e:	48 c1 e8 20          	shr    $0x20,%rax
  800420b362:	89 c2                	mov    %eax,%edx
  800420b364:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b36b:	00 00 00 
  800420b36e:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420b374:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b37b:	00 00 00 
  800420b37e:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420b385:	00 00 00 
	SETGATE(idt[40], istrap, GD_KT, CSE_IRQ8, dpl);
  800420b388:	48 b8 ba d0 20 04 80 	movabs $0x800420d0ba,%rax
  800420b38f:	00 00 00 
  800420b392:	89 c2                	mov    %eax,%edx
  800420b394:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b39b:	00 00 00 
  800420b39e:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420b3a5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b3ac:	00 00 00 
  800420b3af:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420b3b6:	08 00 
  800420b3b8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b3bf:	00 00 00 
  800420b3c2:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b3c9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b3cc:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b3d2:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b3d9:	00 00 00 
  800420b3dc:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b3e3:	83 e2 07             	and    $0x7,%edx
  800420b3e6:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b3ec:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b3f0:	74 07                	je     800420b3f9 <trap_init+0x21f9>
  800420b3f2:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b3f7:	eb 05                	jmp    800420b3fe <trap_init+0x21fe>
  800420b3f9:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b3fe:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b405:	00 00 00 
  800420b408:	89 d1                	mov    %edx,%ecx
  800420b40a:	83 e1 0f             	and    $0xf,%ecx
  800420b40d:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b414:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b417:	09 ca                	or     %ecx,%edx
  800420b419:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b41f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b426:	00 00 00 
  800420b429:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b430:	83 e2 ef             	and    $0xffffffef,%edx
  800420b433:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b439:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b43c:	89 c2                	mov    %eax,%edx
  800420b43e:	83 e2 03             	and    $0x3,%edx
  800420b441:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b448:	00 00 00 
  800420b44b:	83 e2 03             	and    $0x3,%edx
  800420b44e:	89 d1                	mov    %edx,%ecx
  800420b450:	c1 e1 05             	shl    $0x5,%ecx
  800420b453:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b45a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b45d:	09 ca                	or     %ecx,%edx
  800420b45f:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b465:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b46c:	00 00 00 
  800420b46f:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b476:	83 ca 80             	or     $0xffffff80,%edx
  800420b479:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b47f:	48 b8 ba d0 20 04 80 	movabs $0x800420d0ba,%rax
  800420b486:	00 00 00 
  800420b489:	48 c1 e8 10          	shr    $0x10,%rax
  800420b48d:	89 c2                	mov    %eax,%edx
  800420b48f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b496:	00 00 00 
  800420b499:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420b4a0:	48 b8 ba d0 20 04 80 	movabs $0x800420d0ba,%rax
  800420b4a7:	00 00 00 
  800420b4aa:	48 c1 e8 20          	shr    $0x20,%rax
  800420b4ae:	89 c2                	mov    %eax,%edx
  800420b4b0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b4b7:	00 00 00 
  800420b4ba:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420b4c0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b4c7:	00 00 00 
  800420b4ca:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420b4d1:	00 00 00 
	SETGATE(idt[41], istrap, GD_KT, CSE_IRQ9, dpl);
  800420b4d4:	48 b8 c4 d0 20 04 80 	movabs $0x800420d0c4,%rax
  800420b4db:	00 00 00 
  800420b4de:	89 c2                	mov    %eax,%edx
  800420b4e0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b4e7:	00 00 00 
  800420b4ea:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420b4f1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b4f8:	00 00 00 
  800420b4fb:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420b502:	08 00 
  800420b504:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b50b:	00 00 00 
  800420b50e:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b515:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b518:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b51e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b525:	00 00 00 
  800420b528:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b52f:	83 e2 07             	and    $0x7,%edx
  800420b532:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b538:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b53c:	74 07                	je     800420b545 <trap_init+0x2345>
  800420b53e:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b543:	eb 05                	jmp    800420b54a <trap_init+0x234a>
  800420b545:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b54a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b551:	00 00 00 
  800420b554:	89 d1                	mov    %edx,%ecx
  800420b556:	83 e1 0f             	and    $0xf,%ecx
  800420b559:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b560:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b563:	09 ca                	or     %ecx,%edx
  800420b565:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b56b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b572:	00 00 00 
  800420b575:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b57c:	83 e2 ef             	and    $0xffffffef,%edx
  800420b57f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b585:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b588:	89 c2                	mov    %eax,%edx
  800420b58a:	83 e2 03             	and    $0x3,%edx
  800420b58d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b594:	00 00 00 
  800420b597:	83 e2 03             	and    $0x3,%edx
  800420b59a:	89 d1                	mov    %edx,%ecx
  800420b59c:	c1 e1 05             	shl    $0x5,%ecx
  800420b59f:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b5a6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b5a9:	09 ca                	or     %ecx,%edx
  800420b5ab:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b5b1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b5b8:	00 00 00 
  800420b5bb:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b5c2:	83 ca 80             	or     $0xffffff80,%edx
  800420b5c5:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b5cb:	48 b8 c4 d0 20 04 80 	movabs $0x800420d0c4,%rax
  800420b5d2:	00 00 00 
  800420b5d5:	48 c1 e8 10          	shr    $0x10,%rax
  800420b5d9:	89 c2                	mov    %eax,%edx
  800420b5db:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b5e2:	00 00 00 
  800420b5e5:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420b5ec:	48 b8 c4 d0 20 04 80 	movabs $0x800420d0c4,%rax
  800420b5f3:	00 00 00 
  800420b5f6:	48 c1 e8 20          	shr    $0x20,%rax
  800420b5fa:	89 c2                	mov    %eax,%edx
  800420b5fc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b603:	00 00 00 
  800420b606:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420b60c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b613:	00 00 00 
  800420b616:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420b61d:	00 00 00 
	SETGATE(idt[42], istrap, GD_KT, CSE_IRQ10, dpl);
  800420b620:	48 b8 ce d0 20 04 80 	movabs $0x800420d0ce,%rax
  800420b627:	00 00 00 
  800420b62a:	89 c2                	mov    %eax,%edx
  800420b62c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b633:	00 00 00 
  800420b636:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420b63d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b644:	00 00 00 
  800420b647:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b64e:	08 00 
  800420b650:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b657:	00 00 00 
  800420b65a:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b661:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b664:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b66a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b671:	00 00 00 
  800420b674:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b67b:	83 e2 07             	and    $0x7,%edx
  800420b67e:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b684:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b688:	74 07                	je     800420b691 <trap_init+0x2491>
  800420b68a:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b68f:	eb 05                	jmp    800420b696 <trap_init+0x2496>
  800420b691:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b696:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b69d:	00 00 00 
  800420b6a0:	89 d1                	mov    %edx,%ecx
  800420b6a2:	83 e1 0f             	and    $0xf,%ecx
  800420b6a5:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b6ac:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b6af:	09 ca                	or     %ecx,%edx
  800420b6b1:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b6b7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b6be:	00 00 00 
  800420b6c1:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b6c8:	83 e2 ef             	and    $0xffffffef,%edx
  800420b6cb:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b6d1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b6d4:	89 c2                	mov    %eax,%edx
  800420b6d6:	83 e2 03             	and    $0x3,%edx
  800420b6d9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b6e0:	00 00 00 
  800420b6e3:	83 e2 03             	and    $0x3,%edx
  800420b6e6:	89 d1                	mov    %edx,%ecx
  800420b6e8:	c1 e1 05             	shl    $0x5,%ecx
  800420b6eb:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b6f2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b6f5:	09 ca                	or     %ecx,%edx
  800420b6f7:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b6fd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b704:	00 00 00 
  800420b707:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b70e:	83 ca 80             	or     $0xffffff80,%edx
  800420b711:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b717:	48 b8 ce d0 20 04 80 	movabs $0x800420d0ce,%rax
  800420b71e:	00 00 00 
  800420b721:	48 c1 e8 10          	shr    $0x10,%rax
  800420b725:	89 c2                	mov    %eax,%edx
  800420b727:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b72e:	00 00 00 
  800420b731:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b738:	48 b8 ce d0 20 04 80 	movabs $0x800420d0ce,%rax
  800420b73f:	00 00 00 
  800420b742:	48 c1 e8 20          	shr    $0x20,%rax
  800420b746:	89 c2                	mov    %eax,%edx
  800420b748:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b74f:	00 00 00 
  800420b752:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b758:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b75f:	00 00 00 
  800420b762:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b769:	00 00 00 
	SETGATE(idt[43], istrap, GD_KT, CSE_IRQ11, dpl);
  800420b76c:	48 b8 d8 d0 20 04 80 	movabs $0x800420d0d8,%rax
  800420b773:	00 00 00 
  800420b776:	89 c2                	mov    %eax,%edx
  800420b778:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b77f:	00 00 00 
  800420b782:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b789:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b790:	00 00 00 
  800420b793:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b79a:	08 00 
  800420b79c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b7a3:	00 00 00 
  800420b7a6:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b7ad:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b7b0:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b7b6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b7bd:	00 00 00 
  800420b7c0:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b7c7:	83 e2 07             	and    $0x7,%edx
  800420b7ca:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b7d0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b7d4:	74 07                	je     800420b7dd <trap_init+0x25dd>
  800420b7d6:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b7db:	eb 05                	jmp    800420b7e2 <trap_init+0x25e2>
  800420b7dd:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b7e2:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b7e9:	00 00 00 
  800420b7ec:	89 d1                	mov    %edx,%ecx
  800420b7ee:	83 e1 0f             	and    $0xf,%ecx
  800420b7f1:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b7f8:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b7fb:	09 ca                	or     %ecx,%edx
  800420b7fd:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b803:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b80a:	00 00 00 
  800420b80d:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b814:	83 e2 ef             	and    $0xffffffef,%edx
  800420b817:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b81d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b820:	89 c2                	mov    %eax,%edx
  800420b822:	83 e2 03             	and    $0x3,%edx
  800420b825:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b82c:	00 00 00 
  800420b82f:	83 e2 03             	and    $0x3,%edx
  800420b832:	89 d1                	mov    %edx,%ecx
  800420b834:	c1 e1 05             	shl    $0x5,%ecx
  800420b837:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b83e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b841:	09 ca                	or     %ecx,%edx
  800420b843:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b849:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b850:	00 00 00 
  800420b853:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b85a:	83 ca 80             	or     $0xffffff80,%edx
  800420b85d:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b863:	48 b8 d8 d0 20 04 80 	movabs $0x800420d0d8,%rax
  800420b86a:	00 00 00 
  800420b86d:	48 c1 e8 10          	shr    $0x10,%rax
  800420b871:	89 c2                	mov    %eax,%edx
  800420b873:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b87a:	00 00 00 
  800420b87d:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b884:	48 b8 d8 d0 20 04 80 	movabs $0x800420d0d8,%rax
  800420b88b:	00 00 00 
  800420b88e:	48 c1 e8 20          	shr    $0x20,%rax
  800420b892:	89 c2                	mov    %eax,%edx
  800420b894:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b89b:	00 00 00 
  800420b89e:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b8a4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b8ab:	00 00 00 
  800420b8ae:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b8b5:	00 00 00 
	SETGATE(idt[44], istrap, GD_KT, CSE_IRQ12, dpl);
  800420b8b8:	48 b8 e2 d0 20 04 80 	movabs $0x800420d0e2,%rax
  800420b8bf:	00 00 00 
  800420b8c2:	89 c2                	mov    %eax,%edx
  800420b8c4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b8cb:	00 00 00 
  800420b8ce:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b8d5:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b8dc:	00 00 00 
  800420b8df:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b8e6:	08 00 
  800420b8e8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b8ef:	00 00 00 
  800420b8f2:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b8f9:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b8fc:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b902:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b909:	00 00 00 
  800420b90c:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b913:	83 e2 07             	and    $0x7,%edx
  800420b916:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b91c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420b920:	74 07                	je     800420b929 <trap_init+0x2729>
  800420b922:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420b927:	eb 05                	jmp    800420b92e <trap_init+0x272e>
  800420b929:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420b92e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b935:	00 00 00 
  800420b938:	89 d1                	mov    %edx,%ecx
  800420b93a:	83 e1 0f             	and    $0xf,%ecx
  800420b93d:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b944:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b947:	09 ca                	or     %ecx,%edx
  800420b949:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b94f:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b956:	00 00 00 
  800420b959:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b960:	83 e2 ef             	and    $0xffffffef,%edx
  800420b963:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b969:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420b96c:	89 c2                	mov    %eax,%edx
  800420b96e:	83 e2 03             	and    $0x3,%edx
  800420b971:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b978:	00 00 00 
  800420b97b:	83 e2 03             	and    $0x3,%edx
  800420b97e:	89 d1                	mov    %edx,%ecx
  800420b980:	c1 e1 05             	shl    $0x5,%ecx
  800420b983:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b98a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b98d:	09 ca                	or     %ecx,%edx
  800420b98f:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b995:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b99c:	00 00 00 
  800420b99f:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b9a6:	83 ca 80             	or     $0xffffff80,%edx
  800420b9a9:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b9af:	48 b8 e2 d0 20 04 80 	movabs $0x800420d0e2,%rax
  800420b9b6:	00 00 00 
  800420b9b9:	48 c1 e8 10          	shr    $0x10,%rax
  800420b9bd:	89 c2                	mov    %eax,%edx
  800420b9bf:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b9c6:	00 00 00 
  800420b9c9:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420b9d0:	48 b8 e2 d0 20 04 80 	movabs $0x800420d0e2,%rax
  800420b9d7:	00 00 00 
  800420b9da:	48 c1 e8 20          	shr    $0x20,%rax
  800420b9de:	89 c2                	mov    %eax,%edx
  800420b9e0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b9e7:	00 00 00 
  800420b9ea:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420b9f0:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420b9f7:	00 00 00 
  800420b9fa:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420ba01:	00 00 00 
	SETGATE(idt[45], istrap, GD_KT, CSE_IRQ13, dpl);
  800420ba04:	48 b8 ec d0 20 04 80 	movabs $0x800420d0ec,%rax
  800420ba0b:	00 00 00 
  800420ba0e:	89 c2                	mov    %eax,%edx
  800420ba10:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ba17:	00 00 00 
  800420ba1a:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420ba21:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ba28:	00 00 00 
  800420ba2b:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420ba32:	08 00 
  800420ba34:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ba3b:	00 00 00 
  800420ba3e:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420ba45:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ba48:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420ba4e:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ba55:	00 00 00 
  800420ba58:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420ba5f:	83 e2 07             	and    $0x7,%edx
  800420ba62:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420ba68:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ba6c:	74 07                	je     800420ba75 <trap_init+0x2875>
  800420ba6e:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420ba73:	eb 05                	jmp    800420ba7a <trap_init+0x287a>
  800420ba75:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420ba7a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420ba81:	00 00 00 
  800420ba84:	89 d1                	mov    %edx,%ecx
  800420ba86:	83 e1 0f             	and    $0xf,%ecx
  800420ba89:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ba90:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ba93:	09 ca                	or     %ecx,%edx
  800420ba95:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ba9b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420baa2:	00 00 00 
  800420baa5:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420baac:	83 e2 ef             	and    $0xffffffef,%edx
  800420baaf:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bab5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420bab8:	89 c2                	mov    %eax,%edx
  800420baba:	83 e2 03             	and    $0x3,%edx
  800420babd:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bac4:	00 00 00 
  800420bac7:	83 e2 03             	and    $0x3,%edx
  800420baca:	89 d1                	mov    %edx,%ecx
  800420bacc:	c1 e1 05             	shl    $0x5,%ecx
  800420bacf:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bad6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bad9:	09 ca                	or     %ecx,%edx
  800420badb:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bae1:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bae8:	00 00 00 
  800420baeb:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420baf2:	83 ca 80             	or     $0xffffff80,%edx
  800420baf5:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bafb:	48 b8 ec d0 20 04 80 	movabs $0x800420d0ec,%rax
  800420bb02:	00 00 00 
  800420bb05:	48 c1 e8 10          	shr    $0x10,%rax
  800420bb09:	89 c2                	mov    %eax,%edx
  800420bb0b:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bb12:	00 00 00 
  800420bb15:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420bb1c:	48 b8 ec d0 20 04 80 	movabs $0x800420d0ec,%rax
  800420bb23:	00 00 00 
  800420bb26:	48 c1 e8 20          	shr    $0x20,%rax
  800420bb2a:	89 c2                	mov    %eax,%edx
  800420bb2c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bb33:	00 00 00 
  800420bb36:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420bb3c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bb43:	00 00 00 
  800420bb46:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420bb4d:	00 00 00 
	SETGATE(idt[46], istrap, GD_KT, CSE_IRQ14, dpl);
  800420bb50:	48 b8 f6 d0 20 04 80 	movabs $0x800420d0f6,%rax
  800420bb57:	00 00 00 
  800420bb5a:	89 c2                	mov    %eax,%edx
  800420bb5c:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bb63:	00 00 00 
  800420bb66:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420bb6d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bb74:	00 00 00 
  800420bb77:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420bb7e:	08 00 
  800420bb80:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bb87:	00 00 00 
  800420bb8a:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bb91:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bb94:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bb9a:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bba1:	00 00 00 
  800420bba4:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bbab:	83 e2 07             	and    $0x7,%edx
  800420bbae:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bbb4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420bbb8:	74 07                	je     800420bbc1 <trap_init+0x29c1>
  800420bbba:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420bbbf:	eb 05                	jmp    800420bbc6 <trap_init+0x29c6>
  800420bbc1:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420bbc6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bbcd:	00 00 00 
  800420bbd0:	89 d1                	mov    %edx,%ecx
  800420bbd2:	83 e1 0f             	and    $0xf,%ecx
  800420bbd5:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bbdc:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bbdf:	09 ca                	or     %ecx,%edx
  800420bbe1:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bbe7:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bbee:	00 00 00 
  800420bbf1:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bbf8:	83 e2 ef             	and    $0xffffffef,%edx
  800420bbfb:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc01:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420bc04:	89 c2                	mov    %eax,%edx
  800420bc06:	83 e2 03             	and    $0x3,%edx
  800420bc09:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bc10:	00 00 00 
  800420bc13:	83 e2 03             	and    $0x3,%edx
  800420bc16:	89 d1                	mov    %edx,%ecx
  800420bc18:	c1 e1 05             	shl    $0x5,%ecx
  800420bc1b:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bc22:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bc25:	09 ca                	or     %ecx,%edx
  800420bc27:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc2d:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bc34:	00 00 00 
  800420bc37:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bc3e:	83 ca 80             	or     $0xffffff80,%edx
  800420bc41:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bc47:	48 b8 f6 d0 20 04 80 	movabs $0x800420d0f6,%rax
  800420bc4e:	00 00 00 
  800420bc51:	48 c1 e8 10          	shr    $0x10,%rax
  800420bc55:	89 c2                	mov    %eax,%edx
  800420bc57:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bc5e:	00 00 00 
  800420bc61:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420bc68:	48 b8 f6 d0 20 04 80 	movabs $0x800420d0f6,%rax
  800420bc6f:	00 00 00 
  800420bc72:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc76:	89 c2                	mov    %eax,%edx
  800420bc78:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bc7f:	00 00 00 
  800420bc82:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420bc88:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bc8f:	00 00 00 
  800420bc92:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420bc99:	00 00 00 
	SETGATE(idt[47], istrap, GD_KT, CSE_IRQ15, dpl);
  800420bc9c:	48 b8 00 d1 20 04 80 	movabs $0x800420d100,%rax
  800420bca3:	00 00 00 
  800420bca6:	89 c2                	mov    %eax,%edx
  800420bca8:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bcaf:	00 00 00 
  800420bcb2:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420bcb9:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bcc0:	00 00 00 
  800420bcc3:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420bcca:	08 00 
  800420bccc:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bcd3:	00 00 00 
  800420bcd6:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420bcdd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bce0:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420bce6:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bced:	00 00 00 
  800420bcf0:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420bcf7:	83 e2 07             	and    $0x7,%edx
  800420bcfa:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420bd00:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420bd04:	74 07                	je     800420bd0d <trap_init+0x2b0d>
  800420bd06:	ba 0f 00 00 00       	mov    $0xf,%edx
  800420bd0b:	eb 05                	jmp    800420bd12 <trap_init+0x2b12>
  800420bd0d:	ba 0e 00 00 00       	mov    $0xe,%edx
  800420bd12:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bd19:	00 00 00 
  800420bd1c:	89 d1                	mov    %edx,%ecx
  800420bd1e:	83 e1 0f             	and    $0xf,%ecx
  800420bd21:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd28:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bd2b:	09 ca                	or     %ecx,%edx
  800420bd2d:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd33:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bd3a:	00 00 00 
  800420bd3d:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd44:	83 e2 ef             	and    $0xffffffef,%edx
  800420bd47:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd4d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420bd50:	89 c2                	mov    %eax,%edx
  800420bd52:	83 e2 03             	and    $0x3,%edx
  800420bd55:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bd5c:	00 00 00 
  800420bd5f:	83 e2 03             	and    $0x3,%edx
  800420bd62:	89 d1                	mov    %edx,%ecx
  800420bd64:	c1 e1 05             	shl    $0x5,%ecx
  800420bd67:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd6e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bd71:	09 ca                	or     %ecx,%edx
  800420bd73:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd79:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bd80:	00 00 00 
  800420bd83:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420bd8a:	83 ca 80             	or     $0xffffff80,%edx
  800420bd8d:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420bd93:	48 b8 00 d1 20 04 80 	movabs $0x800420d100,%rax
  800420bd9a:	00 00 00 
  800420bd9d:	48 c1 e8 10          	shr    $0x10,%rax
  800420bda1:	89 c2                	mov    %eax,%edx
  800420bda3:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bdaa:	00 00 00 
  800420bdad:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420bdb4:	48 b8 00 d1 20 04 80 	movabs $0x800420d100,%rax
  800420bdbb:	00 00 00 
  800420bdbe:	48 c1 e8 20          	shr    $0x20,%rax
  800420bdc2:	89 c2                	mov    %eax,%edx
  800420bdc4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bdcb:	00 00 00 
  800420bdce:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420bdd4:	48 b8 80 22 48 04 80 	movabs $0x8004482280,%rax
  800420bddb:	00 00 00 
  800420bdde:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420bde5:	00 00 00 


	// LAB 3: Your code here.
	idt_pd.pd_lim = sizeof(idt)-1;
  800420bde8:	48 b8 80 32 48 04 80 	movabs $0x8004483280,%rax
  800420bdef:	00 00 00 
  800420bdf2:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420bdf7:	48 ba 80 22 48 04 80 	movabs $0x8004482280,%rdx
  800420bdfe:	00 00 00 
  800420be01:	48 b8 80 32 48 04 80 	movabs $0x8004483280,%rax
  800420be08:	00 00 00 
  800420be0b:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420be0f:	48 b8 1d be 20 04 80 	movabs $0x800420be1d,%rax
  800420be16:	00 00 00 
  800420be19:	ff d0                	callq  *%rax
}
  800420be1b:	c9                   	leaveq 
  800420be1c:	c3                   	retq   

000000800420be1d <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420be1d:	55                   	push   %rbp
  800420be1e:	48 89 e5             	mov    %rsp,%rbp
  800420be21:	53                   	push   %rbx
  800420be22:	48 83 ec 28          	sub    $0x28,%rsp
	//
	// LAB 4: Your code here:

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	int id = thiscpu->cpu_id;
  800420be26:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420be2d:	00 00 00 
  800420be30:	ff d0                	callq  *%rax
  800420be32:	48 98                	cltq   
  800420be34:	48 c1 e0 03          	shl    $0x3,%rax
  800420be38:	48 89 c2             	mov    %rax,%rdx
  800420be3b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be3f:	48 01 c2             	add    %rax,%rdx
  800420be42:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420be49:	00 00 00 
  800420be4c:	48 01 d0             	add    %rdx,%rax
  800420be4f:	0f b6 00             	movzbl (%rax),%eax
  800420be52:	0f b6 c0             	movzbl %al,%eax
  800420be55:	89 45 ec             	mov    %eax,-0x14(%rbp)
	size_t kstacktop_ncpus = KSTACKTOP - id*(KSTKSIZE+KSTKGAP);
  800420be58:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420be5b:	89 d0                	mov    %edx,%eax
  800420be5d:	01 c0                	add    %eax,%eax
  800420be5f:	01 d0                	add    %edx,%eax
  800420be61:	c1 e0 0f             	shl    $0xf,%eax
  800420be64:	48 98                	cltq   
  800420be66:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420be6d:	00 00 00 
  800420be70:	48 89 d1             	mov    %rdx,%rcx
  800420be73:	48 29 c1             	sub    %rax,%rcx
  800420be76:	48 89 c8             	mov    %rcx,%rax
  800420be79:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	thiscpu->cpu_ts.ts_esp0 = kstacktop_ncpus;
  800420be7d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420be84:	00 00 00 
  800420be87:	ff d0                	callq  *%rax
  800420be89:	48 98                	cltq   
  800420be8b:	48 c1 e0 03          	shl    $0x3,%rax
  800420be8f:	48 89 c2             	mov    %rax,%rdx
  800420be92:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be96:	48 01 c2             	add    %rax,%rdx
  800420be99:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420bea0:	00 00 00 
  800420bea3:	48 01 c2             	add    %rax,%rdx
  800420bea6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420beaa:	48 89 42 14          	mov    %rax,0x14(%rdx)
	SETTSS((struct SystemSegdesc64 *)(&gdt[(GD_TSS0>>3)+2*id]),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420beae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420beb1:	48 98                	cltq   
  800420beb3:	48 c1 e0 04          	shl    $0x4,%rax
  800420beb7:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bebb:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bec2:	00 00 00 
  800420bec5:	48 01 d0             	add    %rdx,%rax
  800420bec8:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420becd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bed0:	48 98                	cltq   
  800420bed2:	48 c1 e0 04          	shl    $0x4,%rax
  800420bed6:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420beda:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bee1:	00 00 00 
  800420bee4:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bee8:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420beef:	00 00 00 
  800420bef2:	ff d0                	callq  *%rax
  800420bef4:	48 98                	cltq   
  800420bef6:	48 c1 e0 03          	shl    $0x3,%rax
  800420befa:	48 89 c2             	mov    %rax,%rdx
  800420befd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf01:	48 01 c2             	add    %rax,%rdx
  800420bf04:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420bf0b:	00 00 00 
  800420bf0e:	48 01 d0             	add    %rdx,%rax
  800420bf11:	48 83 c0 10          	add    $0x10,%rax
  800420bf15:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420bf19:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bf1c:	48 98                	cltq   
  800420bf1e:	48 c1 e0 04          	shl    $0x4,%rax
  800420bf22:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bf26:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bf2d:	00 00 00 
  800420bf30:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bf34:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420bf3b:	00 00 00 
  800420bf3e:	ff d0                	callq  *%rax
  800420bf40:	48 98                	cltq   
  800420bf42:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf46:	48 89 c2             	mov    %rax,%rdx
  800420bf49:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bf4d:	48 01 c2             	add    %rax,%rdx
  800420bf50:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420bf57:	00 00 00 
  800420bf5a:	48 01 d0             	add    %rdx,%rax
  800420bf5d:	48 83 c0 10          	add    $0x10,%rax
  800420bf61:	48 c1 e8 10          	shr    $0x10,%rax
  800420bf65:	88 43 04             	mov    %al,0x4(%rbx)
  800420bf68:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bf6b:	48 98                	cltq   
  800420bf6d:	48 c1 e0 04          	shl    $0x4,%rax
  800420bf71:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bf75:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bf7c:	00 00 00 
  800420bf7f:	48 01 d0             	add    %rdx,%rax
  800420bf82:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bf86:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bf89:	83 ca 09             	or     $0x9,%edx
  800420bf8c:	88 50 05             	mov    %dl,0x5(%rax)
  800420bf8f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bf92:	48 98                	cltq   
  800420bf94:	48 c1 e0 04          	shl    $0x4,%rax
  800420bf98:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bf9c:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bfa3:	00 00 00 
  800420bfa6:	48 01 d0             	add    %rdx,%rax
  800420bfa9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bfad:	83 e2 ef             	and    $0xffffffef,%edx
  800420bfb0:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfb3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bfb6:	48 98                	cltq   
  800420bfb8:	48 c1 e0 04          	shl    $0x4,%rax
  800420bfbc:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bfc0:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bfc7:	00 00 00 
  800420bfca:	48 01 d0             	add    %rdx,%rax
  800420bfcd:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bfd1:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bfd4:	88 50 05             	mov    %dl,0x5(%rax)
  800420bfd7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bfda:	48 98                	cltq   
  800420bfdc:	48 c1 e0 04          	shl    $0x4,%rax
  800420bfe0:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420bfe4:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420bfeb:	00 00 00 
  800420bfee:	48 01 d0             	add    %rdx,%rax
  800420bff1:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bff5:	83 ca 80             	or     $0xffffff80,%edx
  800420bff8:	88 50 05             	mov    %dl,0x5(%rax)
  800420bffb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420bffe:	48 98                	cltq   
  800420c000:	48 c1 e0 04          	shl    $0x4,%rax
  800420c004:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c008:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c00f:	00 00 00 
  800420c012:	48 01 d0             	add    %rdx,%rax
  800420c015:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c019:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c01c:	88 50 06             	mov    %dl,0x6(%rax)
  800420c01f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c022:	48 98                	cltq   
  800420c024:	48 c1 e0 04          	shl    $0x4,%rax
  800420c028:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c02c:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c033:	00 00 00 
  800420c036:	48 01 d0             	add    %rdx,%rax
  800420c039:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c03d:	83 e2 ef             	and    $0xffffffef,%edx
  800420c040:	88 50 06             	mov    %dl,0x6(%rax)
  800420c043:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c046:	48 98                	cltq   
  800420c048:	48 c1 e0 04          	shl    $0x4,%rax
  800420c04c:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c050:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c057:	00 00 00 
  800420c05a:	48 01 d0             	add    %rdx,%rax
  800420c05d:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c061:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c064:	88 50 06             	mov    %dl,0x6(%rax)
  800420c067:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c06a:	48 98                	cltq   
  800420c06c:	48 c1 e0 04          	shl    $0x4,%rax
  800420c070:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c074:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c07b:	00 00 00 
  800420c07e:	48 01 d0             	add    %rdx,%rax
  800420c081:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c085:	83 e2 7f             	and    $0x7f,%edx
  800420c088:	88 50 06             	mov    %dl,0x6(%rax)
  800420c08b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c08e:	48 98                	cltq   
  800420c090:	48 c1 e0 04          	shl    $0x4,%rax
  800420c094:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c098:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c09f:	00 00 00 
  800420c0a2:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420c0a6:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420c0ad:	00 00 00 
  800420c0b0:	ff d0                	callq  *%rax
  800420c0b2:	48 98                	cltq   
  800420c0b4:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0b8:	48 89 c2             	mov    %rax,%rdx
  800420c0bb:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0bf:	48 01 c2             	add    %rax,%rdx
  800420c0c2:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420c0c9:	00 00 00 
  800420c0cc:	48 01 d0             	add    %rdx,%rax
  800420c0cf:	48 83 c0 10          	add    $0x10,%rax
  800420c0d3:	48 c1 e8 18          	shr    $0x18,%rax
  800420c0d7:	88 43 07             	mov    %al,0x7(%rbx)
  800420c0da:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c0dd:	48 98                	cltq   
  800420c0df:	48 c1 e0 04          	shl    $0x4,%rax
  800420c0e3:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c0e7:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c0ee:	00 00 00 
  800420c0f1:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420c0f5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420c0fc:	00 00 00 
  800420c0ff:	ff d0                	callq  *%rax
  800420c101:	48 98                	cltq   
  800420c103:	48 c1 e0 03          	shl    $0x3,%rax
  800420c107:	48 89 c2             	mov    %rax,%rdx
  800420c10a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c10e:	48 01 c2             	add    %rax,%rdx
  800420c111:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420c118:	00 00 00 
  800420c11b:	48 01 d0             	add    %rdx,%rax
  800420c11e:	48 83 c0 10          	add    $0x10,%rax
  800420c122:	48 c1 e8 20          	shr    $0x20,%rax
  800420c126:	89 43 08             	mov    %eax,0x8(%rbx)
  800420c129:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c12c:	48 98                	cltq   
  800420c12e:	48 c1 e0 04          	shl    $0x4,%rax
  800420c132:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c136:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c13d:	00 00 00 
  800420c140:	48 01 d0             	add    %rdx,%rax
  800420c143:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420c147:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c14a:	48 98                	cltq   
  800420c14c:	48 c1 e0 04          	shl    $0x4,%rax
  800420c150:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c154:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c15b:	00 00 00 
  800420c15e:	48 01 d0             	add    %rdx,%rax
  800420c161:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420c165:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c168:	48 98                	cltq   
  800420c16a:	48 c1 e0 04          	shl    $0x4,%rax
  800420c16e:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420c172:	48 b8 c0 05 23 04 80 	movabs $0x80042305c0,%rax
  800420c179:	00 00 00 
  800420c17c:	48 01 d0             	add    %rdx,%rax
  800420c17f:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)

	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40),STS_T64A, (uint64_t) (&ts),sizeof(struct Taskstate), 0);
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)	*/
	ltr(GD_TSS0 + ((2*id << 3) & (~0x7)));
  800420c185:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c188:	01 c0                	add    %eax,%eax
  800420c18a:	c1 e0 03             	shl    $0x3,%eax
  800420c18d:	83 c0 28             	add    $0x28,%eax
  800420c190:	0f b7 c0             	movzwl %ax,%eax
  800420c193:	66 89 45 de          	mov    %ax,-0x22(%rbp)
    __asm __volatile("lgdt (%0)" : : "r" (p));
}
    static __inline void
ltr(uint16_t sel)
{
    __asm __volatile("ltr %0" : : "r" (sel));
  800420c197:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  800420c19b:	0f 00 d8             	ltr    %ax
  800420c19e:	48 b8 80 32 48 04 80 	movabs $0x8004483280,%rax
  800420c1a5:	00 00 00 
  800420c1a8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
}  

    static __inline void
lidt(void *p)
{
    __asm __volatile("lidt (%0)" : : "r" (p));
  800420c1ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c1b0:	0f 01 18             	lidt   (%rax)
	//ltr(GD_TSS0+2*id);
	
	// Load the IDT
	lidt(&idt_pd);
}
  800420c1b3:	48 83 c4 28          	add    $0x28,%rsp
  800420c1b7:	5b                   	pop    %rbx
  800420c1b8:	5d                   	pop    %rbp
  800420c1b9:	c3                   	retq   

000000800420c1ba <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420c1ba:	55                   	push   %rbp
  800420c1bb:	48 89 e5             	mov    %rsp,%rbp
  800420c1be:	53                   	push   %rbx
  800420c1bf:	48 83 ec 28          	sub    $0x28,%rsp
  800420c1c3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420c1c7:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420c1ce:	00 00 00 
  800420c1d1:	ff d0                	callq  *%rax
  800420c1d3:	89 c2                	mov    %eax,%edx
  800420c1d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c1d9:	48 89 c6             	mov    %rax,%rsi
  800420c1dc:	48 bf 8e d7 21 04 80 	movabs $0x800421d78e,%rdi
  800420c1e3:	00 00 00 
  800420c1e6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1eb:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420c1f2:	00 00 00 
  800420c1f5:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420c1f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c1fb:	48 89 c7             	mov    %rax,%rdi
  800420c1fe:	48 b8 d0 c4 20 04 80 	movabs $0x800420c4d0,%rax
  800420c205:	00 00 00 
  800420c208:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420c20a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c20e:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420c212:	0f b7 c0             	movzwl %ax,%eax
  800420c215:	89 c6                	mov    %eax,%esi
  800420c217:	48 bf ac d7 21 04 80 	movabs $0x800421d7ac,%rdi
  800420c21e:	00 00 00 
  800420c221:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c226:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c22d:	00 00 00 
  800420c230:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420c232:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c236:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420c23d:	0f b7 c0             	movzwl %ax,%eax
  800420c240:	89 c6                	mov    %eax,%esi
  800420c242:	48 bf bf d7 21 04 80 	movabs $0x800421d7bf,%rdi
  800420c249:	00 00 00 
  800420c24c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c251:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c258:	00 00 00 
  800420c25b:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420c25d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c261:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c268:	89 c7                	mov    %eax,%edi
  800420c26a:	48 b8 a1 91 20 04 80 	movabs $0x80042091a1,%rax
  800420c271:	00 00 00 
  800420c274:	ff d0                	callq  *%rax
  800420c276:	48 89 c2             	mov    %rax,%rdx
  800420c279:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c27d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c284:	48 89 c6             	mov    %rax,%rsi
  800420c287:	48 bf d2 d7 21 04 80 	movabs $0x800421d7d2,%rdi
  800420c28e:	00 00 00 
  800420c291:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c296:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420c29d:	00 00 00 
  800420c2a0:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420c2a2:	48 b8 90 32 48 04 80 	movabs $0x8004483290,%rax
  800420c2a9:	00 00 00 
  800420c2ac:	48 8b 00             	mov    (%rax),%rax
  800420c2af:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420c2b3:	75 3a                	jne    800420c2ef <print_trapframe+0x135>
  800420c2b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c2b9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c2c0:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c2c4:	75 29                	jne    800420c2ef <print_trapframe+0x135>

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c2c6:	0f 20 d3             	mov    %cr2,%rbx
  800420c2c9:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
    return val;
  800420c2cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420c2d1:	48 89 c6             	mov    %rax,%rsi
  800420c2d4:	48 bf e4 d7 21 04 80 	movabs $0x800421d7e4,%rdi
  800420c2db:	00 00 00 
  800420c2de:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2e3:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c2ea:	00 00 00 
  800420c2ed:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420c2ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c2f3:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c2fa:	48 89 c6             	mov    %rax,%rsi
  800420c2fd:	48 bf f3 d7 21 04 80 	movabs $0x800421d7f3,%rdi
  800420c304:	00 00 00 
  800420c307:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c30c:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c313:	00 00 00 
  800420c316:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420c318:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c31c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c323:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c327:	0f 85 9b 00 00 00    	jne    800420c3c8 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420c32d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c331:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c338:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c33b:	84 c0                	test   %al,%al
  800420c33d:	74 0c                	je     800420c34b <print_trapframe+0x191>
  800420c33f:	48 b9 01 d8 21 04 80 	movabs $0x800421d801,%rcx
  800420c346:	00 00 00 
  800420c349:	eb 0a                	jmp    800420c355 <print_trapframe+0x19b>
  800420c34b:	48 b9 0c d8 21 04 80 	movabs $0x800421d80c,%rcx
  800420c352:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420c355:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c359:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c360:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c363:	48 85 c0             	test   %rax,%rax
  800420c366:	74 0c                	je     800420c374 <print_trapframe+0x1ba>
  800420c368:	48 ba 18 d8 21 04 80 	movabs $0x800421d818,%rdx
  800420c36f:	00 00 00 
  800420c372:	eb 0a                	jmp    800420c37e <print_trapframe+0x1c4>
  800420c374:	48 ba 1e d8 21 04 80 	movabs $0x800421d81e,%rdx
  800420c37b:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420c37e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c382:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c389:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c38c:	48 85 c0             	test   %rax,%rax
  800420c38f:	74 0c                	je     800420c39d <print_trapframe+0x1e3>
  800420c391:	48 b8 23 d8 21 04 80 	movabs $0x800421d823,%rax
  800420c398:	00 00 00 
  800420c39b:	eb 0a                	jmp    800420c3a7 <print_trapframe+0x1ed>
  800420c39d:	48 b8 28 d8 21 04 80 	movabs $0x800421d828,%rax
  800420c3a4:	00 00 00 
  800420c3a7:	48 89 c6             	mov    %rax,%rsi
  800420c3aa:	48 bf 2f d8 21 04 80 	movabs $0x800421d82f,%rdi
  800420c3b1:	00 00 00 
  800420c3b4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3b9:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  800420c3c0:	00 00 00 
  800420c3c3:	41 ff d0             	callq  *%r8
  800420c3c6:	eb 1b                	jmp    800420c3e3 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420c3c8:	48 bf 3e d8 21 04 80 	movabs $0x800421d83e,%rdi
  800420c3cf:	00 00 00 
  800420c3d2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3d7:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c3de:	00 00 00 
  800420c3e1:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420c3e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c3e7:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c3ee:	48 89 c6             	mov    %rax,%rsi
  800420c3f1:	48 bf 40 d8 21 04 80 	movabs $0x800421d840,%rdi
  800420c3f8:	00 00 00 
  800420c3fb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c400:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c407:	00 00 00 
  800420c40a:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c40c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c410:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c417:	0f b7 c0             	movzwl %ax,%eax
  800420c41a:	89 c6                	mov    %eax,%esi
  800420c41c:	48 bf 4f d8 21 04 80 	movabs $0x800421d84f,%rdi
  800420c423:	00 00 00 
  800420c426:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c42b:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c432:	00 00 00 
  800420c435:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c437:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c43b:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c442:	48 89 c6             	mov    %rax,%rsi
  800420c445:	48 bf 62 d8 21 04 80 	movabs $0x800421d862,%rdi
  800420c44c:	00 00 00 
  800420c44f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c454:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c45b:	00 00 00 
  800420c45e:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c460:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c464:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c46b:	0f b7 c0             	movzwl %ax,%eax
  800420c46e:	83 e0 03             	and    $0x3,%eax
  800420c471:	85 c0                	test   %eax,%eax
  800420c473:	74 54                	je     800420c4c9 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c479:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c480:	48 89 c6             	mov    %rax,%rsi
  800420c483:	48 bf 71 d8 21 04 80 	movabs $0x800421d871,%rdi
  800420c48a:	00 00 00 
  800420c48d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c492:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c499:	00 00 00 
  800420c49c:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c49e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c4a2:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c4a9:	0f b7 c0             	movzwl %ax,%eax
  800420c4ac:	89 c6                	mov    %eax,%esi
  800420c4ae:	48 bf 80 d8 21 04 80 	movabs $0x800421d880,%rdi
  800420c4b5:	00 00 00 
  800420c4b8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4bd:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c4c4:	00 00 00 
  800420c4c7:	ff d2                	callq  *%rdx
	}
}
  800420c4c9:	48 83 c4 28          	add    $0x28,%rsp
  800420c4cd:	5b                   	pop    %rbx
  800420c4ce:	5d                   	pop    %rbp
  800420c4cf:	c3                   	retq   

000000800420c4d0 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c4d0:	55                   	push   %rbp
  800420c4d1:	48 89 e5             	mov    %rsp,%rbp
  800420c4d4:	48 83 ec 10          	sub    $0x10,%rsp
  800420c4d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c4dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4e0:	48 8b 00             	mov    (%rax),%rax
  800420c4e3:	48 89 c6             	mov    %rax,%rsi
  800420c4e6:	48 bf 93 d8 21 04 80 	movabs $0x800421d893,%rdi
  800420c4ed:	00 00 00 
  800420c4f0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4f5:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c4fc:	00 00 00 
  800420c4ff:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c501:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c505:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c509:	48 89 c6             	mov    %rax,%rsi
  800420c50c:	48 bf a2 d8 21 04 80 	movabs $0x800421d8a2,%rdi
  800420c513:	00 00 00 
  800420c516:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c51b:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c522:	00 00 00 
  800420c525:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c527:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c52b:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c52f:	48 89 c6             	mov    %rax,%rsi
  800420c532:	48 bf b1 d8 21 04 80 	movabs $0x800421d8b1,%rdi
  800420c539:	00 00 00 
  800420c53c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c541:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c548:	00 00 00 
  800420c54b:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c54d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c551:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c555:	48 89 c6             	mov    %rax,%rsi
  800420c558:	48 bf c0 d8 21 04 80 	movabs $0x800421d8c0,%rdi
  800420c55f:	00 00 00 
  800420c562:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c567:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c56e:	00 00 00 
  800420c571:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c573:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c577:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c57b:	48 89 c6             	mov    %rax,%rsi
  800420c57e:	48 bf cf d8 21 04 80 	movabs $0x800421d8cf,%rdi
  800420c585:	00 00 00 
  800420c588:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c58d:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c594:	00 00 00 
  800420c597:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c599:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c59d:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c5a1:	48 89 c6             	mov    %rax,%rsi
  800420c5a4:	48 bf de d8 21 04 80 	movabs $0x800421d8de,%rdi
  800420c5ab:	00 00 00 
  800420c5ae:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5b3:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c5ba:	00 00 00 
  800420c5bd:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c5bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5c3:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c5c7:	48 89 c6             	mov    %rax,%rsi
  800420c5ca:	48 bf ed d8 21 04 80 	movabs $0x800421d8ed,%rdi
  800420c5d1:	00 00 00 
  800420c5d4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5d9:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c5e0:	00 00 00 
  800420c5e3:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c5e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5e9:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c5ed:	48 89 c6             	mov    %rax,%rsi
  800420c5f0:	48 bf fb d8 21 04 80 	movabs $0x800421d8fb,%rdi
  800420c5f7:	00 00 00 
  800420c5fa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5ff:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c606:	00 00 00 
  800420c609:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c60b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c60f:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c613:	48 89 c6             	mov    %rax,%rsi
  800420c616:	48 bf 09 d9 21 04 80 	movabs $0x800421d909,%rdi
  800420c61d:	00 00 00 
  800420c620:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c625:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c62c:	00 00 00 
  800420c62f:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c631:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c635:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c639:	48 89 c6             	mov    %rax,%rsi
  800420c63c:	48 bf 18 d9 21 04 80 	movabs $0x800421d918,%rdi
  800420c643:	00 00 00 
  800420c646:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c64b:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c652:	00 00 00 
  800420c655:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c657:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c65b:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c65f:	48 89 c6             	mov    %rax,%rsi
  800420c662:	48 bf 27 d9 21 04 80 	movabs $0x800421d927,%rdi
  800420c669:	00 00 00 
  800420c66c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c671:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c678:	00 00 00 
  800420c67b:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c67d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c681:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c685:	48 89 c6             	mov    %rax,%rsi
  800420c688:	48 bf 36 d9 21 04 80 	movabs $0x800421d936,%rdi
  800420c68f:	00 00 00 
  800420c692:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c697:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c69e:	00 00 00 
  800420c6a1:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c6a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6a7:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c6ab:	48 89 c6             	mov    %rax,%rsi
  800420c6ae:	48 bf 45 d9 21 04 80 	movabs $0x800421d945,%rdi
  800420c6b5:	00 00 00 
  800420c6b8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6bd:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c6c4:	00 00 00 
  800420c6c7:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c6c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6cd:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c6d1:	48 89 c6             	mov    %rax,%rsi
  800420c6d4:	48 bf 54 d9 21 04 80 	movabs $0x800421d954,%rdi
  800420c6db:	00 00 00 
  800420c6de:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6e3:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c6ea:	00 00 00 
  800420c6ed:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c6ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c6f3:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c6f7:	48 89 c6             	mov    %rax,%rsi
  800420c6fa:	48 bf 63 d9 21 04 80 	movabs $0x800421d963,%rdi
  800420c701:	00 00 00 
  800420c704:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c709:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c710:	00 00 00 
  800420c713:	ff d2                	callq  *%rdx
}
  800420c715:	c9                   	leaveq 
  800420c716:	c3                   	retq   

000000800420c717 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c717:	55                   	push   %rbp
  800420c718:	48 89 e5             	mov    %rsp,%rbp
  800420c71b:	48 83 ec 10          	sub    $0x10,%rsp
  800420c71f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 3: Your code here.

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c727:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c72e:	48 83 f8 27          	cmp    $0x27,%rax
  800420c732:	75 33                	jne    800420c767 <trap_dispatch+0x50>
		cprintf("Spurious interrupt on irq 7\n");
  800420c734:	48 bf 72 d9 21 04 80 	movabs $0x800421d972,%rdi
  800420c73b:	00 00 00 
  800420c73e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c743:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420c74a:	00 00 00 
  800420c74d:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c74f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c753:	48 89 c7             	mov    %rax,%rdi
  800420c756:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  800420c75d:	00 00 00 
  800420c760:	ff d0                	callq  *%rax
		return;
  800420c762:	e9 9f 01 00 00       	jmpq   800420c906 <trap_dispatch+0x1ef>
	}

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
  800420c767:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c76b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c772:	48 83 f8 20          	cmp    $0x20,%rax
  800420c776:	75 18                	jne    800420c790 <trap_dispatch+0x79>
		lapic_eoi();
  800420c778:	48 b8 62 73 21 04 80 	movabs $0x8004217362,%rax
  800420c77f:	00 00 00 
  800420c782:	ff d0                	callq  *%rax
		//print_trapframe(tf);
		sched_yield();
  800420c784:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  800420c78b:	00 00 00 
  800420c78e:	ff d0                	callq  *%rax
	// LAB 6: Your code here.


	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_KBD) {
  800420c790:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c794:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c79b:	48 83 f8 21          	cmp    $0x21,%rax
  800420c79f:	75 11                	jne    800420c7b2 <trap_dispatch+0x9b>
		kbd_intr();
  800420c7a1:	48 b8 51 10 20 04 80 	movabs $0x8004201051,%rax
  800420c7a8:	00 00 00 
  800420c7ab:	ff d0                	callq  *%rax
		return;
  800420c7ad:	e9 54 01 00 00       	jmpq   800420c906 <trap_dispatch+0x1ef>
	}
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SERIAL) {
  800420c7b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7b6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c7bd:	48 83 f8 24          	cmp    $0x24,%rax
  800420c7c1:	75 11                	jne    800420c7d4 <trap_dispatch+0xbd>
		serial_intr();
  800420c7c3:	48 b8 a8 07 20 04 80 	movabs $0x80042007a8,%rax
  800420c7ca:	00 00 00 
  800420c7cd:	ff d0                	callq  *%rax
		return;
  800420c7cf:	e9 32 01 00 00       	jmpq   800420c906 <trap_dispatch+0x1ef>
	}


	// Unexpected trap: The user process or the kernel has a bug.
	switch(tf->tf_trapno) {
  800420c7d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7d8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c7df:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c7e3:	74 11                	je     800420c7f6 <trap_dispatch+0xdf>
  800420c7e5:	48 83 f8 30          	cmp    $0x30,%rax
  800420c7e9:	74 3b                	je     800420c826 <trap_dispatch+0x10f>
  800420c7eb:	48 83 f8 03          	cmp    $0x3,%rax
  800420c7ef:	74 1d                	je     800420c80e <trap_dispatch+0xf7>
  800420c7f1:	e9 85 00 00 00       	jmpq   800420c87b <trap_dispatch+0x164>
	case T_PGFLT:
			page_fault_handler(tf);
  800420c7f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c7fa:	48 89 c7             	mov    %rax,%rdi
  800420c7fd:	48 b8 4b cc 20 04 80 	movabs $0x800420cc4b,%rax
  800420c804:	00 00 00 
  800420c807:	ff d0                	callq  *%rax
			break;
  800420c809:	e9 f8 00 00 00       	jmpq   800420c906 <trap_dispatch+0x1ef>
	case T_BRKPT:
			monitor(tf);
  800420c80e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c812:	48 89 c7             	mov    %rax,%rdi
  800420c815:	48 b8 1f 17 20 04 80 	movabs $0x800420171f,%rax
  800420c81c:	00 00 00 
  800420c81f:	ff d0                	callq  *%rax
			break;
  800420c821:	e9 e0 00 00 00       	jmpq   800420c906 <trap_dispatch+0x1ef>
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, 
										  tf->tf_regs.reg_rdx,
										  tf->tf_regs.reg_rcx,
										  tf->tf_regs.reg_rbx,
										  tf->tf_regs.reg_rdi,
										  tf->tf_regs.reg_rsi);
  800420c826:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	case T_BRKPT:
			monitor(tf);
			break;
	case T_SYSCALL:
			//print_trapframe(tf);
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, 
  800420c82a:	4c 8b 40 40          	mov    0x40(%rax),%r8
										  tf->tf_regs.reg_rdx,
										  tf->tf_regs.reg_rcx,
										  tf->tf_regs.reg_rbx,
										  tf->tf_regs.reg_rdi,
  800420c82e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	case T_BRKPT:
			monitor(tf);
			break;
	case T_SYSCALL:
			//print_trapframe(tf);
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, 
  800420c832:	48 8b 78 48          	mov    0x48(%rax),%rdi
										  tf->tf_regs.reg_rdx,
										  tf->tf_regs.reg_rcx,
										  tf->tf_regs.reg_rbx,
  800420c836:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	case T_BRKPT:
			monitor(tf);
			break;
	case T_SYSCALL:
			//print_trapframe(tf);
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, 
  800420c83a:	48 8b 48 68          	mov    0x68(%rax),%rcx
										  tf->tf_regs.reg_rdx,
										  tf->tf_regs.reg_rcx,
  800420c83e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	case T_BRKPT:
			monitor(tf);
			break;
	case T_SYSCALL:
			//print_trapframe(tf);
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, 
  800420c842:	48 8b 50 60          	mov    0x60(%rax),%rdx
										  tf->tf_regs.reg_rdx,
  800420c846:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	case T_BRKPT:
			monitor(tf);
			break;
	case T_SYSCALL:
			//print_trapframe(tf);
			tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, 
  800420c84a:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c84e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c852:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c856:	4d 89 c1             	mov    %r8,%r9
  800420c859:	49 89 f8             	mov    %rdi,%r8
  800420c85c:	48 89 c7             	mov    %rax,%rdi
  800420c85f:	48 b8 ce e8 20 04 80 	movabs $0x800420e8ce,%rax
  800420c866:	00 00 00 
  800420c869:	ff d0                	callq  *%rax
  800420c86b:	48 89 c2             	mov    %rax,%rdx
  800420c86e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c872:	48 89 50 70          	mov    %rdx,0x70(%rax)
										  tf->tf_regs.reg_rdx,
										  tf->tf_regs.reg_rcx,
										  tf->tf_regs.reg_rbx,
										  tf->tf_regs.reg_rdi,
										  tf->tf_regs.reg_rsi);
			break;
  800420c876:	e9 8b 00 00 00       	jmpq   800420c906 <trap_dispatch+0x1ef>
	default:
		print_trapframe(tf);
  800420c87b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c87f:	48 89 c7             	mov    %rax,%rdi
  800420c882:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  800420c889:	00 00 00 
  800420c88c:	ff d0                	callq  *%rax
		if (tf->tf_cs == GD_KT) {
  800420c88e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c892:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c899:	66 83 f8 08          	cmp    $0x8,%ax
  800420c89d:	75 2a                	jne    800420c8c9 <trap_dispatch+0x1b2>
			panic("unhandled trap in kernel");
  800420c89f:	48 ba 8f d9 21 04 80 	movabs $0x800421d98f,%rdx
  800420c8a6:	00 00 00 
  800420c8a9:	be 49 01 00 00       	mov    $0x149,%esi
  800420c8ae:	48 bf a8 d9 21 04 80 	movabs $0x800421d9a8,%rdi
  800420c8b5:	00 00 00 
  800420c8b8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8bd:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800420c8c4:	00 00 00 
  800420c8c7:	ff d1                	callq  *%rcx
		}
		else {
			env_destroy(curenv);
  800420c8c9:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420c8d0:	00 00 00 
  800420c8d3:	ff d0                	callq  *%rax
  800420c8d5:	48 98                	cltq   
  800420c8d7:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8db:	48 89 c2             	mov    %rax,%rdx
  800420c8de:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c8e2:	48 01 c2             	add    %rax,%rdx
  800420c8e5:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420c8ec:	00 00 00 
  800420c8ef:	48 01 d0             	add    %rdx,%rax
  800420c8f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c8f6:	48 89 c7             	mov    %rax,%rdi
  800420c8f9:	48 b8 59 89 20 04 80 	movabs $0x8004208959,%rax
  800420c900:	00 00 00 
  800420c903:	ff d0                	callq  *%rax
			return;
  800420c905:	90                   	nop
		}
	}
}
  800420c906:	c9                   	leaveq 
  800420c907:	c3                   	retq   

000000800420c908 <trap>:

void
trap(struct Trapframe *tf)
{
  800420c908:	55                   	push   %rbp
  800420c909:	48 89 e5             	mov    %rsp,%rbp
  800420c90c:	53                   	push   %rbx
  800420c90d:	48 83 ec 28          	sub    $0x28,%rsp
  800420c911:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420c915:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420c916:	48 b8 50 37 48 04 80 	movabs $0x8004483750,%rax
  800420c91d:	00 00 00 
  800420c920:	48 8b 00             	mov    (%rax),%rax
  800420c923:	48 85 c0             	test   %rax,%rax
  800420c926:	74 01                	je     800420c929 <trap+0x21>
		asm volatile("hlt");
  800420c928:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420c929:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420c930:	00 00 00 
  800420c933:	ff d0                	callq  *%rax
  800420c935:	48 98                	cltq   
  800420c937:	48 c1 e0 03          	shl    $0x3,%rax
  800420c93b:	48 89 c2             	mov    %rax,%rdx
  800420c93e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c942:	48 01 c2             	add    %rax,%rdx
  800420c945:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420c94c:	00 00 00 
  800420c94f:	48 01 d0             	add    %rdx,%rax
  800420c952:	48 83 c0 04          	add    $0x4,%rax
  800420c956:	be 01 00 00 00       	mov    $0x1,%esi
  800420c95b:	48 89 c7             	mov    %rax,%rdi
  800420c95e:	48 b8 54 91 20 04 80 	movabs $0x8004209154,%rax
  800420c965:	00 00 00 
  800420c968:	ff d0                	callq  *%rax
  800420c96a:	83 f8 02             	cmp    $0x2,%eax
  800420c96d:	75 0c                	jne    800420c97b <trap+0x73>
		lock_kernel();
  800420c96f:	48 b8 85 91 20 04 80 	movabs $0x8004209185,%rax
  800420c976:	00 00 00 
  800420c979:	ff d0                	callq  *%rax

    static __inline uint64_t
read_eflags(void)
{
    uint64_t rflags;
    __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420c97b:	9c                   	pushfq 
  800420c97c:	5b                   	pop    %rbx
  800420c97d:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
    return rflags;
  800420c981:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420c985:	25 00 02 00 00       	and    $0x200,%eax
  800420c98a:	48 85 c0             	test   %rax,%rax
  800420c98d:	74 35                	je     800420c9c4 <trap+0xbc>
  800420c98f:	48 b9 b4 d9 21 04 80 	movabs $0x800421d9b4,%rcx
  800420c996:	00 00 00 
  800420c999:	48 ba cd d9 21 04 80 	movabs $0x800421d9cd,%rdx
  800420c9a0:	00 00 00 
  800420c9a3:	be 66 01 00 00       	mov    $0x166,%esi
  800420c9a8:	48 bf a8 d9 21 04 80 	movabs $0x800421d9a8,%rdi
  800420c9af:	00 00 00 
  800420c9b2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c9b7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420c9be:	00 00 00 
  800420c9c1:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420c9c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c9c8:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c9cf:	0f b7 c0             	movzwl %ax,%eax
  800420c9d2:	83 e0 03             	and    $0x3,%eax
  800420c9d5:	83 f8 03             	cmp    $0x3,%eax
  800420c9d8:	0f 85 97 01 00 00    	jne    800420cb75 <trap+0x26d>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420c9de:	48 b8 85 91 20 04 80 	movabs $0x8004209185,%rax
  800420c9e5:	00 00 00 
  800420c9e8:	ff d0                	callq  *%rax
		assert(curenv);
  800420c9ea:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420c9f1:	00 00 00 
  800420c9f4:	ff d0                	callq  *%rax
  800420c9f6:	48 98                	cltq   
  800420c9f8:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9fc:	48 89 c2             	mov    %rax,%rdx
  800420c9ff:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca03:	48 01 c2             	add    %rax,%rdx
  800420ca06:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420ca0d:	00 00 00 
  800420ca10:	48 01 d0             	add    %rdx,%rax
  800420ca13:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ca17:	48 85 c0             	test   %rax,%rax
  800420ca1a:	75 35                	jne    800420ca51 <trap+0x149>
  800420ca1c:	48 b9 e2 d9 21 04 80 	movabs $0x800421d9e2,%rcx
  800420ca23:	00 00 00 
  800420ca26:	48 ba cd d9 21 04 80 	movabs $0x800421d9cd,%rdx
  800420ca2d:	00 00 00 
  800420ca30:	be 6e 01 00 00       	mov    $0x16e,%esi
  800420ca35:	48 bf a8 d9 21 04 80 	movabs $0x800421d9a8,%rdi
  800420ca3c:	00 00 00 
  800420ca3f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca44:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420ca4b:	00 00 00 
  800420ca4e:	41 ff d0             	callq  *%r8
		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420ca51:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420ca58:	00 00 00 
  800420ca5b:	ff d0                	callq  *%rax
  800420ca5d:	48 98                	cltq   
  800420ca5f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca63:	48 89 c2             	mov    %rax,%rdx
  800420ca66:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca6a:	48 01 c2             	add    %rax,%rdx
  800420ca6d:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420ca74:	00 00 00 
  800420ca77:	48 01 d0             	add    %rdx,%rax
  800420ca7a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ca7e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420ca84:	83 f8 01             	cmp    $0x1,%eax
  800420ca87:	75 79                	jne    800420cb02 <trap+0x1fa>
			env_free(curenv);
  800420ca89:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420ca90:	00 00 00 
  800420ca93:	ff d0                	callq  *%rax
  800420ca95:	48 98                	cltq   
  800420ca97:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca9b:	48 89 c2             	mov    %rax,%rdx
  800420ca9e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420caa2:	48 01 c2             	add    %rax,%rdx
  800420caa5:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420caac:	00 00 00 
  800420caaf:	48 01 d0             	add    %rdx,%rax
  800420cab2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cab6:	48 89 c7             	mov    %rax,%rdi
  800420cab9:	48 b8 0e 85 20 04 80 	movabs $0x800420850e,%rax
  800420cac0:	00 00 00 
  800420cac3:	ff d0                	callq  *%rax
			curenv = NULL;
  800420cac5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cacc:	00 00 00 
  800420cacf:	ff d0                	callq  *%rax
  800420cad1:	48 98                	cltq   
  800420cad3:	48 c1 e0 03          	shl    $0x3,%rax
  800420cad7:	48 89 c2             	mov    %rax,%rdx
  800420cada:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cade:	48 01 c2             	add    %rax,%rdx
  800420cae1:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cae8:	00 00 00 
  800420caeb:	48 01 d0             	add    %rdx,%rax
  800420caee:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800420caf5:	00 
			sched_yield();
  800420caf6:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  800420cafd:	00 00 00 
  800420cb00:	ff d0                	callq  *%rax
		}
		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420cb02:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cb09:	00 00 00 
  800420cb0c:	ff d0                	callq  *%rax
  800420cb0e:	48 98                	cltq   
  800420cb10:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb14:	48 89 c2             	mov    %rax,%rdx
  800420cb17:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb1b:	48 01 c2             	add    %rax,%rdx
  800420cb1e:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cb25:	00 00 00 
  800420cb28:	48 01 d0             	add    %rdx,%rax
  800420cb2b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420cb2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cb33:	48 89 c6             	mov    %rax,%rsi
  800420cb36:	b8 18 00 00 00       	mov    $0x18,%eax
  800420cb3b:	48 89 d7             	mov    %rdx,%rdi
  800420cb3e:	48 89 c1             	mov    %rax,%rcx
  800420cb41:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420cb44:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cb4b:	00 00 00 
  800420cb4e:	ff d0                	callq  *%rax
  800420cb50:	48 98                	cltq   
  800420cb52:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb56:	48 89 c2             	mov    %rax,%rdx
  800420cb59:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb5d:	48 01 c2             	add    %rax,%rdx
  800420cb60:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cb67:	00 00 00 
  800420cb6a:	48 01 d0             	add    %rdx,%rax
  800420cb6d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cb71:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420cb75:	48 b8 90 32 48 04 80 	movabs $0x8004483290,%rax
  800420cb7c:	00 00 00 
  800420cb7f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420cb83:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420cb86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cb8a:	48 89 c7             	mov    %rax,%rdi
  800420cb8d:	48 b8 17 c7 20 04 80 	movabs $0x800420c717,%rax
  800420cb94:	00 00 00 
  800420cb97:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420cb99:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cba0:	00 00 00 
  800420cba3:	ff d0                	callq  *%rax
  800420cba5:	48 98                	cltq   
  800420cba7:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbab:	48 89 c2             	mov    %rax,%rdx
  800420cbae:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cbb2:	48 01 c2             	add    %rax,%rdx
  800420cbb5:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cbbc:	00 00 00 
  800420cbbf:	48 01 d0             	add    %rdx,%rax
  800420cbc2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cbc6:	48 85 c0             	test   %rax,%rax
  800420cbc9:	74 74                	je     800420cc3f <trap+0x337>
  800420cbcb:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cbd2:	00 00 00 
  800420cbd5:	ff d0                	callq  *%rax
  800420cbd7:	48 98                	cltq   
  800420cbd9:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbdd:	48 89 c2             	mov    %rax,%rdx
  800420cbe0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cbe4:	48 01 c2             	add    %rax,%rdx
  800420cbe7:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cbee:	00 00 00 
  800420cbf1:	48 01 d0             	add    %rdx,%rax
  800420cbf4:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cbf8:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cbfe:	83 f8 03             	cmp    $0x3,%eax
  800420cc01:	75 3c                	jne    800420cc3f <trap+0x337>
		env_run(curenv);
  800420cc03:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cc0a:	00 00 00 
  800420cc0d:	ff d0                	callq  *%rax
  800420cc0f:	48 98                	cltq   
  800420cc11:	48 c1 e0 03          	shl    $0x3,%rax
  800420cc15:	48 89 c2             	mov    %rax,%rdx
  800420cc18:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cc1c:	48 01 c2             	add    %rax,%rdx
  800420cc1f:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cc26:	00 00 00 
  800420cc29:	48 01 d0             	add    %rdx,%rax
  800420cc2c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cc30:	48 89 c7             	mov    %rax,%rdi
  800420cc33:	48 b8 3c 8b 20 04 80 	movabs $0x8004208b3c,%rax
  800420cc3a:	00 00 00 
  800420cc3d:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420cc3f:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  800420cc46:	00 00 00 
  800420cc49:	ff d0                	callq  *%rax

000000800420cc4b <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420cc4b:	55                   	push   %rbp
  800420cc4c:	48 89 e5             	mov    %rsp,%rbp
  800420cc4f:	53                   	push   %rbx
  800420cc50:	48 83 ec 38          	sub    $0x38,%rsp
  800420cc54:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420cc58:	0f 20 d3             	mov    %cr2,%rbx
  800420cc5b:	48 89 5d d8          	mov    %rbx,-0x28(%rbp)
    return val;
  800420cc5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420cc63:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if (!(tf->tf_cs & 0x3)) {
  800420cc67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc6b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cc72:	0f b7 c0             	movzwl %ax,%eax
  800420cc75:	83 e0 03             	and    $0x3,%eax
  800420cc78:	85 c0                	test   %eax,%eax
  800420cc7a:	75 3d                	jne    800420ccb9 <page_fault_handler+0x6e>
		print_trapframe(tf);
  800420cc7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc80:	48 89 c7             	mov    %rax,%rdi
  800420cc83:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  800420cc8a:	00 00 00 
  800420cc8d:	ff d0                	callq  *%rax
        panic("unhandled trap in kernel");
  800420cc8f:	48 ba 8f d9 21 04 80 	movabs $0x800421d98f,%rdx
  800420cc96:	00 00 00 
  800420cc99:	be 9c 01 00 00       	mov    $0x19c,%esi
  800420cc9e:	48 bf a8 d9 21 04 80 	movabs $0x800421d9a8,%rdi
  800420cca5:	00 00 00 
  800420cca8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ccad:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800420ccb4:	00 00 00 
  800420ccb7:	ff d1                	callq  *%rcx
	// Hints:
	//   user_mem_assert() and env_run() are useful here.
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').
	
	if (curenv->env_pgfault_upcall) {
  800420ccb9:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420ccc0:	00 00 00 
  800420ccc3:	ff d0                	callq  *%rax
  800420ccc5:	48 98                	cltq   
  800420ccc7:	48 c1 e0 03          	shl    $0x3,%rax
  800420cccb:	48 89 c2             	mov    %rax,%rdx
  800420ccce:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ccd2:	48 01 c2             	add    %rax,%rdx
  800420ccd5:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420ccdc:	00 00 00 
  800420ccdf:	48 01 d0             	add    %rdx,%rax
  800420cce2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cce6:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cced:	48 85 c0             	test   %rax,%rax
  800420ccf0:	0f 84 08 02 00 00    	je     800420cefe <page_fault_handler+0x2b3>
		struct UTrapframe *utexp;
		if (tf->tf_rsp <= UXSTACKTOP-1 && tf->tf_rsp >= UXSTACKTOP-PGSIZE) {
  800420ccf6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ccfa:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cd01:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420cd06:	48 39 c2             	cmp    %rax,%rdx
  800420cd09:	77 2c                	ja     800420cd37 <page_fault_handler+0xec>
  800420cd0b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd0f:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cd16:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420cd1b:	48 39 c2             	cmp    %rax,%rdx
  800420cd1e:	76 17                	jbe    800420cd37 <page_fault_handler+0xec>
			utexp = (struct UTrapframe*) (tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420cd20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd24:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420cd2b:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420cd31:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420cd35:	eb 0e                	jmp    800420cd45 <page_fault_handler+0xfa>
		}
		else {
			utexp = (struct UTrapframe*)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420cd37:	c7 45 e8 60 ff 7f ef 	movl   $0xef7fff60,-0x18(%rbp)
  800420cd3e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
		}
		//storing that 64 bit thingy.(this was tough!, I'm weak with bits ;) )
		//(time frame) to be stored...but how does it get pushed into the stack...you assign it to uxstacktop
		//thats brilliant. Thank you! thank you...wait a minute...see if it overflows!
		user_mem_assert(curenv, (void*)utexp, sizeof(struct UTrapframe), PTE_W|PTE_U);
  800420cd45:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cd4c:	00 00 00 
  800420cd4f:	ff d0                	callq  *%rax
  800420cd51:	48 98                	cltq   
  800420cd53:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd57:	48 89 c2             	mov    %rax,%rdx
  800420cd5a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cd5e:	48 01 c2             	add    %rax,%rdx
  800420cd61:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cd68:	00 00 00 
  800420cd6b:	48 01 d0             	add    %rdx,%rax
  800420cd6e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cd72:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cd76:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420cd7b:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420cd80:	48 89 c7             	mov    %rax,%rdi
  800420cd83:	48 b8 6f 39 20 04 80 	movabs $0x800420396f,%rax
  800420cd8a:	00 00 00 
  800420cd8d:	ff d0                	callq  *%rax
		utexp->utf_fault_va = fault_va;
  800420cd8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd93:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cd97:	48 89 10             	mov    %rdx,(%rax)
		utexp->utf_err = tf->tf_err;
  800420cd9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd9e:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420cda5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cda9:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utexp->utf_regs = tf->tf_regs;
  800420cdad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cdb1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420cdb5:	48 8b 0a             	mov    (%rdx),%rcx
  800420cdb8:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420cdbc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420cdc0:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420cdc4:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420cdc8:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420cdcc:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420cdd0:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420cdd4:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420cdd8:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420cddc:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420cde0:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420cde4:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420cde8:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420cdec:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420cdf0:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420cdf4:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420cdf8:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420cdfc:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420ce00:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420ce04:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420ce08:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420ce0c:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420ce10:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420ce14:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420ce18:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420ce1c:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420ce20:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420ce24:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420ce28:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utexp->utf_rip = tf->tf_rip;
  800420ce2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce33:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420ce3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce3e:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utexp->utf_eflags = tf->tf_eflags;
  800420ce45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce49:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ce50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce54:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utexp->utf_rsp = tf->tf_rsp;
  800420ce5b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ce5f:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ce66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce6a:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		//How do i run the upcall...set the rip...thats nice...thank you exercise 10 :)
		tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420ce71:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420ce78:	00 00 00 
  800420ce7b:	ff d0                	callq  *%rax
  800420ce7d:	48 98                	cltq   
  800420ce7f:	48 c1 e0 03          	shl    $0x3,%rax
  800420ce83:	48 89 c2             	mov    %rax,%rdx
  800420ce86:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ce8a:	48 01 c2             	add    %rax,%rdx
  800420ce8d:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420ce94:	00 00 00 
  800420ce97:	48 01 d0             	add    %rdx,%rax
  800420ce9a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ce9e:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cea5:	48 89 c2             	mov    %rax,%rdx
  800420cea8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ceac:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uint64_t)utexp;
  800420ceb3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ceb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cebb:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv);
  800420cec2:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cec9:	00 00 00 
  800420cecc:	ff d0                	callq  *%rax
  800420cece:	48 98                	cltq   
  800420ced0:	48 c1 e0 03          	shl    $0x3,%rax
  800420ced4:	48 89 c2             	mov    %rax,%rdx
  800420ced7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cedb:	48 01 c2             	add    %rax,%rdx
  800420cede:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cee5:	00 00 00 
  800420cee8:	48 01 d0             	add    %rdx,%rax
  800420ceeb:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ceef:	48 89 c7             	mov    %rax,%rdi
  800420cef2:	48 b8 3c 8b 20 04 80 	movabs $0x8004208b3c,%rax
  800420cef9:	00 00 00 
  800420cefc:	ff d0                	callq  *%rax
	}
	// LAB 4: Your code here.

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n", curenv->env_id, fault_va, tf->tf_rip);
  800420cefe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf02:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800420cf09:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cf10:	00 00 00 
  800420cf13:	ff d0                	callq  *%rax
  800420cf15:	48 98                	cltq   
  800420cf17:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf1b:	48 89 c2             	mov    %rax,%rdx
  800420cf1e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf22:	48 01 c2             	add    %rax,%rdx
  800420cf25:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cf2c:	00 00 00 
  800420cf2f:	48 01 d0             	add    %rdx,%rax
  800420cf32:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cf36:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cf3c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cf40:	48 89 d9             	mov    %rbx,%rcx
  800420cf43:	89 c6                	mov    %eax,%esi
  800420cf45:	48 bf f0 d9 21 04 80 	movabs $0x800421d9f0,%rdi
  800420cf4c:	00 00 00 
  800420cf4f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cf54:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  800420cf5b:	00 00 00 
  800420cf5e:	41 ff d0             	callq  *%r8
	print_trapframe(tf);
  800420cf61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cf65:	48 89 c7             	mov    %rax,%rdi
  800420cf68:	48 b8 ba c1 20 04 80 	movabs $0x800420c1ba,%rax
  800420cf6f:	00 00 00 
  800420cf72:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420cf74:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420cf7b:	00 00 00 
  800420cf7e:	ff d0                	callq  *%rax
  800420cf80:	48 98                	cltq   
  800420cf82:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf86:	48 89 c2             	mov    %rax,%rdx
  800420cf89:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cf8d:	48 01 c2             	add    %rax,%rdx
  800420cf90:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420cf97:	00 00 00 
  800420cf9a:	48 01 d0             	add    %rdx,%rax
  800420cf9d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cfa1:	48 89 c7             	mov    %rax,%rdi
  800420cfa4:	48 b8 59 89 20 04 80 	movabs $0x8004208959,%rax
  800420cfab:	00 00 00 
  800420cfae:	ff d0                	callq  *%rax
}
  800420cfb0:	48 83 c4 38          	add    $0x38,%rsp
  800420cfb4:	5b                   	pop    %rbx
  800420cfb5:	5d                   	pop    %rbp
  800420cfb6:	c3                   	retq   
	...

000000800420cfb8 <CSE_DIVIDE>:
	pushq $(num);							\
	jmp _alltraps

.text

TRAPHANDLER_NOEC(CSE_DIVIDE,0)      /* divide error*/ 
  800420cfb8:	6a 00                	pushq  $0x0
  800420cfba:	6a 00                	pushq  $0x0
  800420cfbc:	e9 48 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cfc1:	90                   	nop

000000800420cfc2 <CSE_DEBUG>:
TRAPHANDLER_NOEC(CSE_DEBUG,1)      /* debug exception*/
  800420cfc2:	6a 00                	pushq  $0x0
  800420cfc4:	6a 01                	pushq  $0x1
  800420cfc6:	e9 3e 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cfcb:	90                   	nop

000000800420cfcc <CSE_NMI>:
TRAPHANDLER_NOEC(CSE_NMI,2)     /* non-maskable interrupt*/
  800420cfcc:	6a 00                	pushq  $0x0
  800420cfce:	6a 02                	pushq  $0x2
  800420cfd0:	e9 34 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cfd5:	90                   	nop

000000800420cfd6 <CSE_BRKPT>:
TRAPHANDLER_NOEC(CSE_BRKPT,3)     /* breakpoint*/
  800420cfd6:	6a 00                	pushq  $0x0
  800420cfd8:	6a 03                	pushq  $0x3
  800420cfda:	e9 2a 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cfdf:	90                   	nop

000000800420cfe0 <CSE_OFLOW>:
TRAPHANDLER_NOEC(CSE_OFLOW,4)     /* overflow*/
  800420cfe0:	6a 00                	pushq  $0x0
  800420cfe2:	6a 04                	pushq  $0x4
  800420cfe4:	e9 20 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cfe9:	90                   	nop

000000800420cfea <CSE_BOUND>:
TRAPHANDLER_NOEC(CSE_BOUND,5)     /* bounds check*/
  800420cfea:	6a 00                	pushq  $0x0
  800420cfec:	6a 05                	pushq  $0x5
  800420cfee:	e9 16 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cff3:	90                   	nop

000000800420cff4 <CSE_ILLOP>:
TRAPHANDLER_NOEC(CSE_ILLOP,6)     /* illegal opcode*/
  800420cff4:	6a 00                	pushq  $0x0
  800420cff6:	6a 06                	pushq  $0x6
  800420cff8:	e9 0c 01 00 00       	jmpq   800420d109 <_alltraps>
  800420cffd:	90                   	nop

000000800420cffe <CSE_DEVICE>:
TRAPHANDLER_NOEC(CSE_DEVICE,7)     /* device not available*/
  800420cffe:	6a 00                	pushq  $0x0
  800420d000:	6a 07                	pushq  $0x7
  800420d002:	e9 02 01 00 00       	jmpq   800420d109 <_alltraps>
  800420d007:	90                   	nop

000000800420d008 <CSE_DBLFLT>:
TRAPHANDLER(CSE_DBLFLT,8)      /* double fault*/
  800420d008:	6a 08                	pushq  $0x8
  800420d00a:	e9 fa 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d00f:	90                   	nop

000000800420d010 <CSE_TSS>:
/* #define T_COPROC  9    // reserved (not generated by recent processors)*/
TRAPHANDLER(CSE_TSS,10)     /* invalid task switch segment*/
  800420d010:	6a 0a                	pushq  $0xa
  800420d012:	e9 f2 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d017:	90                   	nop

000000800420d018 <CSE_SEGNP>:
TRAPHANDLER(CSE_SEGNP,11)      /* segment not present*/
  800420d018:	6a 0b                	pushq  $0xb
  800420d01a:	e9 ea 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d01f:	90                   	nop

000000800420d020 <CSE_STACK>:
TRAPHANDLER(CSE_STACK,12)      /* stack exception*/
  800420d020:	6a 0c                	pushq  $0xc
  800420d022:	e9 e2 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d027:	90                   	nop

000000800420d028 <CSE_GPFLT>:
TRAPHANDLER(CSE_GPFLT,13)      /* general protection fault*/
  800420d028:	6a 0d                	pushq  $0xd
  800420d02a:	e9 da 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d02f:	90                   	nop

000000800420d030 <CSE_PGFLT>:
TRAPHANDLER(CSE_PGFLT,14)      /* page fault*/
  800420d030:	6a 0e                	pushq  $0xe
  800420d032:	e9 d2 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d037:	90                   	nop

000000800420d038 <CSE_FPERR>:
/* #define T_RES    15    // reserved*/
TRAPHANDLER_NOEC(CSE_FPERR,16)      /* floating point error*/
  800420d038:	6a 00                	pushq  $0x0
  800420d03a:	6a 10                	pushq  $0x10
  800420d03c:	e9 c8 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d041:	90                   	nop

000000800420d042 <CSE_ALIGN>:
TRAPHANDLER_NOEC(CSE_ALIGN,17)      /* aligment check*/
  800420d042:	6a 00                	pushq  $0x0
  800420d044:	6a 11                	pushq  $0x11
  800420d046:	e9 be 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d04b:	90                   	nop

000000800420d04c <CSE_MCHK>:
TRAPHANDLER_NOEC(CSE_MCHK,18)      /* machine check*/
  800420d04c:	6a 00                	pushq  $0x0
  800420d04e:	6a 12                	pushq  $0x12
  800420d050:	e9 b4 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d055:	90                   	nop

000000800420d056 <CSE_SIMDERR>:
TRAPHANDLER_NOEC(CSE_SIMDERR,19)      /* SIMD floating point error*/
  800420d056:	6a 00                	pushq  $0x0
  800420d058:	6a 13                	pushq  $0x13
  800420d05a:	e9 aa 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d05f:	90                   	nop

000000800420d060 <CSE_SYSCALL>:



TRAPHANDLER_NOEC(CSE_SYSCALL,48) /* System call */
  800420d060:	6a 00                	pushq  $0x0
  800420d062:	6a 30                	pushq  $0x30
  800420d064:	e9 a0 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d069:	90                   	nop

000000800420d06a <CSE_IRQ0>:
/*IRQ (HW INTERRUPTS)*/
TRAPHANDLER_NOEC(CSE_IRQ0, 32)
  800420d06a:	6a 00                	pushq  $0x0
  800420d06c:	6a 20                	pushq  $0x20
  800420d06e:	e9 96 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d073:	90                   	nop

000000800420d074 <CSE_IRQ1>:
TRAPHANDLER_NOEC(CSE_IRQ1, 33)
  800420d074:	6a 00                	pushq  $0x0
  800420d076:	6a 21                	pushq  $0x21
  800420d078:	e9 8c 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d07d:	90                   	nop

000000800420d07e <CSE_IRQ2>:
TRAPHANDLER_NOEC(CSE_IRQ2, 34)
  800420d07e:	6a 00                	pushq  $0x0
  800420d080:	6a 22                	pushq  $0x22
  800420d082:	e9 82 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d087:	90                   	nop

000000800420d088 <CSE_IRQ3>:
TRAPHANDLER_NOEC(CSE_IRQ3, 35)
  800420d088:	6a 00                	pushq  $0x0
  800420d08a:	6a 23                	pushq  $0x23
  800420d08c:	e9 78 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d091:	90                   	nop

000000800420d092 <CSE_IRQ4>:
TRAPHANDLER_NOEC(CSE_IRQ4, 36)
  800420d092:	6a 00                	pushq  $0x0
  800420d094:	6a 24                	pushq  $0x24
  800420d096:	e9 6e 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d09b:	90                   	nop

000000800420d09c <CSE_IRQ5>:
TRAPHANDLER_NOEC(CSE_IRQ5, 37)
  800420d09c:	6a 00                	pushq  $0x0
  800420d09e:	6a 25                	pushq  $0x25
  800420d0a0:	e9 64 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0a5:	90                   	nop

000000800420d0a6 <CSE_IRQ6>:
TRAPHANDLER_NOEC(CSE_IRQ6, 38)
  800420d0a6:	6a 00                	pushq  $0x0
  800420d0a8:	6a 26                	pushq  $0x26
  800420d0aa:	e9 5a 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0af:	90                   	nop

000000800420d0b0 <CSE_IRQ7>:
TRAPHANDLER_NOEC(CSE_IRQ7, 39)
  800420d0b0:	6a 00                	pushq  $0x0
  800420d0b2:	6a 27                	pushq  $0x27
  800420d0b4:	e9 50 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0b9:	90                   	nop

000000800420d0ba <CSE_IRQ8>:
TRAPHANDLER_NOEC(CSE_IRQ8, 40)
  800420d0ba:	6a 00                	pushq  $0x0
  800420d0bc:	6a 28                	pushq  $0x28
  800420d0be:	e9 46 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0c3:	90                   	nop

000000800420d0c4 <CSE_IRQ9>:
TRAPHANDLER_NOEC(CSE_IRQ9, 41)
  800420d0c4:	6a 00                	pushq  $0x0
  800420d0c6:	6a 29                	pushq  $0x29
  800420d0c8:	e9 3c 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0cd:	90                   	nop

000000800420d0ce <CSE_IRQ10>:
TRAPHANDLER_NOEC(CSE_IRQ10, 42)
  800420d0ce:	6a 00                	pushq  $0x0
  800420d0d0:	6a 2a                	pushq  $0x2a
  800420d0d2:	e9 32 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0d7:	90                   	nop

000000800420d0d8 <CSE_IRQ11>:
TRAPHANDLER_NOEC(CSE_IRQ11, 43)
  800420d0d8:	6a 00                	pushq  $0x0
  800420d0da:	6a 2b                	pushq  $0x2b
  800420d0dc:	e9 28 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0e1:	90                   	nop

000000800420d0e2 <CSE_IRQ12>:
TRAPHANDLER_NOEC(CSE_IRQ12, 44)
  800420d0e2:	6a 00                	pushq  $0x0
  800420d0e4:	6a 2c                	pushq  $0x2c
  800420d0e6:	e9 1e 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0eb:	90                   	nop

000000800420d0ec <CSE_IRQ13>:
TRAPHANDLER_NOEC(CSE_IRQ13, 45)
  800420d0ec:	6a 00                	pushq  $0x0
  800420d0ee:	6a 2d                	pushq  $0x2d
  800420d0f0:	e9 14 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0f5:	90                   	nop

000000800420d0f6 <CSE_IRQ14>:
TRAPHANDLER_NOEC(CSE_IRQ14, 46)
  800420d0f6:	6a 00                	pushq  $0x0
  800420d0f8:	6a 2e                	pushq  $0x2e
  800420d0fa:	e9 0a 00 00 00       	jmpq   800420d109 <_alltraps>
  800420d0ff:	90                   	nop

000000800420d100 <CSE_IRQ15>:
TRAPHANDLER_NOEC(CSE_IRQ15, 47)
  800420d100:	6a 00                	pushq  $0x0
  800420d102:	6a 2f                	pushq  $0x2f
  800420d104:	e9 00 00 00 00       	jmpq   800420d109 <_alltraps>

000000800420d109 <_alltraps>:
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */
.global _alltraps
_alltraps:
	subq $8,%rsp 
  800420d109:	48 83 ec 08          	sub    $0x8,%rsp
	movw %ds,(%rsp)
  800420d10d:	8c 1c 24             	mov    %ds,(%rsp)
	subq $8,%rsp
  800420d110:	48 83 ec 08          	sub    $0x8,%rsp
	movw %es,(%rsp)
  800420d114:	8c 04 24             	mov    %es,(%rsp)
	PUSHA
  800420d117:	48 83 ec 78          	sub    $0x78,%rsp
  800420d11b:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420d120:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420d125:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420d12a:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420d12f:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420d134:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420d139:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420d13e:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420d143:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420d148:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420d14d:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420d152:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420d157:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420d15c:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420d161:	4c 89 3c 24          	mov    %r15,(%rsp)
	movq $GD_KD,%rax
  800420d165:	48 c7 c0 10 00 00 00 	mov    $0x10,%rax
	movw %rax,%ds
  800420d16c:	8e d8                	mov    %eax,%ds
	movw %rax,%es
  800420d16e:	8e c0                	mov    %eax,%es
	movq %rsp,%rdi
  800420d170:	48 89 e7             	mov    %rsp,%rdi
	/*movq $0, %rbp*/
	call trap
  800420d173:	e8 90 f7 ff ff       	callq  800420c908 <trap>
	POPA_
  800420d178:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420d17c:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420d181:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420d186:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420d18b:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420d190:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420d195:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420d19a:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420d19f:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420d1a4:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420d1a9:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420d1ae:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420d1b3:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420d1b8:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420d1bd:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420d1c2:	48 83 c4 78          	add    $0x78,%rsp
	add $8, %rsp
  800420d1c6:	48 83 c4 08          	add    $0x8,%rsp
	movw (%rsp),%es
  800420d1ca:	8e 04 24             	mov    (%rsp),%es
	add $8, %rsp
  800420d1cd:	48 83 c4 08          	add    $0x8,%rsp
	movw (%rsp),%ds
  800420d1d1:	8e 1c 24             	mov    (%rsp),%ds
	iret
  800420d1d4:	cf                   	iret   
  800420d1d5:	00 00                	add    %al,(%rax)
	...

000000800420d1d8 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420d1d8:	55                   	push   %rbp
  800420d1d9:	48 89 e5             	mov    %rsp,%rbp
  800420d1dc:	53                   	push   %rbx
  800420d1dd:	48 83 ec 20          	sub    $0x20,%rsp
  800420d1e1:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  800420d1e5:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
			 "+m" (*addr), "=a" (result):
  800420d1e8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d1ec:	8b 45 dc             	mov    -0x24(%rbp),%eax
			 "+m" (*addr), "=a" (result):
  800420d1ef:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d1f3:	89 c3                	mov    %eax,%ebx
  800420d1f5:	89 d8                	mov    %ebx,%eax
  800420d1f7:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d1fa:	89 c3                	mov    %eax,%ebx
  800420d1fc:	89 5d f4             	mov    %ebx,-0xc(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420d1ff:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  800420d202:	48 83 c4 20          	add    $0x20,%rsp
  800420d206:	5b                   	pop    %rbx
  800420d207:	5d                   	pop    %rbp
  800420d208:	c3                   	retq   

000000800420d209 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d209:	55                   	push   %rbp
  800420d20a:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d20d:	48 bf 00 07 23 04 80 	movabs $0x8004230700,%rdi
  800420d214:	00 00 00 
  800420d217:	48 b8 91 77 21 04 80 	movabs $0x8004217791,%rax
  800420d21e:	00 00 00 
  800420d221:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420d223:	f3 90                	pause  
}
  800420d225:	5d                   	pop    %rbp
  800420d226:	c3                   	retq   

000000800420d227 <vmxon>:

void sched_halt(void);

#include <vmm/vmx.h>
static int
vmxon() {
  800420d227:	55                   	push   %rbp
  800420d228:	48 89 e5             	mov    %rsp,%rbp
  800420d22b:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	if(!thiscpu->is_vmx_root) {
  800420d22f:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d236:	00 00 00 
  800420d239:	ff d0                	callq  *%rax
  800420d23b:	48 98                	cltq   
  800420d23d:	48 c1 e0 03          	shl    $0x3,%rax
  800420d241:	48 89 c2             	mov    %rax,%rdx
  800420d244:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d248:	48 01 c2             	add    %rax,%rdx
  800420d24b:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d252:	00 00 00 
  800420d255:	48 01 d0             	add    %rdx,%rax
  800420d258:	0f b6 40 78          	movzbl 0x78(%rax),%eax
  800420d25c:	83 f0 01             	xor    $0x1,%eax
  800420d25f:	84 c0                	test   %al,%al
  800420d261:	74 5a                	je     800420d2bd <vmxon+0x96>
		r = vmx_init_vmxon();
  800420d263:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d268:	48 ba 07 94 21 04 80 	movabs $0x8004219407,%rdx
  800420d26f:	00 00 00 
  800420d272:	ff d2                	callq  *%rdx
  800420d274:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(r < 0) {
  800420d277:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d27b:	79 25                	jns    800420d2a2 <vmxon+0x7b>
			cprintf("Error executing VMXON: %e\n", r);
  800420d27d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d280:	89 c6                	mov    %eax,%esi
  800420d282:	48 bf 00 dc 21 04 80 	movabs $0x800421dc00,%rdi
  800420d289:	00 00 00 
  800420d28c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d291:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420d298:	00 00 00 
  800420d29b:	ff d2                	callq  *%rdx
			return r;
  800420d29d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d2a0:	eb 20                	jmp    800420d2c2 <vmxon+0x9b>
		}
		cprintf("VMXON\n");
  800420d2a2:	48 bf 1b dc 21 04 80 	movabs $0x800421dc1b,%rdi
  800420d2a9:	00 00 00 
  800420d2ac:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2b1:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420d2b8:	00 00 00 
  800420d2bb:	ff d2                	callq  *%rdx
	}
	return 0;
  800420d2bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d2c2:	c9                   	leaveq 
  800420d2c3:	c3                   	retq   

000000800420d2c4 <sched_yield>:

// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420d2c4:	55                   	push   %rbp
  800420d2c5:	48 89 e5             	mov    %rsp,%rbp
  800420d2c8:	48 83 ec 10          	sub    $0x10,%rsp
	//
	// Never choose an environment that's currently running on
	// another CPU (env_status == ENV_RUNNING). If there are
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.
	idle = thiscpu->cpu_env;
  800420d2cc:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d2d3:	00 00 00 
  800420d2d6:	ff d0                	callq  *%rax
  800420d2d8:	48 98                	cltq   
  800420d2da:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2de:	48 89 c2             	mov    %rax,%rdx
  800420d2e1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d2e5:	48 01 c2             	add    %rax,%rdx
  800420d2e8:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d2ef:	00 00 00 
  800420d2f2:	48 01 d0             	add    %rdx,%rax
  800420d2f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d2f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int i = 0;
  800420d2fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if(idle)
  800420d304:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d309:	74 3b                	je     800420d346 <sched_yield+0x82>
 		i = ENVX(thiscpu->cpu_env->env_id);
  800420d30b:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d312:	00 00 00 
  800420d315:	ff d0                	callq  *%rax
  800420d317:	48 98                	cltq   
  800420d319:	48 c1 e0 03          	shl    $0x3,%rax
  800420d31d:	48 89 c2             	mov    %rax,%rdx
  800420d320:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d324:	48 01 c2             	add    %rax,%rdx
  800420d327:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d32e:	00 00 00 
  800420d331:	48 01 d0             	add    %rdx,%rax
  800420d334:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d338:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d33e:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420d343:	89 45 fc             	mov    %eax,-0x4(%rbp)
	int k = 0 ;
  800420d346:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	while(k<NENV) {
  800420d34d:	e9 91 02 00 00       	jmpq   800420d5e3 <sched_yield+0x31f>
		i = (i+1)%NENV;	
  800420d352:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d355:	8d 50 01             	lea    0x1(%rax),%edx
  800420d358:	89 d0                	mov    %edx,%eax
  800420d35a:	c1 f8 1f             	sar    $0x1f,%eax
  800420d35d:	c1 e8 16             	shr    $0x16,%eax
  800420d360:	01 c2                	add    %eax,%edx
  800420d362:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420d368:	89 d1                	mov    %edx,%ecx
  800420d36a:	29 c1                	sub    %eax,%ecx
  800420d36c:	89 c8                	mov    %ecx,%eax
  800420d36e:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (envs[i].env_status == ENV_RUNNABLE) {
  800420d371:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d378:	00 00 00 
  800420d37b:	48 8b 08             	mov    (%rax),%rcx
  800420d37e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d381:	48 63 d0             	movslq %eax,%rdx
  800420d384:	48 89 d0             	mov    %rdx,%rax
  800420d387:	48 c1 e0 02          	shl    $0x2,%rax
  800420d38b:	48 01 d0             	add    %rdx,%rax
  800420d38e:	48 01 c0             	add    %rax,%rax
  800420d391:	48 01 d0             	add    %rdx,%rax
  800420d394:	48 c1 e0 05          	shl    $0x5,%rax
  800420d398:	48 01 c8             	add    %rcx,%rax
  800420d39b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d3a1:	83 f8 02             	cmp    $0x2,%eax
  800420d3a4:	0f 85 35 02 00 00    	jne    800420d5df <sched_yield+0x31b>
			if (envs[i].env_type == ENV_TYPE_GUEST) {
  800420d3aa:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d3b1:	00 00 00 
  800420d3b4:	48 8b 08             	mov    (%rax),%rcx
  800420d3b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d3ba:	48 63 d0             	movslq %eax,%rdx
  800420d3bd:	48 89 d0             	mov    %rdx,%rax
  800420d3c0:	48 c1 e0 02          	shl    $0x2,%rax
  800420d3c4:	48 01 d0             	add    %rdx,%rax
  800420d3c7:	48 01 c0             	add    %rax,%rax
  800420d3ca:	48 01 d0             	add    %rdx,%rax
  800420d3cd:	48 c1 e0 05          	shl    $0x5,%rax
  800420d3d1:	48 01 c8             	add    %rcx,%rax
  800420d3d4:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420d3da:	83 f8 03             	cmp    $0x3,%eax
  800420d3dd:	0f 85 c3 01 00 00    	jne    800420d5a6 <sched_yield+0x2e2>
				// Cannot do this inside guest...
				// the environment doesn't have a clue that it is an environment.
				// Its an OS now.. :D
				if (!vmxon()) {
  800420d3e3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d3e8:	48 ba 27 d2 20 04 80 	movabs $0x800420d227,%rdx
  800420d3ef:	00 00 00 
  800420d3f2:	ff d2                	callq  *%rdx
  800420d3f4:	85 c0                	test   %eax,%eax
  800420d3f6:	0f 85 7b 02 00 00    	jne    800420d677 <sched_yield+0x3b3>
					if (curenv && curenv->env_status == ENV_RUNNING) {
  800420d3fc:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d403:	00 00 00 
  800420d406:	ff d0                	callq  *%rax
  800420d408:	48 98                	cltq   
  800420d40a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d40e:	48 89 c2             	mov    %rax,%rdx
  800420d411:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d415:	48 01 c2             	add    %rax,%rdx
  800420d418:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d41f:	00 00 00 
  800420d422:	48 01 d0             	add    %rdx,%rax
  800420d425:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d429:	48 85 c0             	test   %rax,%rax
  800420d42c:	74 6f                	je     800420d49d <sched_yield+0x1d9>
  800420d42e:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d435:	00 00 00 
  800420d438:	ff d0                	callq  *%rax
  800420d43a:	48 98                	cltq   
  800420d43c:	48 c1 e0 03          	shl    $0x3,%rax
  800420d440:	48 89 c2             	mov    %rax,%rdx
  800420d443:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d447:	48 01 c2             	add    %rax,%rdx
  800420d44a:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d451:	00 00 00 
  800420d454:	48 01 d0             	add    %rdx,%rax
  800420d457:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d45b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d461:	83 f8 03             	cmp    $0x3,%eax
  800420d464:	75 37                	jne    800420d49d <sched_yield+0x1d9>
						curenv->env_status = ENV_RUNNABLE;
  800420d466:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d46d:	00 00 00 
  800420d470:	ff d0                	callq  *%rax
  800420d472:	48 98                	cltq   
  800420d474:	48 c1 e0 03          	shl    $0x3,%rax
  800420d478:	48 89 c2             	mov    %rax,%rdx
  800420d47b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d47f:	48 01 c2             	add    %rax,%rdx
  800420d482:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d489:	00 00 00 
  800420d48c:	48 01 d0             	add    %rdx,%rax
  800420d48f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d493:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420d49a:	00 00 00 
    				}
 		    		curenv = &envs[i];
  800420d49d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d4a4:	00 00 00 
  800420d4a7:	ff d0                	callq  *%rax
  800420d4a9:	48 98                	cltq   
  800420d4ab:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4af:	48 89 c2             	mov    %rax,%rdx
  800420d4b2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d4b6:	48 01 c2             	add    %rax,%rdx
  800420d4b9:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d4c0:	00 00 00 
  800420d4c3:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800420d4c7:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d4ce:	00 00 00 
  800420d4d1:	48 8b 30             	mov    (%rax),%rsi
  800420d4d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4d7:	48 63 d0             	movslq %eax,%rdx
  800420d4da:	48 89 d0             	mov    %rdx,%rax
  800420d4dd:	48 c1 e0 02          	shl    $0x2,%rax
  800420d4e1:	48 01 d0             	add    %rdx,%rax
  800420d4e4:	48 01 c0             	add    %rax,%rax
  800420d4e7:	48 01 d0             	add    %rdx,%rax
  800420d4ea:	48 c1 e0 05          	shl    $0x5,%rax
  800420d4ee:	48 01 f0             	add    %rsi,%rax
  800420d4f1:	48 89 41 08          	mov    %rax,0x8(%rcx)
					curenv->env_status = ENV_RUNNING;
  800420d4f5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d4fc:	00 00 00 
  800420d4ff:	ff d0                	callq  *%rax
  800420d501:	48 98                	cltq   
  800420d503:	48 c1 e0 03          	shl    $0x3,%rax
  800420d507:	48 89 c2             	mov    %rax,%rdx
  800420d50a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d50e:	48 01 c2             	add    %rax,%rdx
  800420d511:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d518:	00 00 00 
  800420d51b:	48 01 d0             	add    %rdx,%rax
  800420d51e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d522:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420d529:	00 00 00 
					curenv->env_runs++;
  800420d52c:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d533:	00 00 00 
  800420d536:	ff d0                	callq  *%rax
  800420d538:	48 98                	cltq   
  800420d53a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d53e:	48 89 c2             	mov    %rax,%rdx
  800420d541:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d545:	48 01 c2             	add    %rax,%rdx
  800420d548:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d54f:	00 00 00 
  800420d552:	48 01 d0             	add    %rdx,%rax
  800420d555:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d559:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  800420d55f:	83 c2 01             	add    $0x1,%edx
  800420d562:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
		    		vmx_vmrun(&envs[i]);
  800420d568:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d56f:	00 00 00 
  800420d572:	48 8b 08             	mov    (%rax),%rcx
  800420d575:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d578:	48 63 d0             	movslq %eax,%rdx
  800420d57b:	48 89 d0             	mov    %rdx,%rax
  800420d57e:	48 c1 e0 02          	shl    $0x2,%rax
  800420d582:	48 01 d0             	add    %rdx,%rax
  800420d585:	48 01 c0             	add    %rax,%rax
  800420d588:	48 01 d0             	add    %rdx,%rax
  800420d58b:	48 c1 e0 05          	shl    $0x5,%rax
  800420d58f:	48 01 c8             	add    %rcx,%rax
  800420d592:	48 89 c7             	mov    %rax,%rdi
  800420d595:	48 b8 77 b5 21 04 80 	movabs $0x800421b577,%rax
  800420d59c:	00 00 00 
  800420d59f:	ff d0                	callq  *%rax
				}
			}
			else {
				env_run(&envs[i]);
			}
			return;
  800420d5a1:	e9 d1 00 00 00       	jmpq   800420d677 <sched_yield+0x3b3>
					curenv->env_runs++;
		    		vmx_vmrun(&envs[i]);
				}
			}
			else {
				env_run(&envs[i]);
  800420d5a6:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d5ad:	00 00 00 
  800420d5b0:	48 8b 08             	mov    (%rax),%rcx
  800420d5b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d5b6:	48 63 d0             	movslq %eax,%rdx
  800420d5b9:	48 89 d0             	mov    %rdx,%rax
  800420d5bc:	48 c1 e0 02          	shl    $0x2,%rax
  800420d5c0:	48 01 d0             	add    %rdx,%rax
  800420d5c3:	48 01 c0             	add    %rax,%rax
  800420d5c6:	48 01 d0             	add    %rdx,%rax
  800420d5c9:	48 c1 e0 05          	shl    $0x5,%rax
  800420d5cd:	48 01 c8             	add    %rcx,%rax
  800420d5d0:	48 89 c7             	mov    %rax,%rdi
  800420d5d3:	48 b8 3c 8b 20 04 80 	movabs $0x8004208b3c,%rax
  800420d5da:	00 00 00 
  800420d5dd:	ff d0                	callq  *%rax
			}
			return;
		}
		k++;
  800420d5df:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
	idle = thiscpu->cpu_env;
	int i = 0;
	if(idle)
 		i = ENVX(thiscpu->cpu_env->env_id);
	int k = 0 ;
	while(k<NENV) {
  800420d5e3:	81 7d f8 ff 03 00 00 	cmpl   $0x3ff,-0x8(%rbp)
  800420d5ea:	0f 8e 62 fd ff ff    	jle    800420d352 <sched_yield+0x8e>
		k++;
	}
	// LAB 4: Your code here.

	// sched_halt never returns
	if(idle && idle->env_status == ENV_RUNNING)
  800420d5f0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d5f5:	74 72                	je     800420d669 <sched_yield+0x3a5>
  800420d5f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d5fb:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d601:	83 f8 03             	cmp    $0x3,%eax
  800420d604:	75 63                	jne    800420d669 <sched_yield+0x3a5>
	{
		if (idle->env_type == ENV_TYPE_GUEST) {
  800420d606:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d60a:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420d610:	83 f8 03             	cmp    $0x3,%eax
  800420d613:	75 41                	jne    800420d656 <sched_yield+0x392>
			if (!vmxon()) {
  800420d615:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d61a:	48 ba 27 d2 20 04 80 	movabs $0x800420d227,%rdx
  800420d621:	00 00 00 
  800420d624:	ff d2                	callq  *%rdx
  800420d626:	85 c0                	test   %eax,%eax
  800420d628:	75 3f                	jne    800420d669 <sched_yield+0x3a5>
				idle->env_runs++;
  800420d62a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d62e:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800420d634:	8d 50 01             	lea    0x1(%rax),%edx
  800420d637:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d63b:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
				vmx_vmrun(idle);
  800420d641:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d645:	48 89 c7             	mov    %rax,%rdi
  800420d648:	48 b8 77 b5 21 04 80 	movabs $0x800421b577,%rax
  800420d64f:	00 00 00 
  800420d652:	ff d0                	callq  *%rax
  800420d654:	eb 13                	jmp    800420d669 <sched_yield+0x3a5>
			}
		}
		else {
			env_run(idle);
  800420d656:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d65a:	48 89 c7             	mov    %rax,%rdi
  800420d65d:	48 b8 3c 8b 20 04 80 	movabs $0x8004208b3c,%rax
  800420d664:	00 00 00 
  800420d667:	ff d0                	callq  *%rax
		}
	}
	sched_halt();
  800420d669:	48 b8 7a d6 20 04 80 	movabs $0x800420d67a,%rax
  800420d670:	00 00 00 
  800420d673:	ff d0                	callq  *%rax
  800420d675:	eb 01                	jmp    800420d678 <sched_yield+0x3b4>
				}
			}
			else {
				env_run(&envs[i]);
			}
			return;
  800420d677:	90                   	nop
		else {
			env_run(idle);
		}
	}
	sched_halt();
}
  800420d678:	c9                   	leaveq 
  800420d679:	c3                   	retq   

000000800420d67a <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.

void
sched_halt(void)
{
  800420d67a:	55                   	push   %rbp
  800420d67b:	48 89 e5             	mov    %rsp,%rbp
  800420d67e:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420d682:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d689:	e9 a3 00 00 00       	jmpq   800420d731 <sched_halt+0xb7>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d68e:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d695:	00 00 00 
  800420d698:	48 8b 08             	mov    (%rax),%rcx
  800420d69b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d69e:	48 63 d0             	movslq %eax,%rdx
  800420d6a1:	48 89 d0             	mov    %rdx,%rax
  800420d6a4:	48 c1 e0 02          	shl    $0x2,%rax
  800420d6a8:	48 01 d0             	add    %rdx,%rax
  800420d6ab:	48 01 c0             	add    %rax,%rax
  800420d6ae:	48 01 d0             	add    %rdx,%rax
  800420d6b1:	48 c1 e0 05          	shl    $0x5,%rax
  800420d6b5:	48 01 c8             	add    %rcx,%rax
  800420d6b8:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d6be:	83 f8 02             	cmp    $0x2,%eax
  800420d6c1:	74 7b                	je     800420d73e <sched_halt+0xc4>
		     envs[i].env_status == ENV_RUNNING ||
  800420d6c3:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d6ca:	00 00 00 
  800420d6cd:	48 8b 08             	mov    (%rax),%rcx
  800420d6d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d6d3:	48 63 d0             	movslq %eax,%rdx
  800420d6d6:	48 89 d0             	mov    %rdx,%rax
  800420d6d9:	48 c1 e0 02          	shl    $0x2,%rax
  800420d6dd:	48 01 d0             	add    %rdx,%rax
  800420d6e0:	48 01 c0             	add    %rax,%rax
  800420d6e3:	48 01 d0             	add    %rdx,%rax
  800420d6e6:	48 c1 e0 05          	shl    $0x5,%rax
  800420d6ea:	48 01 c8             	add    %rcx,%rax
  800420d6ed:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d6f3:	83 f8 03             	cmp    $0x3,%eax
  800420d6f6:	74 46                	je     800420d73e <sched_halt+0xc4>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420d6f8:	48 b8 50 22 48 04 80 	movabs $0x8004482250,%rax
  800420d6ff:	00 00 00 
  800420d702:	48 8b 08             	mov    (%rax),%rcx
  800420d705:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d708:	48 63 d0             	movslq %eax,%rdx
  800420d70b:	48 89 d0             	mov    %rdx,%rax
  800420d70e:	48 c1 e0 02          	shl    $0x2,%rax
  800420d712:	48 01 d0             	add    %rdx,%rax
  800420d715:	48 01 c0             	add    %rax,%rax
  800420d718:	48 01 d0             	add    %rdx,%rax
  800420d71b:	48 c1 e0 05          	shl    $0x5,%rax
  800420d71f:	48 01 c8             	add    %rcx,%rax
  800420d722:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420d728:	83 f8 01             	cmp    $0x1,%eax
  800420d72b:	74 11                	je     800420d73e <sched_halt+0xc4>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420d72d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d731:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d738:	0f 8e 50 ff ff ff    	jle    800420d68e <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420d73e:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d745:	75 2e                	jne    800420d775 <sched_halt+0xfb>
		cprintf("No runnable environments in the system!\n");
  800420d747:	48 bf 28 dc 21 04 80 	movabs $0x800421dc28,%rdi
  800420d74e:	00 00 00 
  800420d751:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d756:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420d75d:	00 00 00 
  800420d760:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420d762:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d767:	48 b8 1f 17 20 04 80 	movabs $0x800420171f,%rax
  800420d76e:	00 00 00 
  800420d771:	ff d0                	callq  *%rax
  800420d773:	eb ed                	jmp    800420d762 <sched_halt+0xe8>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420d775:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d77c:	00 00 00 
  800420d77f:	ff d0                	callq  *%rax
  800420d781:	48 98                	cltq   
  800420d783:	48 c1 e0 03          	shl    $0x3,%rax
  800420d787:	48 89 c2             	mov    %rax,%rdx
  800420d78a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d78e:	48 01 c2             	add    %rax,%rdx
  800420d791:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d798:	00 00 00 
  800420d79b:	48 01 d0             	add    %rdx,%rax
  800420d79e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800420d7a5:	00 
	lcr3(PADDR(boot_pml4e));
  800420d7a6:	48 b8 68 37 48 04 80 	movabs $0x8004483768,%rax
  800420d7ad:	00 00 00 
  800420d7b0:	48 8b 00             	mov    (%rax),%rax
  800420d7b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d7b7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d7be:	00 00 00 
  800420d7c1:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d7c5:	77 32                	ja     800420d7f9 <sched_halt+0x17f>
  800420d7c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d7cb:	48 89 c1             	mov    %rax,%rcx
  800420d7ce:	48 ba 58 dc 21 04 80 	movabs $0x800421dc58,%rdx
  800420d7d5:	00 00 00 
  800420d7d8:	be 74 00 00 00       	mov    $0x74,%esi
  800420d7dd:	48 bf 7c dc 21 04 80 	movabs $0x800421dc7c,%rdi
  800420d7e4:	00 00 00 
  800420d7e7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d7ec:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420d7f3:	00 00 00 
  800420d7f6:	41 ff d0             	callq  *%r8
  800420d7f9:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420d800:	ff ff ff 
  800420d803:	48 03 45 f0          	add    -0x10(%rbp),%rax
  800420d807:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d80b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d80f:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d812:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d819:	00 00 00 
  800420d81c:	ff d0                	callq  *%rax
  800420d81e:	48 98                	cltq   
  800420d820:	48 c1 e0 03          	shl    $0x3,%rax
  800420d824:	48 89 c2             	mov    %rax,%rdx
  800420d827:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d82b:	48 01 c2             	add    %rax,%rdx
  800420d82e:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d835:	00 00 00 
  800420d838:	48 01 d0             	add    %rdx,%rax
  800420d83b:	48 83 c0 04          	add    $0x4,%rax
  800420d83f:	be 02 00 00 00       	mov    $0x2,%esi
  800420d844:	48 89 c7             	mov    %rax,%rdi
  800420d847:	48 b8 d8 d1 20 04 80 	movabs $0x800420d1d8,%rax
  800420d84e:	00 00 00 
  800420d851:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420d853:	48 b8 09 d2 20 04 80 	movabs $0x800420d209,%rax
  800420d85a:	00 00 00 
  800420d85d:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d85f:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d866:	00 00 00 
  800420d869:	ff d0                	callq  *%rax
  800420d86b:	48 98                	cltq   
  800420d86d:	48 c1 e0 03          	shl    $0x3,%rax
  800420d871:	48 89 c2             	mov    %rax,%rdx
  800420d874:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d878:	48 01 c2             	add    %rax,%rdx
  800420d87b:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d882:	00 00 00 
  800420d885:	48 01 d0             	add    %rdx,%rax
  800420d888:	48 8b 40 14          	mov    0x14(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420d88c:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d893:	48 89 c4             	mov    %rax,%rsp
  800420d896:	6a 00                	pushq  $0x0
  800420d898:	6a 00                	pushq  $0x0
  800420d89a:	fb                   	sti    
  800420d89b:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420d89c:	c9                   	leaveq 
  800420d89d:	c3                   	retq   
	...

000000800420d8a0 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420d8a0:	55                   	push   %rbp
  800420d8a1:	48 89 e5             	mov    %rsp,%rbp
  800420d8a4:	48 83 ec 08          	sub    $0x8,%rsp
  800420d8a8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420d8ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d8b0:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  800420d8b7:	00 00 00 
  800420d8ba:	48 8b 00             	mov    (%rax),%rax
  800420d8bd:	48 89 d1             	mov    %rdx,%rcx
  800420d8c0:	48 29 c1             	sub    %rax,%rcx
  800420d8c3:	48 89 c8             	mov    %rcx,%rax
  800420d8c6:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420d8ca:	c9                   	leaveq 
  800420d8cb:	c3                   	retq   

000000800420d8cc <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420d8cc:	55                   	push   %rbp
  800420d8cd:	48 89 e5             	mov    %rsp,%rbp
  800420d8d0:	48 83 ec 08          	sub    $0x8,%rsp
  800420d8d4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420d8d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d8dc:	48 89 c7             	mov    %rax,%rdi
  800420d8df:	48 b8 a0 d8 20 04 80 	movabs $0x800420d8a0,%rax
  800420d8e6:	00 00 00 
  800420d8e9:	ff d0                	callq  *%rax
  800420d8eb:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420d8ef:	c9                   	leaveq 
  800420d8f0:	c3                   	retq   

000000800420d8f1 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800420d8f1:	55                   	push   %rbp
  800420d8f2:	48 89 e5             	mov    %rsp,%rbp
  800420d8f5:	48 83 ec 20          	sub    $0x20,%rsp
  800420d8f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420d8fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d901:	48 89 c7             	mov    %rax,%rdi
  800420d904:	48 b8 cc d8 20 04 80 	movabs $0x800420d8cc,%rax
  800420d90b:	00 00 00 
  800420d90e:	ff d0                	callq  *%rax
  800420d910:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d914:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d918:	48 c1 e8 0c          	shr    $0xc,%rax
  800420d91c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420d91f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420d922:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800420d929:	00 00 00 
  800420d92c:	48 8b 00             	mov    (%rax),%rax
  800420d92f:	48 39 c2             	cmp    %rax,%rdx
  800420d932:	72 32                	jb     800420d966 <page2kva+0x75>
  800420d934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d938:	48 89 c1             	mov    %rax,%rcx
  800420d93b:	48 ba 90 dc 21 04 80 	movabs $0x800421dc90,%rdx
  800420d942:	00 00 00 
  800420d945:	be 5b 00 00 00       	mov    $0x5b,%esi
  800420d94a:	48 bf b3 dc 21 04 80 	movabs $0x800421dcb3,%rdi
  800420d951:	00 00 00 
  800420d954:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d959:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420d960:	00 00 00 
  800420d963:	41 ff d0             	callq  *%r8
  800420d966:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420d96d:	00 00 00 
  800420d970:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  800420d974:	c9                   	leaveq 
  800420d975:	c3                   	retq   

000000800420d976 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d976:	55                   	push   %rbp
  800420d977:	48 89 e5             	mov    %rsp,%rbp
  800420d97a:	48 83 ec 10          	sub    $0x10,%rsp
  800420d97e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d982:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, s, len, PTE_U);
  800420d986:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420d98d:	00 00 00 
  800420d990:	ff d0                	callq  *%rax
  800420d992:	48 98                	cltq   
  800420d994:	48 c1 e0 03          	shl    $0x3,%rax
  800420d998:	48 89 c2             	mov    %rax,%rdx
  800420d99b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d99f:	48 01 c2             	add    %rax,%rdx
  800420d9a2:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420d9a9:	00 00 00 
  800420d9ac:	48 01 d0             	add    %rdx,%rax
  800420d9af:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d9b3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d9b7:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d9bb:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d9c0:	48 89 c7             	mov    %rax,%rdi
  800420d9c3:	48 b8 6f 39 20 04 80 	movabs $0x800420396f,%rax
  800420d9ca:	00 00 00 
  800420d9cd:	ff d0                	callq  *%rax
	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420d9cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d9d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d9d7:	48 89 c6             	mov    %rax,%rsi
  800420d9da:	48 bf c1 dc 21 04 80 	movabs $0x800421dcc1,%rdi
  800420d9e1:	00 00 00 
  800420d9e4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d9e9:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420d9f0:	00 00 00 
  800420d9f3:	ff d1                	callq  *%rcx
}
  800420d9f5:	c9                   	leaveq 
  800420d9f6:	c3                   	retq   

000000800420d9f7 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d9f7:	55                   	push   %rbp
  800420d9f8:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d9fb:	48 b8 2d 11 20 04 80 	movabs $0x800420112d,%rax
  800420da02:	00 00 00 
  800420da05:	ff d0                	callq  *%rax
}
  800420da07:	5d                   	pop    %rbp
  800420da08:	c3                   	retq   

000000800420da09 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420da09:	55                   	push   %rbp
  800420da0a:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420da0d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420da14:	00 00 00 
  800420da17:	ff d0                	callq  *%rax
  800420da19:	48 98                	cltq   
  800420da1b:	48 c1 e0 03          	shl    $0x3,%rax
  800420da1f:	48 89 c2             	mov    %rax,%rdx
  800420da22:	48 c1 e2 04          	shl    $0x4,%rdx
  800420da26:	48 01 c2             	add    %rax,%rdx
  800420da29:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420da30:	00 00 00 
  800420da33:	48 01 d0             	add    %rdx,%rax
  800420da36:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420da3a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420da40:	5d                   	pop    %rbp
  800420da41:	c3                   	retq   

000000800420da42 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420da42:	55                   	push   %rbp
  800420da43:	48 89 e5             	mov    %rsp,%rbp
  800420da46:	48 83 ec 20          	sub    $0x20,%rsp
  800420da4a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420da4d:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420da51:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420da54:	ba 01 00 00 00       	mov    $0x1,%edx
  800420da59:	48 89 ce             	mov    %rcx,%rsi
  800420da5c:	89 c7                	mov    %eax,%edi
  800420da5e:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420da65:	00 00 00 
  800420da68:	ff d0                	callq  *%rax
  800420da6a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420da6d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420da71:	79 05                	jns    800420da78 <sys_env_destroy+0x36>
		return r;
  800420da73:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420da76:	eb 18                	jmp    800420da90 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420da78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420da7c:	48 89 c7             	mov    %rax,%rdi
  800420da7f:	48 b8 59 89 20 04 80 	movabs $0x8004208959,%rax
  800420da86:	00 00 00 
  800420da89:	ff d0                	callq  *%rax
	return 0;
  800420da8b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420da90:	c9                   	leaveq 
  800420da91:	c3                   	retq   

000000800420da92 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420da92:	55                   	push   %rbp
  800420da93:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420da96:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  800420da9d:	00 00 00 
  800420daa0:	ff d0                	callq  *%rax

000000800420daa2 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420daa2:	55                   	push   %rbp
  800420daa3:	48 89 e5             	mov    %rsp,%rbp
  800420daa6:	53                   	push   %rbx
  800420daa7:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env* child;
	int r = env_alloc(&child, curenv->env_id);
  800420daab:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420dab2:	00 00 00 
  800420dab5:	ff d0                	callq  *%rax
  800420dab7:	48 98                	cltq   
  800420dab9:	48 c1 e0 03          	shl    $0x3,%rax
  800420dabd:	48 89 c2             	mov    %rax,%rdx
  800420dac0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dac4:	48 01 c2             	add    %rax,%rdx
  800420dac7:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420dace:	00 00 00 
  800420dad1:	48 01 d0             	add    %rdx,%rax
  800420dad4:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420dad8:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420dade:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420dae2:	89 d6                	mov    %edx,%esi
  800420dae4:	48 89 c7             	mov    %rax,%rdi
  800420dae7:	48 b8 2d 80 20 04 80 	movabs $0x800420802d,%rax
  800420daee:	00 00 00 
  800420daf1:	ff d0                	callq  *%rax
  800420daf3:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(r < 0) {
  800420daf6:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420dafa:	79 28                	jns    800420db24 <sys_exofork+0x82>
		cprintf("\nenv_alloc, sys_exofork %e \n",r);
  800420dafc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420daff:	89 c6                	mov    %eax,%esi
  800420db01:	48 bf c6 dc 21 04 80 	movabs $0x800421dcc6,%rdi
  800420db08:	00 00 00 
  800420db0b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420db10:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420db17:	00 00 00 
  800420db1a:	ff d2                	callq  *%rdx
		return r;
  800420db1c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420db1f:	e9 a6 00 00 00       	jmpq   800420dbca <sys_exofork+0x128>
	}
	child->env_status = ENV_NOT_RUNNABLE;
  800420db24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420db28:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420db2f:	00 00 00 
	child->env_tf = curenv->env_tf;
  800420db32:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420db36:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420db3d:	00 00 00 
  800420db40:	ff d0                	callq  *%rax
  800420db42:	48 98                	cltq   
  800420db44:	48 c1 e0 03          	shl    $0x3,%rax
  800420db48:	48 89 c2             	mov    %rax,%rdx
  800420db4b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420db4f:	48 01 c2             	add    %rax,%rdx
  800420db52:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420db59:	00 00 00 
  800420db5c:	48 01 d0             	add    %rdx,%rax
  800420db5f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420db63:	48 89 da             	mov    %rbx,%rdx
  800420db66:	48 89 c6             	mov    %rax,%rsi
  800420db69:	b8 18 00 00 00       	mov    $0x18,%eax
  800420db6e:	48 89 d7             	mov    %rdx,%rdi
  800420db71:	48 89 c1             	mov    %rax,%rcx
  800420db74:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	child->env_tf.tf_regs.reg_rax = 0; //setting return value for child
  800420db77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420db7b:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420db82:	00 
	child->env_parent_id = curenv->env_id;
  800420db83:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420db87:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420db8e:	00 00 00 
  800420db91:	ff d0                	callq  *%rax
  800420db93:	48 98                	cltq   
  800420db95:	48 c1 e0 03          	shl    $0x3,%rax
  800420db99:	48 89 c2             	mov    %rax,%rdx
  800420db9c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dba0:	48 01 c2             	add    %rax,%rdx
  800420dba3:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420dbaa:	00 00 00 
  800420dbad:	48 01 d0             	add    %rdx,%rax
  800420dbb0:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420dbb4:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420dbba:	89 83 cc 00 00 00    	mov    %eax,0xcc(%rbx)
	return child->env_id;
  800420dbc0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dbc4:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
	//panic("sys_exofork not implemented");
}
  800420dbca:	48 83 c4 18          	add    $0x18,%rsp
  800420dbce:	5b                   	pop    %rbx
  800420dbcf:	5d                   	pop    %rbp
  800420dbd0:	c3                   	retq   

000000800420dbd1 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420dbd1:	55                   	push   %rbp
  800420dbd2:	48 89 e5             	mov    %rsp,%rbp
  800420dbd5:	48 83 ec 20          	sub    $0x20,%rsp
  800420dbd9:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420dbdc:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// Hint: Use the 'envid2env' function from kern/env.c to translate an
	// envid to a struct Env.
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.	
	if((status != ENV_RUNNABLE) && (status != ENV_NOT_RUNNABLE)) {
  800420dbdf:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420dbe3:	74 2d                	je     800420dc12 <sys_env_set_status+0x41>
  800420dbe5:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420dbe9:	74 27                	je     800420dc12 <sys_env_set_status+0x41>
		cprintf("\n improper status %e\n", -E_INVAL);
  800420dbeb:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800420dbf0:	48 bf e3 dc 21 04 80 	movabs $0x800421dce3,%rdi
  800420dbf7:	00 00 00 
  800420dbfa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dbff:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dc06:	00 00 00 
  800420dc09:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420dc0b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dc10:	eb 5d                	jmp    800420dc6f <sys_env_set_status+0x9e>
	}
	struct Env* envnow;
	int r = envid2env(envid, &envnow, 1);
  800420dc12:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dc16:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dc19:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dc1e:	48 89 ce             	mov    %rcx,%rsi
  800420dc21:	89 c7                	mov    %eax,%edi
  800420dc23:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420dc2a:	00 00 00 
  800420dc2d:	ff d0                	callq  *%rax
  800420dc2f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(r < 0) {
  800420dc32:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dc36:	79 25                	jns    800420dc5d <sys_env_set_status+0x8c>
		cprintf("\n envid2env %e\n", r);
  800420dc38:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc3b:	89 c6                	mov    %eax,%esi
  800420dc3d:	48 bf f9 dc 21 04 80 	movabs $0x800421dcf9,%rdi
  800420dc44:	00 00 00 
  800420dc47:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dc4c:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dc53:	00 00 00 
  800420dc56:	ff d2                	callq  *%rdx
		return r;
  800420dc58:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc5b:	eb 12                	jmp    800420dc6f <sys_env_set_status+0x9e>
	}
	envnow->env_status = status;
  800420dc5d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dc61:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420dc64:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420dc6a:	b8 00 00 00 00       	mov    $0x0,%eax
	// LAB 4: Your code here.
	//panic("sys_env_set_status not implemented");
}
  800420dc6f:	c9                   	leaveq 
  800420dc70:	c3                   	retq   

000000800420dc71 <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420dc71:	55                   	push   %rbp
  800420dc72:	48 89 e5             	mov    %rsp,%rbp
  800420dc75:	48 83 ec 20          	sub    $0x20,%rsp
  800420dc79:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420dc7c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 5: Your code here.
	// Remember to check whether the user has supplied us with a good
	// address!
    struct Env *envnow;
    int r = envid2env(envid, &envnow, 1); 
  800420dc80:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dc84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dc87:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dc8c:	48 89 ce             	mov    %rcx,%rsi
  800420dc8f:	89 c7                	mov    %eax,%edi
  800420dc91:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420dc98:	00 00 00 
  800420dc9b:	ff d0                	callq  *%rax
  800420dc9d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r<0) {
  800420dca0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dca4:	79 25                	jns    800420dccb <sys_env_set_trapframe+0x5a>
        cprintf("\n bad ENvid sys_env_set_pgfault_upcall %e \n",r);
  800420dca6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dca9:	89 c6                	mov    %eax,%esi
  800420dcab:	48 bf 10 dd 21 04 80 	movabs $0x800421dd10,%rdi
  800420dcb2:	00 00 00 
  800420dcb5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dcba:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dcc1:	00 00 00 
  800420dcc4:	ff d2                	callq  *%rdx
        return r;
  800420dcc6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dcc9:	eb 50                	jmp    800420dd1b <sys_env_set_trapframe+0xaa>
    }
    envnow->env_tf = *tf;
  800420dccb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420dccf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dcd3:	48 89 c6             	mov    %rax,%rsi
  800420dcd6:	b8 18 00 00 00       	mov    $0x18,%eax
  800420dcdb:	48 89 d7             	mov    %rdx,%rdi
  800420dcde:	48 89 c1             	mov    %rax,%rcx
  800420dce1:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	envnow->env_tf.tf_cs |= 3;
  800420dce4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dce8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420dcec:	0f b7 92 a0 00 00 00 	movzwl 0xa0(%rdx),%edx
  800420dcf3:	83 ca 03             	or     $0x3,%edx
  800420dcf6:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
   	envnow->env_tf.tf_eflags |= FL_IF;
  800420dcfd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd01:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420dd05:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420dd0c:	80 ce 02             	or     $0x2,%dh
  800420dd0f:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

    return 0;
  800420dd16:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dd1b:	c9                   	leaveq 
  800420dd1c:	c3                   	retq   

000000800420dd1d <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420dd1d:	55                   	push   %rbp
  800420dd1e:	48 89 e5             	mov    %rsp,%rbp
  800420dd21:	48 83 ec 20          	sub    $0x20,%rsp
  800420dd25:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420dd28:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Env *newenv;
	int r = envid2env(envid, &newenv, 1);
  800420dd2c:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dd30:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dd33:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dd38:	48 89 ce             	mov    %rcx,%rsi
  800420dd3b:	89 c7                	mov    %eax,%edi
  800420dd3d:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420dd44:	00 00 00 
  800420dd47:	ff d0                	callq  *%rax
  800420dd49:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r<0) {
  800420dd4c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dd50:	79 25                	jns    800420dd77 <sys_env_set_pgfault_upcall+0x5a>
		cprintf("\n bad ENvid sys_env_set_pgfault_upcall %e \n",r);
  800420dd52:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dd55:	89 c6                	mov    %eax,%esi
  800420dd57:	48 bf 10 dd 21 04 80 	movabs $0x800421dd10,%rdi
  800420dd5e:	00 00 00 
  800420dd61:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd66:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dd6d:	00 00 00 
  800420dd70:	ff d2                	callq  *%rdx
		return r;
  800420dd72:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dd75:	eb 14                	jmp    800420dd8b <sys_env_set_pgfault_upcall+0x6e>
	}
	newenv->env_pgfault_upcall = func;
  800420dd77:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd7b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420dd7f:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420dd86:	b8 00 00 00 00       	mov    $0x0,%eax
	// LAB 4: Your code here.
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420dd8b:	c9                   	leaveq 
  800420dd8c:	c3                   	retq   

000000800420dd8d <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420dd8d:	55                   	push   %rbp
  800420dd8e:	48 89 e5             	mov    %rsp,%rbp
  800420dd91:	48 83 ec 30          	sub    $0x30,%rsp
  800420dd95:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420dd98:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420dd9c:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   Most of the new code you write should be to check the
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!
	struct Env* envnow;
	int r = envid2env(envid, &envnow, 1);
  800420dd9f:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420dda3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420dda6:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ddab:	48 89 ce             	mov    %rcx,%rsi
  800420ddae:	89 c7                	mov    %eax,%edi
  800420ddb0:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420ddb7:	00 00 00 
  800420ddba:	ff d0                	callq  *%rax
  800420ddbc:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(r<0){
  800420ddbf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ddc3:	79 28                	jns    800420dded <sys_page_alloc+0x60>
		cprintf("\nenvid2end sys_page_alloc %e \n", r);
  800420ddc5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ddc8:	89 c6                	mov    %eax,%esi
  800420ddca:	48 bf 40 dd 21 04 80 	movabs $0x800421dd40,%rdi
  800420ddd1:	00 00 00 
  800420ddd4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ddd9:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dde0:	00 00 00 
  800420dde3:	ff d2                	callq  *%rdx
		return r;
  800420dde5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dde8:	e9 20 01 00 00       	jmpq   800420df0d <sys_page_alloc+0x180>
	}
	struct PageInfo *pp = page_alloc(0);
  800420dded:	bf 00 00 00 00       	mov    $0x0,%edi
  800420ddf2:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800420ddf9:	00 00 00 
  800420ddfc:	ff d0                	callq  *%rax
  800420ddfe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (!pp) {
  800420de02:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420de07:	75 2a                	jne    800420de33 <sys_page_alloc+0xa6>
		cprintf("\n No memory to allocate page SYS_PAGE_ALLOC %e \n", -E_NO_MEM);
  800420de09:	be fc ff ff ff       	mov    $0xfffffffc,%esi
  800420de0e:	48 bf 60 dd 21 04 80 	movabs $0x800421dd60,%rdi
  800420de15:	00 00 00 
  800420de18:	b8 00 00 00 00       	mov    $0x0,%eax
  800420de1d:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420de24:	00 00 00 
  800420de27:	ff d2                	callq  *%rdx
		return -E_NO_MEM;
  800420de29:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420de2e:	e9 da 00 00 00       	jmpq   800420df0d <sys_page_alloc+0x180>
	}
	if ((uint64_t)va >= UTOP || PGOFF(va))
  800420de33:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420de37:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420de3e:	00 00 00 
  800420de41:	48 39 c2             	cmp    %rax,%rdx
  800420de44:	77 0e                	ja     800420de54 <sys_page_alloc+0xc7>
  800420de46:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420de4a:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420de4f:	48 85 c0             	test   %rax,%rax
  800420de52:	74 0a                	je     800420de5e <sys_page_alloc+0xd1>
    	return -E_INVAL;
  800420de54:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420de59:	e9 af 00 00 00       	jmpq   800420df0d <sys_page_alloc+0x180>

	int newperm = PTE_U | PTE_P;
  800420de5e:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%rbp)
	if ((perm & newperm) != newperm || (perm & ~PTE_SYSCALL)) {
  800420de65:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420de68:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420de6b:	21 d0                	and    %edx,%eax
  800420de6d:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420de70:	75 0c                	jne    800420de7e <sys_page_alloc+0xf1>
  800420de72:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420de75:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420de7a:	85 c0                	test   %eax,%eax
  800420de7c:	74 27                	je     800420dea5 <sys_page_alloc+0x118>
		cprintf("\n permission error %e sys_page_alloc\n", -E_INVAL);
  800420de7e:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800420de83:	48 bf 98 dd 21 04 80 	movabs $0x800421dd98,%rdi
  800420de8a:	00 00 00 
  800420de8d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420de92:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420de99:	00 00 00 
  800420de9c:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420de9e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dea3:	eb 68                	jmp    800420df0d <sys_page_alloc+0x180>
	}
	if (page_insert(envnow->env_pml4e, pp, va, perm) < 0) {
  800420dea5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dea9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420deb0:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420deb3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420deb7:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420debb:	48 89 c7             	mov    %rax,%rdi
  800420debe:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  800420dec5:	00 00 00 
  800420dec8:	ff d0                	callq  *%rax
  800420deca:	85 c0                	test   %eax,%eax
  800420decc:	79 3a                	jns    800420df08 <sys_page_alloc+0x17b>
		cprintf("\n No memory to allocate page SYS_PAGE_ALLOC %e \n", -E_NO_MEM);
  800420dece:	be fc ff ff ff       	mov    $0xfffffffc,%esi
  800420ded3:	48 bf 60 dd 21 04 80 	movabs $0x800421dd60,%rdi
  800420deda:	00 00 00 
  800420dedd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dee2:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dee9:	00 00 00 
  800420deec:	ff d2                	callq  *%rdx
		page_free(pp);
  800420deee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420def2:	48 89 c7             	mov    %rax,%rdi
  800420def5:	48 b8 71 2c 20 04 80 	movabs $0x8004202c71,%rax
  800420defc:	00 00 00 
  800420deff:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  800420df01:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420df06:	eb 05                	jmp    800420df0d <sys_page_alloc+0x180>
	}
	//memset(page2kva(pp), 0, PGSIZE);	
	return 0;
  800420df08:	b8 00 00 00 00       	mov    $0x0,%eax
	// LAB 4: Your code here.
	// panic("sys_page_alloc not implemented");
}
  800420df0d:	c9                   	leaveq 
  800420df0e:	c3                   	retq   

000000800420df0f <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420df0f:	55                   	push   %rbp
  800420df10:	48 89 e5             	mov    %rsp,%rbp
  800420df13:	48 83 ec 50          	sub    $0x50,%rsp
  800420df17:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420df1a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420df1e:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420df21:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420df25:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   Again, most of the new code you write should be to check the
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.
	struct Env *srcenv, *dstenv;
	int r1 = envid2env(srcenvid, &srcenv, 1);
  800420df29:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420df2d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420df30:	ba 01 00 00 00       	mov    $0x1,%edx
  800420df35:	48 89 ce             	mov    %rcx,%rsi
  800420df38:	89 c7                	mov    %eax,%edi
  800420df3a:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420df41:	00 00 00 
  800420df44:	ff d0                	callq  *%rax
  800420df46:	89 45 fc             	mov    %eax,-0x4(%rbp)
	int r2 = envid2env(dstenvid, &dstenv, 1);
  800420df49:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420df4d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420df50:	ba 01 00 00 00       	mov    $0x1,%edx
  800420df55:	48 89 ce             	mov    %rcx,%rsi
  800420df58:	89 c7                	mov    %eax,%edi
  800420df5a:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420df61:	00 00 00 
  800420df64:	ff d0                	callq  *%rax
  800420df66:	89 45 f8             	mov    %eax,-0x8(%rbp)
	/* Proper envid check*/
	if (r1 < 0 || r2 < 0) {
  800420df69:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420df6d:	78 06                	js     800420df75 <sys_page_map+0x66>
  800420df6f:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420df73:	79 2d                	jns    800420dfa2 <sys_page_map+0x93>
		cprintf("\n envid2env error %e, %e sys_page_map\n", r1, r2);
  800420df75:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800420df78:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420df7b:	89 c6                	mov    %eax,%esi
  800420df7d:	48 bf c0 dd 21 04 80 	movabs $0x800421ddc0,%rdi
  800420df84:	00 00 00 
  800420df87:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df8c:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420df93:	00 00 00 
  800420df96:	ff d1                	callq  *%rcx
		return -E_BAD_ENV;
  800420df98:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420df9d:	e9 a5 01 00 00       	jmpq   800420e147 <sys_page_map+0x238>
	}
	/*Address range check*/
	if((uintptr_t)srcva >= UTOP || (uintptr_t)dstva >= UTOP || PGOFF(srcva) || PGOFF(dstva)) {
  800420dfa2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420dfa6:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dfad:	00 00 00 
  800420dfb0:	48 39 c2             	cmp    %rax,%rdx
  800420dfb3:	77 2f                	ja     800420dfe4 <sys_page_map+0xd5>
  800420dfb5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420dfb9:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dfc0:	00 00 00 
  800420dfc3:	48 39 c2             	cmp    %rax,%rdx
  800420dfc6:	77 1c                	ja     800420dfe4 <sys_page_map+0xd5>
  800420dfc8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420dfcc:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420dfd1:	48 85 c0             	test   %rax,%rax
  800420dfd4:	75 0e                	jne    800420dfe4 <sys_page_map+0xd5>
  800420dfd6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420dfda:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420dfdf:	48 85 c0             	test   %rax,%rax
  800420dfe2:	74 2a                	je     800420e00e <sys_page_map+0xff>
		cprintf("\n envid2env error %e sys_page_map\n", -E_INVAL);
  800420dfe4:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800420dfe9:	48 bf e8 dd 21 04 80 	movabs $0x800421dde8,%rdi
  800420dff0:	00 00 00 
  800420dff3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dff8:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420dfff:	00 00 00 
  800420e002:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420e004:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e009:	e9 39 01 00 00       	jmpq   800420e147 <sys_page_map+0x238>
	}
	/*Correct page request check*/
	struct PageInfo *map;
	pte_t *p_entry;
	map = page_lookup(srcenv->env_pml4e, srcva, &p_entry);
  800420e00e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e012:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e019:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420e01d:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420e021:	48 89 ce             	mov    %rcx,%rsi
  800420e024:	48 89 c7             	mov    %rax,%rdi
  800420e027:	48 b8 7f 35 20 04 80 	movabs $0x800420357f,%rax
  800420e02e:	00 00 00 
  800420e031:	ff d0                	callq  *%rax
  800420e033:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!map) {
  800420e037:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e03c:	75 2a                	jne    800420e068 <sys_page_map+0x159>
		cprintf("\n No page available or not mapped properly SYS_PAGE_ALLOC %e \n", -E_NO_MEM);
  800420e03e:	be fc ff ff ff       	mov    $0xfffffffc,%esi
  800420e043:	48 bf 10 de 21 04 80 	movabs $0x800421de10,%rdi
  800420e04a:	00 00 00 
  800420e04d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e052:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e059:	00 00 00 
  800420e05c:	ff d2                	callq  *%rdx
		return -E_NO_MEM;
  800420e05e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e063:	e9 df 00 00 00       	jmpq   800420e147 <sys_page_map+0x238>
	}
	/*Proper Permission check*/
	int map_perm = PTE_P | PTE_U;
  800420e068:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%rbp)
	if ((perm & map_perm) != map_perm || (perm & ~PTE_SYSCALL)) {
  800420e06f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e072:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420e075:	21 d0                	and    %edx,%eax
  800420e077:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420e07a:	75 0c                	jne    800420e088 <sys_page_map+0x179>
  800420e07c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e07f:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e084:	85 c0                	test   %eax,%eax
  800420e086:	74 2a                	je     800420e0b2 <sys_page_map+0x1a3>
		cprintf("\n permission error %e sys_page_map\n", -E_INVAL);
  800420e088:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800420e08d:	48 bf 50 de 21 04 80 	movabs $0x800421de50,%rdi
  800420e094:	00 00 00 
  800420e097:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e09c:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e0a3:	00 00 00 
  800420e0a6:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420e0a8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e0ad:	e9 95 00 00 00       	jmpq   800420e147 <sys_page_map+0x238>
	}
	if((perm & PTE_W) && !(*p_entry & PTE_W)) {
  800420e0b2:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e0b5:	83 e0 02             	and    $0x2,%eax
  800420e0b8:	85 c0                	test   %eax,%eax
  800420e0ba:	74 36                	je     800420e0f2 <sys_page_map+0x1e3>
  800420e0bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e0c0:	48 8b 00             	mov    (%rax),%rax
  800420e0c3:	83 e0 02             	and    $0x2,%eax
  800420e0c6:	48 85 c0             	test   %rax,%rax
  800420e0c9:	75 27                	jne    800420e0f2 <sys_page_map+0x1e3>
		cprintf("\n permission error %e sys_page_map\n", -E_INVAL);
  800420e0cb:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800420e0d0:	48 bf 50 de 21 04 80 	movabs $0x800421de50,%rdi
  800420e0d7:	00 00 00 
  800420e0da:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e0df:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e0e6:	00 00 00 
  800420e0e9:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420e0eb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e0f0:	eb 55                	jmp    800420e147 <sys_page_map+0x238>
	}
	/*Page insert check*/
	if(page_insert(dstenv->env_pml4e, map, dstva, perm) < 0) {
  800420e0f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e0f6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e0fd:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420e100:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e104:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420e108:	48 89 c7             	mov    %rax,%rdi
  800420e10b:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  800420e112:	00 00 00 
  800420e115:	ff d0                	callq  *%rax
  800420e117:	85 c0                	test   %eax,%eax
  800420e119:	79 27                	jns    800420e142 <sys_page_map+0x233>
		cprintf("\n No memory to allocate page SYS_PAGE_MAP %e \n", -E_NO_MEM);
  800420e11b:	be fc ff ff ff       	mov    $0xfffffffc,%esi
  800420e120:	48 bf 78 de 21 04 80 	movabs $0x800421de78,%rdi
  800420e127:	00 00 00 
  800420e12a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e12f:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e136:	00 00 00 
  800420e139:	ff d2                	callq  *%rdx
		return -E_NO_MEM;
  800420e13b:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e140:	eb 05                	jmp    800420e147 <sys_page_map+0x238>
	}
	return 0;
  800420e142:	b8 00 00 00 00       	mov    $0x0,%eax
	// LAB 4: Your code here.
	//panic("sys_page_map not implemented");
}
  800420e147:	c9                   	leaveq 
  800420e148:	c3                   	retq   

000000800420e149 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420e149:	55                   	push   %rbp
  800420e14a:	48 89 e5             	mov    %rsp,%rbp
  800420e14d:	48 83 ec 20          	sub    $0x20,%rsp
  800420e151:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e154:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().
	struct Env* envnow;
	int r = envid2env(envid, &envnow, 1);
  800420e158:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e15c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e15f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e164:	48 89 ce             	mov    %rcx,%rsi
  800420e167:	89 c7                	mov    %eax,%edi
  800420e169:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420e170:	00 00 00 
  800420e173:	ff d0                	callq  *%rax
  800420e175:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(r < 0) {
  800420e178:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e17c:	79 25                	jns    800420e1a3 <sys_page_unmap+0x5a>
		cprintf("\n envid2env error %e sys_page_map\n", r);
  800420e17e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e181:	89 c6                	mov    %eax,%esi
  800420e183:	48 bf e8 dd 21 04 80 	movabs $0x800421dde8,%rdi
  800420e18a:	00 00 00 
  800420e18d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e192:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e199:	00 00 00 
  800420e19c:	ff d2                	callq  *%rdx
		return r;
  800420e19e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e1a1:	eb 4e                	jmp    800420e1f1 <sys_page_unmap+0xa8>
	}
	if ((uint64_t)va >= UTOP || PGOFF(va))
  800420e1a3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e1a7:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e1ae:	00 00 00 
  800420e1b1:	48 39 c2             	cmp    %rax,%rdx
  800420e1b4:	77 0e                	ja     800420e1c4 <sys_page_unmap+0x7b>
  800420e1b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e1ba:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e1bf:	48 85 c0             	test   %rax,%rax
  800420e1c2:	74 07                	je     800420e1cb <sys_page_unmap+0x82>
    	return -E_INVAL;
  800420e1c4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e1c9:	eb 26                	jmp    800420e1f1 <sys_page_unmap+0xa8>
	page_remove(envnow->env_pml4e, va);
  800420e1cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e1cf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e1d6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e1da:	48 89 d6             	mov    %rdx,%rsi
  800420e1dd:	48 89 c7             	mov    %rax,%rdi
  800420e1e0:	48 b8 fc 35 20 04 80 	movabs $0x80042035fc,%rax
  800420e1e7:	00 00 00 
  800420e1ea:	ff d0                	callq  *%rax
	return 0;
  800420e1ec:	b8 00 00 00 00       	mov    $0x0,%eax
	// LAB 4: Your code here.
	//panic("sys_page_unmap not implemented");
}
  800420e1f1:	c9                   	leaveq 
  800420e1f2:	c3                   	retq   

000000800420e1f3 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420e1f3:	55                   	push   %rbp
  800420e1f4:	48 89 e5             	mov    %rsp,%rbp
  800420e1f7:	53                   	push   %rbx
  800420e1f8:	48 83 ec 48          	sub    $0x48,%rsp
  800420e1fc:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420e1ff:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420e202:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e206:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	struct Env *recvr;
	int r = envid2env(envid, &recvr, 0);	
  800420e209:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420e20d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420e210:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e215:	48 89 ce             	mov    %rcx,%rsi
  800420e218:	89 c7                	mov    %eax,%edi
  800420e21a:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420e221:	00 00 00 
  800420e224:	ff d0                	callq  *%rax
  800420e226:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (r < 0) {
  800420e229:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e22d:	79 23                	jns    800420e252 <sys_ipc_try_send+0x5f>
		cprintf("\n Bad ENV\n");
  800420e22f:	48 bf a7 de 21 04 80 	movabs $0x800421dea7,%rdi
  800420e236:	00 00 00 
  800420e239:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e23e:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e245:	00 00 00 
  800420e248:	ff d2                	callq  *%rdx
		return r;
  800420e24a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e24d:	e9 50 02 00 00       	jmpq   800420e4a2 <sys_ipc_try_send+0x2af>
	}
	if (recvr->env_ipc_recving == 0) {
  800420e252:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e256:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420e25d:	83 f0 01             	xor    $0x1,%eax
  800420e260:	84 c0                	test   %al,%al
  800420e262:	74 0a                	je     800420e26e <sys_ipc_try_send+0x7b>
		return -E_IPC_NOT_RECV;
  800420e264:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420e269:	e9 34 02 00 00       	jmpq   800420e4a2 <sys_ipc_try_send+0x2af>
	}
	recvr->env_ipc_recving = 0;
  800420e26e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e272:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	recvr->env_ipc_from = curenv->env_id;
  800420e279:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
  800420e27d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e284:	00 00 00 
  800420e287:	ff d0                	callq  *%rax
  800420e289:	48 98                	cltq   
  800420e28b:	48 c1 e0 03          	shl    $0x3,%rax
  800420e28f:	48 89 c2             	mov    %rax,%rdx
  800420e292:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e296:	48 01 c2             	add    %rax,%rdx
  800420e299:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e2a0:	00 00 00 
  800420e2a3:	48 01 d0             	add    %rdx,%rax
  800420e2a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e2aa:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e2b0:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	recvr->env_ipc_perm = 0;
  800420e2b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e2ba:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420e2c1:	00 00 00 
	if((srcva && (srcva < (void*)UTOP)) && ((recvr->env_ipc_dstva) && (recvr->env_ipc_dstva < (void*)UTOP))){
  800420e2c4:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420e2c9:	0f 84 b3 01 00 00    	je     800420e482 <sys_ipc_try_send+0x28f>
  800420e2cf:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e2d6:	00 00 00 
  800420e2d9:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420e2dd:	0f 87 9f 01 00 00    	ja     800420e482 <sys_ipc_try_send+0x28f>
  800420e2e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e2e7:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420e2ee:	48 85 c0             	test   %rax,%rax
  800420e2f1:	0f 84 8b 01 00 00    	je     800420e482 <sys_ipc_try_send+0x28f>
  800420e2f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e2fb:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e302:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e309:	00 00 00 
  800420e30c:	48 39 c2             	cmp    %rax,%rdx
  800420e30f:	0f 87 6d 01 00 00    	ja     800420e482 <sys_ipc_try_send+0x28f>
		if(PGOFF(srcva)) {
  800420e315:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e319:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e31e:	48 85 c0             	test   %rax,%rax
  800420e321:	74 25                	je     800420e348 <sys_ipc_try_send+0x155>
			cprintf("\n Not pageAligned\n");
  800420e323:	48 bf b2 de 21 04 80 	movabs $0x800421deb2,%rdi
  800420e32a:	00 00 00 
  800420e32d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e332:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e339:	00 00 00 
  800420e33c:	ff d2                	callq  *%rdx
			return -E_INVAL;
  800420e33e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e343:	e9 5a 01 00 00       	jmpq   800420e4a2 <sys_ipc_try_send+0x2af>
		}
		int map_perm = PTE_U | PTE_P;
  800420e348:	c7 45 e8 05 00 00 00 	movl   $0x5,-0x18(%rbp)
		if(((perm & map_perm) != map_perm) || (perm & ~PTE_SYSCALL)) {
  800420e34f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420e352:	89 c2                	mov    %eax,%edx
  800420e354:	23 55 bc             	and    -0x44(%rbp),%edx
  800420e357:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800420e35a:	39 c2                	cmp    %eax,%edx
  800420e35c:	75 0c                	jne    800420e36a <sys_ipc_try_send+0x177>
  800420e35e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e361:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e366:	85 c0                	test   %eax,%eax
  800420e368:	74 25                	je     800420e38f <sys_ipc_try_send+0x19c>
			cprintf("\nPermission error\n");
  800420e36a:	48 bf c5 de 21 04 80 	movabs $0x800421dec5,%rdi
  800420e371:	00 00 00 
  800420e374:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e379:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e380:	00 00 00 
  800420e383:	ff d2                	callq  *%rdx
			return -E_INVAL;
  800420e385:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e38a:	e9 13 01 00 00       	jmpq   800420e4a2 <sys_ipc_try_send+0x2af>
		}
		pte_t* entry;
		struct PageInfo *map = page_lookup(curenv->env_pml4e, srcva, &entry);
  800420e38f:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e396:	00 00 00 
  800420e399:	ff d0                	callq  *%rax
  800420e39b:	48 98                	cltq   
  800420e39d:	48 c1 e0 03          	shl    $0x3,%rax
  800420e3a1:	48 89 c2             	mov    %rax,%rdx
  800420e3a4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e3a8:	48 01 c2             	add    %rax,%rdx
  800420e3ab:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e3b2:	00 00 00 
  800420e3b5:	48 01 d0             	add    %rdx,%rax
  800420e3b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e3bc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e3c3:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420e3c7:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420e3cb:	48 89 ce             	mov    %rcx,%rsi
  800420e3ce:	48 89 c7             	mov    %rax,%rdi
  800420e3d1:	48 b8 7f 35 20 04 80 	movabs $0x800420357f,%rax
  800420e3d8:	00 00 00 
  800420e3db:	ff d0                	callq  *%rax
  800420e3dd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(!(map) || ((perm & PTE_W) && !(*entry & PTE_W))) {
  800420e3e1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e3e6:	74 19                	je     800420e401 <sys_ipc_try_send+0x20e>
  800420e3e8:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e3eb:	83 e0 02             	and    $0x2,%eax
  800420e3ee:	85 c0                	test   %eax,%eax
  800420e3f0:	74 31                	je     800420e423 <sys_ipc_try_send+0x230>
  800420e3f2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e3f6:	48 8b 00             	mov    (%rax),%rax
  800420e3f9:	83 e0 02             	and    $0x2,%eax
  800420e3fc:	48 85 c0             	test   %rax,%rax
  800420e3ff:	75 22                	jne    800420e423 <sys_ipc_try_send+0x230>
			cprintf("\n VA is not mapped in senders address space or Sending read only pages with write permissions not permissible\n");
  800420e401:	48 bf d8 de 21 04 80 	movabs $0x800421ded8,%rdi
  800420e408:	00 00 00 
  800420e40b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e410:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e417:	00 00 00 
  800420e41a:	ff d2                	callq  *%rdx
			return -E_INVAL;
  800420e41c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e421:	eb 7f                	jmp    800420e4a2 <sys_ipc_try_send+0x2af>
		}
		if(page_insert(recvr->env_pml4e, map, recvr->env_ipc_dstva , perm) < 0) {
  800420e423:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420e426:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e42a:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e431:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e435:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e43c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e440:	48 89 c7             	mov    %rax,%rdi
  800420e443:	48 b8 2c 34 20 04 80 	movabs $0x800420342c,%rax
  800420e44a:	00 00 00 
  800420e44d:	ff d0                	callq  *%rax
  800420e44f:	85 c0                	test   %eax,%eax
  800420e451:	79 22                	jns    800420e475 <sys_ipc_try_send+0x282>
			cprintf("\n No memory to map the page to target env\n");
  800420e453:	48 bf 48 df 21 04 80 	movabs $0x800421df48,%rdi
  800420e45a:	00 00 00 
  800420e45d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e462:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e469:	00 00 00 
  800420e46c:	ff d2                	callq  *%rdx
			return -E_NO_MEM;
  800420e46e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e473:	eb 2d                	jmp    800420e4a2 <sys_ipc_try_send+0x2af>
		}
		recvr->env_ipc_perm = perm;
  800420e475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e479:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420e47c:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
	}
	recvr->env_ipc_value = value;
  800420e482:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e486:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420e489:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	recvr->env_status = ENV_RUNNABLE;
  800420e48f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e493:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420e49a:	00 00 00 
	return 0;
  800420e49d:	b8 00 00 00 00       	mov    $0x0,%eax
	// LAB 4: Your code here.
	// panic("sys_ipc_try_send not implemented");
}
  800420e4a2:	48 83 c4 48          	add    $0x48,%rsp
  800420e4a6:	5b                   	pop    %rbx
  800420e4a7:	5d                   	pop    %rbp
  800420e4a8:	c3                   	retq   

000000800420e4a9 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420e4a9:	55                   	push   %rbp
  800420e4aa:	48 89 e5             	mov    %rsp,%rbp
  800420e4ad:	48 83 ec 10          	sub    $0x10,%rsp
  800420e4b1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	curenv->env_ipc_recving = 1;
  800420e4b5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e4bc:	00 00 00 
  800420e4bf:	ff d0                	callq  *%rax
  800420e4c1:	48 98                	cltq   
  800420e4c3:	48 c1 e0 03          	shl    $0x3,%rax
  800420e4c7:	48 89 c2             	mov    %rax,%rdx
  800420e4ca:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e4ce:	48 01 c2             	add    %rax,%rdx
  800420e4d1:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e4d8:	00 00 00 
  800420e4db:	48 01 d0             	add    %rdx,%rax
  800420e4de:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e4e2:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	if(dstva < (void*)UTOP) {
  800420e4e9:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e4f0:	00 00 00 
  800420e4f3:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420e4f7:	77 15                	ja     800420e50e <sys_ipc_recv+0x65>
		if(PGOFF(dstva))
  800420e4f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e4fd:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e502:	48 85 c0             	test   %rax,%rax
  800420e505:	74 07                	je     800420e50e <sys_ipc_recv+0x65>
			return -E_INVAL;
  800420e507:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	curenv->env_tf.tf_regs.reg_rax = 0;
	sched_yield();
	// LAB 4: Your code here.
	//panic("sys_ipc_recv not implemented");
	return 0;
}
  800420e50c:	c9                   	leaveq 
  800420e50d:	c3                   	retq   
	curenv->env_ipc_recving = 1;
	if(dstva < (void*)UTOP) {
		if(PGOFF(dstva))
			return -E_INVAL;
	}	
	curenv->env_ipc_dstva = dstva;
  800420e50e:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e515:	00 00 00 
  800420e518:	ff d0                	callq  *%rax
  800420e51a:	48 98                	cltq   
  800420e51c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e520:	48 89 c2             	mov    %rax,%rdx
  800420e523:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e527:	48 01 c2             	add    %rax,%rdx
  800420e52a:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e531:	00 00 00 
  800420e534:	48 01 d0             	add    %rdx,%rax
  800420e537:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e53b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e53f:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420e546:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e54d:	00 00 00 
  800420e550:	ff d0                	callq  *%rax
  800420e552:	48 98                	cltq   
  800420e554:	48 c1 e0 03          	shl    $0x3,%rax
  800420e558:	48 89 c2             	mov    %rax,%rdx
  800420e55b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e55f:	48 01 c2             	add    %rax,%rdx
  800420e562:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e569:	00 00 00 
  800420e56c:	48 01 d0             	add    %rdx,%rax
  800420e56f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e573:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e57a:	00 00 00 
	curenv->env_tf.tf_regs.reg_rax = 0;
  800420e57d:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e584:	00 00 00 
  800420e587:	ff d0                	callq  *%rax
  800420e589:	48 98                	cltq   
  800420e58b:	48 c1 e0 03          	shl    $0x3,%rax
  800420e58f:	48 89 c2             	mov    %rax,%rdx
  800420e592:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e596:	48 01 c2             	add    %rax,%rdx
  800420e599:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e5a0:	00 00 00 
  800420e5a3:	48 01 d0             	add    %rdx,%rax
  800420e5a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e5aa:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e5b1:	00 
	sched_yield();
  800420e5b2:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  800420e5b9:	00 00 00 
  800420e5bc:	ff d0                	callq  *%rax

000000800420e5be <sys_time_msec>:


// Return the current time.
static int
sys_time_msec(void)
{
  800420e5be:	55                   	push   %rbp
  800420e5bf:	48 89 e5             	mov    %rsp,%rbp
	// LAB 6: Your code here.
	panic("sys_time_msec not implemented");
  800420e5c2:	48 ba 73 df 21 04 80 	movabs $0x800421df73,%rdx
  800420e5c9:	00 00 00 
  800420e5cc:	be ba 01 00 00       	mov    $0x1ba,%esi
  800420e5d1:	48 bf 91 df 21 04 80 	movabs $0x800421df91,%rdi
  800420e5d8:	00 00 00 
  800420e5db:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e5e0:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800420e5e7:	00 00 00 
  800420e5ea:	ff d1                	callq  *%rcx

000000800420e5ec <sys_ept_map>:
//       env_pml4e to store the root of the extended page tables.
// 
static int
sys_ept_map(envid_t srcenvid, void *srcva,
	    envid_t guest, void* guest_pa, int perm)
{
  800420e5ec:	55                   	push   %rbp
  800420e5ed:	48 89 e5             	mov    %rsp,%rbp
  800420e5f0:	48 83 ec 50          	sub    $0x50,%rsp
  800420e5f4:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420e5f7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420e5fb:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420e5fe:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420e602:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	/* Your code here */
	struct Env* srcenv;
	struct Env* guestenv;
	int r = envid2env(srcenvid, &srcenv, 1);
  800420e606:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420e60a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420e60d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e612:	48 89 ce             	mov    %rcx,%rsi
  800420e615:	89 c7                	mov    %eax,%edi
  800420e617:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420e61e:	00 00 00 
  800420e621:	ff d0                	callq  *%rax
  800420e623:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0) {
  800420e626:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e62a:	79 23                	jns    800420e64f <sys_ept_map+0x63>
		cprintf("\n Invalid envid");
  800420e62c:	48 bf a0 df 21 04 80 	movabs $0x800421dfa0,%rdi
  800420e633:	00 00 00 
  800420e636:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e63b:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e642:	00 00 00 
  800420e645:	ff d2                	callq  *%rdx
		return r;
  800420e647:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e64a:	e9 df 01 00 00       	jmpq   800420e82e <sys_ept_map+0x242>
	}
	r = envid2env(guest, &guestenv, 1);
  800420e64f:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420e653:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420e656:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e65b:	48 89 ce             	mov    %rcx,%rsi
  800420e65e:	89 c7                	mov    %eax,%edi
  800420e660:	48 b8 9d 74 20 04 80 	movabs $0x800420749d,%rax
  800420e667:	00 00 00 
  800420e66a:	ff d0                	callq  *%rax
  800420e66c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0) {
  800420e66f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e673:	79 23                	jns    800420e698 <sys_ept_map+0xac>
		cprintf("\n Invalid guest envid");
  800420e675:	48 bf b0 df 21 04 80 	movabs $0x800421dfb0,%rdi
  800420e67c:	00 00 00 
  800420e67f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e684:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e68b:	00 00 00 
  800420e68e:	ff d2                	callq  *%rdx
		return r;
  800420e690:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e693:	e9 96 01 00 00       	jmpq   800420e82e <sys_ept_map+0x242>
	}
	if ((uint64_t)srcva >= UTOP || PGOFF(srcva) || PGOFF(guest_pa) || (uint64_t)guest_pa >= guestenv->env_vmxinfo.phys_sz) {
  800420e698:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e69c:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e6a3:	00 00 00 
  800420e6a6:	48 39 c2             	cmp    %rax,%rdx
  800420e6a9:	77 30                	ja     800420e6db <sys_ept_map+0xef>
  800420e6ab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e6af:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e6b4:	48 85 c0             	test   %rax,%rax
  800420e6b7:	75 22                	jne    800420e6db <sys_ept_map+0xef>
  800420e6b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420e6bd:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e6c2:	48 85 c0             	test   %rax,%rax
  800420e6c5:	75 14                	jne    800420e6db <sys_ept_map+0xef>
  800420e6c7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e6cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e6cf:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  800420e6d6:	48 39 c2             	cmp    %rax,%rdx
  800420e6d9:	72 37                	jb     800420e712 <sys_ept_map+0x126>
		cprintf("\n Invalid param %p guest_pa %p\n", guest_pa , guestenv->env_vmxinfo.phys_sz);
  800420e6db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e6df:	48 8b 90 20 01 00 00 	mov    0x120(%rax),%rdx
  800420e6e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420e6ea:	48 89 c6             	mov    %rax,%rsi
  800420e6ed:	48 bf c8 df 21 04 80 	movabs $0x800421dfc8,%rdi
  800420e6f4:	00 00 00 
  800420e6f7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e6fc:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800420e703:	00 00 00 
  800420e706:	ff d1                	callq  *%rcx
		return -E_INVAL;
  800420e708:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e70d:	e9 1c 01 00 00       	jmpq   800420e82e <sys_ept_map+0x242>
    }
	pte_t* pte;
	struct PageInfo *map = page_lookup(srcenv->env_pml4e, srcva, &pte);
  800420e712:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e716:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e71d:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420e721:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420e725:	48 89 ce             	mov    %rcx,%rsi
  800420e728:	48 89 c7             	mov    %rax,%rdi
  800420e72b:	48 b8 7f 35 20 04 80 	movabs $0x800420357f,%rax
  800420e732:	00 00 00 
  800420e735:	ff d0                	callq  *%rax
  800420e737:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (!map) {
  800420e73b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e740:	75 25                	jne    800420e767 <sys_ept_map+0x17b>
		cprintf("\n page not found\n");
  800420e742:	48 bf e8 df 21 04 80 	movabs $0x800421dfe8,%rdi
  800420e749:	00 00 00 
  800420e74c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e751:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e758:	00 00 00 
  800420e75b:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420e75d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e762:	e9 c7 00 00 00       	jmpq   800420e82e <sys_ept_map+0x242>
	}
	if ((!perm) || ((perm & __EPTE_WRITE) && (!(*pte & PTE_W))))
  800420e767:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  800420e76b:	74 19                	je     800420e786 <sys_ept_map+0x19a>
  800420e76d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e770:	83 e0 02             	and    $0x2,%eax
  800420e773:	85 c0                	test   %eax,%eax
  800420e775:	74 34                	je     800420e7ab <sys_ept_map+0x1bf>
  800420e777:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e77b:	48 8b 00             	mov    (%rax),%rax
  800420e77e:	83 e0 02             	and    $0x2,%eax
  800420e781:	48 85 c0             	test   %rax,%rax
  800420e784:	75 25                	jne    800420e7ab <sys_ept_map+0x1bf>
	{
		cprintf("\n Something wrong with write permissions \n");
  800420e786:	48 bf 00 e0 21 04 80 	movabs $0x800421e000,%rdi
  800420e78d:	00 00 00 
  800420e790:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e795:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e79c:	00 00 00 
  800420e79f:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420e7a1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e7a6:	e9 83 00 00 00       	jmpq   800420e82e <sys_ept_map+0x242>
	}
	pte_t* host_ident = page2kva(map);
  800420e7ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7af:	48 89 c7             	mov    %rax,%rdi
  800420e7b2:	48 b8 f1 d8 20 04 80 	movabs $0x800420d8f1,%rax
  800420e7b9:	00 00 00 
  800420e7bc:	ff d0                	callq  *%rax
  800420e7be:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	r = ept_map_hva2gpa(guestenv->env_pml4e,(void*)host_ident, guest_pa, perm, 1);
  800420e7c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7c6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e7cd:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420e7d0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e7d4:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420e7d8:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  800420e7de:	48 89 c7             	mov    %rax,%rdi
  800420e7e1:	48 b8 59 8c 21 04 80 	movabs $0x8004218c59,%rax
  800420e7e8:	00 00 00 
  800420e7eb:	ff d0                	callq  *%rax
  800420e7ed:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0) {
  800420e7f0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e7f4:	79 20                	jns    800420e816 <sys_ept_map+0x22a>
		cprintf("\n hva to gpa fault");
  800420e7f6:	48 bf 2b e0 21 04 80 	movabs $0x800421e02b,%rdi
  800420e7fd:	00 00 00 
  800420e800:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e805:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420e80c:	00 00 00 
  800420e80f:	ff d2                	callq  *%rdx
		return r;
  800420e811:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e814:	eb 18                	jmp    800420e82e <sys_ept_map+0x242>
	}
	map->pp_ref++; //This is for the srcenv... this is very very important.. referenced by both the envs.
  800420e816:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e81a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420e81e:	8d 50 01             	lea    0x1(%rax),%edx
  800420e821:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e825:	66 89 50 08          	mov    %dx,0x8(%rax)
	return 0;
  800420e829:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e82e:	c9                   	leaveq 
  800420e82f:	c3                   	retq   

000000800420e830 <sys_env_mkguest>:

static envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  800420e830:	55                   	push   %rbp
  800420e831:	48 89 e5             	mov    %rsp,%rbp
  800420e834:	48 83 ec 20          	sub    $0x20,%rsp
  800420e838:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e83c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;
	struct Env *e;

	if ((r = env_guest_alloc(&e, curenv->env_id)) < 0)
  800420e840:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420e847:	00 00 00 
  800420e84a:	ff d0                	callq  *%rax
  800420e84c:	48 98                	cltq   
  800420e84e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e852:	48 89 c2             	mov    %rax,%rdx
  800420e855:	48 c1 e2 04          	shl    $0x4,%rdx
  800420e859:	48 01 c2             	add    %rax,%rdx
  800420e85c:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420e863:	00 00 00 
  800420e866:	48 01 d0             	add    %rdx,%rax
  800420e869:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e86d:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420e873:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800420e877:	89 d6                	mov    %edx,%esi
  800420e879:	48 89 c7             	mov    %rax,%rdi
  800420e87c:	48 b8 b9 78 20 04 80 	movabs $0x80042078b9,%rax
  800420e883:	00 00 00 
  800420e886:	ff d0                	callq  *%rax
  800420e888:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420e88b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e88f:	79 05                	jns    800420e896 <sys_env_mkguest+0x66>
		return r;
  800420e891:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e894:	eb 36                	jmp    800420e8cc <sys_env_mkguest+0x9c>
	e->env_status = ENV_NOT_RUNNABLE;
  800420e896:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e89a:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e8a1:	00 00 00 
	e->env_vmxinfo.phys_sz = gphysz;
  800420e8a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e8a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e8ac:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
	e->env_tf.tf_rip = gRIP;
  800420e8b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e8b7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e8bb:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	return e->env_id;
  800420e8c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e8c6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420e8cc:	c9                   	leaveq 
  800420e8cd:	c3                   	retq   

000000800420e8ce <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420e8ce:	55                   	push   %rbp
  800420e8cf:	48 89 e5             	mov    %rsp,%rbp
  800420e8d2:	48 83 ec 30          	sub    $0x30,%rsp
  800420e8d6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e8da:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420e8de:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420e8e2:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420e8e6:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420e8ea:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	switch (syscallno) {
  800420e8ee:	48 83 7d f8 10       	cmpq   $0x10,-0x8(%rbp)
  800420e8f3:	0f 87 fc 01 00 00    	ja     800420eaf5 <syscall+0x227>
  800420e8f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8fd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e904:	00 
  800420e905:	48 b8 40 e0 21 04 80 	movabs $0x800421e040,%rax
  800420e90c:	00 00 00 
  800420e90f:	48 01 d0             	add    %rdx,%rax
  800420e912:	48 8b 00             	mov    (%rax),%rax
  800420e915:	ff e0                	jmpq   *%rax
	case SYS_ept_map:
		return sys_ept_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420e917:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e91b:	89 c7                	mov    %eax,%edi
  800420e91d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e921:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e925:	89 c2                	mov    %eax,%edx
  800420e927:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420e92b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e92f:	41 89 f8             	mov    %edi,%r8d
  800420e932:	89 c7                	mov    %eax,%edi
  800420e934:	48 b8 ec e5 20 04 80 	movabs $0x800420e5ec,%rax
  800420e93b:	00 00 00 
  800420e93e:	ff d0                	callq  *%rax
  800420e940:	48 98                	cltq   
  800420e942:	e9 b5 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_env_mkguest:
		return sys_env_mkguest(a1, a2);
  800420e947:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e94b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e94f:	48 89 d6             	mov    %rdx,%rsi
  800420e952:	48 89 c7             	mov    %rax,%rdi
  800420e955:	48 b8 30 e8 20 04 80 	movabs $0x800420e830,%rax
  800420e95c:	00 00 00 
  800420e95f:	ff d0                	callq  *%rax
  800420e961:	48 98                	cltq   
  800420e963:	e9 94 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_cputs :
		sys_cputs((const char *)a1, (size_t)a2);
  800420e968:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e96c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e970:	48 89 d6             	mov    %rdx,%rsi
  800420e973:	48 89 c7             	mov    %rax,%rdi
  800420e976:	48 b8 76 d9 20 04 80 	movabs $0x800420d976,%rax
  800420e97d:	00 00 00 
  800420e980:	ff d0                	callq  *%rax
		return 0;
  800420e982:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e987:	e9 70 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_cgetc :
		return sys_cgetc();
  800420e98c:	48 b8 f7 d9 20 04 80 	movabs $0x800420d9f7,%rax
  800420e993:	00 00 00 
  800420e996:	ff d0                	callq  *%rax
  800420e998:	48 98                	cltq   
  800420e99a:	e9 5d 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_getenvid :
		return sys_getenvid();
  800420e99f:	48 b8 09 da 20 04 80 	movabs $0x800420da09,%rax
  800420e9a6:	00 00 00 
  800420e9a9:	ff d0                	callq  *%rax
  800420e9ab:	48 98                	cltq   
  800420e9ad:	e9 4a 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_env_destroy :
		return sys_env_destroy(a1);
  800420e9b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e9b6:	89 c7                	mov    %eax,%edi
  800420e9b8:	48 b8 42 da 20 04 80 	movabs $0x800420da42,%rax
  800420e9bf:	00 00 00 
  800420e9c2:	ff d0                	callq  *%rax
  800420e9c4:	48 98                	cltq   
  800420e9c6:	e9 31 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_yield:
		sys_yield();
  800420e9cb:	48 b8 92 da 20 04 80 	movabs $0x800420da92,%rax
  800420e9d2:	00 00 00 
  800420e9d5:	ff d0                	callq  *%rax
	case SYS_exofork:
		return sys_exofork();
  800420e9d7:	48 b8 a2 da 20 04 80 	movabs $0x800420daa2,%rax
  800420e9de:	00 00 00 
  800420e9e1:	ff d0                	callq  *%rax
  800420e9e3:	48 98                	cltq   
  800420e9e5:	e9 12 01 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_env_set_status:
		return sys_env_set_status((envid_t)a1, (int)a2);
  800420e9ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9ee:	89 c2                	mov    %eax,%edx
  800420e9f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e9f4:	89 d6                	mov    %edx,%esi
  800420e9f6:	89 c7                	mov    %eax,%edi
  800420e9f8:	48 b8 d1 db 20 04 80 	movabs $0x800420dbd1,%rax
  800420e9ff:	00 00 00 
  800420ea02:	ff d0                	callq  *%rax
  800420ea04:	48 98                	cltq   
  800420ea06:	e9 f1 00 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_page_alloc:
		return sys_page_alloc((envid_t)a1, (void*)a2, (int)a3);
  800420ea0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea0f:	89 c2                	mov    %eax,%edx
  800420ea11:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ea15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea19:	48 89 ce             	mov    %rcx,%rsi
  800420ea1c:	89 c7                	mov    %eax,%edi
  800420ea1e:	48 b8 8d dd 20 04 80 	movabs $0x800420dd8d,%rax
  800420ea25:	00 00 00 
  800420ea28:	ff d0                	callq  *%rax
  800420ea2a:	48 98                	cltq   
  800420ea2c:	e9 cb 00 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_page_map:
		return sys_page_map((envid_t)a1, (void *)a2,(envid_t) a3, (void *)a4, (int) a5);
  800420ea31:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ea35:	89 c7                	mov    %eax,%edi
  800420ea37:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ea3b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea3f:	89 c2                	mov    %eax,%edx
  800420ea41:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420ea45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea49:	41 89 f8             	mov    %edi,%r8d
  800420ea4c:	89 c7                	mov    %eax,%edi
  800420ea4e:	48 b8 0f df 20 04 80 	movabs $0x800420df0f,%rax
  800420ea55:	00 00 00 
  800420ea58:	ff d0                	callq  *%rax
  800420ea5a:	48 98                	cltq   
  800420ea5c:	e9 9b 00 00 00       	jmpq   800420eafc <syscall+0x22e>
	case SYS_page_unmap:
		return sys_page_unmap((envid_t)a1, (void*)a2);
  800420ea61:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ea65:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea69:	48 89 d6             	mov    %rdx,%rsi
  800420ea6c:	89 c7                	mov    %eax,%edi
  800420ea6e:	48 b8 49 e1 20 04 80 	movabs $0x800420e149,%rax
  800420ea75:	00 00 00 
  800420ea78:	ff d0                	callq  *%rax
  800420ea7a:	48 98                	cltq   
  800420ea7c:	eb 7e                	jmp    800420eafc <syscall+0x22e>
	case SYS_env_set_pgfault_upcall:
		return sys_env_set_pgfault_upcall((envid_t)a1, (void*)a2);
  800420ea7e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ea82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea86:	48 89 d6             	mov    %rdx,%rsi
  800420ea89:	89 c7                	mov    %eax,%edi
  800420ea8b:	48 b8 1d dd 20 04 80 	movabs $0x800420dd1d,%rax
  800420ea92:	00 00 00 
  800420ea95:	ff d0                	callq  *%rax
  800420ea97:	48 98                	cltq   
  800420ea99:	eb 61                	jmp    800420eafc <syscall+0x22e>
	case SYS_ipc_try_send:
		return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void*)a3, (unsigned)a4);
  800420ea9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea9f:	89 c1                	mov    %eax,%ecx
  800420eaa1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eaa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eaa9:	89 c6                	mov    %eax,%esi
  800420eaab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eaaf:	89 c7                	mov    %eax,%edi
  800420eab1:	48 b8 f3 e1 20 04 80 	movabs $0x800420e1f3,%rax
  800420eab8:	00 00 00 
  800420eabb:	ff d0                	callq  *%rax
  800420eabd:	48 98                	cltq   
  800420eabf:	eb 3b                	jmp    800420eafc <syscall+0x22e>
	case SYS_ipc_recv:
		return sys_ipc_recv((void*)a1);
  800420eac1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eac5:	48 89 c7             	mov    %rax,%rdi
  800420eac8:	48 b8 a9 e4 20 04 80 	movabs $0x800420e4a9,%rax
  800420eacf:	00 00 00 
  800420ead2:	ff d0                	callq  *%rax
  800420ead4:	48 98                	cltq   
  800420ead6:	eb 24                	jmp    800420eafc <syscall+0x22e>
	case SYS_env_set_trapframe:
		return sys_env_set_trapframe((envid_t)a1, (struct Trapframe *)a2);
  800420ead8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eadc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eae0:	48 89 d6             	mov    %rdx,%rsi
  800420eae3:	89 c7                	mov    %eax,%edi
  800420eae5:	48 b8 71 dc 20 04 80 	movabs $0x800420dc71,%rax
  800420eaec:	00 00 00 
  800420eaef:	ff d0                	callq  *%rax
  800420eaf1:	48 98                	cltq   
  800420eaf3:	eb 07                	jmp    800420eafc <syscall+0x22e>
	default:
		return -E_INVAL;
  800420eaf5:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax
	}
}
  800420eafc:	c9                   	leaveq 
  800420eafd:	c3                   	retq   
	...

000000800420eb00 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420eb00:	55                   	push   %rbp
  800420eb01:	48 89 e5             	mov    %rsp,%rbp
  800420eb04:	48 81 ec b0 61 00 00 	sub    $0x61b0,%rsp
  800420eb0b:	48 89 bd a8 9e ff ff 	mov    %rdi,-0x6158(%rbp)
  800420eb12:	48 89 b5 a0 9e ff ff 	mov    %rsi,-0x6160(%rbp)
  800420eb19:	48 89 95 98 9e ff ff 	mov    %rdx,-0x6168(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420eb20:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420eb27:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420eb2e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420eb32:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420eb39:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420eb40:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420eb44:	48 8b 95 a0 9e ff ff 	mov    -0x6160(%rbp),%rdx
  800420eb4b:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420eb52:	48 89 d1             	mov    %rdx,%rcx
  800420eb55:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420eb5a:	48 89 ce             	mov    %rcx,%rsi
  800420eb5d:	48 89 c7             	mov    %rax,%rdi
  800420eb60:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  800420eb67:	00 00 00 
  800420eb6a:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420eb6c:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420eb73:	00 
	
	if(die->die_tag != DW_TAG_subprogram)
  800420eb74:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420eb7b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420eb7f:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420eb83:	74 0a                	je     800420eb8f <list_func_die+0x8f>
		return 0;
  800420eb85:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eb8a:	e9 de 04 00 00       	jmpq   800420f06d <list_func_die+0x56d>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420eb8f:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420eb93:	ba 38 00 00 00       	mov    $0x38,%edx
  800420eb98:	be 00 00 00 00       	mov    $0x0,%esi
  800420eb9d:	48 89 c7             	mov    %rax,%rdi
  800420eba0:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  800420eba7:	00 00 00 
  800420ebaa:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420ebac:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ebb3:	be 11 00 00 00       	mov    $0x11,%esi
  800420ebb8:	48 89 c7             	mov    %rax,%rdi
  800420ebbb:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420ebc2:	00 00 00 
  800420ebc5:	ff d0                	callq  *%rax
  800420ebc7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420ebcb:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ebd2:	be 12 00 00 00       	mov    $0x12,%esi
  800420ebd7:	48 89 c7             	mov    %rax,%rdi
  800420ebda:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420ebe1:	00 00 00 
  800420ebe4:	ff d0                	callq  *%rax
  800420ebe6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420ebea:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ebef:	0f 84 73 04 00 00    	je     800420f068 <list_func_die+0x568>
  800420ebf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebf9:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ebfd:	48 3b 85 98 9e ff ff 	cmp    -0x6168(%rbp),%rax
  800420ec04:	0f 83 5e 04 00 00    	jae    800420f068 <list_func_die+0x568>
  800420ec0a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ec0f:	0f 84 53 04 00 00    	je     800420f068 <list_func_die+0x568>
  800420ec15:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ec19:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ec1d:	48 3b 85 98 9e ff ff 	cmp    -0x6168(%rbp),%rax
  800420ec24:	0f 86 3e 04 00 00    	jbe    800420f068 <list_func_die+0x568>
	{
		info->rip_file = die->cu_die->die_name;
  800420ec2a:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ec31:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ec38:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420ec3f:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ec46:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420ec49:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ec50:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420ec57:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ec5e:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420ec62:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ec69:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420ec70:	48 89 c7             	mov    %rax,%rdi
  800420ec73:	48 b8 44 00 21 04 80 	movabs $0x8004210044,%rax
  800420ec7a:	00 00 00 
  800420ec7d:	ff d0                	callq  *%rax
  800420ec7f:	48 8b 95 a8 9e ff ff 	mov    -0x6158(%rbp),%rdx
  800420ec86:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420ec89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec8d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ec91:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ec98:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420ec9c:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420eca3:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ecaa:	48 85 c0             	test   %rax,%rax
  800420ecad:	75 35                	jne    800420ece4 <list_func_die+0x1e4>
  800420ecaf:	48 b9 18 e4 21 04 80 	movabs $0x800421e418,%rcx
  800420ecb6:	00 00 00 
  800420ecb9:	48 ba 24 e4 21 04 80 	movabs $0x800421e424,%rdx
  800420ecc0:	00 00 00 
  800420ecc3:	be 72 00 00 00       	mov    $0x72,%esi
  800420ecc8:	48 bf 39 e4 21 04 80 	movabs $0x800421e439,%rdi
  800420eccf:	00 00 00 
  800420ecd2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ecd7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420ecde:	00 00 00 
  800420ece1:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420ece4:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420eceb:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ecf2:	48 8b 95 98 9e ff ff 	mov    -0x6168(%rbp),%rdx
  800420ecf9:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420ecfd:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420ed02:	48 89 c7             	mov    %rax,%rdi
  800420ed05:	48 b8 57 59 21 04 80 	movabs $0x8004215957,%rax
  800420ed0c:	00 00 00 
  800420ed0f:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420ed11:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ed15:	89 c2                	mov    %eax,%edx
  800420ed17:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ed1e:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420ed21:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ed28:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420ed2f:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420ed36:	00 00 00 
  800420ed39:	48 8b 00             	mov    (%rax),%rax
  800420ed3c:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420ed43:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420ed4a:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420ed4e:	48 89 c7             	mov    %rax,%rdi
  800420ed51:	48 b8 8f 25 21 04 80 	movabs $0x800421258f,%rax
  800420ed58:	00 00 00 
  800420ed5b:	ff d0                	callq  *%rax
  800420ed5d:	83 f8 04             	cmp    $0x4,%eax
  800420ed60:	0f 84 fb 02 00 00    	je     800420f061 <list_func_die+0x561>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420ed66:	48 8b 85 38 cf ff ff 	mov    -0x30c8(%rbp),%rax
  800420ed6d:	48 83 f8 05          	cmp    $0x5,%rax
  800420ed71:	0f 85 e6 02 00 00    	jne    800420f05d <list_func_die+0x55d>
				goto last;

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420ed77:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420ed7e:	be 49 00 00 00       	mov    $0x49,%esi
  800420ed83:	48 89 c7             	mov    %rax,%rdi
  800420ed86:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420ed8d:	00 00 00 
  800420ed90:	ff d0                	callq  *%rax
  800420ed92:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
		try_again:
			if(attr != NULL)
  800420ed96:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420ed9b:	0f 84 d7 00 00 00    	je     800420ee78 <list_func_die+0x378>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420eda1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eda5:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420eda9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edad:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420edb1:	48 01 d0             	add    %rdx,%rax
  800420edb4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420edb8:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420edbf:	00 00 00 
  800420edc2:	48 8b 08             	mov    (%rax),%rcx
  800420edc5:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420edcc:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  800420edd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edd4:	48 8b 38             	mov    (%rax),%rdi
  800420edd7:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420eddb:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420eddf:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420ede4:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420ede8:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420eded:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420edf1:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420edf6:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420edfa:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420edff:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420ee03:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420ee08:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ee0c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420ee11:	48 89 cf             	mov    %rcx,%rdi
  800420ee14:	48 b8 b5 21 21 04 80 	movabs $0x80042121b5,%rax
  800420ee1b:	00 00 00 
  800420ee1e:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420ee20:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ee27:	be 0b 00 00 00       	mov    $0xb,%esi
  800420ee2c:	48 89 c7             	mov    %rax,%rdi
  800420ee2f:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420ee36:	00 00 00 
  800420ee39:	ff d0                	callq  *%rax
  800420ee3b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		
				if(attr != NULL)
  800420ee3f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420ee44:	74 0e                	je     800420ee54 <list_func_die+0x354>
				{
					ret_val = attr->u[0].u64;
  800420ee46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee4a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ee4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ee52:	eb 24                	jmp    800420ee78 <list_func_die+0x378>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420ee54:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ee5b:	be 49 00 00 00       	mov    $0x49,%esi
  800420ee60:	48 89 c7             	mov    %rax,%rdi
  800420ee63:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420ee6a:	00 00 00 
  800420ee6d:	ff d0                	callq  *%rax
  800420ee6f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					goto try_again;
  800420ee73:	e9 1e ff ff ff       	jmpq   800420ed96 <list_func_die+0x296>
				}
			}
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420ee78:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ee7f:	8b 48 28             	mov    0x28(%rax),%ecx
  800420ee82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee86:	89 c2                	mov    %eax,%edx
  800420ee88:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420ee8f:	48 63 c9             	movslq %ecx,%rcx
  800420ee92:	48 83 c1 08          	add    $0x8,%rcx
  800420ee96:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->rip_fn_narg++;
  800420ee9a:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420eea1:	8b 40 28             	mov    0x28(%rax),%eax
  800420eea4:	8d 50 01             	lea    0x1(%rax),%edx
  800420eea7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420eeae:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420eeb1:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420eeb8:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420eebf:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420eec4:	48 89 ce             	mov    %rcx,%rsi
  800420eec7:	48 89 c7             	mov    %rax,%rdi
  800420eeca:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  800420eed1:	00 00 00 
  800420eed4:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420eed6:	e9 4a 01 00 00       	jmpq   800420f025 <list_func_die+0x525>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420eedb:	48 8b 85 38 cf ff ff 	mov    -0x30c8(%rbp),%rax
  800420eee2:	48 83 f8 05          	cmp    $0x5,%rax
  800420eee6:	0f 85 74 01 00 00    	jne    800420f060 <list_func_die+0x560>
					break;

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420eeec:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420eef3:	be 49 00 00 00       	mov    $0x49,%esi
  800420eef8:	48 89 c7             	mov    %rax,%rdi
  800420eefb:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420ef02:	00 00 00 
  800420ef05:	ff d0                	callq  *%rax
  800420ef07:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
				if(attr != NULL)
  800420ef0b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420ef10:	0f 84 b1 00 00 00    	je     800420efc7 <list_func_die+0x4c7>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420ef16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef1a:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420ef1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef22:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ef26:	48 01 d0             	add    %rdx,%rax
  800420ef29:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420ef2d:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420ef34:	00 00 00 
  800420ef37:	48 8b 08             	mov    (%rax),%rcx
  800420ef3a:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420ef41:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  800420ef45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef49:	48 8b 38             	mov    (%rax),%rdi
  800420ef4c:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420ef50:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420ef54:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420ef59:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420ef5d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420ef62:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420ef66:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420ef6b:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420ef6f:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420ef74:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420ef78:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420ef7d:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ef81:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420ef86:	48 89 cf             	mov    %rcx,%rdi
  800420ef89:	48 b8 b5 21 21 04 80 	movabs $0x80042121b5,%rax
  800420ef90:	00 00 00 
  800420ef93:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420ef95:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ef9c:	be 0b 00 00 00       	mov    $0xb,%esi
  800420efa1:	48 89 c7             	mov    %rax,%rdi
  800420efa4:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  800420efab:	00 00 00 
  800420efae:	ff d0                	callq  *%rax
  800420efb0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        
					if(attr != NULL)
  800420efb4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420efb9:	74 0c                	je     800420efc7 <list_func_die+0x4c7>
					{
						ret_val = attr->u[0].u64;
  800420efbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efbf:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420efc3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420efc7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420efce:	8b 48 28             	mov    0x28(%rax),%ecx
  800420efd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420efd5:	89 c2                	mov    %eax,%edx
  800420efd7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420efde:	48 63 c9             	movslq %ecx,%rcx
  800420efe1:	48 83 c1 08          	add    $0x8,%rcx
  800420efe5:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->rip_fn_narg++;
  800420efe9:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420eff0:	8b 40 28             	mov    0x28(%rax),%eax
  800420eff3:	8d 50 01             	lea    0x1(%rax),%edx
  800420eff6:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420effd:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420f000:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420f007:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420f00e:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f013:	48 89 ce             	mov    %rcx,%rsi
  800420f016:	48 89 c7             	mov    %rax,%rdi
  800420f019:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  800420f020:	00 00 00 
  800420f023:	ff d0                	callq  *%rax
			}
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420f025:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f02c:	00 00 00 
  800420f02f:	48 8b 00             	mov    (%rax),%rax
  800420f032:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420f036:	48 8d 95 20 cf ff ff 	lea    -0x30e0(%rbp),%rdx
  800420f03d:	48 8d b5 b0 9e ff ff 	lea    -0x6150(%rbp),%rsi
  800420f044:	48 89 c7             	mov    %rax,%rdi
  800420f047:	48 b8 4b 23 21 04 80 	movabs $0x800421234b,%rax
  800420f04e:	00 00 00 
  800420f051:	ff d0                	callq  *%rax
  800420f053:	85 c0                	test   %eax,%eax
  800420f055:	0f 84 80 fe ff ff    	je     800420eedb <list_func_die+0x3db>
  800420f05b:	eb 04                	jmp    800420f061 <list_func_die+0x561>
		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
				goto last;
  800420f05d:	90                   	nop
  800420f05e:	eb 01                	jmp    800420f061 <list_func_die+0x561>
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
					break;
  800420f060:	90                   	nop
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420f061:	b8 01 00 00 00       	mov    $0x1,%eax
  800420f066:	eb 05                	jmp    800420f06d <list_func_die+0x56d>
	}

	return 0;
  800420f068:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f06d:	c9                   	leaveq 
  800420f06e:	c3                   	retq   

000000800420f06f <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420f06f:	55                   	push   %rbp
  800420f070:	48 89 e5             	mov    %rsp,%rbp
  800420f073:	48 81 ec c0 91 00 00 	sub    $0x91c0,%rsp
  800420f07a:	48 89 bd 48 6e ff ff 	mov    %rdi,-0x91b8(%rbp)
  800420f081:	48 89 b5 40 6e ff ff 	mov    %rsi,-0x91c0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420f088:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f08f:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420f090:	48 8b 85 48 6e ff ff 	mov    -0x91b8(%rbp),%rax
  800420f097:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420f09b:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f0a2:	48 ba 47 e4 21 04 80 	movabs $0x800421e447,%rdx
  800420f0a9:	00 00 00 
  800420f0ac:	48 89 10             	mov    %rdx,(%rax)
	info->rip_line = 0;
  800420f0af:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f0b6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420f0bd:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f0c4:	48 ba 47 e4 21 04 80 	movabs $0x800421e447,%rdx
  800420f0cb:	00 00 00 
  800420f0ce:	48 89 50 10          	mov    %rdx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420f0d2:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f0d9:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420f0e0:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f0e7:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420f0ee:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420f0f2:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f0f9:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420f100:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420f107:	00 00 00 
  800420f10a:	48 39 85 48 6e ff ff 	cmp    %rax,-0x91b8(%rbp)
  800420f111:	76 13                	jbe    800420f126 <debuginfo_rip+0xb7>
		elf = (void *)0x10000 + KERNBASE;
  800420f113:	c7 45 f8 00 00 01 04 	movl   $0x4010000,-0x8(%rbp)
  800420f11a:	c7 45 fc 80 00 00 00 	movl   $0x80,-0x4(%rbp)
  800420f121:	e9 f4 00 00 00       	jmpq   800420f21a <debuginfo_rip+0x1ab>
	} else {
		if(curenv != lastenv) {
  800420f126:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420f12d:	00 00 00 
  800420f130:	ff d0                	callq  *%rax
  800420f132:	48 98                	cltq   
  800420f134:	48 c1 e0 03          	shl    $0x3,%rax
  800420f138:	48 89 c2             	mov    %rax,%rdx
  800420f13b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420f13f:	48 01 c2             	add    %rax,%rdx
  800420f142:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420f149:	00 00 00 
  800420f14c:	48 01 d0             	add    %rdx,%rax
  800420f14f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f153:	48 b8 98 32 48 04 80 	movabs $0x8004483298,%rax
  800420f15a:	00 00 00 
  800420f15d:	48 8b 00             	mov    (%rax),%rax
  800420f160:	48 39 c2             	cmp    %rax,%rdx
  800420f163:	74 7d                	je     800420f1e2 <debuginfo_rip+0x173>
			find_debug_sections((uintptr_t)curenv->elf);
  800420f165:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420f16c:	00 00 00 
  800420f16f:	ff d0                	callq  *%rax
  800420f171:	48 98                	cltq   
  800420f173:	48 c1 e0 03          	shl    $0x3,%rax
  800420f177:	48 89 c2             	mov    %rax,%rdx
  800420f17a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420f17e:	48 01 c2             	add    %rax,%rdx
  800420f181:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420f188:	00 00 00 
  800420f18b:	48 01 d0             	add    %rdx,%rax
  800420f18e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f192:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420f199:	48 89 c7             	mov    %rax,%rdi
  800420f19c:	48 b8 54 5b 21 04 80 	movabs $0x8004215b54,%rax
  800420f1a3:	00 00 00 
  800420f1a6:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420f1a8:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420f1af:	00 00 00 
  800420f1b2:	ff d0                	callq  *%rax
  800420f1b4:	48 98                	cltq   
  800420f1b6:	48 c1 e0 03          	shl    $0x3,%rax
  800420f1ba:	48 89 c2             	mov    %rax,%rdx
  800420f1bd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420f1c1:	48 01 c2             	add    %rax,%rdx
  800420f1c4:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420f1cb:	00 00 00 
  800420f1ce:	48 01 d0             	add    %rdx,%rax
  800420f1d1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f1d5:	48 b8 98 32 48 04 80 	movabs $0x8004483298,%rax
  800420f1dc:	00 00 00 
  800420f1df:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420f1e2:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800420f1e9:	00 00 00 
  800420f1ec:	ff d0                	callq  *%rax
  800420f1ee:	48 98                	cltq   
  800420f1f0:	48 c1 e0 03          	shl    $0x3,%rax
  800420f1f4:	48 89 c2             	mov    %rax,%rdx
  800420f1f7:	48 c1 e2 04          	shl    $0x4,%rdx
  800420f1fb:	48 01 c2             	add    %rax,%rdx
  800420f1fe:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800420f205:	00 00 00 
  800420f208:	48 01 d0             	add    %rdx,%rax
  800420f20b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f20f:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420f216:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420f21a:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f221:	00 00 00 
  800420f224:	48 8b 00             	mov    (%rax),%rax
  800420f227:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f22b:	48 89 d6             	mov    %rdx,%rsi
  800420f22e:	48 89 c7             	mov    %rax,%rdi
  800420f231:	48 b8 8a 11 21 04 80 	movabs $0x800421118a,%rax
  800420f238:	00 00 00 
  800420f23b:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420f23d:	48 bf 51 e4 21 04 80 	movabs $0x800421e451,%rdi
  800420f244:	00 00 00 
  800420f247:	48 b8 d4 5a 21 04 80 	movabs $0x8004215ad4,%rax
  800420f24e:	00 00 00 
  800420f251:	ff d0                	callq  *%rax
  800420f253:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420f257:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f25e:	00 00 00 
  800420f261:	48 8b 00             	mov    (%rax),%rax
  800420f264:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f268:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420f26c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420f270:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f277:	00 00 00 
  800420f27a:	48 8b 00             	mov    (%rax),%rax
  800420f27d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f281:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420f285:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
	assert(dbg->dbg_info_size);
  800420f289:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f290:	00 00 00 
  800420f293:	48 8b 00             	mov    (%rax),%rax
  800420f296:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420f29a:	48 85 c0             	test   %rax,%rax
  800420f29d:	0f 85 74 01 00 00    	jne    800420f417 <debuginfo_rip+0x3a8>
  800420f2a3:	48 b9 5d e4 21 04 80 	movabs $0x800421e45d,%rcx
  800420f2aa:	00 00 00 
  800420f2ad:	48 ba 24 e4 21 04 80 	movabs $0x800421e424,%rdx
  800420f2b4:	00 00 00 
  800420f2b7:	be e1 00 00 00       	mov    $0xe1,%esi
  800420f2bc:	48 bf 39 e4 21 04 80 	movabs $0x800421e439,%rdi
  800420f2c3:	00 00 00 
  800420f2c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f2cb:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800420f2d2:	00 00 00 
  800420f2d5:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420f2d8:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f2df:	00 00 00 
  800420f2e2:	48 8b 00             	mov    (%rax),%rax
  800420f2e5:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420f2e9:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420f2f0:	be 00 00 00 00       	mov    $0x0,%esi
  800420f2f5:	48 89 c7             	mov    %rax,%rdi
  800420f2f8:	48 b8 4b 23 21 04 80 	movabs $0x800421234b,%rax
  800420f2ff:	00 00 00 
  800420f302:	ff d0                	callq  *%rax
  800420f304:	83 f8 04             	cmp    $0x4,%eax
  800420f307:	0f 84 0d 01 00 00    	je     800420f41a <debuginfo_rip+0x3ab>
		{
			continue;
		}	
		cudie.cu_header = &cu;
  800420f30d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f311:	48 89 85 20 a2 ff ff 	mov    %rax,-0x5de0(%rbp)
		cudie.cu_die = NULL;
  800420f318:	48 c7 85 28 a2 ff ff 	movq   $0x0,-0x5dd8(%rbp)
  800420f31f:	00 00 00 00 
	    
		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420f323:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f32a:	00 00 00 
  800420f32d:	48 8b 00             	mov    (%rax),%rax
  800420f330:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420f337:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420f33e:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
  800420f342:	48 89 c7             	mov    %rax,%rdi
  800420f345:	48 b8 8f 25 21 04 80 	movabs $0x800421258f,%rax
  800420f34c:	00 00 00 
  800420f34f:	ff d0                	callq  *%rax
  800420f351:	83 f8 04             	cmp    $0x4,%eax
  800420f354:	0f 84 c3 00 00 00    	je     800420f41d <debuginfo_rip+0x3ae>
		{
			continue;
		}	
		die.cu_header = &cu;
  800420f35a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f35e:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
		die.cu_die = &cudie;
  800420f365:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420f36c:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420f373:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420f37a:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420f381:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420f388:	48 89 ce             	mov    %rcx,%rsi
  800420f38b:	48 89 c7             	mov    %rax,%rdi
  800420f38e:	48 b8 00 eb 20 04 80 	movabs $0x800420eb00,%rax
  800420f395:	00 00 00 
  800420f398:	ff d0                	callq  *%rax
  800420f39a:	85 c0                	test   %eax,%eax
  800420f39c:	0f 85 b1 00 00 00    	jne    800420f453 <debuginfo_rip+0x3e4>
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420f3a2:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f3a9:	00 00 00 
  800420f3ac:	48 8b 00             	mov    (%rax),%rax
  800420f3af:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420f3b3:	48 8d 95 50 6e ff ff 	lea    -0x91b0(%rbp),%rdx
  800420f3ba:	48 8d b5 30 cf ff ff 	lea    -0x30d0(%rbp),%rsi
  800420f3c1:	48 89 c7             	mov    %rax,%rdi
  800420f3c4:	48 b8 4b 23 21 04 80 	movabs $0x800421234b,%rax
  800420f3cb:	00 00 00 
  800420f3ce:	ff d0                	callq  *%rax
  800420f3d0:	85 c0                	test   %eax,%eax
  800420f3d2:	78 4c                	js     800420f420 <debuginfo_rip+0x3b1>
				break; 
			die = die2;
  800420f3d4:	48 8d 85 30 cf ff ff 	lea    -0x30d0(%rbp),%rax
  800420f3db:	48 8d 8d 50 6e ff ff 	lea    -0x91b0(%rbp),%rcx
  800420f3e2:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f3e7:	48 89 ce             	mov    %rcx,%rsi
  800420f3ea:	48 89 c7             	mov    %rax,%rdi
  800420f3ed:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  800420f3f4:	00 00 00 
  800420f3f7:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420f3f9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420f3fd:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
			die.cu_die = &cudie;
  800420f404:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420f40b:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		}
  800420f412:	e9 5c ff ff ff       	jmpq   800420f373 <debuginfo_rip+0x304>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420f417:	90                   	nop
  800420f418:	eb 07                	jmp    800420f421 <debuginfo_rip+0x3b2>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
		{
			continue;
  800420f41a:	90                   	nop
  800420f41b:	eb 04                	jmp    800420f421 <debuginfo_rip+0x3b2>
		cudie.cu_header = &cu;
		cudie.cu_die = NULL;
	    
		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
		{
			continue;
  800420f41d:	90                   	nop
  800420f41e:	eb 01                	jmp    800420f421 <debuginfo_rip+0x3b2>
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
				break; 
  800420f420:	90                   	nop
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420f421:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800420f428:	00 00 00 
  800420f42b:	48 8b 00             	mov    (%rax),%rax
  800420f42e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420f432:	48 89 d6             	mov    %rdx,%rsi
  800420f435:	48 89 c7             	mov    %rax,%rdi
  800420f438:	48 b8 66 12 21 04 80 	movabs $0x8004211266,%rax
  800420f43f:	00 00 00 
  800420f442:	ff d0                	callq  *%rax
  800420f444:	85 c0                	test   %eax,%eax
  800420f446:	0f 84 8c fe ff ff    	je     800420f2d8 <debuginfo_rip+0x269>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}
    
	return -1;
  800420f44c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f451:	eb 06                	jmp    800420f459 <debuginfo_rip+0x3ea>
		die.cu_header = &cu;
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
  800420f453:	90                   	nop
	}
    
	return -1;

find_done:
	return 0;
  800420f454:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420f459:	c9                   	leaveq 
  800420f45a:	c3                   	retq   
	...

000000800420f45c <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420f45c:	55                   	push   %rbp
  800420f45d:	48 89 e5             	mov    %rsp,%rbp
  800420f460:	48 83 ec 30          	sub    $0x30,%rsp
  800420f464:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f468:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f46c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f470:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  800420f473:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  800420f477:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420f47b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f47e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420f482:	77 52                	ja     800420f4d6 <printnum+0x7a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420f484:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420f487:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420f48b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420f48e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420f492:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f496:	ba 00 00 00 00       	mov    $0x0,%edx
  800420f49b:	48 f7 75 d0          	divq   -0x30(%rbp)
  800420f49f:	48 89 c2             	mov    %rax,%rdx
  800420f4a2:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420f4a5:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f4a8:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420f4ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4b0:	41 89 f9             	mov    %edi,%r9d
  800420f4b3:	48 89 c7             	mov    %rax,%rdi
  800420f4b6:	48 b8 5c f4 20 04 80 	movabs $0x800420f45c,%rax
  800420f4bd:	00 00 00 
  800420f4c0:	ff d0                	callq  *%rax
  800420f4c2:	eb 1c                	jmp    800420f4e0 <printnum+0x84>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800420f4c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f4c8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f4cb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420f4cf:	48 89 d6             	mov    %rdx,%rsi
  800420f4d2:	89 c7                	mov    %eax,%edi
  800420f4d4:	ff d1                	callq  *%rcx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420f4d6:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  800420f4da:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  800420f4de:	7f e4                	jg     800420f4c4 <printnum+0x68>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420f4e0:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f4e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f4e7:	ba 00 00 00 00       	mov    $0x0,%edx
  800420f4ec:	48 f7 f1             	div    %rcx
  800420f4ef:	48 89 d0             	mov    %rdx,%rax
  800420f4f2:	48 ba 70 e6 21 04 80 	movabs $0x800421e670,%rdx
  800420f4f9:	00 00 00 
  800420f4fc:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420f500:	0f be c0             	movsbl %al,%eax
  800420f503:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f507:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420f50b:	48 89 d6             	mov    %rdx,%rsi
  800420f50e:	89 c7                	mov    %eax,%edi
  800420f510:	ff d1                	callq  *%rcx
}
  800420f512:	c9                   	leaveq 
  800420f513:	c3                   	retq   

000000800420f514 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420f514:	55                   	push   %rbp
  800420f515:	48 89 e5             	mov    %rsp,%rbp
  800420f518:	48 83 ec 20          	sub    $0x20,%rsp
  800420f51c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f520:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420f523:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420f527:	7e 52                	jle    800420f57b <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420f529:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f52d:	8b 00                	mov    (%rax),%eax
  800420f52f:	83 f8 30             	cmp    $0x30,%eax
  800420f532:	73 24                	jae    800420f558 <getuint+0x44>
  800420f534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f538:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f53c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f540:	8b 00                	mov    (%rax),%eax
  800420f542:	89 c0                	mov    %eax,%eax
  800420f544:	48 01 d0             	add    %rdx,%rax
  800420f547:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f54b:	8b 12                	mov    (%rdx),%edx
  800420f54d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f550:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f554:	89 0a                	mov    %ecx,(%rdx)
  800420f556:	eb 17                	jmp    800420f56f <getuint+0x5b>
  800420f558:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f55c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f560:	48 89 d0             	mov    %rdx,%rax
  800420f563:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f567:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f56b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f56f:	48 8b 00             	mov    (%rax),%rax
  800420f572:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f576:	e9 a3 00 00 00       	jmpq   800420f61e <getuint+0x10a>
	else if (lflag)
  800420f57b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f57f:	74 4f                	je     800420f5d0 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420f581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f585:	8b 00                	mov    (%rax),%eax
  800420f587:	83 f8 30             	cmp    $0x30,%eax
  800420f58a:	73 24                	jae    800420f5b0 <getuint+0x9c>
  800420f58c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f590:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f594:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f598:	8b 00                	mov    (%rax),%eax
  800420f59a:	89 c0                	mov    %eax,%eax
  800420f59c:	48 01 d0             	add    %rdx,%rax
  800420f59f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5a3:	8b 12                	mov    (%rdx),%edx
  800420f5a5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f5a8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5ac:	89 0a                	mov    %ecx,(%rdx)
  800420f5ae:	eb 17                	jmp    800420f5c7 <getuint+0xb3>
  800420f5b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5b4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f5b8:	48 89 d0             	mov    %rdx,%rax
  800420f5bb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f5bf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5c3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f5c7:	48 8b 00             	mov    (%rax),%rax
  800420f5ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f5ce:	eb 4e                	jmp    800420f61e <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420f5d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5d4:	8b 00                	mov    (%rax),%eax
  800420f5d6:	83 f8 30             	cmp    $0x30,%eax
  800420f5d9:	73 24                	jae    800420f5ff <getuint+0xeb>
  800420f5db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5df:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f5e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5e7:	8b 00                	mov    (%rax),%eax
  800420f5e9:	89 c0                	mov    %eax,%eax
  800420f5eb:	48 01 d0             	add    %rdx,%rax
  800420f5ee:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5f2:	8b 12                	mov    (%rdx),%edx
  800420f5f4:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f5f7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f5fb:	89 0a                	mov    %ecx,(%rdx)
  800420f5fd:	eb 17                	jmp    800420f616 <getuint+0x102>
  800420f5ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f603:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f607:	48 89 d0             	mov    %rdx,%rax
  800420f60a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f60e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f612:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f616:	8b 00                	mov    (%rax),%eax
  800420f618:	89 c0                	mov    %eax,%eax
  800420f61a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420f61e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f622:	c9                   	leaveq 
  800420f623:	c3                   	retq   

000000800420f624 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420f624:	55                   	push   %rbp
  800420f625:	48 89 e5             	mov    %rsp,%rbp
  800420f628:	48 83 ec 20          	sub    $0x20,%rsp
  800420f62c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f630:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420f633:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420f637:	7e 52                	jle    800420f68b <getint+0x67>
		x=va_arg(*ap, long long);
  800420f639:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f63d:	8b 00                	mov    (%rax),%eax
  800420f63f:	83 f8 30             	cmp    $0x30,%eax
  800420f642:	73 24                	jae    800420f668 <getint+0x44>
  800420f644:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f648:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f64c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f650:	8b 00                	mov    (%rax),%eax
  800420f652:	89 c0                	mov    %eax,%eax
  800420f654:	48 01 d0             	add    %rdx,%rax
  800420f657:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f65b:	8b 12                	mov    (%rdx),%edx
  800420f65d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f660:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f664:	89 0a                	mov    %ecx,(%rdx)
  800420f666:	eb 17                	jmp    800420f67f <getint+0x5b>
  800420f668:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f66c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f670:	48 89 d0             	mov    %rdx,%rax
  800420f673:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f677:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f67b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f67f:	48 8b 00             	mov    (%rax),%rax
  800420f682:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f686:	e9 a3 00 00 00       	jmpq   800420f72e <getint+0x10a>
	else if (lflag)
  800420f68b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420f68f:	74 4f                	je     800420f6e0 <getint+0xbc>
		x=va_arg(*ap, long);
  800420f691:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f695:	8b 00                	mov    (%rax),%eax
  800420f697:	83 f8 30             	cmp    $0x30,%eax
  800420f69a:	73 24                	jae    800420f6c0 <getint+0x9c>
  800420f69c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6a0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f6a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6a8:	8b 00                	mov    (%rax),%eax
  800420f6aa:	89 c0                	mov    %eax,%eax
  800420f6ac:	48 01 d0             	add    %rdx,%rax
  800420f6af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6b3:	8b 12                	mov    (%rdx),%edx
  800420f6b5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f6b8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6bc:	89 0a                	mov    %ecx,(%rdx)
  800420f6be:	eb 17                	jmp    800420f6d7 <getint+0xb3>
  800420f6c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6c4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f6c8:	48 89 d0             	mov    %rdx,%rax
  800420f6cb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f6cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f6d3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f6d7:	48 8b 00             	mov    (%rax),%rax
  800420f6da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f6de:	eb 4e                	jmp    800420f72e <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420f6e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6e4:	8b 00                	mov    (%rax),%eax
  800420f6e6:	83 f8 30             	cmp    $0x30,%eax
  800420f6e9:	73 24                	jae    800420f70f <getint+0xeb>
  800420f6eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6ef:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420f6f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6f7:	8b 00                	mov    (%rax),%eax
  800420f6f9:	89 c0                	mov    %eax,%eax
  800420f6fb:	48 01 d0             	add    %rdx,%rax
  800420f6fe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f702:	8b 12                	mov    (%rdx),%edx
  800420f704:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420f707:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f70b:	89 0a                	mov    %ecx,(%rdx)
  800420f70d:	eb 17                	jmp    800420f726 <getint+0x102>
  800420f70f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f713:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420f717:	48 89 d0             	mov    %rdx,%rax
  800420f71a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420f71e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f722:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420f726:	8b 00                	mov    (%rax),%eax
  800420f728:	48 98                	cltq   
  800420f72a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420f72e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f732:	c9                   	leaveq 
  800420f733:	c3                   	retq   

000000800420f734 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420f734:	55                   	push   %rbp
  800420f735:	48 89 e5             	mov    %rsp,%rbp
  800420f738:	41 54                	push   %r12
  800420f73a:	53                   	push   %rbx
  800420f73b:	48 83 ec 60          	sub    $0x60,%rsp
  800420f73f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420f743:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420f747:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f74b:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420f74f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f753:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420f757:	48 8b 0a             	mov    (%rdx),%rcx
  800420f75a:	48 89 08             	mov    %rcx,(%rax)
  800420f75d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f761:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f765:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f769:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f76d:	eb 17                	jmp    800420f786 <vprintfmt+0x52>
			if (ch == '\0')
  800420f76f:	85 db                	test   %ebx,%ebx
  800420f771:	0f 84 ea 04 00 00    	je     800420fc61 <vprintfmt+0x52d>
				return;
			putch(ch, putdat);
  800420f777:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f77b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420f77f:	48 89 c6             	mov    %rax,%rsi
  800420f782:	89 df                	mov    %ebx,%edi
  800420f784:	ff d2                	callq  *%rdx
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f786:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f78a:	0f b6 00             	movzbl (%rax),%eax
  800420f78d:	0f b6 d8             	movzbl %al,%ebx
  800420f790:	83 fb 25             	cmp    $0x25,%ebx
  800420f793:	0f 95 c0             	setne  %al
  800420f796:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  800420f79b:	84 c0                	test   %al,%al
  800420f79d:	75 d0                	jne    800420f76f <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420f79f:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420f7a3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420f7aa:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420f7b1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420f7b8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  800420f7bf:	eb 04                	jmp    800420f7c5 <vprintfmt+0x91>
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
			goto reswitch;
  800420f7c1:	90                   	nop
  800420f7c2:	eb 01                	jmp    800420f7c5 <vprintfmt+0x91>
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
			goto reswitch;
  800420f7c4:	90                   	nop
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420f7c5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f7c9:	0f b6 00             	movzbl (%rax),%eax
  800420f7cc:	0f b6 d8             	movzbl %al,%ebx
  800420f7cf:	89 d8                	mov    %ebx,%eax
  800420f7d1:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  800420f7d6:	83 e8 23             	sub    $0x23,%eax
  800420f7d9:	83 f8 55             	cmp    $0x55,%eax
  800420f7dc:	0f 87 4b 04 00 00    	ja     800420fc2d <vprintfmt+0x4f9>
  800420f7e2:	89 c0                	mov    %eax,%eax
  800420f7e4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420f7eb:	00 
  800420f7ec:	48 b8 98 e6 21 04 80 	movabs $0x800421e698,%rax
  800420f7f3:	00 00 00 
  800420f7f6:	48 01 d0             	add    %rdx,%rax
  800420f7f9:	48 8b 00             	mov    (%rax),%rax
  800420f7fc:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420f7fe:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420f802:	eb c1                	jmp    800420f7c5 <vprintfmt+0x91>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420f804:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420f808:	eb bb                	jmp    800420f7c5 <vprintfmt+0x91>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420f80a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420f811:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420f814:	89 d0                	mov    %edx,%eax
  800420f816:	c1 e0 02             	shl    $0x2,%eax
  800420f819:	01 d0                	add    %edx,%eax
  800420f81b:	01 c0                	add    %eax,%eax
  800420f81d:	01 d8                	add    %ebx,%eax
  800420f81f:	83 e8 30             	sub    $0x30,%eax
  800420f822:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420f825:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f829:	0f b6 00             	movzbl (%rax),%eax
  800420f82c:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420f82f:	83 fb 2f             	cmp    $0x2f,%ebx
  800420f832:	7e 63                	jle    800420f897 <vprintfmt+0x163>
  800420f834:	83 fb 39             	cmp    $0x39,%ebx
  800420f837:	7f 5e                	jg     800420f897 <vprintfmt+0x163>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420f839:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420f83e:	eb d1                	jmp    800420f811 <vprintfmt+0xdd>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  800420f840:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f843:	83 f8 30             	cmp    $0x30,%eax
  800420f846:	73 17                	jae    800420f85f <vprintfmt+0x12b>
  800420f848:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f84c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f84f:	89 c0                	mov    %eax,%eax
  800420f851:	48 01 d0             	add    %rdx,%rax
  800420f854:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f857:	83 c2 08             	add    $0x8,%edx
  800420f85a:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f85d:	eb 0f                	jmp    800420f86e <vprintfmt+0x13a>
  800420f85f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f863:	48 89 d0             	mov    %rdx,%rax
  800420f866:	48 83 c2 08          	add    $0x8,%rdx
  800420f86a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f86e:	8b 00                	mov    (%rax),%eax
  800420f870:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420f873:	eb 23                	jmp    800420f898 <vprintfmt+0x164>

		case '.':
			if (width < 0)
  800420f875:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f879:	0f 89 42 ff ff ff    	jns    800420f7c1 <vprintfmt+0x8d>
				width = 0;
  800420f87f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420f886:	e9 36 ff ff ff       	jmpq   800420f7c1 <vprintfmt+0x8d>

		case '#':
			altflag = 1;
  800420f88b:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420f892:	e9 2e ff ff ff       	jmpq   800420f7c5 <vprintfmt+0x91>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  800420f897:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800420f898:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f89c:	0f 89 22 ff ff ff    	jns    800420f7c4 <vprintfmt+0x90>
				width = precision, precision = -1;
  800420f8a2:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f8a5:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420f8a8:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420f8af:	e9 10 ff ff ff       	jmpq   800420f7c4 <vprintfmt+0x90>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420f8b4:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420f8b8:	e9 08 ff ff ff       	jmpq   800420f7c5 <vprintfmt+0x91>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420f8bd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f8c0:	83 f8 30             	cmp    $0x30,%eax
  800420f8c3:	73 17                	jae    800420f8dc <vprintfmt+0x1a8>
  800420f8c5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f8c9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f8cc:	89 c0                	mov    %eax,%eax
  800420f8ce:	48 01 d0             	add    %rdx,%rax
  800420f8d1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f8d4:	83 c2 08             	add    $0x8,%edx
  800420f8d7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f8da:	eb 0f                	jmp    800420f8eb <vprintfmt+0x1b7>
  800420f8dc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f8e0:	48 89 d0             	mov    %rdx,%rax
  800420f8e3:	48 83 c2 08          	add    $0x8,%rdx
  800420f8e7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f8eb:	8b 00                	mov    (%rax),%eax
  800420f8ed:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f8f1:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420f8f5:	48 89 d6             	mov    %rdx,%rsi
  800420f8f8:	89 c7                	mov    %eax,%edi
  800420f8fa:	ff d1                	callq  *%rcx
			break;
  800420f8fc:	e9 5a 03 00 00       	jmpq   800420fc5b <vprintfmt+0x527>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420f901:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f904:	83 f8 30             	cmp    $0x30,%eax
  800420f907:	73 17                	jae    800420f920 <vprintfmt+0x1ec>
  800420f909:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f90d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f910:	89 c0                	mov    %eax,%eax
  800420f912:	48 01 d0             	add    %rdx,%rax
  800420f915:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f918:	83 c2 08             	add    $0x8,%edx
  800420f91b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f91e:	eb 0f                	jmp    800420f92f <vprintfmt+0x1fb>
  800420f920:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f924:	48 89 d0             	mov    %rdx,%rax
  800420f927:	48 83 c2 08          	add    $0x8,%rdx
  800420f92b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f92f:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420f931:	85 db                	test   %ebx,%ebx
  800420f933:	79 02                	jns    800420f937 <vprintfmt+0x203>
				err = -err;
  800420f935:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420f937:	83 fb 15             	cmp    $0x15,%ebx
  800420f93a:	7f 16                	jg     800420f952 <vprintfmt+0x21e>
  800420f93c:	48 b8 c0 e5 21 04 80 	movabs $0x800421e5c0,%rax
  800420f943:	00 00 00 
  800420f946:	48 63 d3             	movslq %ebx,%rdx
  800420f949:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420f94d:	4d 85 e4             	test   %r12,%r12
  800420f950:	75 2e                	jne    800420f980 <vprintfmt+0x24c>
				printfmt(putch, putdat, "error %d", err);
  800420f952:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f956:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f95a:	89 d9                	mov    %ebx,%ecx
  800420f95c:	48 ba 81 e6 21 04 80 	movabs $0x800421e681,%rdx
  800420f963:	00 00 00 
  800420f966:	48 89 c7             	mov    %rax,%rdi
  800420f969:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f96e:	49 b8 6b fc 20 04 80 	movabs $0x800420fc6b,%r8
  800420f975:	00 00 00 
  800420f978:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420f97b:	e9 db 02 00 00       	jmpq   800420fc5b <vprintfmt+0x527>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420f980:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f984:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f988:	4c 89 e1             	mov    %r12,%rcx
  800420f98b:	48 ba 8a e6 21 04 80 	movabs $0x800421e68a,%rdx
  800420f992:	00 00 00 
  800420f995:	48 89 c7             	mov    %rax,%rdi
  800420f998:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f99d:	49 b8 6b fc 20 04 80 	movabs $0x800420fc6b,%r8
  800420f9a4:	00 00 00 
  800420f9a7:	41 ff d0             	callq  *%r8
			break;
  800420f9aa:	e9 ac 02 00 00       	jmpq   800420fc5b <vprintfmt+0x527>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420f9af:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f9b2:	83 f8 30             	cmp    $0x30,%eax
  800420f9b5:	73 17                	jae    800420f9ce <vprintfmt+0x29a>
  800420f9b7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f9bb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f9be:	89 c0                	mov    %eax,%eax
  800420f9c0:	48 01 d0             	add    %rdx,%rax
  800420f9c3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f9c6:	83 c2 08             	add    $0x8,%edx
  800420f9c9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f9cc:	eb 0f                	jmp    800420f9dd <vprintfmt+0x2a9>
  800420f9ce:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f9d2:	48 89 d0             	mov    %rdx,%rax
  800420f9d5:	48 83 c2 08          	add    $0x8,%rdx
  800420f9d9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f9dd:	4c 8b 20             	mov    (%rax),%r12
  800420f9e0:	4d 85 e4             	test   %r12,%r12
  800420f9e3:	75 0a                	jne    800420f9ef <vprintfmt+0x2bb>
				p = "(null)";
  800420f9e5:	49 bc 8d e6 21 04 80 	movabs $0x800421e68d,%r12
  800420f9ec:	00 00 00 
			if (width > 0 && padc != '-')
  800420f9ef:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f9f3:	7e 7a                	jle    800420fa6f <vprintfmt+0x33b>
  800420f9f5:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420f9f9:	74 74                	je     800420fa6f <vprintfmt+0x33b>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f9fb:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f9fe:	48 98                	cltq   
  800420fa00:	48 89 c6             	mov    %rax,%rsi
  800420fa03:	4c 89 e7             	mov    %r12,%rdi
  800420fa06:	48 b8 72 00 21 04 80 	movabs $0x8004210072,%rax
  800420fa0d:	00 00 00 
  800420fa10:	ff d0                	callq  *%rax
  800420fa12:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420fa15:	eb 17                	jmp    800420fa2e <vprintfmt+0x2fa>
					putch(padc, putdat);
  800420fa17:	0f be 45 d3          	movsbl -0x2d(%rbp),%eax
  800420fa1b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420fa1f:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420fa23:	48 89 d6             	mov    %rdx,%rsi
  800420fa26:	89 c7                	mov    %eax,%edi
  800420fa28:	ff d1                	callq  *%rcx
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420fa2a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420fa2e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fa32:	7f e3                	jg     800420fa17 <vprintfmt+0x2e3>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420fa34:	eb 39                	jmp    800420fa6f <vprintfmt+0x33b>
				if (altflag && (ch < ' ' || ch > '~'))
  800420fa36:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420fa3a:	74 1e                	je     800420fa5a <vprintfmt+0x326>
  800420fa3c:	83 fb 1f             	cmp    $0x1f,%ebx
  800420fa3f:	7e 05                	jle    800420fa46 <vprintfmt+0x312>
  800420fa41:	83 fb 7e             	cmp    $0x7e,%ebx
  800420fa44:	7e 14                	jle    800420fa5a <vprintfmt+0x326>
					putch('?', putdat);
  800420fa46:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fa4a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fa4e:	48 89 c6             	mov    %rax,%rsi
  800420fa51:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420fa56:	ff d2                	callq  *%rdx
  800420fa58:	eb 0f                	jmp    800420fa69 <vprintfmt+0x335>
				else
					putch(ch, putdat);
  800420fa5a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fa5e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fa62:	48 89 c6             	mov    %rax,%rsi
  800420fa65:	89 df                	mov    %ebx,%edi
  800420fa67:	ff d2                	callq  *%rdx
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420fa69:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420fa6d:	eb 01                	jmp    800420fa70 <vprintfmt+0x33c>
  800420fa6f:	90                   	nop
  800420fa70:	41 0f b6 04 24       	movzbl (%r12),%eax
  800420fa75:	0f be d8             	movsbl %al,%ebx
  800420fa78:	85 db                	test   %ebx,%ebx
  800420fa7a:	0f 95 c0             	setne  %al
  800420fa7d:	49 83 c4 01          	add    $0x1,%r12
  800420fa81:	84 c0                	test   %al,%al
  800420fa83:	74 28                	je     800420faad <vprintfmt+0x379>
  800420fa85:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420fa89:	78 ab                	js     800420fa36 <vprintfmt+0x302>
  800420fa8b:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420fa8f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420fa93:	79 a1                	jns    800420fa36 <vprintfmt+0x302>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420fa95:	eb 16                	jmp    800420faad <vprintfmt+0x379>
				putch(' ', putdat);
  800420fa97:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fa9b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fa9f:	48 89 c6             	mov    %rax,%rsi
  800420faa2:	bf 20 00 00 00       	mov    $0x20,%edi
  800420faa7:	ff d2                	callq  *%rdx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420faa9:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420faad:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420fab1:	7f e4                	jg     800420fa97 <vprintfmt+0x363>
				putch(' ', putdat);
			break;
  800420fab3:	e9 a3 01 00 00       	jmpq   800420fc5b <vprintfmt+0x527>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420fab8:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fabc:	be 03 00 00 00       	mov    $0x3,%esi
  800420fac1:	48 89 c7             	mov    %rax,%rdi
  800420fac4:	48 b8 24 f6 20 04 80 	movabs $0x800420f624,%rax
  800420facb:	00 00 00 
  800420face:	ff d0                	callq  *%rax
  800420fad0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420fad4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fad8:	48 85 c0             	test   %rax,%rax
  800420fadb:	79 1d                	jns    800420fafa <vprintfmt+0x3c6>
				putch('-', putdat);
  800420fadd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fae1:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fae5:	48 89 c6             	mov    %rax,%rsi
  800420fae8:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420faed:	ff d2                	callq  *%rdx
				num = -(long long) num;
  800420faef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faf3:	48 f7 d8             	neg    %rax
  800420faf6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420fafa:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420fb01:	e9 e8 00 00 00       	jmpq   800420fbee <vprintfmt+0x4ba>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420fb06:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fb0a:	be 03 00 00 00       	mov    $0x3,%esi
  800420fb0f:	48 89 c7             	mov    %rax,%rdi
  800420fb12:	48 b8 14 f5 20 04 80 	movabs $0x800420f514,%rax
  800420fb19:	00 00 00 
  800420fb1c:	ff d0                	callq  *%rax
  800420fb1e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420fb22:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420fb29:	e9 c0 00 00 00       	jmpq   800420fbee <vprintfmt+0x4ba>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  800420fb2e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fb32:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fb36:	48 89 c6             	mov    %rax,%rsi
  800420fb39:	bf 58 00 00 00       	mov    $0x58,%edi
  800420fb3e:	ff d2                	callq  *%rdx
			putch('X', putdat);
  800420fb40:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fb44:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fb48:	48 89 c6             	mov    %rax,%rsi
  800420fb4b:	bf 58 00 00 00       	mov    $0x58,%edi
  800420fb50:	ff d2                	callq  *%rdx
			putch('X', putdat);
  800420fb52:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fb56:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fb5a:	48 89 c6             	mov    %rax,%rsi
  800420fb5d:	bf 58 00 00 00       	mov    $0x58,%edi
  800420fb62:	ff d2                	callq  *%rdx
			break;
  800420fb64:	e9 f2 00 00 00       	jmpq   800420fc5b <vprintfmt+0x527>

			// pointer
		case 'p':
			putch('0', putdat);
  800420fb69:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fb6d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fb71:	48 89 c6             	mov    %rax,%rsi
  800420fb74:	bf 30 00 00 00       	mov    $0x30,%edi
  800420fb79:	ff d2                	callq  *%rdx
			putch('x', putdat);
  800420fb7b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fb7f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fb83:	48 89 c6             	mov    %rax,%rsi
  800420fb86:	bf 78 00 00 00       	mov    $0x78,%edi
  800420fb8b:	ff d2                	callq  *%rdx
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420fb8d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420fb90:	83 f8 30             	cmp    $0x30,%eax
  800420fb93:	73 17                	jae    800420fbac <vprintfmt+0x478>
  800420fb95:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fb99:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420fb9c:	89 c0                	mov    %eax,%eax
  800420fb9e:	48 01 d0             	add    %rdx,%rax
  800420fba1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420fba4:	83 c2 08             	add    $0x8,%edx
  800420fba7:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420fbaa:	eb 0f                	jmp    800420fbbb <vprintfmt+0x487>
				(uintptr_t) va_arg(aq, void *);
  800420fbac:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420fbb0:	48 89 d0             	mov    %rdx,%rax
  800420fbb3:	48 83 c2 08          	add    $0x8,%rdx
  800420fbb7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420fbbb:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420fbbe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420fbc2:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420fbc9:	eb 23                	jmp    800420fbee <vprintfmt+0x4ba>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420fbcb:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420fbcf:	be 03 00 00 00       	mov    $0x3,%esi
  800420fbd4:	48 89 c7             	mov    %rax,%rdi
  800420fbd7:	48 b8 14 f5 20 04 80 	movabs $0x800420f514,%rax
  800420fbde:	00 00 00 
  800420fbe1:	ff d0                	callq  *%rax
  800420fbe3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420fbe7:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420fbee:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420fbf3:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420fbf6:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420fbf9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fbfd:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420fc01:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fc05:	45 89 c1             	mov    %r8d,%r9d
  800420fc08:	41 89 f8             	mov    %edi,%r8d
  800420fc0b:	48 89 c7             	mov    %rax,%rdi
  800420fc0e:	48 b8 5c f4 20 04 80 	movabs $0x800420f45c,%rax
  800420fc15:	00 00 00 
  800420fc18:	ff d0                	callq  *%rax
			break;
  800420fc1a:	eb 3f                	jmp    800420fc5b <vprintfmt+0x527>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420fc1c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fc20:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fc24:	48 89 c6             	mov    %rax,%rsi
  800420fc27:	89 df                	mov    %ebx,%edi
  800420fc29:	ff d2                	callq  *%rdx
			break;
  800420fc2b:	eb 2e                	jmp    800420fc5b <vprintfmt+0x527>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420fc2d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fc31:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420fc35:	48 89 c6             	mov    %rax,%rsi
  800420fc38:	bf 25 00 00 00       	mov    $0x25,%edi
  800420fc3d:	ff d2                	callq  *%rdx
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420fc3f:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420fc44:	eb 05                	jmp    800420fc4b <vprintfmt+0x517>
  800420fc46:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420fc4b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fc4f:	48 83 e8 01          	sub    $0x1,%rax
  800420fc53:	0f b6 00             	movzbl (%rax),%eax
  800420fc56:	3c 25                	cmp    $0x25,%al
  800420fc58:	75 ec                	jne    800420fc46 <vprintfmt+0x512>
				/* do nothing */;
			break;
  800420fc5a:	90                   	nop
		}
	}
  800420fc5b:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420fc5c:	e9 25 fb ff ff       	jmpq   800420f786 <vprintfmt+0x52>
			if (ch == '\0')
				return;
  800420fc61:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420fc62:	48 83 c4 60          	add    $0x60,%rsp
  800420fc66:	5b                   	pop    %rbx
  800420fc67:	41 5c                	pop    %r12
  800420fc69:	5d                   	pop    %rbp
  800420fc6a:	c3                   	retq   

000000800420fc6b <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420fc6b:	55                   	push   %rbp
  800420fc6c:	48 89 e5             	mov    %rsp,%rbp
  800420fc6f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420fc76:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420fc7d:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420fc84:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420fc8b:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420fc92:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420fc99:	84 c0                	test   %al,%al
  800420fc9b:	74 20                	je     800420fcbd <printfmt+0x52>
  800420fc9d:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420fca1:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420fca5:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420fca9:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420fcad:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420fcb1:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420fcb5:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420fcb9:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420fcbd:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420fcc4:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420fccb:	00 00 00 
  800420fcce:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420fcd5:	00 00 00 
  800420fcd8:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420fcdc:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420fce3:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420fcea:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420fcf1:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420fcf8:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420fcff:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420fd06:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420fd0d:	48 89 c7             	mov    %rax,%rdi
  800420fd10:	48 b8 34 f7 20 04 80 	movabs $0x800420f734,%rax
  800420fd17:	00 00 00 
  800420fd1a:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420fd1c:	c9                   	leaveq 
  800420fd1d:	c3                   	retq   

000000800420fd1e <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420fd1e:	55                   	push   %rbp
  800420fd1f:	48 89 e5             	mov    %rsp,%rbp
  800420fd22:	48 83 ec 10          	sub    $0x10,%rsp
  800420fd26:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420fd29:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420fd2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd31:	8b 40 10             	mov    0x10(%rax),%eax
  800420fd34:	8d 50 01             	lea    0x1(%rax),%edx
  800420fd37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd3b:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420fd3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd42:	48 8b 10             	mov    (%rax),%rdx
  800420fd45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd49:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fd4d:	48 39 c2             	cmp    %rax,%rdx
  800420fd50:	73 17                	jae    800420fd69 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420fd52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd56:	48 8b 00             	mov    (%rax),%rax
  800420fd59:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fd5c:	88 10                	mov    %dl,(%rax)
  800420fd5e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fd62:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fd66:	48 89 10             	mov    %rdx,(%rax)
}
  800420fd69:	c9                   	leaveq 
  800420fd6a:	c3                   	retq   

000000800420fd6b <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420fd6b:	55                   	push   %rbp
  800420fd6c:	48 89 e5             	mov    %rsp,%rbp
  800420fd6f:	48 83 ec 50          	sub    $0x50,%rsp
  800420fd73:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420fd77:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420fd7a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420fd7e:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420fd82:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420fd86:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fd8a:	48 8b 0a             	mov    (%rdx),%rcx
  800420fd8d:	48 89 08             	mov    %rcx,(%rax)
  800420fd90:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420fd94:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420fd98:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420fd9c:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420fda0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fda4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420fda8:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420fdab:	48 98                	cltq   
  800420fdad:	48 83 e8 01          	sub    $0x1,%rax
  800420fdb1:	48 03 45 c8          	add    -0x38(%rbp),%rax
  800420fdb5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420fdb9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420fdc0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420fdc5:	74 06                	je     800420fdcd <vsnprintf+0x62>
  800420fdc7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420fdcb:	7f 07                	jg     800420fdd4 <vsnprintf+0x69>
		return -E_INVAL;
  800420fdcd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420fdd2:	eb 2f                	jmp    800420fe03 <vsnprintf+0x98>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420fdd4:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420fdd8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420fddc:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420fde0:	48 89 c6             	mov    %rax,%rsi
  800420fde3:	48 bf 1e fd 20 04 80 	movabs $0x800420fd1e,%rdi
  800420fdea:	00 00 00 
  800420fded:	48 b8 34 f7 20 04 80 	movabs $0x800420f734,%rax
  800420fdf4:	00 00 00 
  800420fdf7:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420fdf9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fdfd:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420fe00:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420fe03:	c9                   	leaveq 
  800420fe04:	c3                   	retq   

000000800420fe05 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420fe05:	55                   	push   %rbp
  800420fe06:	48 89 e5             	mov    %rsp,%rbp
  800420fe09:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420fe10:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420fe17:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420fe1d:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420fe24:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420fe2b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420fe32:	84 c0                	test   %al,%al
  800420fe34:	74 20                	je     800420fe56 <snprintf+0x51>
  800420fe36:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420fe3a:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420fe3e:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420fe42:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420fe46:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420fe4a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420fe4e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420fe52:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420fe56:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420fe5d:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420fe64:	00 00 00 
  800420fe67:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420fe6e:	00 00 00 
  800420fe71:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420fe75:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420fe7c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420fe83:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420fe8a:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420fe91:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420fe98:	48 8b 0a             	mov    (%rdx),%rcx
  800420fe9b:	48 89 08             	mov    %rcx,(%rax)
  800420fe9e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420fea2:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420fea6:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420feaa:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420feae:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420feb5:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420febc:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420fec2:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420fec9:	48 89 c7             	mov    %rax,%rdi
  800420fecc:	48 b8 6b fd 20 04 80 	movabs $0x800420fd6b,%rax
  800420fed3:	00 00 00 
  800420fed6:	ff d0                	callq  *%rax
  800420fed8:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420fede:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420fee4:	c9                   	leaveq 
  800420fee5:	c3                   	retq   
	...

000000800420fee8 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420fee8:	55                   	push   %rbp
  800420fee9:	48 89 e5             	mov    %rsp,%rbp
  800420feec:	48 83 ec 20          	sub    $0x20,%rsp
  800420fef0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420fef4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fef9:	74 22                	je     800420ff1d <readline+0x35>
		cprintf("%s", prompt);
  800420fefb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420feff:	48 89 c6             	mov    %rax,%rsi
  800420ff02:	48 bf 48 e9 21 04 80 	movabs $0x800421e948,%rdi
  800420ff09:	00 00 00 
  800420ff0c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff11:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420ff18:	00 00 00 
  800420ff1b:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420ff1d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420ff24:	bf 00 00 00 00       	mov    $0x0,%edi
  800420ff29:	48 b8 ba 12 20 04 80 	movabs $0x80042012ba,%rax
  800420ff30:	00 00 00 
  800420ff33:	ff d0                	callq  *%rax
  800420ff35:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800420ff38:	eb 01                	jmp    800420ff3b <readline+0x53>
			if (echoing)
				cputchar('\n');
			buf[i] = 0;
			return buf;
		}
	}
  800420ff3a:	90                   	nop
#endif

	i = 0;
	echoing = iscons(0);
	while (1) {
		c = getchar();
  800420ff3b:	48 b8 98 12 20 04 80 	movabs $0x8004201298,%rax
  800420ff42:	00 00 00 
  800420ff45:	ff d0                	callq  *%rax
  800420ff47:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420ff4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420ff4e:	79 30                	jns    800420ff80 <readline+0x98>
			if (c != -E_EOF)
  800420ff50:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420ff54:	74 20                	je     800420ff76 <readline+0x8e>
				cprintf("read error: %e\n", c);
  800420ff56:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ff59:	89 c6                	mov    %eax,%esi
  800420ff5b:	48 bf 4b e9 21 04 80 	movabs $0x800421e94b,%rdi
  800420ff62:	00 00 00 
  800420ff65:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff6a:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800420ff71:	00 00 00 
  800420ff74:	ff d2                	callq  *%rdx
			return NULL;
  800420ff76:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff7b:	e9 c0 00 00 00       	jmpq   8004210040 <readline+0x158>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420ff80:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420ff84:	74 06                	je     800420ff8c <readline+0xa4>
  800420ff86:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420ff8a:	75 26                	jne    800420ffb2 <readline+0xca>
  800420ff8c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ff90:	7e 20                	jle    800420ffb2 <readline+0xca>
			if (echoing)
  800420ff92:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420ff96:	74 11                	je     800420ffa9 <readline+0xc1>
				cputchar('\b');
  800420ff98:	bf 08 00 00 00       	mov    $0x8,%edi
  800420ff9d:	48 b8 7a 12 20 04 80 	movabs $0x800420127a,%rax
  800420ffa4:	00 00 00 
  800420ffa7:	ff d0                	callq  *%rax
			i--;
  800420ffa9:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420ffad:	e9 89 00 00 00       	jmpq   800421003b <readline+0x153>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420ffb2:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420ffb6:	7e 3d                	jle    800420fff5 <readline+0x10d>
  800420ffb8:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420ffbf:	7f 34                	jg     800420fff5 <readline+0x10d>
			if (echoing)
  800420ffc1:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420ffc5:	74 11                	je     800420ffd8 <readline+0xf0>
				cputchar(c);
  800420ffc7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ffca:	89 c7                	mov    %eax,%edi
  800420ffcc:	48 b8 7a 12 20 04 80 	movabs $0x800420127a,%rax
  800420ffd3:	00 00 00 
  800420ffd6:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420ffd8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ffdb:	89 c1                	mov    %eax,%ecx
  800420ffdd:	48 ba a0 32 48 04 80 	movabs $0x80044832a0,%rdx
  800420ffe4:	00 00 00 
  800420ffe7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ffea:	48 98                	cltq   
  800420ffec:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420ffef:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420fff3:	eb 46                	jmp    800421003b <readline+0x153>
		} else if (c == '\n' || c == '\r') {
  800420fff5:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420fff9:	74 0a                	je     8004210005 <readline+0x11d>
  800420fffb:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420ffff:	0f 85 35 ff ff ff    	jne    800420ff3a <readline+0x52>
			if (echoing)
  8004210005:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004210009:	74 11                	je     800421001c <readline+0x134>
				cputchar('\n');
  800421000b:	bf 0a 00 00 00       	mov    $0xa,%edi
  8004210010:	48 b8 7a 12 20 04 80 	movabs $0x800420127a,%rax
  8004210017:	00 00 00 
  800421001a:	ff d0                	callq  *%rax
			buf[i] = 0;
  800421001c:	48 ba a0 32 48 04 80 	movabs $0x80044832a0,%rdx
  8004210023:	00 00 00 
  8004210026:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210029:	48 98                	cltq   
  800421002b:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800421002f:	48 b8 a0 32 48 04 80 	movabs $0x80044832a0,%rax
  8004210036:	00 00 00 
  8004210039:	eb 05                	jmp    8004210040 <readline+0x158>
		}
	}
  800421003b:	e9 fa fe ff ff       	jmpq   800420ff3a <readline+0x52>
}
  8004210040:	c9                   	leaveq 
  8004210041:	c3                   	retq   
	...

0000008004210044 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8004210044:	55                   	push   %rbp
  8004210045:	48 89 e5             	mov    %rsp,%rbp
  8004210048:	48 83 ec 18          	sub    $0x18,%rsp
  800421004c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  8004210050:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210057:	eb 09                	jmp    8004210062 <strlen+0x1e>
		n++;
  8004210059:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800421005d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210062:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210066:	0f b6 00             	movzbl (%rax),%eax
  8004210069:	84 c0                	test   %al,%al
  800421006b:	75 ec                	jne    8004210059 <strlen+0x15>
		n++;
	return n;
  800421006d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210070:	c9                   	leaveq 
  8004210071:	c3                   	retq   

0000008004210072 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  8004210072:	55                   	push   %rbp
  8004210073:	48 89 e5             	mov    %rsp,%rbp
  8004210076:	48 83 ec 20          	sub    $0x20,%rsp
  800421007a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421007e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8004210082:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210089:	eb 0e                	jmp    8004210099 <strnlen+0x27>
		n++;
  800421008b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800421008f:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210094:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  8004210099:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421009e:	74 0b                	je     80042100ab <strnlen+0x39>
  80042100a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100a4:	0f b6 00             	movzbl (%rax),%eax
  80042100a7:	84 c0                	test   %al,%al
  80042100a9:	75 e0                	jne    800421008b <strnlen+0x19>
		n++;
	return n;
  80042100ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042100ae:	c9                   	leaveq 
  80042100af:	c3                   	retq   

00000080042100b0 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80042100b0:	55                   	push   %rbp
  80042100b1:	48 89 e5             	mov    %rsp,%rbp
  80042100b4:	48 83 ec 20          	sub    $0x20,%rsp
  80042100b8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042100bc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  80042100c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  80042100c8:	90                   	nop
  80042100c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042100cd:	0f b6 10             	movzbl (%rax),%edx
  80042100d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100d4:	88 10                	mov    %dl,(%rax)
  80042100d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100da:	0f b6 00             	movzbl (%rax),%eax
  80042100dd:	84 c0                	test   %al,%al
  80042100df:	0f 95 c0             	setne  %al
  80042100e2:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042100e7:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  80042100ec:	84 c0                	test   %al,%al
  80042100ee:	75 d9                	jne    80042100c9 <strcpy+0x19>
		/* do nothing */;
	return ret;
  80042100f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042100f4:	c9                   	leaveq 
  80042100f5:	c3                   	retq   

00000080042100f6 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80042100f6:	55                   	push   %rbp
  80042100f7:	48 89 e5             	mov    %rsp,%rbp
  80042100fa:	48 83 ec 20          	sub    $0x20,%rsp
  80042100fe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210102:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  8004210106:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421010a:	48 89 c7             	mov    %rax,%rdi
  800421010d:	48 b8 44 00 21 04 80 	movabs $0x8004210044,%rax
  8004210114:	00 00 00 
  8004210117:	ff d0                	callq  *%rax
  8004210119:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800421011c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421011f:	48 98                	cltq   
  8004210121:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004210125:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210129:	48 89 d6             	mov    %rdx,%rsi
  800421012c:	48 89 c7             	mov    %rax,%rdi
  800421012f:	48 b8 b0 00 21 04 80 	movabs $0x80042100b0,%rax
  8004210136:	00 00 00 
  8004210139:	ff d0                	callq  *%rax
	return dst;
  800421013b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800421013f:	c9                   	leaveq 
  8004210140:	c3                   	retq   

0000008004210141 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  8004210141:	55                   	push   %rbp
  8004210142:	48 89 e5             	mov    %rsp,%rbp
  8004210145:	48 83 ec 28          	sub    $0x28,%rsp
  8004210149:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421014d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210151:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  8004210155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210159:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800421015d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210164:	00 
  8004210165:	eb 27                	jmp    800421018e <strncpy+0x4d>
		*dst++ = *src;
  8004210167:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421016b:	0f b6 10             	movzbl (%rax),%edx
  800421016e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210172:	88 10                	mov    %dl,(%rax)
  8004210174:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  8004210179:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421017d:	0f b6 00             	movzbl (%rax),%eax
  8004210180:	84 c0                	test   %al,%al
  8004210182:	74 05                	je     8004210189 <strncpy+0x48>
			src++;
  8004210184:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  8004210189:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800421018e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210192:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004210196:	72 cf                	jb     8004210167 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  8004210198:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421019c:	c9                   	leaveq 
  800421019d:	c3                   	retq   

000000800421019e <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800421019e:	55                   	push   %rbp
  800421019f:	48 89 e5             	mov    %rsp,%rbp
  80042101a2:	48 83 ec 28          	sub    $0x28,%rsp
  80042101a6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042101aa:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042101ae:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  80042101b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101b6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  80042101ba:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042101bf:	74 37                	je     80042101f8 <strlcpy+0x5a>
		while (--size > 0 && *src != '\0')
  80042101c1:	eb 17                	jmp    80042101da <strlcpy+0x3c>
			*dst++ = *src++;
  80042101c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042101c7:	0f b6 10             	movzbl (%rax),%edx
  80042101ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101ce:	88 10                	mov    %dl,(%rax)
  80042101d0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042101d5:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80042101da:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  80042101df:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042101e4:	74 0b                	je     80042101f1 <strlcpy+0x53>
  80042101e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042101ea:	0f b6 00             	movzbl (%rax),%eax
  80042101ed:	84 c0                	test   %al,%al
  80042101ef:	75 d2                	jne    80042101c3 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  80042101f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101f5:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  80042101f8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042101fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210200:	48 89 d1             	mov    %rdx,%rcx
  8004210203:	48 29 c1             	sub    %rax,%rcx
  8004210206:	48 89 c8             	mov    %rcx,%rax
}
  8004210209:	c9                   	leaveq 
  800421020a:	c3                   	retq   

000000800421020b <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800421020b:	55                   	push   %rbp
  800421020c:	48 89 e5             	mov    %rsp,%rbp
  800421020f:	48 83 ec 10          	sub    $0x10,%rsp
  8004210213:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210217:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800421021b:	eb 0a                	jmp    8004210227 <strcmp+0x1c>
		p++, q++;
  800421021d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210222:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8004210227:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421022b:	0f b6 00             	movzbl (%rax),%eax
  800421022e:	84 c0                	test   %al,%al
  8004210230:	74 12                	je     8004210244 <strcmp+0x39>
  8004210232:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210236:	0f b6 10             	movzbl (%rax),%edx
  8004210239:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421023d:	0f b6 00             	movzbl (%rax),%eax
  8004210240:	38 c2                	cmp    %al,%dl
  8004210242:	74 d9                	je     800421021d <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  8004210244:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210248:	0f b6 00             	movzbl (%rax),%eax
  800421024b:	0f b6 d0             	movzbl %al,%edx
  800421024e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210252:	0f b6 00             	movzbl (%rax),%eax
  8004210255:	0f b6 c0             	movzbl %al,%eax
  8004210258:	89 d1                	mov    %edx,%ecx
  800421025a:	29 c1                	sub    %eax,%ecx
  800421025c:	89 c8                	mov    %ecx,%eax
}
  800421025e:	c9                   	leaveq 
  800421025f:	c3                   	retq   

0000008004210260 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8004210260:	55                   	push   %rbp
  8004210261:	48 89 e5             	mov    %rsp,%rbp
  8004210264:	48 83 ec 18          	sub    $0x18,%rsp
  8004210268:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421026c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004210270:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  8004210274:	eb 0f                	jmp    8004210285 <strncmp+0x25>
		n--, p++, q++;
  8004210276:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800421027b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210280:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8004210285:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421028a:	74 1d                	je     80042102a9 <strncmp+0x49>
  800421028c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210290:	0f b6 00             	movzbl (%rax),%eax
  8004210293:	84 c0                	test   %al,%al
  8004210295:	74 12                	je     80042102a9 <strncmp+0x49>
  8004210297:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421029b:	0f b6 10             	movzbl (%rax),%edx
  800421029e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102a2:	0f b6 00             	movzbl (%rax),%eax
  80042102a5:	38 c2                	cmp    %al,%dl
  80042102a7:	74 cd                	je     8004210276 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  80042102a9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042102ae:	75 07                	jne    80042102b7 <strncmp+0x57>
		return 0;
  80042102b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042102b5:	eb 1a                	jmp    80042102d1 <strncmp+0x71>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80042102b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102bb:	0f b6 00             	movzbl (%rax),%eax
  80042102be:	0f b6 d0             	movzbl %al,%edx
  80042102c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102c5:	0f b6 00             	movzbl (%rax),%eax
  80042102c8:	0f b6 c0             	movzbl %al,%eax
  80042102cb:	89 d1                	mov    %edx,%ecx
  80042102cd:	29 c1                	sub    %eax,%ecx
  80042102cf:	89 c8                	mov    %ecx,%eax
}
  80042102d1:	c9                   	leaveq 
  80042102d2:	c3                   	retq   

00000080042102d3 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80042102d3:	55                   	push   %rbp
  80042102d4:	48 89 e5             	mov    %rsp,%rbp
  80042102d7:	48 83 ec 10          	sub    $0x10,%rsp
  80042102db:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042102df:	89 f0                	mov    %esi,%eax
  80042102e1:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  80042102e4:	eb 17                	jmp    80042102fd <strchr+0x2a>
		if (*s == c)
  80042102e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102ea:	0f b6 00             	movzbl (%rax),%eax
  80042102ed:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80042102f0:	75 06                	jne    80042102f8 <strchr+0x25>
			return (char *) s;
  80042102f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102f6:	eb 15                	jmp    800421030d <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80042102f8:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042102fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210301:	0f b6 00             	movzbl (%rax),%eax
  8004210304:	84 c0                	test   %al,%al
  8004210306:	75 de                	jne    80042102e6 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  8004210308:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421030d:	c9                   	leaveq 
  800421030e:	c3                   	retq   

000000800421030f <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800421030f:	55                   	push   %rbp
  8004210310:	48 89 e5             	mov    %rsp,%rbp
  8004210313:	48 83 ec 10          	sub    $0x10,%rsp
  8004210317:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421031b:	89 f0                	mov    %esi,%eax
  800421031d:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004210320:	eb 11                	jmp    8004210333 <strfind+0x24>
		if (*s == c)
  8004210322:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210326:	0f b6 00             	movzbl (%rax),%eax
  8004210329:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800421032c:	74 12                	je     8004210340 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800421032e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210333:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210337:	0f b6 00             	movzbl (%rax),%eax
  800421033a:	84 c0                	test   %al,%al
  800421033c:	75 e4                	jne    8004210322 <strfind+0x13>
  800421033e:	eb 01                	jmp    8004210341 <strfind+0x32>
		if (*s == c)
			break;
  8004210340:	90                   	nop
	return (char *) s;
  8004210341:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210345:	c9                   	leaveq 
  8004210346:	c3                   	retq   

0000008004210347 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  8004210347:	55                   	push   %rbp
  8004210348:	48 89 e5             	mov    %rsp,%rbp
  800421034b:	48 83 ec 18          	sub    $0x18,%rsp
  800421034f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210353:	89 75 f4             	mov    %esi,-0xc(%rbp)
  8004210356:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800421035a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421035f:	75 06                	jne    8004210367 <memset+0x20>
		return v;
  8004210361:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210365:	eb 69                	jmp    80042103d0 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  8004210367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421036b:	83 e0 03             	and    $0x3,%eax
  800421036e:	48 85 c0             	test   %rax,%rax
  8004210371:	75 48                	jne    80042103bb <memset+0x74>
  8004210373:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210377:	83 e0 03             	and    $0x3,%eax
  800421037a:	48 85 c0             	test   %rax,%rax
  800421037d:	75 3c                	jne    80042103bb <memset+0x74>
		c &= 0xFF;
  800421037f:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8004210386:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210389:	89 c2                	mov    %eax,%edx
  800421038b:	c1 e2 18             	shl    $0x18,%edx
  800421038e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210391:	c1 e0 10             	shl    $0x10,%eax
  8004210394:	09 c2                	or     %eax,%edx
  8004210396:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210399:	c1 e0 08             	shl    $0x8,%eax
  800421039c:	09 d0                	or     %edx,%eax
  800421039e:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  80042103a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103a5:	48 89 c1             	mov    %rax,%rcx
  80042103a8:	48 c1 e9 02          	shr    $0x2,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80042103ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042103b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042103b3:	48 89 d7             	mov    %rdx,%rdi
  80042103b6:	fc                   	cld    
  80042103b7:	f3 ab                	rep stos %eax,%es:(%rdi)
  80042103b9:	eb 11                	jmp    80042103cc <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80042103bb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042103bf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042103c2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042103c6:	48 89 d7             	mov    %rdx,%rdi
  80042103c9:	fc                   	cld    
  80042103ca:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  80042103cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042103d0:	c9                   	leaveq 
  80042103d1:	c3                   	retq   

00000080042103d2 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80042103d2:	55                   	push   %rbp
  80042103d3:	48 89 e5             	mov    %rsp,%rbp
  80042103d6:	48 83 ec 28          	sub    $0x28,%rsp
  80042103da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042103de:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042103e2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  80042103e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042103ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  80042103ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042103f2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  80042103f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042103fa:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042103fe:	0f 83 88 00 00 00    	jae    800421048c <memmove+0xba>
  8004210404:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210408:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421040c:	48 01 d0             	add    %rdx,%rax
  800421040f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004210413:	76 77                	jbe    800421048c <memmove+0xba>
		s += n;
  8004210415:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210419:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800421041d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210421:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8004210425:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210429:	83 e0 03             	and    $0x3,%eax
  800421042c:	48 85 c0             	test   %rax,%rax
  800421042f:	75 3b                	jne    800421046c <memmove+0x9a>
  8004210431:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210435:	83 e0 03             	and    $0x3,%eax
  8004210438:	48 85 c0             	test   %rax,%rax
  800421043b:	75 2f                	jne    800421046c <memmove+0x9a>
  800421043d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210441:	83 e0 03             	and    $0x3,%eax
  8004210444:	48 85 c0             	test   %rax,%rax
  8004210447:	75 23                	jne    800421046c <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  8004210449:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421044d:	48 83 e8 04          	sub    $0x4,%rax
  8004210451:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210455:	48 83 ea 04          	sub    $0x4,%rdx
  8004210459:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421045d:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  8004210461:	48 89 c7             	mov    %rax,%rdi
  8004210464:	48 89 d6             	mov    %rdx,%rsi
  8004210467:	fd                   	std    
  8004210468:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800421046a:	eb 1d                	jmp    8004210489 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800421046c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210470:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004210474:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210478:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800421047c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210480:	48 89 d7             	mov    %rdx,%rdi
  8004210483:	48 89 c1             	mov    %rax,%rcx
  8004210486:	fd                   	std    
  8004210487:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  8004210489:	fc                   	cld    
  800421048a:	eb 57                	jmp    80042104e3 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800421048c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210490:	83 e0 03             	and    $0x3,%eax
  8004210493:	48 85 c0             	test   %rax,%rax
  8004210496:	75 36                	jne    80042104ce <memmove+0xfc>
  8004210498:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421049c:	83 e0 03             	and    $0x3,%eax
  800421049f:	48 85 c0             	test   %rax,%rax
  80042104a2:	75 2a                	jne    80042104ce <memmove+0xfc>
  80042104a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104a8:	83 e0 03             	and    $0x3,%eax
  80042104ab:	48 85 c0             	test   %rax,%rax
  80042104ae:	75 1e                	jne    80042104ce <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80042104b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042104b4:	48 89 c1             	mov    %rax,%rcx
  80042104b7:	48 c1 e9 02          	shr    $0x2,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80042104bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104bf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042104c3:	48 89 c7             	mov    %rax,%rdi
  80042104c6:	48 89 d6             	mov    %rdx,%rsi
  80042104c9:	fc                   	cld    
  80042104ca:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80042104cc:	eb 15                	jmp    80042104e3 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80042104ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104d2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042104d6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042104da:	48 89 c7             	mov    %rax,%rdi
  80042104dd:	48 89 d6             	mov    %rdx,%rsi
  80042104e0:	fc                   	cld    
  80042104e1:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  80042104e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042104e7:	c9                   	leaveq 
  80042104e8:	c3                   	retq   

00000080042104e9 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80042104e9:	55                   	push   %rbp
  80042104ea:	48 89 e5             	mov    %rsp,%rbp
  80042104ed:	48 83 ec 18          	sub    $0x18,%rsp
  80042104f1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042104f5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042104f9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  80042104fd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210501:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210505:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210509:	48 89 ce             	mov    %rcx,%rsi
  800421050c:	48 89 c7             	mov    %rax,%rdi
  800421050f:	48 b8 d2 03 21 04 80 	movabs $0x80042103d2,%rax
  8004210516:	00 00 00 
  8004210519:	ff d0                	callq  *%rax
}
  800421051b:	c9                   	leaveq 
  800421051c:	c3                   	retq   

000000800421051d <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800421051d:	55                   	push   %rbp
  800421051e:	48 89 e5             	mov    %rsp,%rbp
  8004210521:	48 83 ec 28          	sub    $0x28,%rsp
  8004210525:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210529:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421052d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  8004210531:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210535:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  8004210539:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421053d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  8004210541:	eb 38                	jmp    800421057b <memcmp+0x5e>
		if (*s1 != *s2)
  8004210543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210547:	0f b6 10             	movzbl (%rax),%edx
  800421054a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421054e:	0f b6 00             	movzbl (%rax),%eax
  8004210551:	38 c2                	cmp    %al,%dl
  8004210553:	74 1c                	je     8004210571 <memcmp+0x54>
			return (int) *s1 - (int) *s2;
  8004210555:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210559:	0f b6 00             	movzbl (%rax),%eax
  800421055c:	0f b6 d0             	movzbl %al,%edx
  800421055f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210563:	0f b6 00             	movzbl (%rax),%eax
  8004210566:	0f b6 c0             	movzbl %al,%eax
  8004210569:	89 d1                	mov    %edx,%ecx
  800421056b:	29 c1                	sub    %eax,%ecx
  800421056d:	89 c8                	mov    %ecx,%eax
  800421056f:	eb 20                	jmp    8004210591 <memcmp+0x74>
		s1++, s2++;
  8004210571:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210576:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800421057b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210580:	0f 95 c0             	setne  %al
  8004210583:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  8004210588:	84 c0                	test   %al,%al
  800421058a:	75 b7                	jne    8004210543 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800421058c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210591:	c9                   	leaveq 
  8004210592:	c3                   	retq   

0000008004210593 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8004210593:	55                   	push   %rbp
  8004210594:	48 89 e5             	mov    %rsp,%rbp
  8004210597:	48 83 ec 28          	sub    $0x28,%rsp
  800421059b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421059f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80042105a2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  80042105a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042105ae:	48 01 d0             	add    %rdx,%rax
  80042105b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  80042105b5:	eb 13                	jmp    80042105ca <memfind+0x37>
		if (*(const unsigned char *) s == (unsigned char) c)
  80042105b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105bb:	0f b6 10             	movzbl (%rax),%edx
  80042105be:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042105c1:	38 c2                	cmp    %al,%dl
  80042105c3:	74 11                	je     80042105d6 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80042105c5:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042105ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105ce:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042105d2:	72 e3                	jb     80042105b7 <memfind+0x24>
  80042105d4:	eb 01                	jmp    80042105d7 <memfind+0x44>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  80042105d6:	90                   	nop
	return (void *) s;
  80042105d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042105db:	c9                   	leaveq 
  80042105dc:	c3                   	retq   

00000080042105dd <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80042105dd:	55                   	push   %rbp
  80042105de:	48 89 e5             	mov    %rsp,%rbp
  80042105e1:	48 83 ec 38          	sub    $0x38,%rsp
  80042105e5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042105e9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042105ed:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  80042105f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  80042105f7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042105fe:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80042105ff:	eb 05                	jmp    8004210606 <strtol+0x29>
		s++;
  8004210601:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004210606:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421060a:	0f b6 00             	movzbl (%rax),%eax
  800421060d:	3c 20                	cmp    $0x20,%al
  800421060f:	74 f0                	je     8004210601 <strtol+0x24>
  8004210611:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210615:	0f b6 00             	movzbl (%rax),%eax
  8004210618:	3c 09                	cmp    $0x9,%al
  800421061a:	74 e5                	je     8004210601 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800421061c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210620:	0f b6 00             	movzbl (%rax),%eax
  8004210623:	3c 2b                	cmp    $0x2b,%al
  8004210625:	75 07                	jne    800421062e <strtol+0x51>
		s++;
  8004210627:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800421062c:	eb 17                	jmp    8004210645 <strtol+0x68>
	else if (*s == '-')
  800421062e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210632:	0f b6 00             	movzbl (%rax),%eax
  8004210635:	3c 2d                	cmp    $0x2d,%al
  8004210637:	75 0c                	jne    8004210645 <strtol+0x68>
		s++, neg = 1;
  8004210639:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800421063e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  8004210645:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004210649:	74 06                	je     8004210651 <strtol+0x74>
  800421064b:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800421064f:	75 28                	jne    8004210679 <strtol+0x9c>
  8004210651:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210655:	0f b6 00             	movzbl (%rax),%eax
  8004210658:	3c 30                	cmp    $0x30,%al
  800421065a:	75 1d                	jne    8004210679 <strtol+0x9c>
  800421065c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210660:	48 83 c0 01          	add    $0x1,%rax
  8004210664:	0f b6 00             	movzbl (%rax),%eax
  8004210667:	3c 78                	cmp    $0x78,%al
  8004210669:	75 0e                	jne    8004210679 <strtol+0x9c>
		s += 2, base = 16;
  800421066b:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  8004210670:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  8004210677:	eb 2c                	jmp    80042106a5 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  8004210679:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800421067d:	75 19                	jne    8004210698 <strtol+0xbb>
  800421067f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210683:	0f b6 00             	movzbl (%rax),%eax
  8004210686:	3c 30                	cmp    $0x30,%al
  8004210688:	75 0e                	jne    8004210698 <strtol+0xbb>
		s++, base = 8;
  800421068a:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800421068f:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8004210696:	eb 0d                	jmp    80042106a5 <strtol+0xc8>
	else if (base == 0)
  8004210698:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800421069c:	75 07                	jne    80042106a5 <strtol+0xc8>
		base = 10;
  800421069e:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80042106a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106a9:	0f b6 00             	movzbl (%rax),%eax
  80042106ac:	3c 2f                	cmp    $0x2f,%al
  80042106ae:	7e 1d                	jle    80042106cd <strtol+0xf0>
  80042106b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106b4:	0f b6 00             	movzbl (%rax),%eax
  80042106b7:	3c 39                	cmp    $0x39,%al
  80042106b9:	7f 12                	jg     80042106cd <strtol+0xf0>
			dig = *s - '0';
  80042106bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106bf:	0f b6 00             	movzbl (%rax),%eax
  80042106c2:	0f be c0             	movsbl %al,%eax
  80042106c5:	83 e8 30             	sub    $0x30,%eax
  80042106c8:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042106cb:	eb 4e                	jmp    800421071b <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  80042106cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106d1:	0f b6 00             	movzbl (%rax),%eax
  80042106d4:	3c 60                	cmp    $0x60,%al
  80042106d6:	7e 1d                	jle    80042106f5 <strtol+0x118>
  80042106d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106dc:	0f b6 00             	movzbl (%rax),%eax
  80042106df:	3c 7a                	cmp    $0x7a,%al
  80042106e1:	7f 12                	jg     80042106f5 <strtol+0x118>
			dig = *s - 'a' + 10;
  80042106e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106e7:	0f b6 00             	movzbl (%rax),%eax
  80042106ea:	0f be c0             	movsbl %al,%eax
  80042106ed:	83 e8 57             	sub    $0x57,%eax
  80042106f0:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042106f3:	eb 26                	jmp    800421071b <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  80042106f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106f9:	0f b6 00             	movzbl (%rax),%eax
  80042106fc:	3c 40                	cmp    $0x40,%al
  80042106fe:	7e 47                	jle    8004210747 <strtol+0x16a>
  8004210700:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210704:	0f b6 00             	movzbl (%rax),%eax
  8004210707:	3c 5a                	cmp    $0x5a,%al
  8004210709:	7f 3c                	jg     8004210747 <strtol+0x16a>
			dig = *s - 'A' + 10;
  800421070b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421070f:	0f b6 00             	movzbl (%rax),%eax
  8004210712:	0f be c0             	movsbl %al,%eax
  8004210715:	83 e8 37             	sub    $0x37,%eax
  8004210718:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800421071b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421071e:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  8004210721:	7d 23                	jge    8004210746 <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  8004210723:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004210728:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421072b:	48 98                	cltq   
  800421072d:	48 89 c2             	mov    %rax,%rdx
  8004210730:	48 0f af 55 f0       	imul   -0x10(%rbp),%rdx
  8004210735:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210738:	48 98                	cltq   
  800421073a:	48 01 d0             	add    %rdx,%rax
  800421073d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  8004210741:	e9 5f ff ff ff       	jmpq   80042106a5 <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  8004210746:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  8004210747:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421074c:	74 0b                	je     8004210759 <strtol+0x17c>
		*endptr = (char *) s;
  800421074e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210752:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210756:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  8004210759:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421075d:	74 09                	je     8004210768 <strtol+0x18b>
  800421075f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210763:	48 f7 d8             	neg    %rax
  8004210766:	eb 04                	jmp    800421076c <strtol+0x18f>
  8004210768:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421076c:	c9                   	leaveq 
  800421076d:	c3                   	retq   

000000800421076e <strstr>:

char * strstr(const char *in, const char *str)
{
  800421076e:	55                   	push   %rbp
  800421076f:	48 89 e5             	mov    %rsp,%rbp
  8004210772:	48 83 ec 30          	sub    $0x30,%rsp
  8004210776:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421077a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800421077e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210782:	0f b6 00             	movzbl (%rax),%eax
  8004210785:	88 45 ff             	mov    %al,-0x1(%rbp)
  8004210788:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
	if (!c)
  800421078d:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8004210791:	75 06                	jne    8004210799 <strstr+0x2b>
		return (char *) in;	// Trivial empty string case
  8004210793:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210797:	eb 68                	jmp    8004210801 <strstr+0x93>

	len = strlen(str);
  8004210799:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421079d:	48 89 c7             	mov    %rax,%rdi
  80042107a0:	48 b8 44 00 21 04 80 	movabs $0x8004210044,%rax
  80042107a7:	00 00 00 
  80042107aa:	ff d0                	callq  *%rax
  80042107ac:	48 98                	cltq   
  80042107ae:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  80042107b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107b6:	0f b6 00             	movzbl (%rax),%eax
  80042107b9:	88 45 ef             	mov    %al,-0x11(%rbp)
  80042107bc:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
			if (!sc)
  80042107c1:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80042107c5:	75 07                	jne    80042107ce <strstr+0x60>
				return (char *) 0;
  80042107c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107cc:	eb 33                	jmp    8004210801 <strstr+0x93>
		} while (sc != c);
  80042107ce:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042107d2:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80042107d5:	75 db                	jne    80042107b2 <strstr+0x44>
	} while (strncmp(in, str, len) != 0);
  80042107d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042107db:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042107df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107e3:	48 89 ce             	mov    %rcx,%rsi
  80042107e6:	48 89 c7             	mov    %rax,%rdi
  80042107e9:	48 b8 60 02 21 04 80 	movabs $0x8004210260,%rax
  80042107f0:	00 00 00 
  80042107f3:	ff d0                	callq  *%rax
  80042107f5:	85 c0                	test   %eax,%eax
  80042107f7:	75 b9                	jne    80042107b2 <strstr+0x44>

	return (char *) (in - 1);
  80042107f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107fd:	48 83 e8 01          	sub    $0x1,%rax
}
  8004210801:	c9                   	leaveq 
  8004210802:	c3                   	retq   
	...

0000008004210804 <_dwarf_read_lsb>:

int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210804:	55                   	push   %rbp
  8004210805:	48 89 e5             	mov    %rsp,%rbp
  8004210808:	48 83 ec 28          	sub    $0x28,%rsp
  800421080c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210810:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210814:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004210817:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421081b:	48 8b 00             	mov    (%rax),%rax
  800421081e:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004210822:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210826:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421082d:	00 
	switch (bytes_to_read) {
  800421082e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210831:	83 f8 02             	cmp    $0x2,%eax
  8004210834:	0f 84 ab 00 00 00    	je     80042108e5 <_dwarf_read_lsb+0xe1>
  800421083a:	83 f8 02             	cmp    $0x2,%eax
  800421083d:	7f 0e                	jg     800421084d <_dwarf_read_lsb+0x49>
  800421083f:	83 f8 01             	cmp    $0x1,%eax
  8004210842:	0f 84 b3 00 00 00    	je     80042108fb <_dwarf_read_lsb+0xf7>
  8004210848:	e9 d9 00 00 00       	jmpq   8004210926 <_dwarf_read_lsb+0x122>
  800421084d:	83 f8 04             	cmp    $0x4,%eax
  8004210850:	74 65                	je     80042108b7 <_dwarf_read_lsb+0xb3>
  8004210852:	83 f8 08             	cmp    $0x8,%eax
  8004210855:	0f 85 cb 00 00 00    	jne    8004210926 <_dwarf_read_lsb+0x122>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800421085b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421085f:	48 83 c0 04          	add    $0x4,%rax
  8004210863:	0f b6 00             	movzbl (%rax),%eax
  8004210866:	0f b6 c0             	movzbl %al,%eax
  8004210869:	48 89 c2             	mov    %rax,%rdx
  800421086c:	48 c1 e2 20          	shl    $0x20,%rdx
  8004210870:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210874:	48 83 c0 05          	add    $0x5,%rax
  8004210878:	0f b6 00             	movzbl (%rax),%eax
  800421087b:	0f b6 c0             	movzbl %al,%eax
  800421087e:	48 c1 e0 28          	shl    $0x28,%rax
  8004210882:	48 09 d0             	or     %rdx,%rax
  8004210885:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  8004210889:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421088d:	48 83 c0 06          	add    $0x6,%rax
  8004210891:	0f b6 00             	movzbl (%rax),%eax
  8004210894:	0f b6 c0             	movzbl %al,%eax
  8004210897:	48 89 c2             	mov    %rax,%rdx
  800421089a:	48 c1 e2 30          	shl    $0x30,%rdx
  800421089e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042108a2:	48 83 c0 07          	add    $0x7,%rax
  80042108a6:	0f b6 00             	movzbl (%rax),%eax
  80042108a9:	0f b6 c0             	movzbl %al,%eax
  80042108ac:	48 c1 e0 38          	shl    $0x38,%rax
  80042108b0:	48 09 d0             	or     %rdx,%rax
  80042108b3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  80042108b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042108bb:	48 83 c0 02          	add    $0x2,%rax
  80042108bf:	0f b6 00             	movzbl (%rax),%eax
  80042108c2:	0f b6 c0             	movzbl %al,%eax
  80042108c5:	48 89 c2             	mov    %rax,%rdx
  80042108c8:	48 c1 e2 10          	shl    $0x10,%rdx
  80042108cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042108d0:	48 83 c0 03          	add    $0x3,%rax
  80042108d4:	0f b6 00             	movzbl (%rax),%eax
  80042108d7:	0f b6 c0             	movzbl %al,%eax
  80042108da:	48 c1 e0 18          	shl    $0x18,%rax
  80042108de:	48 09 d0             	or     %rdx,%rax
  80042108e1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  80042108e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042108e9:	48 83 c0 01          	add    $0x1,%rax
  80042108ed:	0f b6 00             	movzbl (%rax),%eax
  80042108f0:	0f b6 c0             	movzbl %al,%eax
  80042108f3:	48 c1 e0 08          	shl    $0x8,%rax
  80042108f7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  80042108fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042108ff:	0f b6 00             	movzbl (%rax),%eax
  8004210902:	0f b6 c0             	movzbl %al,%eax
  8004210905:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210909:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800421090a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421090e:	48 8b 10             	mov    (%rax),%rdx
  8004210911:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210914:	48 98                	cltq   
  8004210916:	48 01 c2             	add    %rax,%rdx
  8004210919:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421091d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210920:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210924:	eb 05                	jmp    800421092b <_dwarf_read_lsb+0x127>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004210926:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800421092b:	c9                   	leaveq 
  800421092c:	c3                   	retq   

000000800421092d <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800421092d:	55                   	push   %rbp
  800421092e:	48 89 e5             	mov    %rsp,%rbp
  8004210931:	48 83 ec 20          	sub    $0x20,%rsp
  8004210935:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210939:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800421093c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210940:	48 8b 00             	mov    (%rax),%rax
  8004210943:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210947:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421094e:	00 
	switch (bytes_to_read) {
  800421094f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210952:	83 f8 02             	cmp    $0x2,%eax
  8004210955:	0f 84 ab 00 00 00    	je     8004210a06 <_dwarf_decode_lsb+0xd9>
  800421095b:	83 f8 02             	cmp    $0x2,%eax
  800421095e:	7f 0e                	jg     800421096e <_dwarf_decode_lsb+0x41>
  8004210960:	83 f8 01             	cmp    $0x1,%eax
  8004210963:	0f 84 b3 00 00 00    	je     8004210a1c <_dwarf_decode_lsb+0xef>
  8004210969:	e9 d9 00 00 00       	jmpq   8004210a47 <_dwarf_decode_lsb+0x11a>
  800421096e:	83 f8 04             	cmp    $0x4,%eax
  8004210971:	74 65                	je     80042109d8 <_dwarf_decode_lsb+0xab>
  8004210973:	83 f8 08             	cmp    $0x8,%eax
  8004210976:	0f 85 cb 00 00 00    	jne    8004210a47 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800421097c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210980:	48 83 c0 04          	add    $0x4,%rax
  8004210984:	0f b6 00             	movzbl (%rax),%eax
  8004210987:	0f b6 c0             	movzbl %al,%eax
  800421098a:	48 89 c2             	mov    %rax,%rdx
  800421098d:	48 c1 e2 20          	shl    $0x20,%rdx
  8004210991:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210995:	48 83 c0 05          	add    $0x5,%rax
  8004210999:	0f b6 00             	movzbl (%rax),%eax
  800421099c:	0f b6 c0             	movzbl %al,%eax
  800421099f:	48 c1 e0 28          	shl    $0x28,%rax
  80042109a3:	48 09 d0             	or     %rdx,%rax
  80042109a6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042109aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042109ae:	48 83 c0 06          	add    $0x6,%rax
  80042109b2:	0f b6 00             	movzbl (%rax),%eax
  80042109b5:	0f b6 c0             	movzbl %al,%eax
  80042109b8:	48 89 c2             	mov    %rax,%rdx
  80042109bb:	48 c1 e2 30          	shl    $0x30,%rdx
  80042109bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042109c3:	48 83 c0 07          	add    $0x7,%rax
  80042109c7:	0f b6 00             	movzbl (%rax),%eax
  80042109ca:	0f b6 c0             	movzbl %al,%eax
  80042109cd:	48 c1 e0 38          	shl    $0x38,%rax
  80042109d1:	48 09 d0             	or     %rdx,%rax
  80042109d4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  80042109d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042109dc:	48 83 c0 02          	add    $0x2,%rax
  80042109e0:	0f b6 00             	movzbl (%rax),%eax
  80042109e3:	0f b6 c0             	movzbl %al,%eax
  80042109e6:	48 89 c2             	mov    %rax,%rdx
  80042109e9:	48 c1 e2 10          	shl    $0x10,%rdx
  80042109ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042109f1:	48 83 c0 03          	add    $0x3,%rax
  80042109f5:	0f b6 00             	movzbl (%rax),%eax
  80042109f8:	0f b6 c0             	movzbl %al,%eax
  80042109fb:	48 c1 e0 18          	shl    $0x18,%rax
  80042109ff:	48 09 d0             	or     %rdx,%rax
  8004210a02:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210a06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a0a:	48 83 c0 01          	add    $0x1,%rax
  8004210a0e:	0f b6 00             	movzbl (%rax),%eax
  8004210a11:	0f b6 c0             	movzbl %al,%eax
  8004210a14:	48 c1 e0 08          	shl    $0x8,%rax
  8004210a18:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004210a1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a20:	0f b6 00             	movzbl (%rax),%eax
  8004210a23:	0f b6 c0             	movzbl %al,%eax
  8004210a26:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210a2a:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  8004210a2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a2f:	48 8b 10             	mov    (%rax),%rdx
  8004210a32:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210a35:	48 98                	cltq   
  8004210a37:	48 01 c2             	add    %rax,%rdx
  8004210a3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a3e:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210a41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a45:	eb 05                	jmp    8004210a4c <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004210a47:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  8004210a4c:	c9                   	leaveq 
  8004210a4d:	c3                   	retq   

0000008004210a4e <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004210a4e:	55                   	push   %rbp
  8004210a4f:	48 89 e5             	mov    %rsp,%rbp
  8004210a52:	48 83 ec 28          	sub    $0x28,%rsp
  8004210a56:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210a5a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210a5e:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  8004210a61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a65:	48 8b 00             	mov    (%rax),%rax
  8004210a68:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004210a6c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  8004210a70:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210a73:	83 f8 02             	cmp    $0x2,%eax
  8004210a76:	74 35                	je     8004210aad <_dwarf_read_msb+0x5f>
  8004210a78:	83 f8 02             	cmp    $0x2,%eax
  8004210a7b:	7f 0a                	jg     8004210a87 <_dwarf_read_msb+0x39>
  8004210a7d:	83 f8 01             	cmp    $0x1,%eax
  8004210a80:	74 18                	je     8004210a9a <_dwarf_read_msb+0x4c>
  8004210a82:	e9 53 01 00 00       	jmpq   8004210bda <_dwarf_read_msb+0x18c>
  8004210a87:	83 f8 04             	cmp    $0x4,%eax
  8004210a8a:	74 49                	je     8004210ad5 <_dwarf_read_msb+0x87>
  8004210a8c:	83 f8 08             	cmp    $0x8,%eax
  8004210a8f:	0f 84 96 00 00 00    	je     8004210b2b <_dwarf_read_msb+0xdd>
  8004210a95:	e9 40 01 00 00       	jmpq   8004210bda <_dwarf_read_msb+0x18c>
	case 1:
		ret = src[0];
  8004210a9a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a9e:	0f b6 00             	movzbl (%rax),%eax
  8004210aa1:	0f b6 c0             	movzbl %al,%eax
  8004210aa4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210aa8:	e9 34 01 00 00       	jmpq   8004210be1 <_dwarf_read_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210aad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ab1:	48 83 c0 01          	add    $0x1,%rax
  8004210ab5:	0f b6 00             	movzbl (%rax),%eax
  8004210ab8:	0f b6 d0             	movzbl %al,%edx
  8004210abb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210abf:	0f b6 00             	movzbl (%rax),%eax
  8004210ac2:	0f b6 c0             	movzbl %al,%eax
  8004210ac5:	48 c1 e0 08          	shl    $0x8,%rax
  8004210ac9:	48 09 d0             	or     %rdx,%rax
  8004210acc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210ad0:	e9 0c 01 00 00       	jmpq   8004210be1 <_dwarf_read_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004210ad5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ad9:	48 83 c0 03          	add    $0x3,%rax
  8004210add:	0f b6 00             	movzbl (%rax),%eax
  8004210ae0:	0f b6 c0             	movzbl %al,%eax
  8004210ae3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210ae7:	48 83 c2 02          	add    $0x2,%rdx
  8004210aeb:	0f b6 12             	movzbl (%rdx),%edx
  8004210aee:	0f b6 d2             	movzbl %dl,%edx
  8004210af1:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210af5:	48 09 d0             	or     %rdx,%rax
  8004210af8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210afc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b00:	48 83 c0 01          	add    $0x1,%rax
  8004210b04:	0f b6 00             	movzbl (%rax),%eax
  8004210b07:	0f b6 c0             	movzbl %al,%eax
  8004210b0a:	48 89 c2             	mov    %rax,%rdx
  8004210b0d:	48 c1 e2 10          	shl    $0x10,%rdx
  8004210b11:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b15:	0f b6 00             	movzbl (%rax),%eax
  8004210b18:	0f b6 c0             	movzbl %al,%eax
  8004210b1b:	48 c1 e0 18          	shl    $0x18,%rax
  8004210b1f:	48 09 d0             	or     %rdx,%rax
  8004210b22:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210b26:	e9 b6 00 00 00       	jmpq   8004210be1 <_dwarf_read_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210b2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b2f:	48 83 c0 07          	add    $0x7,%rax
  8004210b33:	0f b6 00             	movzbl (%rax),%eax
  8004210b36:	0f b6 c0             	movzbl %al,%eax
  8004210b39:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210b3d:	48 83 c2 06          	add    $0x6,%rdx
  8004210b41:	0f b6 12             	movzbl (%rdx),%edx
  8004210b44:	0f b6 d2             	movzbl %dl,%edx
  8004210b47:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210b4b:	48 09 d0             	or     %rdx,%rax
  8004210b4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210b52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b56:	48 83 c0 05          	add    $0x5,%rax
  8004210b5a:	0f b6 00             	movzbl (%rax),%eax
  8004210b5d:	0f b6 c0             	movzbl %al,%eax
  8004210b60:	48 89 c2             	mov    %rax,%rdx
  8004210b63:	48 c1 e2 10          	shl    $0x10,%rdx
  8004210b67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b6b:	48 83 c0 04          	add    $0x4,%rax
  8004210b6f:	0f b6 00             	movzbl (%rax),%eax
  8004210b72:	0f b6 c0             	movzbl %al,%eax
  8004210b75:	48 c1 e0 18          	shl    $0x18,%rax
  8004210b79:	48 09 d0             	or     %rdx,%rax
  8004210b7c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210b80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b84:	48 83 c0 03          	add    $0x3,%rax
  8004210b88:	0f b6 00             	movzbl (%rax),%eax
  8004210b8b:	0f b6 c0             	movzbl %al,%eax
  8004210b8e:	48 89 c2             	mov    %rax,%rdx
  8004210b91:	48 c1 e2 20          	shl    $0x20,%rdx
  8004210b95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b99:	48 83 c0 02          	add    $0x2,%rax
  8004210b9d:	0f b6 00             	movzbl (%rax),%eax
  8004210ba0:	0f b6 c0             	movzbl %al,%eax
  8004210ba3:	48 c1 e0 28          	shl    $0x28,%rax
  8004210ba7:	48 09 d0             	or     %rdx,%rax
  8004210baa:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210bae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bb2:	48 83 c0 01          	add    $0x1,%rax
  8004210bb6:	0f b6 00             	movzbl (%rax),%eax
  8004210bb9:	0f b6 c0             	movzbl %al,%eax
  8004210bbc:	48 89 c2             	mov    %rax,%rdx
  8004210bbf:	48 c1 e2 30          	shl    $0x30,%rdx
  8004210bc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210bc7:	0f b6 00             	movzbl (%rax),%eax
  8004210bca:	0f b6 c0             	movzbl %al,%eax
  8004210bcd:	48 c1 e0 38          	shl    $0x38,%rax
  8004210bd1:	48 09 d0             	or     %rdx,%rax
  8004210bd4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210bd8:	eb 07                	jmp    8004210be1 <_dwarf_read_msb+0x193>
	default:
		return (0);
  8004210bda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bdf:	eb 1a                	jmp    8004210bfb <_dwarf_read_msb+0x1ad>
	}

	*offsetp += bytes_to_read;
  8004210be1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210be5:	48 8b 10             	mov    (%rax),%rdx
  8004210be8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210beb:	48 98                	cltq   
  8004210bed:	48 01 c2             	add    %rax,%rdx
  8004210bf0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210bf4:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210bf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210bfb:	c9                   	leaveq 
  8004210bfc:	c3                   	retq   

0000008004210bfd <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  8004210bfd:	55                   	push   %rbp
  8004210bfe:	48 89 e5             	mov    %rsp,%rbp
  8004210c01:	48 83 ec 20          	sub    $0x20,%rsp
  8004210c05:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210c09:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210c0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210c10:	48 8b 00             	mov    (%rax),%rax
  8004210c13:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210c17:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210c1e:	00 
	switch (bytes_to_read) {
  8004210c1f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210c22:	83 f8 02             	cmp    $0x2,%eax
  8004210c25:	74 35                	je     8004210c5c <_dwarf_decode_msb+0x5f>
  8004210c27:	83 f8 02             	cmp    $0x2,%eax
  8004210c2a:	7f 0a                	jg     8004210c36 <_dwarf_decode_msb+0x39>
  8004210c2c:	83 f8 01             	cmp    $0x1,%eax
  8004210c2f:	74 18                	je     8004210c49 <_dwarf_decode_msb+0x4c>
  8004210c31:	e9 53 01 00 00       	jmpq   8004210d89 <_dwarf_decode_msb+0x18c>
  8004210c36:	83 f8 04             	cmp    $0x4,%eax
  8004210c39:	74 49                	je     8004210c84 <_dwarf_decode_msb+0x87>
  8004210c3b:	83 f8 08             	cmp    $0x8,%eax
  8004210c3e:	0f 84 96 00 00 00    	je     8004210cda <_dwarf_decode_msb+0xdd>
  8004210c44:	e9 40 01 00 00       	jmpq   8004210d89 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004210c49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c4d:	0f b6 00             	movzbl (%rax),%eax
  8004210c50:	0f b6 c0             	movzbl %al,%eax
  8004210c53:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210c57:	e9 34 01 00 00       	jmpq   8004210d90 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  8004210c5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c60:	48 83 c0 01          	add    $0x1,%rax
  8004210c64:	0f b6 00             	movzbl (%rax),%eax
  8004210c67:	0f b6 d0             	movzbl %al,%edx
  8004210c6a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c6e:	0f b6 00             	movzbl (%rax),%eax
  8004210c71:	0f b6 c0             	movzbl %al,%eax
  8004210c74:	48 c1 e0 08          	shl    $0x8,%rax
  8004210c78:	48 09 d0             	or     %rdx,%rax
  8004210c7b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210c7f:	e9 0c 01 00 00       	jmpq   8004210d90 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004210c84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c88:	48 83 c0 03          	add    $0x3,%rax
  8004210c8c:	0f b6 00             	movzbl (%rax),%eax
  8004210c8f:	0f b6 c0             	movzbl %al,%eax
  8004210c92:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210c96:	48 83 c2 02          	add    $0x2,%rdx
  8004210c9a:	0f b6 12             	movzbl (%rdx),%edx
  8004210c9d:	0f b6 d2             	movzbl %dl,%edx
  8004210ca0:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210ca4:	48 09 d0             	or     %rdx,%rax
  8004210ca7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  8004210cab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210caf:	48 83 c0 01          	add    $0x1,%rax
  8004210cb3:	0f b6 00             	movzbl (%rax),%eax
  8004210cb6:	0f b6 c0             	movzbl %al,%eax
  8004210cb9:	48 89 c2             	mov    %rax,%rdx
  8004210cbc:	48 c1 e2 10          	shl    $0x10,%rdx
  8004210cc0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210cc4:	0f b6 00             	movzbl (%rax),%eax
  8004210cc7:	0f b6 c0             	movzbl %al,%eax
  8004210cca:	48 c1 e0 18          	shl    $0x18,%rax
  8004210cce:	48 09 d0             	or     %rdx,%rax
  8004210cd1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210cd5:	e9 b6 00 00 00       	jmpq   8004210d90 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210cda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210cde:	48 83 c0 07          	add    $0x7,%rax
  8004210ce2:	0f b6 00             	movzbl (%rax),%eax
  8004210ce5:	0f b6 c0             	movzbl %al,%eax
  8004210ce8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210cec:	48 83 c2 06          	add    $0x6,%rdx
  8004210cf0:	0f b6 12             	movzbl (%rdx),%edx
  8004210cf3:	0f b6 d2             	movzbl %dl,%edx
  8004210cf6:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210cfa:	48 09 d0             	or     %rdx,%rax
  8004210cfd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210d01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d05:	48 83 c0 05          	add    $0x5,%rax
  8004210d09:	0f b6 00             	movzbl (%rax),%eax
  8004210d0c:	0f b6 c0             	movzbl %al,%eax
  8004210d0f:	48 89 c2             	mov    %rax,%rdx
  8004210d12:	48 c1 e2 10          	shl    $0x10,%rdx
  8004210d16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d1a:	48 83 c0 04          	add    $0x4,%rax
  8004210d1e:	0f b6 00             	movzbl (%rax),%eax
  8004210d21:	0f b6 c0             	movzbl %al,%eax
  8004210d24:	48 c1 e0 18          	shl    $0x18,%rax
  8004210d28:	48 09 d0             	or     %rdx,%rax
  8004210d2b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  8004210d2f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d33:	48 83 c0 03          	add    $0x3,%rax
  8004210d37:	0f b6 00             	movzbl (%rax),%eax
  8004210d3a:	0f b6 c0             	movzbl %al,%eax
  8004210d3d:	48 89 c2             	mov    %rax,%rdx
  8004210d40:	48 c1 e2 20          	shl    $0x20,%rdx
  8004210d44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d48:	48 83 c0 02          	add    $0x2,%rax
  8004210d4c:	0f b6 00             	movzbl (%rax),%eax
  8004210d4f:	0f b6 c0             	movzbl %al,%eax
  8004210d52:	48 c1 e0 28          	shl    $0x28,%rax
  8004210d56:	48 09 d0             	or     %rdx,%rax
  8004210d59:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  8004210d5d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d61:	48 83 c0 01          	add    $0x1,%rax
  8004210d65:	0f b6 00             	movzbl (%rax),%eax
  8004210d68:	0f b6 c0             	movzbl %al,%eax
  8004210d6b:	48 89 c2             	mov    %rax,%rdx
  8004210d6e:	48 c1 e2 30          	shl    $0x30,%rdx
  8004210d72:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d76:	0f b6 00             	movzbl (%rax),%eax
  8004210d79:	0f b6 c0             	movzbl %al,%eax
  8004210d7c:	48 c1 e0 38          	shl    $0x38,%rax
  8004210d80:	48 09 d0             	or     %rdx,%rax
  8004210d83:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210d87:	eb 07                	jmp    8004210d90 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  8004210d89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210d8e:	eb 1a                	jmp    8004210daa <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  8004210d90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d94:	48 8b 10             	mov    (%rax),%rdx
  8004210d97:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210d9a:	48 98                	cltq   
  8004210d9c:	48 01 c2             	add    %rax,%rdx
  8004210d9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210da3:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210da6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210daa:	c9                   	leaveq 
  8004210dab:	c3                   	retq   

0000008004210dac <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210dac:	55                   	push   %rbp
  8004210dad:	48 89 e5             	mov    %rsp,%rbp
  8004210db0:	53                   	push   %rbx
  8004210db1:	48 83 ec 30          	sub    $0x30,%rsp
  8004210db5:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  8004210db9:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	int64_t ret = 0;
  8004210dbd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004210dc4:	00 
	uint8_t b;
	int shift = 0;
  8004210dc5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210dcc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210dd0:	48 8b 00             	mov    (%rax),%rax
  8004210dd3:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004210dd7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  8004210ddb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ddf:	0f b6 00             	movzbl (%rax),%eax
  8004210de2:	88 45 df             	mov    %al,-0x21(%rbp)
  8004210de5:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210dea:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210dee:	89 c2                	mov    %eax,%edx
  8004210df0:	83 e2 7f             	and    $0x7f,%edx
  8004210df3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210df6:	89 d3                	mov    %edx,%ebx
  8004210df8:	89 c1                	mov    %eax,%ecx
  8004210dfa:	d3 e3                	shl    %cl,%ebx
  8004210dfc:	89 d8                	mov    %ebx,%eax
  8004210dfe:	48 98                	cltq   
  8004210e00:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		(*offsetp)++;
  8004210e04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210e08:	48 8b 00             	mov    (%rax),%rax
  8004210e0b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210e0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210e13:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210e16:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  8004210e1a:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210e1e:	84 c0                	test   %al,%al
  8004210e20:	78 b9                	js     8004210ddb <_dwarf_read_sleb128+0x2f>

	if (shift < 32 && (b & 0x40) != 0)
  8004210e22:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8004210e26:	7f 21                	jg     8004210e49 <_dwarf_read_sleb128+0x9d>
  8004210e28:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210e2c:	83 e0 40             	and    $0x40,%eax
  8004210e2f:	85 c0                	test   %eax,%eax
  8004210e31:	74 16                	je     8004210e49 <_dwarf_read_sleb128+0x9d>
		ret |= (-1 << shift);
  8004210e33:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210e36:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210e3b:	89 d3                	mov    %edx,%ebx
  8004210e3d:	89 c1                	mov    %eax,%ecx
  8004210e3f:	d3 e3                	shl    %cl,%ebx
  8004210e41:	89 d8                	mov    %ebx,%eax
  8004210e43:	48 98                	cltq   
  8004210e45:	48 09 45 f0          	or     %rax,-0x10(%rbp)

	return (ret);
  8004210e49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210e4d:	48 83 c4 30          	add    $0x30,%rsp
  8004210e51:	5b                   	pop    %rbx
  8004210e52:	5d                   	pop    %rbp
  8004210e53:	c3                   	retq   

0000008004210e54 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  8004210e54:	55                   	push   %rbp
  8004210e55:	48 89 e5             	mov    %rsp,%rbp
  8004210e58:	53                   	push   %rbx
  8004210e59:	48 83 ec 30          	sub    $0x30,%rsp
  8004210e5d:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  8004210e61:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	uint64_t ret = 0;
  8004210e65:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004210e6c:	00 
	uint8_t b;
	int shift = 0;
  8004210e6d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004210e74:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210e78:	48 8b 00             	mov    (%rax),%rax
  8004210e7b:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004210e7f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  8004210e83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210e87:	0f b6 00             	movzbl (%rax),%eax
  8004210e8a:	88 45 df             	mov    %al,-0x21(%rbp)
  8004210e8d:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210e92:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210e96:	89 c2                	mov    %eax,%edx
  8004210e98:	83 e2 7f             	and    $0x7f,%edx
  8004210e9b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210e9e:	89 d3                	mov    %edx,%ebx
  8004210ea0:	89 c1                	mov    %eax,%ecx
  8004210ea2:	d3 e3                	shl    %cl,%ebx
  8004210ea4:	89 d8                	mov    %ebx,%eax
  8004210ea6:	48 98                	cltq   
  8004210ea8:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		(*offsetp)++;
  8004210eac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210eb0:	48 8b 00             	mov    (%rax),%rax
  8004210eb3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210eb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210ebb:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210ebe:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  8004210ec2:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210ec6:	84 c0                	test   %al,%al
  8004210ec8:	78 b9                	js     8004210e83 <_dwarf_read_uleb128+0x2f>

	return (ret);
  8004210eca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210ece:	48 83 c4 30          	add    $0x30,%rsp
  8004210ed2:	5b                   	pop    %rbx
  8004210ed3:	5d                   	pop    %rbp
  8004210ed4:	c3                   	retq   

0000008004210ed5 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  8004210ed5:	55                   	push   %rbp
  8004210ed6:	48 89 e5             	mov    %rsp,%rbp
  8004210ed9:	53                   	push   %rbx
  8004210eda:	48 83 ec 28          	sub    $0x28,%rsp
  8004210ede:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
	int64_t ret = 0;
  8004210ee2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004210ee9:	00 
	uint8_t b;
	int shift = 0;
  8004210eea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	uint8_t *src = *dp;
  8004210ef1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210ef5:	48 8b 00             	mov    (%rax),%rax
  8004210ef8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  8004210efc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210f00:	0f b6 00             	movzbl (%rax),%eax
  8004210f03:	88 45 df             	mov    %al,-0x21(%rbp)
  8004210f06:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210f0b:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210f0f:	89 c2                	mov    %eax,%edx
  8004210f11:	83 e2 7f             	and    $0x7f,%edx
  8004210f14:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f17:	89 d3                	mov    %edx,%ebx
  8004210f19:	89 c1                	mov    %eax,%ecx
  8004210f1b:	d3 e3                	shl    %cl,%ebx
  8004210f1d:	89 d8                	mov    %ebx,%eax
  8004210f1f:	48 98                	cltq   
  8004210f21:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		shift += 7;
  8004210f25:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  8004210f29:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210f2d:	84 c0                	test   %al,%al
  8004210f2f:	78 cb                	js     8004210efc <_dwarf_decode_sleb128+0x27>

	if (shift < 32 && (b & 0x40) != 0)
  8004210f31:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  8004210f35:	7f 21                	jg     8004210f58 <_dwarf_decode_sleb128+0x83>
  8004210f37:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210f3b:	83 e0 40             	and    $0x40,%eax
  8004210f3e:	85 c0                	test   %eax,%eax
  8004210f40:	74 16                	je     8004210f58 <_dwarf_decode_sleb128+0x83>
		ret |= (-1 << shift);
  8004210f42:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f45:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210f4a:	89 d3                	mov    %edx,%ebx
  8004210f4c:	89 c1                	mov    %eax,%ecx
  8004210f4e:	d3 e3                	shl    %cl,%ebx
  8004210f50:	89 d8                	mov    %ebx,%eax
  8004210f52:	48 98                	cltq   
  8004210f54:	48 09 45 f0          	or     %rax,-0x10(%rbp)

	*dp = src;
  8004210f58:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f5c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210f60:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210f63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210f67:	48 83 c4 28          	add    $0x28,%rsp
  8004210f6b:	5b                   	pop    %rbx
  8004210f6c:	5d                   	pop    %rbp
  8004210f6d:	c3                   	retq   

0000008004210f6e <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  8004210f6e:	55                   	push   %rbp
  8004210f6f:	48 89 e5             	mov    %rsp,%rbp
  8004210f72:	53                   	push   %rbx
  8004210f73:	48 83 ec 28          	sub    $0x28,%rsp
  8004210f77:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
	uint64_t ret = 0;
  8004210f7b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004210f82:	00 
	uint8_t b;
	int shift = 0;
  8004210f83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	uint8_t *src = *dp;
  8004210f8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f8e:	48 8b 00             	mov    (%rax),%rax
  8004210f91:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  8004210f95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210f99:	0f b6 00             	movzbl (%rax),%eax
  8004210f9c:	88 45 df             	mov    %al,-0x21(%rbp)
  8004210f9f:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210fa4:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210fa8:	89 c2                	mov    %eax,%edx
  8004210faa:	83 e2 7f             	and    $0x7f,%edx
  8004210fad:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210fb0:	89 d3                	mov    %edx,%ebx
  8004210fb2:	89 c1                	mov    %eax,%ecx
  8004210fb4:	d3 e3                	shl    %cl,%ebx
  8004210fb6:	89 d8                	mov    %ebx,%eax
  8004210fb8:	48 98                	cltq   
  8004210fba:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		shift += 7;
  8004210fbe:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  8004210fc2:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210fc6:	84 c0                	test   %al,%al
  8004210fc8:	78 cb                	js     8004210f95 <_dwarf_decode_uleb128+0x27>

	*dp = src;
  8004210fca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210fce:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210fd2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210fd5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210fd9:	48 83 c4 28          	add    $0x28,%rsp
  8004210fdd:	5b                   	pop    %rbx
  8004210fde:	5d                   	pop    %rbp
  8004210fdf:	c3                   	retq   

0000008004210fe0 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  8004210fe0:	55                   	push   %rbp
  8004210fe1:	48 89 e5             	mov    %rsp,%rbp
  8004210fe4:	48 83 ec 28          	sub    $0x28,%rsp
  8004210fe8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210fec:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210ff0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004210ff4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ff8:	48 8b 00             	mov    (%rax),%rax
  8004210ffb:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004210fff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211003:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211007:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800421100b:	eb 17                	jmp    8004211024 <_dwarf_read_string+0x44>
		src++;
  800421100d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004211012:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211016:	48 8b 00             	mov    (%rax),%rax
  8004211019:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421101d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211021:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  8004211024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211028:	0f b6 00             	movzbl (%rax),%eax
  800421102b:	84 c0                	test   %al,%al
  800421102d:	74 0d                	je     800421103c <_dwarf_read_string+0x5c>
  800421102f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211033:	48 8b 00             	mov    (%rax),%rax
  8004211036:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421103a:	72 d1                	jb     800421100d <_dwarf_read_string+0x2d>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800421103c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211040:	0f b6 00             	movzbl (%rax),%eax
  8004211043:	84 c0                	test   %al,%al
  8004211045:	75 1f                	jne    8004211066 <_dwarf_read_string+0x86>
  8004211047:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421104b:	48 8b 00             	mov    (%rax),%rax
  800421104e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211052:	73 12                	jae    8004211066 <_dwarf_read_string+0x86>
		(*offsetp)++;
  8004211054:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211058:	48 8b 00             	mov    (%rax),%rax
  800421105b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421105f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211063:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211066:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421106a:	c9                   	leaveq 
  800421106b:	c3                   	retq   

000000800421106c <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800421106c:	55                   	push   %rbp
  800421106d:	48 89 e5             	mov    %rsp,%rbp
  8004211070:	48 83 ec 28          	sub    $0x28,%rsp
  8004211074:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211078:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421107c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  8004211080:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211084:	48 8b 00             	mov    (%rax),%rax
  8004211087:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800421108b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421108f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211093:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  8004211097:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421109b:	48 8b 00             	mov    (%rax),%rax
  800421109e:	48 89 c2             	mov    %rax,%rdx
  80042110a1:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  80042110a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042110a9:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042110ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042110b0:	c9                   	leaveq 
  80042110b1:	c3                   	retq   

00000080042110b2 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  80042110b2:	55                   	push   %rbp
  80042110b3:	48 89 e5             	mov    %rsp,%rbp
  80042110b6:	48 83 ec 20          	sub    $0x20,%rsp
  80042110ba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  80042110be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042110c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  80042110c6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042110cb:	75 35                	jne    8004211102 <_dwarf_elf_get_byte_order+0x50>
  80042110cd:	48 b9 60 e9 21 04 80 	movabs $0x800421e960,%rcx
  80042110d4:	00 00 00 
  80042110d7:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042110de:	00 00 00 
  80042110e1:	be 2b 01 00 00       	mov    $0x12b,%esi
  80042110e6:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  80042110ed:	00 00 00 
  80042110f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110f5:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042110fc:	00 00 00 
  80042110ff:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  8004211102:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211106:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800421110a:	0f b6 c0             	movzbl %al,%eax
  800421110d:	83 f8 02             	cmp    $0x2,%eax
  8004211110:	75 07                	jne    8004211119 <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  8004211112:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211117:	eb 05                	jmp    800421111e <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  8004211119:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800421111e:	c9                   	leaveq 
  800421111f:	c3                   	retq   

0000008004211120 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  8004211120:	55                   	push   %rbp
  8004211121:	48 89 e5             	mov    %rsp,%rbp
  8004211124:	48 83 ec 20          	sub    $0x20,%rsp
  8004211128:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800421112c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211130:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211134:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211139:	75 35                	jne    8004211170 <_dwarf_elf_get_pointer_size+0x50>
  800421113b:	48 b9 60 e9 21 04 80 	movabs $0x800421e960,%rcx
  8004211142:	00 00 00 
  8004211145:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  800421114c:	00 00 00 
  800421114f:	be 41 01 00 00       	mov    $0x141,%esi
  8004211154:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  800421115b:	00 00 00 
  800421115e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211163:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421116a:	00 00 00 
  800421116d:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  8004211170:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211174:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  8004211178:	3c 01                	cmp    $0x1,%al
  800421117a:	75 07                	jne    8004211183 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800421117c:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211181:	eb 05                	jmp    8004211188 <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  8004211183:	b8 08 00 00 00       	mov    $0x8,%eax
}
  8004211188:	c9                   	leaveq 
  8004211189:	c3                   	retq   

000000800421118a <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800421118a:	55                   	push   %rbp
  800421118b:	48 89 e5             	mov    %rsp,%rbp
  800421118e:	48 83 ec 10          	sub    $0x10,%rsp
  8004211192:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004211196:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800421119a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421119e:	ba 58 00 00 00       	mov    $0x58,%edx
  80042111a3:	be 00 00 00 00       	mov    $0x0,%esi
  80042111a8:	48 89 c7             	mov    %rax,%rdi
  80042111ab:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042111b2:	00 00 00 
  80042111b5:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  80042111b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111bb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  80042111c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111c6:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042111cd:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  80042111ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111d2:	48 89 c7             	mov    %rax,%rdi
  80042111d5:	48 b8 20 11 21 04 80 	movabs $0x8004211120,%rax
  80042111dc:	00 00 00 
  80042111df:	ff d0                	callq  *%rax
  80042111e1:	0f b6 d0             	movzbl %al,%edx
  80042111e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042111e8:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  80042111eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111ef:	48 89 c7             	mov    %rax,%rdi
  80042111f2:	48 b8 b2 10 21 04 80 	movabs $0x80042110b2,%rax
  80042111f9:	00 00 00 
  80042111fc:	ff d0                	callq  *%rax
  80042111fe:	85 c0                	test   %eax,%eax
  8004211200:	75 26                	jne    8004211228 <_dwarf_init+0x9e>
		dbg->read = _dwarf_read_msb;
  8004211202:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211206:	48 ba 4e 0a 21 04 80 	movabs $0x8004210a4e,%rdx
  800421120d:	00 00 00 
  8004211210:	48 89 50 18          	mov    %rdx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004211214:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211218:	48 ba fd 0b 21 04 80 	movabs $0x8004210bfd,%rdx
  800421121f:	00 00 00 
  8004211222:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211226:	eb 24                	jmp    800421124c <_dwarf_init+0xc2>
	} else {
		dbg->read = _dwarf_read_lsb;
  8004211228:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421122c:	48 ba 04 08 21 04 80 	movabs $0x8004210804,%rdx
  8004211233:	00 00 00 
  8004211236:	48 89 50 18          	mov    %rdx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800421123a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421123e:	48 ba 2d 09 21 04 80 	movabs $0x800421092d,%rdx
  8004211245:	00 00 00 
  8004211248:	48 89 50 20          	mov    %rdx,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800421124c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211250:	48 89 c7             	mov    %rax,%rdi
  8004211253:	48 b8 90 27 21 04 80 	movabs $0x8004212790,%rax
  800421125a:	00 00 00 
  800421125d:	ff d0                	callq  *%rax
	return 0;
  800421125f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211264:	c9                   	leaveq 
  8004211265:	c3                   	retq   

0000008004211266 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  8004211266:	55                   	push   %rbp
  8004211267:	48 89 e5             	mov    %rsp,%rbp
  800421126a:	48 83 ec 20          	sub    $0x20,%rsp
  800421126e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211272:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  8004211276:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421127a:	48 8b 10             	mov    (%rax),%rdx
  800421127d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211281:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211285:	48 39 c2             	cmp    %rax,%rdx
  8004211288:	76 0a                	jbe    8004211294 <_get_next_cu+0x2e>
		return -1;
  800421128a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421128f:	e9 73 01 00 00       	jmpq   8004211407 <_get_next_cu+0x1a1>

	offset = dbg->curr_off_dbginfo;
  8004211294:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211298:	48 8b 00             	mov    (%rax),%rax
  800421129b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800421129f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042112a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042112a7:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  80042112ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112af:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042112b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042112bb:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80042112bf:	ba 04 00 00 00       	mov    $0x4,%edx
  80042112c4:	48 89 ce             	mov    %rcx,%rsi
  80042112c7:	48 89 c7             	mov    %rax,%rdi
  80042112ca:	41 ff d0             	callq  *%r8
  80042112cd:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  80042112d0:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80042112d4:	75 2b                	jne    8004211301 <_get_next_cu+0x9b>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  80042112d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112da:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042112de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042112e6:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80042112ea:	ba 08 00 00 00       	mov    $0x8,%edx
  80042112ef:	48 89 ce             	mov    %rcx,%rsi
  80042112f2:	48 89 c7             	mov    %rax,%rdi
  80042112f5:	41 ff d0             	callq  *%r8
  80042112f8:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  80042112fb:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  80042112ff:	eb 04                	jmp    8004211305 <_get_next_cu+0x9f>
	} else {
		dwarf_size = 4;
  8004211301:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004211305:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211309:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800421130d:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004211310:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211313:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211317:	48 01 c2             	add    %rax,%rdx
  800421131a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421131e:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004211321:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211325:	48 8b 10             	mov    (%rax),%rdx
  8004211328:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421132c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004211330:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211333:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211337:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800421133a:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800421133e:	75 07                	jne    8004211347 <_get_next_cu+0xe1>
  8004211340:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211345:	eb 05                	jmp    800421134c <_get_next_cu+0xe6>
  8004211347:	b8 0c 00 00 00       	mov    $0xc,%eax
  800421134c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211350:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004211353:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211357:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421135b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421135f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211363:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004211367:	ba 02 00 00 00       	mov    $0x2,%edx
  800421136c:	48 89 ce             	mov    %rcx,%rsi
  800421136f:	48 89 c7             	mov    %rax,%rdi
  8004211372:	41 ff d0             	callq  *%r8
  8004211375:	89 c2                	mov    %eax,%edx
  8004211377:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421137b:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800421137f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211383:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211387:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800421138b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421138f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211393:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  8004211397:	48 89 ce             	mov    %rcx,%rsi
  800421139a:	48 89 c7             	mov    %rax,%rdi
  800421139d:	41 ff d0             	callq  *%r8
  80042113a0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042113a4:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  80042113a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113ac:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042113b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042113b4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042113b8:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  80042113bc:	ba 01 00 00 00       	mov    $0x1,%edx
  80042113c1:	48 89 ce             	mov    %rcx,%rsi
  80042113c4:	48 89 c7             	mov    %rax,%rdi
  80042113c7:	41 ff d0             	callq  *%r8
  80042113ca:	89 c2                	mov    %eax,%edx
  80042113cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113d0:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  80042113d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113d7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042113db:	66 83 f8 01          	cmp    $0x1,%ax
  80042113df:	76 0e                	jbe    80042113ef <_get_next_cu+0x189>
  80042113e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113e5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042113e9:	66 83 f8 04          	cmp    $0x4,%ax
  80042113ed:	76 07                	jbe    80042113f6 <_get_next_cu+0x190>
		return -1;
  80042113ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042113f4:	eb 11                	jmp    8004211407 <_get_next_cu+0x1a1>
	}

	cu->cu_die_offset = offset;
  80042113f6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042113fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042113fe:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004211402:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211407:	c9                   	leaveq 
  8004211408:	c3                   	retq   

0000008004211409 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004211409:	55                   	push   %rbp
  800421140a:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800421140d:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004211411:	0f b6 c8             	movzbl %al,%ecx
  8004211414:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004211418:	0f b7 d0             	movzwl %ax,%edx
  800421141b:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800421141f:	48 89 c6             	mov    %rax,%rsi
  8004211422:	48 bf 92 e9 21 04 80 	movabs $0x800421e992,%rdi
  8004211429:	00 00 00 
  800421142c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211431:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  8004211438:	00 00 00 
  800421143b:	41 ff d0             	callq  *%r8
}
  800421143e:	5d                   	pop    %rbp
  800421143f:	c3                   	retq   

0000008004211440 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004211440:	55                   	push   %rbp
  8004211441:	48 89 e5             	mov    %rsp,%rbp
  8004211444:	48 83 ec 60          	sub    $0x60,%rsp
  8004211448:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421144c:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004211450:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004211454:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  8004211458:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800421145d:	75 35                	jne    8004211494 <_dwarf_abbrev_parse+0x54>
  800421145f:	48 b9 a1 e9 21 04 80 	movabs $0x800421e9a1,%rcx
  8004211466:	00 00 00 
  8004211469:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  8004211470:	00 00 00 
  8004211473:	be a6 01 00 00       	mov    $0x1a6,%esi
  8004211478:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  800421147f:	00 00 00 
  8004211482:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211487:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421148e:	00 00 00 
  8004211491:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  8004211494:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004211499:	75 35                	jne    80042114d0 <_dwarf_abbrev_parse+0x90>
  800421149b:	48 b9 ad e9 21 04 80 	movabs $0x800421e9ad,%rcx
  80042114a2:	00 00 00 
  80042114a5:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042114ac:	00 00 00 
  80042114af:	be a7 01 00 00       	mov    $0x1a7,%esi
  80042114b4:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  80042114bb:	00 00 00 
  80042114be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042114c3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042114ca:	00 00 00 
  80042114cd:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  80042114d0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042114d4:	48 8b 10             	mov    (%rax),%rdx
  80042114d7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042114db:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042114df:	48 39 c2             	cmp    %rax,%rdx
  80042114e2:	72 0a                	jb     80042114ee <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  80042114e4:	b8 04 00 00 00       	mov    $0x4,%eax
  80042114e9:	e9 d7 01 00 00       	jmpq   80042116c5 <_dwarf_abbrev_parse+0x285>

	aboff = *offset;
  80042114ee:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042114f2:	48 8b 00             	mov    (%rax),%rax
  80042114f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  80042114f9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042114fd:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211501:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211505:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211509:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421150d:	48 89 d6             	mov    %rdx,%rsi
  8004211510:	48 89 c7             	mov    %rax,%rdi
  8004211513:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  800421151a:	00 00 00 
  800421151d:	ff d0                	callq  *%rax
  800421151f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004211523:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211528:	75 15                	jne    800421153f <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800421152a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421152e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  8004211535:	b8 00 00 00 00       	mov    $0x0,%eax
  800421153a:	e9 86 01 00 00       	jmpq   80042116c5 <_dwarf_abbrev_parse+0x285>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800421153f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211543:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211547:	48 89 d6             	mov    %rdx,%rsi
  800421154a:	48 89 c7             	mov    %rax,%rdi
  800421154d:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  8004211554:	00 00 00 
  8004211557:	ff d0                	callq  *%rax
  8004211559:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800421155d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211561:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211565:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211569:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421156d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211572:	48 89 ce             	mov    %rcx,%rsi
  8004211575:	48 89 c7             	mov    %rax,%rdi
  8004211578:	41 ff d0             	callq  *%r8
  800421157b:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800421157e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211582:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211586:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004211589:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421158d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211591:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004211595:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211599:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800421159d:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  80042115a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042115a4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042115a8:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  80042115ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042115b0:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80042115b7:	00 
	abp->ab_atnum    = 0;
  80042115b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042115bc:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  80042115c3:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  80042115c4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042115c8:	48 8b 00             	mov    (%rax),%rax
  80042115cb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  80042115cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115d3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042115d7:	48 89 d6             	mov    %rdx,%rsi
  80042115da:	48 89 c7             	mov    %rax,%rdi
  80042115dd:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  80042115e4:	00 00 00 
  80042115e7:	ff d0                	callq  *%rax
  80042115e9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  80042115ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115f1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042115f5:	48 89 d6             	mov    %rdx,%rsi
  80042115f8:	48 89 c7             	mov    %rax,%rdi
  80042115fb:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  8004211602:	00 00 00 
  8004211605:	ff d0                	callq  *%rax
  8004211607:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800421160b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211610:	0f 84 89 00 00 00    	je     800421169f <_dwarf_abbrev_parse+0x25f>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004211616:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421161a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421161e:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211622:	48 89 d0             	mov    %rdx,%rax
  8004211625:	48 01 c0             	add    %rax,%rax
  8004211628:	48 01 d0             	add    %rdx,%rax
  800421162b:	48 c1 e0 03          	shl    $0x3,%rax
  800421162f:	48 01 c8             	add    %rcx,%rax
  8004211632:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004211636:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421163a:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800421163d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211641:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211645:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211649:	48 89 d0             	mov    %rdx,%rax
  800421164c:	48 01 c0             	add    %rax,%rax
  800421164f:	48 01 d0             	add    %rdx,%rax
  8004211652:	48 c1 e0 03          	shl    $0x3,%rax
  8004211656:	48 01 c8             	add    %rcx,%rax
  8004211659:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800421165d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211661:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004211664:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211668:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421166c:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211670:	48 89 d0             	mov    %rdx,%rax
  8004211673:	48 01 c0             	add    %rax,%rax
  8004211676:	48 01 d0             	add    %rdx,%rax
  8004211679:	48 c1 e0 03          	shl    $0x3,%rax
  800421167d:	48 01 c8             	add    %rcx,%rax
  8004211680:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004211684:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211688:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800421168b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421168f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211693:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211697:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421169b:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800421169f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042116a4:	0f 85 1a ff ff ff    	jne    80042115c4 <_dwarf_abbrev_parse+0x184>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  80042116aa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042116ae:	48 8b 00             	mov    (%rax),%rax
  80042116b1:	48 89 c2             	mov    %rax,%rdx
  80042116b4:	48 2b 55 f8          	sub    -0x8(%rbp),%rdx
  80042116b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042116bc:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  80042116c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042116c5:	c9                   	leaveq 
  80042116c6:	c3                   	retq   

00000080042116c7 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  80042116c7:	55                   	push   %rbp
  80042116c8:	48 89 e5             	mov    %rsp,%rbp
  80042116cb:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  80042116cf:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042116d3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042116d7:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  80042116db:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042116e0:	75 0a                	jne    80042116ec <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  80042116e2:	b8 04 00 00 00       	mov    $0x4,%eax
  80042116e7:	e9 0b 01 00 00       	jmpq   80042117f7 <_dwarf_abbrev_find+0x130>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  80042116ec:	48 bf b8 e9 21 04 80 	movabs $0x800421e9b8,%rdi
  80042116f3:	00 00 00 
  80042116f6:	48 b8 d4 5a 21 04 80 	movabs $0x8004215ad4,%rax
  80042116fd:	00 00 00 
  8004211700:	ff d0                	callq  *%rax
  8004211702:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004211706:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421170b:	75 35                	jne    8004211742 <_dwarf_abbrev_find+0x7b>
  800421170d:	48 b9 ad e9 21 04 80 	movabs $0x800421e9ad,%rcx
  8004211714:	00 00 00 
  8004211717:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  800421171e:	00 00 00 
  8004211721:	be e7 01 00 00       	mov    $0x1e7,%esi
  8004211726:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  800421172d:	00 00 00 
  8004211730:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211735:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421173c:	00 00 00 
  800421173f:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004211742:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211746:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  800421174a:	e9 8b 00 00 00       	jmpq   80042117da <_dwarf_abbrev_find+0x113>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800421174f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004211753:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211757:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800421175b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421175f:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004211763:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211767:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  800421176b:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211770:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004211774:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211779:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800421177d:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211782:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004211786:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800421178b:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800421178f:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211794:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004211798:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800421179d:	48 89 c7             	mov    %rax,%rdi
  80042117a0:	48 b8 40 14 21 04 80 	movabs $0x8004211440,%rax
  80042117a7:	00 00 00 
  80042117aa:	ff d0                	callq  *%rax
  80042117ac:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  80042117af:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042117b3:	74 05                	je     80042117ba <_dwarf_abbrev_find+0xf3>
			return (ret);
  80042117b5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042117b8:	eb 3d                	jmp    80042117f7 <_dwarf_abbrev_find+0x130>
		if (abp->ab_entry == entry) {
  80042117ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042117be:	48 8b 00             	mov    (%rax),%rax
  80042117c1:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042117c5:	75 07                	jne    80042117ce <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  80042117c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042117cc:	eb 29                	jmp    80042117f7 <_dwarf_abbrev_find+0x130>
		}
		if (abp->ab_entry == 0) {
  80042117ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042117d2:	48 8b 00             	mov    (%rax),%rax
  80042117d5:	48 85 c0             	test   %rax,%rax
  80042117d8:	74 17                	je     80042117f1 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  80042117da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042117de:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042117e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042117e6:	48 39 c2             	cmp    %rax,%rdx
  80042117e9:	0f 87 60 ff ff ff    	ja     800421174f <_dwarf_abbrev_find+0x88>
  80042117ef:	eb 01                	jmp    80042117f2 <_dwarf_abbrev_find+0x12b>
			return DW_DLE_NONE;
		}
		if (abp->ab_entry == 0) {
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  80042117f1:	90                   	nop
		}
	}

	return DW_DLE_NO_ENTRY;
  80042117f2:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042117f7:	c9                   	leaveq 
  80042117f8:	c3                   	retq   

00000080042117f9 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  80042117f9:	55                   	push   %rbp
  80042117fa:	48 89 e5             	mov    %rsp,%rbp
  80042117fd:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004211804:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800421180b:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004211812:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004211819:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004211820:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004211827:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800421182e:	48 bf c6 e9 21 04 80 	movabs $0x800421e9c6,%rdi
  8004211835:	00 00 00 
  8004211838:	48 b8 d4 5a 21 04 80 	movabs $0x8004215ad4,%rax
  800421183f:	00 00 00 
  8004211842:	ff d0                	callq  *%rax
  8004211844:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004211848:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421184c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211850:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  8004211854:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421185b:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421185f:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  8004211862:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004211869:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004211870:	ba 60 00 00 00       	mov    $0x60,%edx
  8004211875:	be 00 00 00 00       	mov    $0x0,%esi
  800421187a:	48 89 c7             	mov    %rax,%rdi
  800421187d:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004211884:	00 00 00 
  8004211887:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004211889:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211890:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004211897:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421189e:	48 8b 00             	mov    (%rax),%rax
  80042118a1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  80042118a5:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042118ac:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042118b0:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042118b4:	8b 45 10             	mov    0x10(%rbp),%eax
  80042118b7:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  80042118ba:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042118c1:	00 

	switch (form) {
  80042118c2:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  80042118c9:	20 
  80042118ca:	0f 87 b4 04 00 00    	ja     8004211d84 <_dwarf_attr_init+0x58b>
  80042118d0:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042118d7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042118de:	00 
  80042118df:	48 b8 f0 e9 21 04 80 	movabs $0x800421e9f0,%rax
  80042118e6:	00 00 00 
  80042118e9:	48 01 d0             	add    %rdx,%rax
  80042118ec:	48 8b 00             	mov    (%rax),%rax
  80042118ef:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042118f1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042118f8:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042118fc:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211903:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8004211907:	0f b6 d0             	movzbl %al,%edx
  800421190a:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211911:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211915:	48 89 ce             	mov    %rcx,%rsi
  8004211918:	48 89 c7             	mov    %rax,%rdi
  800421191b:	41 ff d0             	callq  *%r8
  800421191e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211922:	e9 67 04 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211927:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421192e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211932:	48 89 d6             	mov    %rdx,%rsi
  8004211935:	48 89 c7             	mov    %rax,%rdi
  8004211938:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  800421193f:	00 00 00 
  8004211942:	ff d0                	callq  *%rax
  8004211944:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211948:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421194c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211953:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211957:	48 89 ce             	mov    %rcx,%rsi
  800421195a:	48 89 c7             	mov    %rax,%rdi
  800421195d:	48 b8 6c 10 21 04 80 	movabs $0x800421106c,%rax
  8004211964:	00 00 00 
  8004211967:	ff d0                	callq  *%rax
  8004211969:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421196d:	e9 1c 04 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004211972:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211979:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421197d:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211984:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211988:	ba 01 00 00 00       	mov    $0x1,%edx
  800421198d:	48 89 ce             	mov    %rcx,%rsi
  8004211990:	48 89 c7             	mov    %rax,%rdi
  8004211993:	41 ff d0             	callq  *%r8
  8004211996:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421199a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421199e:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042119a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119a9:	48 89 ce             	mov    %rcx,%rsi
  80042119ac:	48 89 c7             	mov    %rax,%rdi
  80042119af:	48 b8 6c 10 21 04 80 	movabs $0x800421106c,%rax
  80042119b6:	00 00 00 
  80042119b9:	ff d0                	callq  *%rax
  80042119bb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042119bf:	e9 ca 03 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042119c4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042119cb:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042119cf:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042119d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119da:	ba 02 00 00 00       	mov    $0x2,%edx
  80042119df:	48 89 ce             	mov    %rcx,%rsi
  80042119e2:	48 89 c7             	mov    %rax,%rdi
  80042119e5:	41 ff d0             	callq  *%r8
  80042119e8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042119ec:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042119f0:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042119f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119fb:	48 89 ce             	mov    %rcx,%rsi
  80042119fe:	48 89 c7             	mov    %rax,%rdi
  8004211a01:	48 b8 6c 10 21 04 80 	movabs $0x800421106c,%rax
  8004211a08:	00 00 00 
  8004211a0b:	ff d0                	callq  *%rax
  8004211a0d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211a11:	e9 78 03 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004211a16:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a1d:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211a21:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211a28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a2c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211a31:	48 89 ce             	mov    %rcx,%rsi
  8004211a34:	48 89 c7             	mov    %rax,%rdi
  8004211a37:	41 ff d0             	callq  *%r8
  8004211a3a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211a3e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211a42:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211a49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a4d:	48 89 ce             	mov    %rcx,%rsi
  8004211a50:	48 89 c7             	mov    %rax,%rdi
  8004211a53:	48 b8 6c 10 21 04 80 	movabs $0x800421106c,%rax
  8004211a5a:	00 00 00 
  8004211a5d:	ff d0                	callq  *%rax
  8004211a5f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211a63:	e9 26 03 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004211a68:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a6f:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211a73:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211a7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a7e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211a83:	48 89 ce             	mov    %rcx,%rsi
  8004211a86:	48 89 c7             	mov    %rax,%rdi
  8004211a89:	41 ff d0             	callq  *%r8
  8004211a8c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211a90:	e9 f9 02 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004211a95:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211a9c:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211aa0:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211aa7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211aab:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211ab0:	48 89 ce             	mov    %rcx,%rsi
  8004211ab3:	48 89 c7             	mov    %rax,%rdi
  8004211ab6:	41 ff d0             	callq  *%r8
  8004211ab9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211abd:	e9 cc 02 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004211ac2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211ac9:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211acd:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211ad4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ad8:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211add:	48 89 ce             	mov    %rcx,%rsi
  8004211ae0:	48 89 c7             	mov    %rax,%rdi
  8004211ae3:	41 ff d0             	callq  *%r8
  8004211ae6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211aea:	e9 9f 02 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  8004211aef:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211af6:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211afa:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211b01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b05:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211b0a:	48 89 ce             	mov    %rcx,%rsi
  8004211b0d:	48 89 c7             	mov    %rax,%rdi
  8004211b10:	41 ff d0             	callq  *%r8
  8004211b13:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211b17:	e9 72 02 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004211b1c:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211b23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b27:	48 89 d6             	mov    %rdx,%rsi
  8004211b2a:	48 89 c7             	mov    %rax,%rdi
  8004211b2d:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  8004211b34:	00 00 00 
  8004211b37:	ff d0                	callq  *%rax
  8004211b39:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004211b40:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004211b47:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004211b4e:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211b55:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211b5c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211b63:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211b6a:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  8004211b71:	4d 89 c1             	mov    %r8,%r9
  8004211b74:	49 89 f8             	mov    %rdi,%r8
  8004211b77:	48 89 c7             	mov    %rax,%rdi
  8004211b7a:	48 b8 f9 17 21 04 80 	movabs $0x80042117f9,%rax
  8004211b81:	00 00 00 
  8004211b84:	ff d0                	callq  *%rax
  8004211b86:	e9 31 03 00 00       	jmpq   8004211ebc <_dwarf_attr_init+0x6c3>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  8004211b8b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211b92:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211b96:	66 83 f8 02          	cmp    $0x2,%ax
  8004211b9a:	75 36                	jne    8004211bd2 <_dwarf_attr_init+0x3d9>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004211b9c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211ba3:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211ba7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211bae:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8004211bb2:	0f b6 d0             	movzbl %al,%edx
  8004211bb5:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211bbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bc0:	48 89 ce             	mov    %rcx,%rsi
  8004211bc3:	48 89 c7             	mov    %rax,%rdi
  8004211bc6:	41 ff d0             	callq  *%r8
  8004211bc9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  8004211bcd:	e9 bb 01 00 00       	jmpq   8004211d8d <_dwarf_attr_init+0x594>
		form = _dwarf_read_uleb128(ds_data, offsetp);
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
  8004211bd2:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004211bd9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211bdd:	66 83 f8 03          	cmp    $0x3,%ax
  8004211be1:	0f 85 a6 01 00 00    	jne    8004211d8d <_dwarf_attr_init+0x594>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211be7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211bee:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211bf2:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211bf6:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211bfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c01:	48 89 ce             	mov    %rcx,%rsi
  8004211c04:	48 89 c7             	mov    %rax,%rdi
  8004211c07:	41 ff d0             	callq  *%r8
  8004211c0a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211c0e:	e9 7a 01 00 00       	jmpq   8004211d8d <_dwarf_attr_init+0x594>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211c13:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211c1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c1e:	48 89 d6             	mov    %rdx,%rsi
  8004211c21:	48 89 c7             	mov    %rax,%rdi
  8004211c24:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  8004211c2b:	00 00 00 
  8004211c2e:	ff d0                	callq  *%rax
  8004211c30:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211c34:	e9 55 01 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  8004211c39:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211c40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c44:	48 89 d6             	mov    %rdx,%rsi
  8004211c47:	48 89 c7             	mov    %rax,%rdi
  8004211c4a:	48 b8 ac 0d 21 04 80 	movabs $0x8004210dac,%rax
  8004211c51:	00 00 00 
  8004211c54:	ff d0                	callq  *%rax
  8004211c56:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211c5a:	e9 2f 01 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211c5f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211c66:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211c6a:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211c6e:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211c75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c79:	48 89 ce             	mov    %rcx,%rsi
  8004211c7c:	48 89 c7             	mov    %rax,%rdi
  8004211c7f:	41 ff d0             	callq  *%r8
  8004211c82:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211c86:	e9 03 01 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004211c8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211c8f:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211c93:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211c9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211c9e:	48 89 ce             	mov    %rcx,%rsi
  8004211ca1:	48 89 c7             	mov    %rax,%rdi
  8004211ca4:	48 b8 e0 0f 21 04 80 	movabs $0x8004210fe0,%rax
  8004211cab:	00 00 00 
  8004211cae:	ff d0                	callq  *%rax
  8004211cb0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211cb4:	e9 d5 00 00 00       	jmpq   8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211cb9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211cc0:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211cc4:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211cc8:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211ccf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211cd3:	48 89 ce             	mov    %rcx,%rsi
  8004211cd6:	48 89 c7             	mov    %rax,%rdi
  8004211cd9:	41 ff d0             	callq  *%r8
  8004211cdc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  8004211ce0:	48 bf d2 e9 21 04 80 	movabs $0x800421e9d2,%rdi
  8004211ce7:	00 00 00 
  8004211cea:	48 b8 d4 5a 21 04 80 	movabs $0x8004215ad4,%rax
  8004211cf1:	00 00 00 
  8004211cf4:	ff d0                	callq  *%rax
  8004211cf6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  8004211cfa:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211cff:	75 35                	jne    8004211d36 <_dwarf_attr_init+0x53d>
  8004211d01:	48 b9 dd e9 21 04 80 	movabs $0x800421e9dd,%rcx
  8004211d08:	00 00 00 
  8004211d0b:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  8004211d12:	00 00 00 
  8004211d15:	be 53 02 00 00       	mov    $0x253,%esi
  8004211d1a:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  8004211d21:	00 00 00 
  8004211d24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d29:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004211d30:	00 00 00 
  8004211d33:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004211d36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d3a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211d3e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211d42:	48 01 d0             	add    %rdx,%rax
  8004211d45:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211d49:	eb 43                	jmp    8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004211d4b:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  8004211d52:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004211d53:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211d57:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211d5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211d62:	48 89 ce             	mov    %rcx,%rsi
  8004211d65:	48 89 c7             	mov    %rax,%rdi
  8004211d68:	48 b8 6c 10 21 04 80 	movabs $0x800421106c,%rax
  8004211d6f:	00 00 00 
  8004211d72:	ff d0                	callq  *%rax
  8004211d74:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211d78:	eb 14                	jmp    8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004211d7a:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  8004211d81:	00 
		break;
  8004211d82:	eb 0a                	jmp    8004211d8e <_dwarf_attr_init+0x595>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004211d84:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004211d8b:	eb 01                	jmp    8004211d8e <_dwarf_attr_init+0x595>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  8004211d8d:	90                   	nop
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
		break;
	}

	if (ret == DW_DLE_NONE) {
  8004211d8e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211d92:	0f 85 21 01 00 00    	jne    8004211eb9 <_dwarf_attr_init+0x6c0>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004211d98:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  8004211d9f:	09 
  8004211da0:	74 1e                	je     8004211dc0 <_dwarf_attr_init+0x5c7>
  8004211da2:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004211da9:	0a 
  8004211daa:	74 14                	je     8004211dc0 <_dwarf_attr_init+0x5c7>
  8004211dac:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  8004211db3:	03 
  8004211db4:	74 0a                	je     8004211dc0 <_dwarf_attr_init+0x5c7>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  8004211db6:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004211dbd:	04 
  8004211dbe:	75 10                	jne    8004211dd0 <_dwarf_attr_init+0x5d7>
			atref.at_block.bl_len = atref.u[0].u64;
  8004211dc0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211dc4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  8004211dc8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211dcc:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  8004211dd0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004211dd4:	48 83 f8 03          	cmp    $0x3,%rax
  8004211dd8:	75 39                	jne    8004211e13 <_dwarf_attr_init+0x61a>
			switch (atref.at_form) {
  8004211dda:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211dde:	48 83 f8 08          	cmp    $0x8,%rax
  8004211de2:	74 1a                	je     8004211dfe <_dwarf_attr_init+0x605>
  8004211de4:	48 83 f8 0e          	cmp    $0xe,%rax
  8004211de8:	75 28                	jne    8004211e12 <_dwarf_attr_init+0x619>
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  8004211dea:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211dee:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211df5:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004211dfc:	eb 15                	jmp    8004211e13 <_dwarf_attr_init+0x61a>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  8004211dfe:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211e02:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211e09:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004211e10:	eb 01                	jmp    8004211e13 <_dwarf_attr_init+0x61a>
			default:
				break;
  8004211e12:	90                   	nop
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  8004211e13:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211e1a:	0f b6 90 58 03 00 00 	movzbl 0x358(%rax),%edx
  8004211e21:	0f b6 c2             	movzbl %dl,%eax
  8004211e24:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  8004211e2b:	48 63 c8             	movslq %eax,%rcx
  8004211e2e:	48 89 c8             	mov    %rcx,%rax
  8004211e31:	48 01 c0             	add    %rax,%rax
  8004211e34:	48 01 c8             	add    %rcx,%rax
  8004211e37:	48 c1 e0 05          	shl    $0x5,%rax
  8004211e3b:	48 01 f0             	add    %rsi,%rax
  8004211e3e:	48 05 70 03 00 00    	add    $0x370,%rax
  8004211e44:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  8004211e4b:	48 89 08             	mov    %rcx,(%rax)
  8004211e4e:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  8004211e55:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004211e59:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
  8004211e5d:	48 89 48 10          	mov    %rcx,0x10(%rax)
  8004211e61:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8004211e65:	48 89 48 18          	mov    %rcx,0x18(%rax)
  8004211e69:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8004211e6d:	48 89 48 20          	mov    %rcx,0x20(%rax)
  8004211e71:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004211e75:	48 89 48 28          	mov    %rcx,0x28(%rax)
  8004211e79:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211e7d:	48 89 48 30          	mov    %rcx,0x30(%rax)
  8004211e81:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211e85:	48 89 48 38          	mov    %rcx,0x38(%rax)
  8004211e89:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004211e8d:	48 89 48 40          	mov    %rcx,0x40(%rax)
  8004211e91:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004211e95:	48 89 48 48          	mov    %rcx,0x48(%rax)
  8004211e99:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004211e9d:	48 89 48 50          	mov    %rcx,0x50(%rax)
  8004211ea1:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004211ea5:	48 89 48 58          	mov    %rcx,0x58(%rax)
  8004211ea9:	83 c2 01             	add    $0x1,%edx
  8004211eac:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211eb3:	88 90 58 03 00 00    	mov    %dl,0x358(%rax)
	}

	return (ret);
  8004211eb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004211ebc:	c9                   	leaveq 
  8004211ebd:	c3                   	retq   

0000008004211ebe <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004211ebe:	55                   	push   %rbp
  8004211ebf:	48 89 e5             	mov    %rsp,%rbp
  8004211ec2:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  8004211ec9:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  8004211ed0:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  8004211ed7:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  8004211ede:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  8004211ee4:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  8004211eeb:	00 
  8004211eec:	75 35                	jne    8004211f23 <dwarf_search_die_within_cu+0x65>
  8004211eee:	48 b9 f8 ea 21 04 80 	movabs $0x800421eaf8,%rcx
  8004211ef5:	00 00 00 
  8004211ef8:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  8004211eff:	00 00 00 
  8004211f02:	be 88 02 00 00       	mov    $0x288,%esi
  8004211f07:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  8004211f0e:	00 00 00 
  8004211f11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f16:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004211f1d:	00 00 00 
  8004211f20:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  8004211f23:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004211f2a:	00 
  8004211f2b:	75 35                	jne    8004211f62 <dwarf_search_die_within_cu+0xa4>
  8004211f2d:	48 b9 fc ea 21 04 80 	movabs $0x800421eafc,%rcx
  8004211f34:	00 00 00 
  8004211f37:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  8004211f3e:	00 00 00 
  8004211f41:	be 8a 02 00 00       	mov    $0x28a,%esi
  8004211f46:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  8004211f4d:	00 00 00 
  8004211f50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f55:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004211f5c:	00 00 00 
  8004211f5f:	41 ff d0             	callq  *%r8

	level = 1;
  8004211f62:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211f69:	e9 15 02 00 00       	jmpq   8004212183 <dwarf_search_die_within_cu+0x2c5>

		die_offset = offset;
  8004211f6e:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211f75:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004211f79:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211f80:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211f84:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004211f8b:	48 89 d6             	mov    %rdx,%rsi
  8004211f8e:	48 89 c7             	mov    %rax,%rdi
  8004211f91:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  8004211f98:	00 00 00 
  8004211f9b:	ff d0                	callq  *%rax
  8004211f9d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004211fa1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211fa6:	75 22                	jne    8004211fca <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  8004211fa8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211fac:	74 09                	je     8004211fb7 <dwarf_search_die_within_cu+0xf9>
  8004211fae:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004211fb5:	75 0a                	jne    8004211fc1 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004211fb7:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211fbc:	e9 f2 01 00 00       	jmpq   80042121b3 <dwarf_search_die_within_cu+0x2f5>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004211fc1:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004211fc5:	e9 b9 01 00 00       	jmpq   8004212183 <dwarf_search_die_within_cu+0x2c5>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004211fca:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004211fd1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211fd5:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211fdc:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004211fe0:	48 89 34 24          	mov    %rsi,(%rsp)
  8004211fe4:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  8004211fe8:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  8004211fed:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  8004211ff1:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004211ff6:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004211ffa:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004211fff:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004212003:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004212008:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  800421200c:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004212011:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004212015:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  800421201a:	48 89 ce             	mov    %rcx,%rsi
  800421201d:	48 89 c7             	mov    %rax,%rdi
  8004212020:	48 b8 c7 16 21 04 80 	movabs $0x80042116c7,%rax
  8004212027:	00 00 00 
  800421202a:	ff d0                	callq  *%rax
  800421202c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421202f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212033:	74 08                	je     800421203d <dwarf_search_die_within_cu+0x17f>
			return (ret);
  8004212035:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212038:	e9 76 01 00 00       	jmpq   80042121b3 <dwarf_search_die_within_cu+0x2f5>
		ret_die->die_offset = die_offset;
  800421203d:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212044:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212048:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  800421204b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212052:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212056:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  800421205a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212061:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004212065:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  800421206c:	b8 66 00 00 00       	mov    $0x66,%eax
  8004212071:	48 89 d6             	mov    %rdx,%rsi
  8004212074:	48 89 c1             	mov    %rax,%rcx
  8004212077:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  800421207a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212081:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004212088:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800421208f:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212096:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  800421209a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042120a1:	e9 8e 00 00 00       	jmpq   8004212134 <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042120a6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042120a9:	48 63 d0             	movslq %eax,%rdx
  80042120ac:	48 89 d0             	mov    %rdx,%rax
  80042120af:	48 01 c0             	add    %rax,%rax
  80042120b2:	48 01 d0             	add    %rdx,%rax
  80042120b5:	48 c1 e0 03          	shl    $0x3,%rax
  80042120b9:	48 01 e8             	add    %rbp,%rax
  80042120bc:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042120c2:	48 8b 08             	mov    (%rax),%rcx
  80042120c5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042120c8:	48 63 d0             	movslq %eax,%rdx
  80042120cb:	48 89 d0             	mov    %rdx,%rax
  80042120ce:	48 01 c0             	add    %rax,%rax
  80042120d1:	48 01 d0             	add    %rdx,%rax
  80042120d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042120d8:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042120df:	48 83 c2 30          	add    $0x30,%rdx
  80042120e3:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
  80042120e7:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042120ee:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042120f5:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042120fc:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004212103:	49 89 c9             	mov    %rcx,%r9
  8004212106:	49 89 f8             	mov    %rdi,%r8
  8004212109:	48 89 d1             	mov    %rdx,%rcx
  800421210c:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004212110:	48 89 c7             	mov    %rax,%rdi
  8004212113:	48 b8 f9 17 21 04 80 	movabs $0x80042117f9,%rax
  800421211a:	00 00 00 
  800421211d:	ff d0                	callq  *%rax
  800421211f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212122:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212126:	74 08                	je     8004212130 <dwarf_search_die_within_cu+0x272>
				return (ret);
  8004212128:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421212b:	e9 83 00 00 00       	jmpq   80042121b3 <dwarf_search_die_within_cu+0x2f5>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004212130:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004212134:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004212137:	48 63 d0             	movslq %eax,%rdx
  800421213a:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004212141:	48 39 c2             	cmp    %rax,%rdx
  8004212144:	0f 82 5c ff ff ff    	jb     80042120a6 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  800421214a:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004212151:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212158:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  800421215c:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004212163:	74 17                	je     800421217c <dwarf_search_die_within_cu+0x2be>
  8004212165:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212169:	7e 11                	jle    800421217c <dwarf_search_die_within_cu+0x2be>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800421216b:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004212172:	3c 01                	cmp    $0x1,%al
  8004212174:	75 0d                	jne    8004212183 <dwarf_search_die_within_cu+0x2c5>
				/* Advance to next DIE level. */
				level++;
  8004212176:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  800421217a:	eb 07                	jmp    8004212183 <dwarf_search_die_within_cu+0x2c5>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  800421217c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212181:	eb 30                	jmp    80042121b3 <dwarf_search_die_within_cu+0x2f5>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004212183:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004212187:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421218e:	48 39 c2             	cmp    %rax,%rdx
  8004212191:	76 1b                	jbe    80042121ae <dwarf_search_die_within_cu+0x2f0>
  8004212193:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421219a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421219e:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042121a5:	48 39 c2             	cmp    %rax,%rdx
  80042121a8:	0f 87 c0 fd ff ff    	ja     8004211f6e <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  80042121ae:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042121b3:	c9                   	leaveq 
  80042121b4:	c3                   	retq   

00000080042121b5 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042121b5:	55                   	push   %rbp
  80042121b6:	48 89 e5             	mov    %rsp,%rbp
  80042121b9:	48 83 ec 70          	sub    $0x70,%rsp
  80042121bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042121c1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042121c5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  80042121c9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042121ce:	75 35                	jne    8004212205 <dwarf_offdie+0x50>
  80042121d0:	48 b9 f8 ea 21 04 80 	movabs $0x800421eaf8,%rcx
  80042121d7:	00 00 00 
  80042121da:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042121e1:	00 00 00 
  80042121e4:	be c6 02 00 00       	mov    $0x2c6,%esi
  80042121e9:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  80042121f0:	00 00 00 
  80042121f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042121f8:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042121ff:	00 00 00 
  8004212202:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212205:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421220a:	75 35                	jne    8004212241 <dwarf_offdie+0x8c>
  800421220c:	48 b9 fc ea 21 04 80 	movabs $0x800421eafc,%rcx
  8004212213:	00 00 00 
  8004212216:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  800421221d:	00 00 00 
  8004212220:	be c7 02 00 00       	mov    $0x2c7,%esi
  8004212225:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  800421222c:	00 00 00 
  800421222f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212234:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421223b:	00 00 00 
  800421223e:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004212241:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004212245:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212249:	76 66                	jbe    80042122b1 <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  800421224b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421224f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004212253:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212257:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  800421225b:	48 89 0c 24          	mov    %rcx,(%rsp)
  800421225f:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004212263:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004212268:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  800421226c:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004212271:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212275:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  800421227a:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  800421227e:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004212283:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004212287:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  800421228c:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004212290:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004212295:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421229a:	48 89 c7             	mov    %rax,%rdi
  800421229d:	48 b8 be 1e 21 04 80 	movabs $0x8004211ebe,%rax
  80042122a4:	00 00 00 
  80042122a7:	ff d0                	callq  *%rax
  80042122a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  80042122ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042122af:	eb 05                	jmp    80042122b6 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  80042122b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042122b6:	c9                   	leaveq 
  80042122b7:	c3                   	retq   

00000080042122b8 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  80042122b8:	55                   	push   %rbp
  80042122b9:	48 89 e5             	mov    %rsp,%rbp
  80042122bc:	48 83 ec 20          	sub    $0x20,%rsp
  80042122c0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042122c4:	89 f0                	mov    %esi,%eax
  80042122c6:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  80042122ca:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042122d1:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  80042122d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042122d9:	eb 57                	jmp    8004212332 <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  80042122db:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042122df:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042122e2:	48 63 d0             	movslq %eax,%rdx
  80042122e5:	48 89 d0             	mov    %rdx,%rax
  80042122e8:	48 01 c0             	add    %rax,%rax
  80042122eb:	48 01 d0             	add    %rdx,%rax
  80042122ee:	48 c1 e0 05          	shl    $0x5,%rax
  80042122f2:	48 01 c8             	add    %rcx,%rax
  80042122f5:	48 05 80 03 00 00    	add    $0x380,%rax
  80042122fb:	48 8b 10             	mov    (%rax),%rdx
  80042122fe:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004212302:	48 39 c2             	cmp    %rax,%rdx
  8004212305:	75 27                	jne    800421232e <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004212307:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421230b:	48 8d 88 70 03 00 00 	lea    0x370(%rax),%rcx
  8004212312:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212315:	48 63 d0             	movslq %eax,%rdx
  8004212318:	48 89 d0             	mov    %rdx,%rax
  800421231b:	48 01 c0             	add    %rax,%rax
  800421231e:	48 01 d0             	add    %rdx,%rax
  8004212321:	48 c1 e0 05          	shl    $0x5,%rax
  8004212325:	48 01 c8             	add    %rcx,%rax
  8004212328:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800421232c:	eb 17                	jmp    8004212345 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  800421232e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004212332:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212336:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  800421233d:	0f b6 c0             	movzbl %al,%eax
  8004212340:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004212343:	7f 96                	jg     80042122db <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004212345:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004212349:	c9                   	leaveq 
  800421234a:	c3                   	retq   

000000800421234b <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  800421234b:	55                   	push   %rbp
  800421234c:	48 89 e5             	mov    %rsp,%rbp
  800421234f:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212353:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212357:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421235b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421235f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004212363:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212368:	75 35                	jne    800421239f <dwarf_siblingof+0x54>
  800421236a:	48 b9 f8 ea 21 04 80 	movabs $0x800421eaf8,%rcx
  8004212371:	00 00 00 
  8004212374:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  800421237b:	00 00 00 
  800421237e:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004212383:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  800421238a:	00 00 00 
  800421238d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212392:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004212399:	00 00 00 
  800421239c:	41 ff d0             	callq  *%r8
	assert(ret_die);
  800421239f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042123a4:	75 35                	jne    80042123db <dwarf_siblingof+0x90>
  80042123a6:	48 b9 fc ea 21 04 80 	movabs $0x800421eafc,%rcx
  80042123ad:	00 00 00 
  80042123b0:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042123b7:	00 00 00 
  80042123ba:	be ef 02 00 00       	mov    $0x2ef,%esi
  80042123bf:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  80042123c6:	00 00 00 
  80042123c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042123ce:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042123d5:	00 00 00 
  80042123d8:	41 ff d0             	callq  *%r8
	assert(cu);
  80042123db:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042123e0:	75 35                	jne    8004212417 <dwarf_siblingof+0xcc>
  80042123e2:	48 b9 04 eb 21 04 80 	movabs $0x800421eb04,%rcx
  80042123e9:	00 00 00 
  80042123ec:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042123f3:	00 00 00 
  80042123f6:	be f0 02 00 00       	mov    $0x2f0,%esi
  80042123fb:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  8004212402:	00 00 00 
  8004212405:	b8 00 00 00 00       	mov    $0x0,%eax
  800421240a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004212411:	00 00 00 
  8004212414:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004212417:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421241c:	75 65                	jne    8004212483 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  800421241e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212422:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004212426:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421242a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421242e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212432:	48 8b 38             	mov    (%rax),%rdi
  8004212435:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212439:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800421243d:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004212442:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004212446:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800421244b:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800421244f:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004212454:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004212458:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800421245d:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004212461:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004212466:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421246a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800421246f:	48 89 cf             	mov    %rcx,%rdi
  8004212472:	48 b8 b5 21 21 04 80 	movabs $0x80042121b5,%rax
  8004212479:	00 00 00 
  800421247c:	ff d0                	callq  *%rax
  800421247e:	e9 0a 01 00 00       	jmpq   800421258d <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004212483:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  800421248a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421248e:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004212492:	84 c0                	test   %al,%al
  8004212494:	75 0e                	jne    80042124a4 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004212496:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421249a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421249e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042124a2:	eb 6b                	jmp    800421250f <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  80042124a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042124a8:	be 01 00 00 00       	mov    $0x1,%esi
  80042124ad:	48 89 c7             	mov    %rax,%rdi
  80042124b0:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  80042124b7:	00 00 00 
  80042124ba:	ff d0                	callq  *%rax
  80042124bc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042124c0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042124c5:	74 35                	je     80042124fc <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  80042124c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042124cf:	48 83 f8 10          	cmp    $0x10,%rax
  80042124d3:	74 19                	je     80042124ee <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  80042124d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124d9:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042124dd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124e1:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042124e5:	48 01 d0             	add    %rdx,%rax
  80042124e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042124ec:	eb 21                	jmp    800421250f <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  80042124ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124f2:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042124f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042124fa:	eb 13                	jmp    800421250f <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  80042124fc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212500:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212504:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004212508:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  800421250f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004212512:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212516:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800421251a:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800421251e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212522:	4c 8b 00             	mov    (%rax),%r8
  8004212525:	4c 89 04 24          	mov    %r8,(%rsp)
  8004212529:	4c 8b 40 08          	mov    0x8(%rax),%r8
  800421252d:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004212532:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004212536:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  800421253b:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421253f:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004212544:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004212548:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  800421254d:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004212551:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004212556:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421255a:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800421255f:	48 b8 be 1e 21 04 80 	movabs $0x8004211ebe,%rax
  8004212566:	00 00 00 
  8004212569:	ff d0                	callq  *%rax
  800421256b:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  800421256e:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004212572:	75 07                	jne    800421257b <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004212574:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212579:	eb 12                	jmp    800421258d <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  800421257b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421257f:	74 07                	je     8004212588 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004212581:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212586:	eb 05                	jmp    800421258d <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004212588:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421258d:	c9                   	leaveq 
  800421258e:	c3                   	retq   

000000800421258f <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800421258f:	55                   	push   %rbp
  8004212590:	48 89 e5             	mov    %rsp,%rbp
  8004212593:	48 83 ec 70          	sub    $0x70,%rsp
  8004212597:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421259b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421259f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042125a3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  80042125a7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042125ac:	75 35                	jne    80042125e3 <dwarf_child+0x54>
  80042125ae:	48 b9 07 eb 21 04 80 	movabs $0x800421eb07,%rcx
  80042125b5:	00 00 00 
  80042125b8:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042125bf:	00 00 00 
  80042125c2:	be 1e 03 00 00       	mov    $0x31e,%esi
  80042125c7:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  80042125ce:	00 00 00 
  80042125d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042125d6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042125dd:	00 00 00 
  80042125e0:	41 ff d0             	callq  *%r8
	assert(ret_die);
  80042125e3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042125e8:	75 35                	jne    800421261f <dwarf_child+0x90>
  80042125ea:	48 b9 fc ea 21 04 80 	movabs $0x800421eafc,%rcx
  80042125f1:	00 00 00 
  80042125f4:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  80042125fb:	00 00 00 
  80042125fe:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004212603:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  800421260a:	00 00 00 
  800421260d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212612:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004212619:	00 00 00 
  800421261c:	41 ff d0             	callq  *%r8
	assert(dbg);
  800421261f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212624:	75 35                	jne    800421265b <dwarf_child+0xcc>
  8004212626:	48 b9 f8 ea 21 04 80 	movabs $0x800421eaf8,%rcx
  800421262d:	00 00 00 
  8004212630:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  8004212637:	00 00 00 
  800421263a:	be 20 03 00 00       	mov    $0x320,%esi
  800421263f:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  8004212646:	00 00 00 
  8004212649:	b8 00 00 00 00       	mov    $0x0,%eax
  800421264e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004212655:	00 00 00 
  8004212658:	41 ff d0             	callq  *%r8
	assert(cu);
  800421265b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004212660:	75 35                	jne    8004212697 <dwarf_child+0x108>
  8004212662:	48 b9 04 eb 21 04 80 	movabs $0x800421eb04,%rcx
  8004212669:	00 00 00 
  800421266c:	48 ba 6a e9 21 04 80 	movabs $0x800421e96a,%rdx
  8004212673:	00 00 00 
  8004212676:	be 21 03 00 00       	mov    $0x321,%esi
  800421267b:	48 bf 7f e9 21 04 80 	movabs $0x800421e97f,%rdi
  8004212682:	00 00 00 
  8004212685:	b8 00 00 00 00       	mov    $0x0,%eax
  800421268a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004212691:	00 00 00 
  8004212694:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004212697:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421269b:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800421269f:	84 c0                	test   %al,%al
  80042126a1:	75 0a                	jne    80042126ad <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  80042126a3:	b8 04 00 00 00       	mov    $0x4,%eax
  80042126a8:	e9 84 00 00 00       	jmpq   8004212731 <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  80042126ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042126b1:	48 8b 70 08          	mov    0x8(%rax),%rsi
  80042126b5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126b9:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  80042126bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042126c1:	48 8b 08             	mov    (%rax),%rcx
  80042126c4:	48 89 0c 24          	mov    %rcx,(%rsp)
  80042126c8:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042126cc:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  80042126d1:	48 8b 48 10          	mov    0x10(%rax),%rcx
  80042126d5:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  80042126da:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042126de:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  80042126e3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042126e7:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  80042126ec:	48 8b 48 28          	mov    0x28(%rax),%rcx
  80042126f0:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  80042126f5:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042126f9:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  80042126fe:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004212703:	48 b8 be 1e 21 04 80 	movabs $0x8004211ebe,%rax
  800421270a:	00 00 00 
  800421270d:	ff d0                	callq  *%rax
  800421270f:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004212712:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004212716:	75 07                	jne    800421271f <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004212718:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421271d:	eb 12                	jmp    8004212731 <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  800421271f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212723:	74 07                	je     800421272c <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004212725:	b8 01 00 00 00       	mov    $0x1,%eax
  800421272a:	eb 05                	jmp    8004212731 <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  800421272c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212731:	c9                   	leaveq 
  8004212732:	c3                   	retq   

0000008004212733 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004212733:	55                   	push   %rbp
  8004212734:	48 89 e5             	mov    %rsp,%rbp
  8004212737:	48 83 ec 20          	sub    $0x20,%rsp
  800421273b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  800421273f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212743:	48 8b 00             	mov    (%rax),%rax
  8004212746:	48 89 c7             	mov    %rax,%rdi
  8004212749:	48 b8 d4 5a 21 04 80 	movabs $0x8004215ad4,%rax
  8004212750:	00 00 00 
  8004212753:	ff d0                	callq  *%rax
  8004212755:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004212759:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421275d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212761:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212765:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004212769:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421276d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212771:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212775:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004212779:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421277d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212785:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004212789:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800421278e:	c9                   	leaveq 
  800421278f:	c3                   	retq   

0000008004212790 <_dwarf_frame_params_init>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);


void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004212790:	55                   	push   %rbp
  8004212791:	48 89 e5             	mov    %rsp,%rbp
  8004212794:	48 83 ec 08          	sub    $0x8,%rsp
  8004212798:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  800421279c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127a0:	66 c7 40 40 42 00    	movw   $0x42,0x40(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  80042127a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127aa:	66 c7 40 42 0b 04    	movw   $0x40b,0x42(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  80042127b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127b4:	66 c7 40 44 9c 05    	movw   $0x59c,0x44(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  80042127ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127be:	66 c7 40 46 0b 04    	movw   $0x40b,0x46(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  80042127c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127c8:	66 c7 40 48 0a 04    	movw   $0x40a,0x48(%rax)
}
  80042127ce:	c9                   	leaveq 
  80042127cf:	c3                   	retq   

00000080042127d0 <dwarf_get_fde_at_pc>:


int
dwarf_get_fde_at_pc(Dwarf_Addr pc,
		    Dwarf_Addr *lopc, Dwarf_Addr *hipc, struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie, Dwarf_Error *error)
{
  80042127d0:	55                   	push   %rbp
  80042127d1:	48 89 e5             	mov    %rsp,%rbp
  80042127d4:	48 83 ec 40          	sub    $0x40,%rsp
  80042127d8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042127dc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042127e0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042127e4:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042127e8:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  80042127ec:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	Dwarf_Fde fde = ret_fde;
  80042127f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042127f4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  80042127f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042127fc:	ba 80 00 00 00       	mov    $0x80,%edx
  8004212801:	be 00 00 00 00       	mov    $0x0,%esi
  8004212806:	48 89 c7             	mov    %rax,%rdi
  8004212809:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004212810:	00 00 00 
  8004212813:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004212815:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212819:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421281d:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) {
  8004212821:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212826:	74 12                	je     800421283a <dwarf_get_fde_at_pc+0x6a>
  8004212828:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421282d:	74 0b                	je     800421283a <dwarf_get_fde_at_pc+0x6a>
  800421282f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212834:	0f 85 a3 00 00 00    	jne    80042128dd <dwarf_get_fde_at_pc+0x10d>
                return (DW_DLV_ERROR);
  800421283a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421283f:	e9 ca 00 00 00       	jmpq   800421290e <dwarf_get_fde_at_pc+0x13e>
        }

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, is_eh_frame, error, fde) < 0)
  8004212844:	48 b8 40 06 23 04 80 	movabs $0x8004230640,%rax
  800421284b:	00 00 00 
  800421284e:	8b 30                	mov    (%rax),%esi
  8004212850:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004212857:	00 00 00 
  800421285a:	48 8b 00             	mov    (%rax),%rax
  800421285d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004212861:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212865:	48 89 c7             	mov    %rax,%rdi
  8004212868:	48 b8 3e 4a 21 04 80 	movabs $0x8004214a3e,%rax
  800421286f:	00 00 00 
  8004212872:	ff d0                	callq  *%rax
  8004212874:	85 c0                	test   %eax,%eax
  8004212876:	79 0a                	jns    8004212882 <dwarf_get_fde_at_pc+0xb2>
		{
			return DW_DLV_NO_ENTRY;
  8004212878:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421287d:	e9 8c 00 00 00       	jmpq   800421290e <dwarf_get_fde_at_pc+0x13e>
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004212882:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212886:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421288a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421288e:	77 4e                	ja     80042128de <dwarf_get_fde_at_pc+0x10e>
  8004212890:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212894:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange) {
  8004212898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421289c:	48 8b 40 38          	mov    0x38(%rax),%rax
        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, is_eh_frame, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042128a0:	48 01 d0             	add    %rdx,%rax
  80042128a3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042128a7:	76 35                	jbe    80042128de <dwarf_get_fde_at_pc+0x10e>
                    fde->fde_adrange) {
                        *lopc = fde->fde_initloc;
  80042128a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128ad:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042128b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042128b5:	48 89 10             	mov    %rdx,(%rax)
                        *hipc = fde->fde_initloc + fde->fde_adrange - 1;
  80042128b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128bc:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042128c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128c4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042128c8:	48 01 d0             	add    %rdx,%rax
  80042128cb:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042128cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042128d3:	48 89 10             	mov    %rdx,(%rax)

                        return (DW_DLV_OK);
  80042128d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042128db:	eb 31                	jmp    800421290e <dwarf_get_fde_at_pc+0x13e>
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) {
                return (DW_DLV_ERROR);
        }

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  80042128dd:	90                   	nop
  80042128de:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042128e5:	00 00 00 
  80042128e8:	48 8b 00             	mov    (%rax),%rax
  80042128eb:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042128ef:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042128f6:	00 00 00 
  80042128f9:	48 8b 00             	mov    (%rax),%rax
  80042128fc:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212900:	48 39 c2             	cmp    %rax,%rdx
  8004212903:	0f 82 3b ff ff ff    	jb     8004212844 <dwarf_get_fde_at_pc+0x74>
                        return (DW_DLV_OK);
                }
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004212909:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800421290e:	c9                   	leaveq 
  800421290f:	c3                   	retq   

0000008004212910 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004212910:	55                   	push   %rbp
  8004212911:	48 89 e5             	mov    %rsp,%rbp
  8004212914:	48 83 ec 30          	sub    $0x30,%rsp
  8004212918:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421291c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212920:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004212924:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
        int i;

        assert(dest != NULL);
  8004212928:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421292d:	75 35                	jne    8004212964 <_dwarf_frame_regtable_copy+0x54>
  800421292f:	48 b9 1a eb 21 04 80 	movabs $0x800421eb1a,%rcx
  8004212936:	00 00 00 
  8004212939:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  8004212940:	00 00 00 
  8004212943:	be 63 00 00 00       	mov    $0x63,%esi
  8004212948:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  800421294f:	00 00 00 
  8004212952:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212957:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421295e:	00 00 00 
  8004212961:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004212964:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212969:	75 35                	jne    80042129a0 <_dwarf_frame_regtable_copy+0x90>
  800421296b:	48 b9 52 eb 21 04 80 	movabs $0x800421eb52,%rcx
  8004212972:	00 00 00 
  8004212975:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  800421297c:	00 00 00 
  800421297f:	be 64 00 00 00       	mov    $0x64,%esi
  8004212984:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  800421298b:	00 00 00 
  800421298e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212993:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421299a:	00 00 00 
  800421299d:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  80042129a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129a4:	48 8b 00             	mov    (%rax),%rax
  80042129a7:	48 85 c0             	test   %rax,%rax
  80042129aa:	75 39                	jne    80042129e5 <_dwarf_frame_regtable_copy+0xd5>
		*dest = &global_rt_table_shadow;
  80042129ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129b0:	48 ba e0 36 48 04 80 	movabs $0x80044836e0,%rdx
  80042129b7:	00 00 00 
  80042129ba:	48 89 10             	mov    %rdx,(%rax)
                /*if ((*dest = malloc(sizeof(Dwarf_Regtable3))) == NULL) {
		  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
		  return (DW_DLE_MEMORY);
		  }*/
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  80042129bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129c1:	48 8b 00             	mov    (%rax),%rax
  80042129c4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042129c8:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  80042129cc:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  80042129d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129d4:	48 8b 00             	mov    (%rax),%rax
  80042129d7:	48 ba 60 38 48 04 80 	movabs $0x8004483860,%rdx
  80042129de:	00 00 00 
  80042129e1:	48 89 50 20          	mov    %rdx,0x20(%rax)
		  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
		  return (DW_DLE_MEMORY);
		  }*/
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042129e5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042129e9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042129ed:	48 8b 00             	mov    (%rax),%rax
  80042129f0:	ba 18 00 00 00       	mov    $0x18,%edx
  80042129f5:	48 89 ce             	mov    %rcx,%rsi
  80042129f8:	48 89 c7             	mov    %rax,%rdi
  80042129fb:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  8004212a02:	00 00 00 
  8004212a05:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212a07:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212a0e:	eb 5a                	jmp    8004212a6a <_dwarf_frame_regtable_copy+0x15a>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004212a10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212a14:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a18:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212a1b:	48 63 d0             	movslq %eax,%rdx
  8004212a1e:	48 89 d0             	mov    %rdx,%rax
  8004212a21:	48 01 c0             	add    %rax,%rax
  8004212a24:	48 01 d0             	add    %rdx,%rax
  8004212a27:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a2b:	48 01 c1             	add    %rax,%rcx
  8004212a2e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a32:	48 8b 00             	mov    (%rax),%rax
  8004212a35:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212a39:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212a3c:	48 63 d0             	movslq %eax,%rdx
  8004212a3f:	48 89 d0             	mov    %rdx,%rax
  8004212a42:	48 01 c0             	add    %rax,%rax
  8004212a45:	48 01 d0             	add    %rdx,%rax
  8004212a48:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a4c:	48 01 f0             	add    %rsi,%rax
  8004212a4f:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212a54:	48 89 ce             	mov    %rcx,%rsi
  8004212a57:	48 89 c7             	mov    %rax,%rdi
  8004212a5a:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  8004212a61:	00 00 00 
  8004212a64:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004212a66:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212a6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a6e:	48 8b 00             	mov    (%rax),%rax
  8004212a71:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212a75:	0f b7 c0             	movzwl %ax,%eax
  8004212a78:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212a7b:	7e 46                	jle    8004212ac3 <_dwarf_frame_regtable_copy+0x1b3>
		     i < src->rt3_reg_table_size; i++)
  8004212a7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212a81:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212a85:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004212a88:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212a8b:	7f 83                	jg     8004212a10 <_dwarf_frame_regtable_copy+0x100>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212a8d:	eb 34                	jmp    8004212ac3 <_dwarf_frame_regtable_copy+0x1b3>
                (*dest)->rt3_rules[i].dw_regnum =
  8004212a8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a93:	48 8b 00             	mov    (%rax),%rax
  8004212a96:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a9a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212a9d:	48 63 d0             	movslq %eax,%rdx
  8004212aa0:	48 89 d0             	mov    %rdx,%rax
  8004212aa3:	48 01 c0             	add    %rax,%rax
  8004212aa6:	48 01 d0             	add    %rdx,%rax
  8004212aa9:	48 c1 e0 03          	shl    $0x3,%rax
  8004212aad:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004212ab1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ab5:	0f b7 40 48          	movzwl 0x48(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  8004212ab9:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004212abd:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004212ac1:	eb 01                	jmp    8004212ac4 <_dwarf_frame_regtable_copy+0x1b4>
  8004212ac3:	90                   	nop
  8004212ac4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ac8:	48 8b 00             	mov    (%rax),%rax
  8004212acb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212acf:	0f b7 c0             	movzwl %ax,%eax
  8004212ad2:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212ad5:	7f b8                	jg     8004212a8f <_dwarf_frame_regtable_copy+0x17f>
                (*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004212ad7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212adc:	c9                   	leaveq 
  8004212add:	c3                   	retq   

0000008004212ade <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004212ade:	55                   	push   %rbp
  8004212adf:	48 89 e5             	mov    %rsp,%rbp
  8004212ae2:	53                   	push   %rbx
  8004212ae3:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004212aea:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004212aee:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004212af2:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004212af6:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004212afa:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004212b01:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)

#ifdef FRAME_DEBUG
        printf("frame_run_inst: (caf=%ju, daf=%jd)\n", caf, daf);
#endif

        ret = DW_DLE_NONE;
  8004212b08:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  8004212b0f:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004212b16:	00 
  8004212b17:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004212b1b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  8004212b1f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212b23:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212b27:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004212b2a:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212b2e:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212b32:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004212b36:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212b3a:	48 89 c7             	mov    %rax,%rdi
  8004212b3d:	48 b8 10 29 21 04 80 	movabs $0x8004212910,%rax
  8004212b44:	00 00 00 
  8004212b47:	ff d0                	callq  *%rax
        p = insts;
  8004212b49:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004212b4d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  8004212b51:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b55:	48 03 45 80          	add    -0x80(%rbp),%rax
  8004212b59:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  8004212b5d:	e9 7c 0d 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>

#ifdef FRAME_DEBUG
                printf("p=%p pe=%p pc=%#jx pc_req=%#jx\n", p, pe, pc, pc_req);
#endif

                if (*p == DW_CFA_nop) {
  8004212b62:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b66:	0f b6 00             	movzbl (%rax),%eax
  8004212b69:	84 c0                	test   %al,%al
  8004212b6b:	75 11                	jne    8004212b7e <_dwarf_frame_run_inst+0xa0>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_nop\n");
#endif
                        p++;
  8004212b6d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b71:	48 83 c0 01          	add    $0x1,%rax
  8004212b75:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  8004212b79:	e9 60 0d 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                }

                high2 = *p & 0xc0;
  8004212b7e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b82:	0f b6 00             	movzbl (%rax),%eax
  8004212b85:	83 e0 c0             	and    $0xffffffc0,%eax
  8004212b88:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  8004212b8b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b8f:	0f b6 00             	movzbl (%rax),%eax
  8004212b92:	83 e0 3f             	and    $0x3f,%eax
  8004212b95:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  8004212b98:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b9c:	48 83 c0 01          	add    $0x1,%rax
  8004212ba0:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  8004212ba4:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004212ba8:	0f 84 a1 01 00 00    	je     8004212d4f <_dwarf_frame_run_inst+0x271>
                        switch (high2) {
  8004212bae:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004212bb2:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004212bb7:	74 37                	je     8004212bf0 <_dwarf_frame_run_inst+0x112>
  8004212bb9:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004212bbe:	0f 84 00 01 00 00    	je     8004212cc4 <_dwarf_frame_run_inst+0x1e6>
  8004212bc4:	83 f8 40             	cmp    $0x40,%eax
  8004212bc7:	0f 85 70 01 00 00    	jne    8004212d3d <_dwarf_frame_run_inst+0x25f>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004212bcd:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212bd1:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212bd8:	ff 
  8004212bd9:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                                printf("DW_CFA_advance_loc(%#jx(%u))\n", pc,
				       low6);
#endif
                                if (pc_req < pc)
  8004212bdd:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212be1:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212be5:	0f 83 5e 01 00 00    	jae    8004212d49 <_dwarf_frame_run_inst+0x26b>
                                        goto program_done;
  8004212beb:	e9 ff 0c 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                                break;
                        case DW_CFA_offset:
                                *row_pc = pc;
  8004212bf0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212bf4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212bf8:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004212bfb:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212bff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c03:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212c07:	66 39 c2             	cmp    %ax,%dx
  8004212c0a:	72 0c                	jb     8004212c18 <_dwarf_frame_run_inst+0x13a>
  8004212c0c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212c13:	e9 d7 0c 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                                RL[low6].dw_offset_relevant = 1;
  8004212c18:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c1c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c20:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c24:	48 89 d0             	mov    %rdx,%rax
  8004212c27:	48 01 c0             	add    %rax,%rax
  8004212c2a:	48 01 d0             	add    %rdx,%rax
  8004212c2d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c31:	48 01 c8             	add    %rcx,%rax
  8004212c34:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004212c37:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c3b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c3f:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c43:	48 89 d0             	mov    %rdx,%rax
  8004212c46:	48 01 c0             	add    %rax,%rax
  8004212c49:	48 01 d0             	add    %rdx,%rax
  8004212c4c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c50:	48 01 c8             	add    %rcx,%rax
  8004212c53:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212c57:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c5b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c5f:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c63:	48 89 d0             	mov    %rdx,%rax
  8004212c66:	48 01 c0             	add    %rax,%rax
  8004212c69:	48 01 d0             	add    %rdx,%rax
  8004212c6c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c70:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212c74:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212c78:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004212c7c:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  8004212c80:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c84:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212c88:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212c8c:	48 89 d0             	mov    %rdx,%rax
  8004212c8f:	48 01 c0             	add    %rax,%rax
  8004212c92:	48 01 d0             	add    %rdx,%rax
  8004212c95:	48 c1 e0 03          	shl    $0x3,%rax
  8004212c99:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004212c9d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ca1:	48 89 c7             	mov    %rax,%rdi
  8004212ca4:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004212cab:	00 00 00 
  8004212cae:	ff d0                	callq  *%rax
  8004212cb0:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212cb7:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  8004212cbb:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
#ifdef FRAME_DEBUG
                                printf("DW_CFA_offset(%jd)\n",
				       RL[low6].dw_offset_or_block_len);
#endif
                                break;
  8004212cbf:	e9 86 00 00 00       	jmpq   8004212d4a <_dwarf_frame_run_inst+0x26c>
                        case DW_CFA_restore:
                                *row_pc = pc;
  8004212cc4:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212cc8:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212ccc:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004212ccf:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212cd3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cd7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212cdb:	66 39 c2             	cmp    %ax,%dx
  8004212cde:	72 0c                	jb     8004212cec <_dwarf_frame_run_inst+0x20e>
  8004212ce0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212ce7:	e9 03 0c 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                                memcpy(&RL[low6], &INITRL[low6],
  8004212cec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212cf0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cf4:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212cf8:	48 89 d0             	mov    %rdx,%rax
  8004212cfb:	48 01 c0             	add    %rax,%rax
  8004212cfe:	48 01 d0             	add    %rdx,%rax
  8004212d01:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d05:	48 01 c1             	add    %rax,%rcx
  8004212d08:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d0c:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212d10:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212d14:	48 89 d0             	mov    %rdx,%rax
  8004212d17:	48 01 c0             	add    %rax,%rax
  8004212d1a:	48 01 d0             	add    %rdx,%rax
  8004212d1d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d21:	48 01 f0             	add    %rsi,%rax
  8004212d24:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212d29:	48 89 ce             	mov    %rcx,%rsi
  8004212d2c:	48 89 c7             	mov    %rax,%rdi
  8004212d2f:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  8004212d36:	00 00 00 
  8004212d39:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
#ifdef FRAME_DEBUG
                                printf("DW_CFA_restore(%u)\n", low6);
#endif
                                break;
  8004212d3b:	eb 0d                	jmp    8004212d4a <_dwarf_frame_run_inst+0x26c>
                        default:
                                DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212d3d:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  8004212d44:	e9 a6 0b 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                                printf("DW_CFA_advance_loc(%#jx(%u))\n", pc,
				       low6);
#endif
                                if (pc_req < pc)
                                        goto program_done;
                                break;
  8004212d49:	90                   	nop
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
                                goto program_done;
                        }

                        continue;
  8004212d4a:	e9 8f 0b 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                }

                switch (low6) {
  8004212d4f:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212d53:	83 f8 16             	cmp    $0x16,%eax
  8004212d56:	0f 87 72 0b 00 00    	ja     80042138ce <_dwarf_frame_run_inst+0xdf0>
  8004212d5c:	89 c0                	mov    %eax,%eax
  8004212d5e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212d65:	00 
  8004212d66:	48 b8 88 eb 21 04 80 	movabs $0x800421eb88,%rax
  8004212d6d:	00 00 00 
  8004212d70:	48 01 d0             	add    %rdx,%rax
  8004212d73:	48 8b 00             	mov    (%rax),%rax
  8004212d76:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
			printf("dbg pointersize :%x\n",dbg->dbg_pointer_size);
  8004212d78:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212d7c:	8b 40 28             	mov    0x28(%rax),%eax
  8004212d7f:	89 c6                	mov    %eax,%esi
  8004212d81:	48 bf 5e eb 21 04 80 	movabs $0x800421eb5e,%rdi
  8004212d88:	00 00 00 
  8004212d8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d90:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004212d97:	00 00 00 
  8004212d9a:	ff d2                	callq  *%rdx
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004212d9c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212da0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212da4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212da8:	8b 50 28             	mov    0x28(%rax),%edx
  8004212dab:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212daf:	89 d6                	mov    %edx,%esi
  8004212db1:	48 89 c7             	mov    %rax,%rdi
  8004212db4:	ff d1                	callq  *%rcx
  8004212db6:	48 89 45 10          	mov    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004212dba:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212dbe:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212dc2:	0f 83 26 0b 00 00    	jae    80042138ee <_dwarf_frame_run_inst+0xe10>
				printf("Program done\n");
  8004212dc8:	48 bf 73 eb 21 04 80 	movabs $0x800421eb73,%rdi
  8004212dcf:	00 00 00 
  8004212dd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212dd7:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004212dde:	00 00 00 
  8004212de1:	ff d2                	callq  *%rdx
			goto program_done;
  8004212de3:	e9 06 0b 00 00       	jmpq   80042138ee <_dwarf_frame_run_inst+0xe10>
                        break;
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  8004212de8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212dec:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004212df0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212df4:	be 01 00 00 00       	mov    $0x1,%esi
  8004212df9:	48 89 c7             	mov    %rax,%rdi
  8004212dfc:	ff d2                	callq  *%rdx
  8004212dfe:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212e05:	ff 
  8004212e06:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc1(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004212e0a:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212e0e:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212e12:	0f 83 bf 0a 00 00    	jae    80042138d7 <_dwarf_frame_run_inst+0xdf9>
                                goto program_done;
  8004212e18:	e9 d2 0a 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        break;
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  8004212e1d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212e21:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004212e25:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e29:	be 02 00 00 00       	mov    $0x2,%esi
  8004212e2e:	48 89 c7             	mov    %rax,%rdi
  8004212e31:	ff d2                	callq  *%rdx
  8004212e33:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212e3a:	ff 
  8004212e3b:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc2(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004212e3f:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212e43:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212e47:	0f 83 8d 0a 00 00    	jae    80042138da <_dwarf_frame_run_inst+0xdfc>
                                goto program_done;
  8004212e4d:	e9 9d 0a 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        break;
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  8004212e52:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212e56:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004212e5a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e5e:	be 04 00 00 00       	mov    $0x4,%esi
  8004212e63:	48 89 c7             	mov    %rax,%rdi
  8004212e66:	ff d2                	callq  *%rdx
  8004212e68:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004212e6f:	ff 
  8004212e70:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc4(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004212e74:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212e78:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212e7c:	0f 83 5b 0a 00 00    	jae    80042138dd <_dwarf_frame_run_inst+0xdff>
                                goto program_done;
  8004212e82:	e9 68 0a 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        break;
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  8004212e87:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212e8b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212e8f:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212e92:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e96:	48 89 c7             	mov    %rax,%rdi
  8004212e99:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004212ea0:	00 00 00 
  8004212ea3:	ff d0                	callq  *%rax
  8004212ea5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212ea9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ead:	48 89 c7             	mov    %rax,%rdi
  8004212eb0:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004212eb7:	00 00 00 
  8004212eba:	ff d0                	callq  *%rax
  8004212ebc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212ec0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ec4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212ec8:	0f b7 c0             	movzwl %ax,%eax
  8004212ecb:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212ecf:	77 0c                	ja     8004212edd <_dwarf_frame_run_inst+0x3ff>
  8004212ed1:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212ed8:	e9 12 0a 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  8004212edd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ee1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ee5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ee9:	48 89 d0             	mov    %rdx,%rax
  8004212eec:	48 01 c0             	add    %rax,%rax
  8004212eef:	48 01 d0             	add    %rdx,%rax
  8004212ef2:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ef6:	48 01 c8             	add    %rcx,%rax
  8004212ef9:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212efc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f00:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f04:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f08:	48 89 d0             	mov    %rdx,%rax
  8004212f0b:	48 01 c0             	add    %rax,%rax
  8004212f0e:	48 01 d0             	add    %rdx,%rax
  8004212f11:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f15:	48 01 c8             	add    %rcx,%rax
  8004212f18:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212f1c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f20:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f24:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f28:	48 89 d0             	mov    %rdx,%rax
  8004212f2b:	48 01 c0             	add    %rax,%rax
  8004212f2e:	48 01 d0             	add    %rdx,%rax
  8004212f31:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f35:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212f39:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212f3d:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004212f41:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212f45:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f49:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212f4d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f51:	48 89 d0             	mov    %rdx,%rax
  8004212f54:	48 01 c0             	add    %rax,%rax
  8004212f57:	48 01 d0             	add    %rdx,%rax
  8004212f5a:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f5e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212f62:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212f69:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212f6e:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_offset_extended(reg=%ju,uoff=%ju)\n",
			       reg, uoff);
#endif
                        break;
  8004212f72:	e9 67 09 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  8004212f77:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212f7b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212f7f:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212f82:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212f86:	48 89 c7             	mov    %rax,%rdi
  8004212f89:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004212f90:	00 00 00 
  8004212f93:	ff d0                	callq  *%rax
  8004212f95:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212f99:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f9d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212fa1:	0f b7 c0             	movzwl %ax,%eax
  8004212fa4:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212fa8:	77 0c                	ja     8004212fb6 <_dwarf_frame_run_inst+0x4d8>
  8004212faa:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212fb1:	e9 39 09 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        memcpy(&RL[reg], &INITRL[reg],
  8004212fb6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212fba:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212fbe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212fc2:	48 89 d0             	mov    %rdx,%rax
  8004212fc5:	48 01 c0             	add    %rax,%rax
  8004212fc8:	48 01 d0             	add    %rdx,%rax
  8004212fcb:	48 c1 e0 03          	shl    $0x3,%rax
  8004212fcf:	48 01 c1             	add    %rax,%rcx
  8004212fd2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212fd6:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212fda:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212fde:	48 89 d0             	mov    %rdx,%rax
  8004212fe1:	48 01 c0             	add    %rax,%rax
  8004212fe4:	48 01 d0             	add    %rdx,%rax
  8004212fe7:	48 c1 e0 03          	shl    $0x3,%rax
  8004212feb:	48 01 f0             	add    %rsi,%rax
  8004212fee:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212ff3:	48 89 ce             	mov    %rcx,%rsi
  8004212ff6:	48 89 c7             	mov    %rax,%rdi
  8004212ff9:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  8004213000:	00 00 00 
  8004213003:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
#ifdef FRAME_DEBUG
                        printf("DW_CFA_restore_extended(%ju)\n", reg);
#endif
                        break;
  8004213005:	e9 d4 08 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_undefined:
                        *row_pc = pc;
  800421300a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421300e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213012:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213015:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213019:	48 89 c7             	mov    %rax,%rdi
  800421301c:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213023:	00 00 00 
  8004213026:	ff d0                	callq  *%rax
  8004213028:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421302c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213030:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213034:	0f b7 c0             	movzwl %ax,%eax
  8004213037:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421303b:	77 0c                	ja     8004213049 <_dwarf_frame_run_inst+0x56b>
  800421303d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213044:	e9 a6 08 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  8004213049:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421304d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213051:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213055:	48 89 d0             	mov    %rdx,%rax
  8004213058:	48 01 c0             	add    %rax,%rax
  800421305b:	48 01 d0             	add    %rdx,%rax
  800421305e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213062:	48 01 c8             	add    %rcx,%rax
  8004213065:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004213068:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421306c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213070:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213074:	48 89 d0             	mov    %rdx,%rax
  8004213077:	48 01 c0             	add    %rax,%rax
  800421307a:	48 01 d0             	add    %rdx,%rax
  800421307d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213081:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213085:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213089:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  800421308d:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_undefined(%ju)\n", reg);
#endif
                        break;
  8004213091:	e9 48 08 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  8004213096:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421309a:	48 89 c7             	mov    %rax,%rdi
  800421309d:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042130a4:	00 00 00 
  80042130a7:	ff d0                	callq  *%rax
  80042130a9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042130ad:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042130b1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042130b5:	0f b7 c0             	movzwl %ax,%eax
  80042130b8:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042130bc:	77 0c                	ja     80042130ca <_dwarf_frame_run_inst+0x5ec>
  80042130be:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042130c5:	e9 25 08 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  80042130ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042130ce:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042130d2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042130d6:	48 89 d0             	mov    %rdx,%rax
  80042130d9:	48 01 c0             	add    %rax,%rax
  80042130dc:	48 01 d0             	add    %rdx,%rax
  80042130df:	48 c1 e0 03          	shl    $0x3,%rax
  80042130e3:	48 01 c8             	add    %rcx,%rax
  80042130e6:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  80042130e9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042130ed:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042130f1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042130f5:	48 89 d0             	mov    %rdx,%rax
  80042130f8:	48 01 c0             	add    %rax,%rax
  80042130fb:	48 01 d0             	add    %rdx,%rax
  80042130fe:	48 c1 e0 03          	shl    $0x3,%rax
  8004213102:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213106:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421310a:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  800421310e:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_same_value(%ju)\n", reg);
#endif
                        break;
  8004213112:	e9 c7 07 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_register:
                        *row_pc = pc;
  8004213117:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421311b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421311f:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213122:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213126:	48 89 c7             	mov    %rax,%rdi
  8004213129:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213130:	00 00 00 
  8004213133:	ff d0                	callq  *%rax
  8004213135:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  8004213139:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421313d:	48 89 c7             	mov    %rax,%rdi
  8004213140:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213147:	00 00 00 
  800421314a:	ff d0                	callq  *%rax
  800421314c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213150:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213154:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213158:	0f b7 c0             	movzwl %ax,%eax
  800421315b:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421315f:	77 0c                	ja     800421316d <_dwarf_frame_run_inst+0x68f>
  8004213161:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213168:	e9 82 07 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  800421316d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213171:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213175:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213179:	48 89 d0             	mov    %rdx,%rax
  800421317c:	48 01 c0             	add    %rax,%rax
  800421317f:	48 01 d0             	add    %rdx,%rax
  8004213182:	48 c1 e0 03          	shl    $0x3,%rax
  8004213186:	48 01 c8             	add    %rcx,%rax
  8004213189:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  800421318c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213190:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213194:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213198:	48 89 d0             	mov    %rdx,%rax
  800421319b:	48 01 c0             	add    %rax,%rax
  800421319e:	48 01 d0             	add    %rdx,%rax
  80042131a1:	48 c1 e0 03          	shl    $0x3,%rax
  80042131a5:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042131a9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042131ad:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_register(reg=%ju,reg2=%ju)\n", reg,
			       reg2);
#endif
                        break;
  80042131b1:	e9 28 07 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  80042131b6:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042131ba:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042131be:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  80042131c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042131c6:	48 89 c7             	mov    %rax,%rdi
  80042131c9:	48 b8 10 29 21 04 80 	movabs $0x8004212910,%rax
  80042131d0:	00 00 00 
  80042131d3:	ff d0                	callq  *%rax
#ifdef FRAME_DEBUG
                        printf("DW_CFA_remember_state\n");
#endif
                        break;
  80042131d5:	e9 04 07 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  80042131da:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042131de:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042131e2:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  80042131e5:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042131e9:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042131ed:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  80042131f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042131f5:	48 89 c7             	mov    %rax,%rdi
  80042131f8:	48 b8 10 29 21 04 80 	movabs $0x8004212910,%rax
  80042131ff:	00 00 00 
  8004213202:	ff d0                	callq  *%rax
#ifdef FRAME_DEBUG
                        printf("DW_CFA_restore_state\n");
#endif
                        break;
  8004213204:	e9 d5 06 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004213209:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421320d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213211:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213214:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213218:	48 89 c7             	mov    %rax,%rdi
  800421321b:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213222:	00 00 00 
  8004213225:	ff d0                	callq  *%rax
  8004213227:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  800421322b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421322f:	48 89 c7             	mov    %rax,%rdi
  8004213232:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213239:	00 00 00 
  800421323c:	ff d0                	callq  *%rax
  800421323e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004213242:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213246:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213249:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421324d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004213251:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213255:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213259:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  800421325d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213261:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213265:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa(reg=%ju,uoff=%ju)\n", reg, uoff);
#endif
                        break;
  8004213269:	e9 70 06 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  800421326e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213272:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213276:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213279:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421327d:	48 89 c7             	mov    %rax,%rdi
  8004213280:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213287:	00 00 00 
  800421328a:	ff d0                	callq  *%rax
  800421328c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  8004213290:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213294:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213298:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * here.
                         */
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_register(%ju)\n", reg);
#endif
                        break;
  800421329c:	e9 3d 06 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  80042132a1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042132a5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042132a9:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  80042132ac:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042132b0:	48 89 c7             	mov    %rax,%rdi
  80042132b3:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042132ba:	00 00 00 
  80042132bd:	ff d0                	callq  *%rax
  80042132bf:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042132c3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132c7:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042132ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132ce:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  80042132d2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132d6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042132da:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_offset(%ju)\n", uoff);
#endif
                        break;
  80042132de:	e9 fb 05 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  80042132e3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042132e7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042132eb:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  80042132ee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132f2:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  80042132f5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132f9:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  80042132fd:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004213301:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213305:	48 89 c7             	mov    %rax,%rdi
  8004213308:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  800421330f:	00 00 00 
  8004213312:	ff d0                	callq  *%rax
  8004213314:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004213318:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421331c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213320:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  8004213324:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213328:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421332c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213330:	48 01 d0             	add    %rdx,%rax
  8004213333:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_expression\n");
#endif
                        break;
  8004213337:	e9 a2 05 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_expression:
                        *row_pc = pc;
  800421333c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213340:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213344:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213347:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421334b:	48 89 c7             	mov    %rax,%rdi
  800421334e:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213355:	00 00 00 
  8004213358:	ff d0                	callq  *%rax
  800421335a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421335e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213362:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213366:	0f b7 c0             	movzwl %ax,%eax
  8004213369:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421336d:	77 0c                	ja     800421337b <_dwarf_frame_run_inst+0x89d>
  800421336f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213376:	e9 74 05 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  800421337b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421337f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213383:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213387:	48 89 d0             	mov    %rdx,%rax
  800421338a:	48 01 c0             	add    %rax,%rax
  800421338d:	48 01 d0             	add    %rdx,%rax
  8004213390:	48 c1 e0 03          	shl    $0x3,%rax
  8004213394:	48 01 c8             	add    %rcx,%rax
  8004213397:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  800421339a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421339e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133a2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042133a6:	48 89 d0             	mov    %rdx,%rax
  80042133a9:	48 01 c0             	add    %rax,%rax
  80042133ac:	48 01 d0             	add    %rdx,%rax
  80042133af:	48 c1 e0 03          	shl    $0x3,%rax
  80042133b3:	48 01 c8             	add    %rcx,%rax
  80042133b6:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  80042133ba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133be:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133c2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042133c6:	48 89 d0             	mov    %rdx,%rax
  80042133c9:	48 01 c0             	add    %rax,%rax
  80042133cc:	48 01 d0             	add    %rdx,%rax
  80042133cf:	48 c1 e0 03          	shl    $0x3,%rax
  80042133d3:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  80042133d7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042133db:	48 89 c7             	mov    %rax,%rdi
  80042133de:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042133e5:	00 00 00 
  80042133e8:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  80042133ea:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  80042133ee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133f2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042133fa:	48 89 d0             	mov    %rdx,%rax
  80042133fd:	48 01 c0             	add    %rax,%rax
  8004213400:	48 01 d0             	add    %rdx,%rax
  8004213403:	48 c1 e0 03          	shl    $0x3,%rax
  8004213407:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421340b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421340f:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004213413:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004213417:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421341b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421341f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213423:	48 89 d0             	mov    %rdx,%rax
  8004213426:	48 01 c0             	add    %rax,%rax
  8004213429:	48 01 d0             	add    %rdx,%rax
  800421342c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213430:	48 01 f0             	add    %rsi,%rax
  8004213433:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213437:	48 01 c8             	add    %rcx,%rax
  800421343a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_expression\n");
#endif
                        break;
  800421343e:	e9 9b 04 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  8004213443:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213447:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421344b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421344e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213452:	48 89 c7             	mov    %rax,%rdi
  8004213455:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  800421345c:	00 00 00 
  800421345f:	ff d0                	callq  *%rax
  8004213461:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004213465:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213469:	48 89 c7             	mov    %rax,%rdi
  800421346c:	48 b8 d5 0e 21 04 80 	movabs $0x8004210ed5,%rax
  8004213473:	00 00 00 
  8004213476:	ff d0                	callq  *%rax
  8004213478:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421347c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213480:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213484:	0f b7 c0             	movzwl %ax,%eax
  8004213487:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421348b:	77 0c                	ja     8004213499 <_dwarf_frame_run_inst+0x9bb>
  800421348d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213494:	e9 56 04 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  8004213499:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421349d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134a1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042134a5:	48 89 d0             	mov    %rdx,%rax
  80042134a8:	48 01 c0             	add    %rax,%rax
  80042134ab:	48 01 d0             	add    %rdx,%rax
  80042134ae:	48 c1 e0 03          	shl    $0x3,%rax
  80042134b2:	48 01 c8             	add    %rcx,%rax
  80042134b5:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  80042134b8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134bc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134c0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042134c4:	48 89 d0             	mov    %rdx,%rax
  80042134c7:	48 01 c0             	add    %rax,%rax
  80042134ca:	48 01 d0             	add    %rdx,%rax
  80042134cd:	48 c1 e0 03          	shl    $0x3,%rax
  80042134d1:	48 01 c8             	add    %rcx,%rax
  80042134d4:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042134d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134dc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134e0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042134e4:	48 89 d0             	mov    %rdx,%rax
  80042134e7:	48 01 c0             	add    %rax,%rax
  80042134ea:	48 01 d0             	add    %rdx,%rax
  80042134ed:	48 c1 e0 03          	shl    $0x3,%rax
  80042134f1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042134f5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042134f9:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80042134fd:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004213501:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213505:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213509:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421350d:	48 89 d0             	mov    %rdx,%rax
  8004213510:	48 01 c0             	add    %rax,%rax
  8004213513:	48 01 d0             	add    %rdx,%rax
  8004213516:	48 c1 e0 03          	shl    $0x3,%rax
  800421351a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421351e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213525:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  800421352a:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_offset_extended_sf(reg=%ju,soff=%jd)\n",
			       reg, soff);
#endif
                        break;
  800421352e:	e9 ab 03 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  8004213533:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213537:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421353b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421353e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213542:	48 89 c7             	mov    %rax,%rdi
  8004213545:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  800421354c:	00 00 00 
  800421354f:	ff d0                	callq  *%rax
  8004213551:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004213555:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213559:	48 89 c7             	mov    %rax,%rdi
  800421355c:	48 b8 d5 0e 21 04 80 	movabs $0x8004210ed5,%rax
  8004213563:	00 00 00 
  8004213566:	ff d0                	callq  *%rax
  8004213568:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  800421356c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213570:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213573:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213577:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  800421357b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421357f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213583:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004213587:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421358b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004213592:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004213597:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_sf(reg=%ju,soff=%jd)\n", reg,
			       soff);
#endif
                        break;
  800421359b:	e9 3e 03 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  80042135a0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042135a4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042135a8:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  80042135ab:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042135af:	48 89 c7             	mov    %rax,%rdi
  80042135b2:	48 b8 d5 0e 21 04 80 	movabs $0x8004210ed5,%rax
  80042135b9:	00 00 00 
  80042135bc:	ff d0                	callq  *%rax
  80042135be:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042135c2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135c6:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042135c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135cd:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  80042135d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135d5:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042135dc:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  80042135e1:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_offset_sf(soff=%jd)\n", soff);
#endif
                        break;
  80042135e5:	e9 f4 02 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  80042135ea:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042135ee:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042135f2:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042135f5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042135f9:	48 89 c7             	mov    %rax,%rdi
  80042135fc:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213603:	00 00 00 
  8004213606:	ff d0                	callq  *%rax
  8004213608:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  800421360c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213610:	48 89 c7             	mov    %rax,%rdi
  8004213613:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  800421361a:	00 00 00 
  800421361d:	ff d0                	callq  *%rax
  800421361f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213623:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213627:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421362b:	0f b7 c0             	movzwl %ax,%eax
  800421362e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213632:	77 0c                	ja     8004213640 <_dwarf_frame_run_inst+0xb62>
  8004213634:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421363b:	e9 af 02 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  8004213640:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213644:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213648:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421364c:	48 89 d0             	mov    %rdx,%rax
  800421364f:	48 01 c0             	add    %rax,%rax
  8004213652:	48 01 d0             	add    %rdx,%rax
  8004213655:	48 c1 e0 03          	shl    $0x3,%rax
  8004213659:	48 01 c8             	add    %rcx,%rax
  800421365c:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421365f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213663:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213667:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421366b:	48 89 d0             	mov    %rdx,%rax
  800421366e:	48 01 c0             	add    %rax,%rax
  8004213671:	48 01 d0             	add    %rdx,%rax
  8004213674:	48 c1 e0 03          	shl    $0x3,%rax
  8004213678:	48 01 c8             	add    %rcx,%rax
  800421367b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421367f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213683:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213687:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421368b:	48 89 d0             	mov    %rdx,%rax
  800421368e:	48 01 c0             	add    %rax,%rax
  8004213691:	48 01 d0             	add    %rdx,%rax
  8004213694:	48 c1 e0 03          	shl    $0x3,%rax
  8004213698:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421369c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042136a0:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80042136a4:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042136a8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136ac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042136b0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042136b4:	48 89 d0             	mov    %rdx,%rax
  80042136b7:	48 01 c0             	add    %rax,%rax
  80042136ba:	48 01 d0             	add    %rdx,%rax
  80042136bd:	48 c1 e0 03          	shl    $0x3,%rax
  80042136c1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042136c5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042136cc:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042136d1:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_offset(reg=%ju,uoff=%ju)\n", reg,
			       uoff);
#endif
                        break;
  80042136d5:	e9 04 02 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  80042136da:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042136de:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042136e2:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042136e5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042136e9:	48 89 c7             	mov    %rax,%rdi
  80042136ec:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042136f3:	00 00 00 
  80042136f6:	ff d0                	callq  *%rax
  80042136f8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  80042136fc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213700:	48 89 c7             	mov    %rax,%rdi
  8004213703:	48 b8 d5 0e 21 04 80 	movabs $0x8004210ed5,%rax
  800421370a:	00 00 00 
  800421370d:	ff d0                	callq  *%rax
  800421370f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213713:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213717:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421371b:	0f b7 c0             	movzwl %ax,%eax
  800421371e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213722:	77 0c                	ja     8004213730 <_dwarf_frame_run_inst+0xc52>
  8004213724:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421372b:	e9 bf 01 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  8004213730:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213734:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213738:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421373c:	48 89 d0             	mov    %rdx,%rax
  800421373f:	48 01 c0             	add    %rax,%rax
  8004213742:	48 01 d0             	add    %rdx,%rax
  8004213745:	48 c1 e0 03          	shl    $0x3,%rax
  8004213749:	48 01 c8             	add    %rcx,%rax
  800421374c:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421374f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213753:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213757:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421375b:	48 89 d0             	mov    %rdx,%rax
  800421375e:	48 01 c0             	add    %rax,%rax
  8004213761:	48 01 d0             	add    %rdx,%rax
  8004213764:	48 c1 e0 03          	shl    $0x3,%rax
  8004213768:	48 01 c8             	add    %rcx,%rax
  800421376b:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421376f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213773:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213777:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421377b:	48 89 d0             	mov    %rdx,%rax
  800421377e:	48 01 c0             	add    %rax,%rax
  8004213781:	48 01 d0             	add    %rdx,%rax
  8004213784:	48 c1 e0 03          	shl    $0x3,%rax
  8004213788:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421378c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213790:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004213794:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004213798:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421379c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137a0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042137a4:	48 89 d0             	mov    %rdx,%rax
  80042137a7:	48 01 c0             	add    %rax,%rax
  80042137aa:	48 01 d0             	add    %rdx,%rax
  80042137ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042137b1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042137b5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042137bc:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  80042137c1:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_offset_sf(reg=%ju,soff=%jd)\n", reg,
			       soff);
#endif
                        break;
  80042137c5:	e9 14 01 00 00       	jmpq   80042138de <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  80042137ca:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042137ce:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042137d2:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042137d5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042137d9:	48 89 c7             	mov    %rax,%rdi
  80042137dc:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042137e3:	00 00 00 
  80042137e6:	ff d0                	callq  *%rax
  80042137e8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042137ec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137f0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042137f4:	0f b7 c0             	movzwl %ax,%eax
  80042137f7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042137fb:	77 0c                	ja     8004213809 <_dwarf_frame_run_inst+0xd2b>
  80042137fd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213804:	e9 e6 00 00 00       	jmpq   80042138ef <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  8004213809:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421380d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213811:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213815:	48 89 d0             	mov    %rdx,%rax
  8004213818:	48 01 c0             	add    %rax,%rax
  800421381b:	48 01 d0             	add    %rdx,%rax
  800421381e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213822:	48 01 c8             	add    %rcx,%rax
  8004213825:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004213828:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421382c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213830:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213834:	48 89 d0             	mov    %rdx,%rax
  8004213837:	48 01 c0             	add    %rax,%rax
  800421383a:	48 01 d0             	add    %rdx,%rax
  800421383d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213841:	48 01 c8             	add    %rcx,%rax
  8004213844:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004213848:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421384c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213850:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213854:	48 89 d0             	mov    %rdx,%rax
  8004213857:	48 01 c0             	add    %rax,%rax
  800421385a:	48 01 d0             	add    %rdx,%rax
  800421385d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213861:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004213865:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213869:	48 89 c7             	mov    %rax,%rdi
  800421386c:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004213873:	00 00 00 
  8004213876:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004213878:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  800421387c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213880:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213884:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213888:	48 89 d0             	mov    %rdx,%rax
  800421388b:	48 01 c0             	add    %rax,%rax
  800421388e:	48 01 d0             	add    %rdx,%rax
  8004213891:	48 c1 e0 03          	shl    $0x3,%rax
  8004213895:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213899:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421389d:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  80042138a1:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042138a5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042138a9:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042138ad:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042138b1:	48 89 d0             	mov    %rdx,%rax
  80042138b4:	48 01 c0             	add    %rax,%rax
  80042138b7:	48 01 d0             	add    %rdx,%rax
  80042138ba:	48 c1 e0 03          	shl    $0x3,%rax
  80042138be:	48 01 f0             	add    %rsi,%rax
  80042138c1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042138c5:	48 01 c8             	add    %rcx,%rax
  80042138c8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_expression\n");
#endif
                        break;
  80042138cc:	eb 10                	jmp    80042138de <_dwarf_frame_run_inst+0xe00>
                default:
                        DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042138ce:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  80042138d5:	eb 18                	jmp    80042138ef <_dwarf_frame_run_inst+0xe11>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc1(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
                                goto program_done;
                        break;
  80042138d7:	90                   	nop
  80042138d8:	eb 04                	jmp    80042138de <_dwarf_frame_run_inst+0xe00>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc2(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
                                goto program_done;
                        break;
  80042138da:	90                   	nop
  80042138db:	eb 01                	jmp    80042138de <_dwarf_frame_run_inst+0xe00>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc4(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
                                goto program_done;
                        break;
  80042138dd:	90                   	nop
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  80042138de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042138e2:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042138e6:	0f 82 76 f2 ff ff    	jb     8004212b62 <_dwarf_frame_run_inst+0x84>
  80042138ec:	eb 01                	jmp    80042138ef <_dwarf_frame_run_inst+0xe11>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
				printf("Program done\n");
			goto program_done;
  80042138ee:	90                   	nop
	  free(init_rt);
	  if (saved_rt) {
	  free(saved_rt->rt3_rules);
	  free(saved_rt);
	  }*/
        return (ret);
  80042138ef:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  80042138f2:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  80042138f9:	5b                   	pop    %rbx
  80042138fa:	5d                   	pop    %rbp
  80042138fb:	c3                   	retq   

00000080042138fc <_dwarf_frame_get_internal_table>:


int
_dwarf_frame_get_internal_table(Dwarf_Fde fde, Dwarf_Addr pc_req,
				Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc, Dwarf_Error *error)
{
  80042138fc:	55                   	push   %rbp
  80042138fd:	48 89 e5             	mov    %rsp,%rbp
  8004213900:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004213904:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213908:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421390c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213910:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213914:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004213918:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800421391d:	75 35                	jne    8004213954 <_dwarf_frame_get_internal_table+0x58>
  800421391f:	48 b9 40 ec 21 04 80 	movabs $0x800421ec40,%rcx
  8004213926:	00 00 00 
  8004213929:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  8004213930:	00 00 00 
  8004213933:	be 01 02 00 00       	mov    $0x201,%esi
  8004213938:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  800421393f:	00 00 00 
  8004213942:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213947:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421394e:	00 00 00 
  8004213951:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  8004213954:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800421395b:	00 00 00 
  800421395e:	48 8b 00             	mov    (%rax),%rax
  8004213961:	48 85 c0             	test   %rax,%rax
  8004213964:	75 35                	jne    800421399b <_dwarf_frame_get_internal_table+0x9f>
  8004213966:	48 b9 4f ec 21 04 80 	movabs $0x800421ec4f,%rcx
  800421396d:	00 00 00 
  8004213970:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  8004213977:	00 00 00 
  800421397a:	be 04 02 00 00       	mov    $0x204,%esi
  800421397f:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  8004213986:	00 00 00 
  8004213989:	b8 00 00 00 00       	mov    $0x0,%eax
  800421398e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004213995:	00 00 00 
  8004213998:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  800421399b:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042139a2:	00 00 00 
  80042139a5:	48 8b 00             	mov    (%rax),%rax
  80042139a8:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042139ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  80042139b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042139b4:	ba 18 00 00 00       	mov    $0x18,%edx
  80042139b9:	be 00 00 00 00       	mov    $0x0,%esi
  80042139be:	48 89 c7             	mov    %rax,%rdi
  80042139c1:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042139c8:	00 00 00 
  80042139cb:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  80042139cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042139d1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042139d5:	0f b7 d0             	movzwl %ax,%edx
  80042139d8:	48 89 d0             	mov    %rdx,%rax
  80042139db:	48 01 c0             	add    %rax,%rax
  80042139de:	48 01 d0             	add    %rdx,%rax
  80042139e1:	48 c1 e0 03          	shl    $0x3,%rax
  80042139e5:	48 89 c2             	mov    %rax,%rdx
  80042139e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042139ec:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042139f0:	be 00 00 00 00       	mov    $0x0,%esi
  80042139f5:	48 89 c7             	mov    %rax,%rdi
  80042139f8:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  80042139ff:	00 00 00 
  8004213a02:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213a04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213a0b:	eb 38                	jmp    8004213a45 <_dwarf_frame_get_internal_table+0x149>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004213a0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213a11:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213a15:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213a18:	48 63 d0             	movslq %eax,%rdx
  8004213a1b:	48 89 d0             	mov    %rdx,%rax
  8004213a1e:	48 01 c0             	add    %rax,%rax
  8004213a21:	48 01 d0             	add    %rdx,%rax
  8004213a24:	48 c1 e0 03          	shl    $0x3,%rax
  8004213a28:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213a2c:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004213a33:	00 00 00 
  8004213a36:	48 8b 00             	mov    (%rax),%rax
  8004213a39:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8004213a3d:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213a41:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004213a45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213a49:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213a4d:	0f b7 c0             	movzwl %ax,%eax
  8004213a50:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213a53:	7f b8                	jg     8004213a0d <_dwarf_frame_get_internal_table+0x111>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  8004213a55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a59:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213a5d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  8004213a61:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004213a66:	75 35                	jne    8004213a9d <_dwarf_frame_get_internal_table+0x1a1>
  8004213a68:	48 b9 5b ec 21 04 80 	movabs $0x800421ec5b,%rcx
  8004213a6f:	00 00 00 
  8004213a72:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  8004213a79:	00 00 00 
  8004213a7c:	be 13 02 00 00       	mov    $0x213,%esi
  8004213a81:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  8004213a88:	00 00 00 
  8004213a8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a90:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004213a97:	00 00 00 
  8004213a9a:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
  8004213a9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
        assert(cie != NULL);
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004213aa1:	4c 8b 48 40          	mov    0x40(%rax),%r9
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
  8004213aa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
        assert(cie != NULL);
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004213aa9:	4c 8b 40 38          	mov    0x38(%rax),%r8
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
  8004213aad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
        assert(cie != NULL);
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004213ab1:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004213ab5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ab9:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004213abd:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004213ac4:	00 00 00 
  8004213ac7:	48 8b 00             	mov    (%rax),%rax
  8004213aca:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213ace:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8004213ad2:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004213ad7:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004213adb:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004213ae0:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004213ae7:	ff ff 
  8004213ae9:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004213af0:	00 
  8004213af1:	48 89 c7             	mov    %rax,%rdi
  8004213af4:	48 b8 de 2a 21 04 80 	movabs $0x8004212ade,%rax
  8004213afb:	00 00 00 
  8004213afe:	ff d0                	callq  *%rax
  8004213b00:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004213b03:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004213b07:	74 08                	je     8004213b11 <_dwarf_frame_get_internal_table+0x215>
                return (ret);
  8004213b09:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213b0c:	e9 a1 00 00 00       	jmpq   8004213bb2 <_dwarf_frame_get_internal_table+0x2b6>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004213b11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b15:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213b19:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004213b1d:	77 78                	ja     8004213b97 <_dwarf_frame_get_internal_table+0x29b>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
					    fde->fde_initloc, pc_req, &row_pc, error);
  8004213b1f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213b23:	48 8b 78 30          	mov    0x30(%rax),%rdi
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
  8004213b27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213b2b:	4c 8b 48 40          	mov    0x40(%rax),%r9
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
  8004213b2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213b33:	4c 8b 50 38          	mov    0x38(%rax),%r10
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
  8004213b37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004213b3b:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004213b3f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b43:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004213b47:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004213b4e:	00 00 00 
  8004213b51:	48 8b 00             	mov    (%rax),%rax
  8004213b54:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004213b58:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  8004213b5c:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004213b61:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004213b65:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004213b6a:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8004213b6e:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004213b73:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213b77:	4d 89 d0             	mov    %r10,%r8
  8004213b7a:	48 89 c7             	mov    %rax,%rdi
  8004213b7d:	48 b8 de 2a 21 04 80 	movabs $0x8004212ade,%rax
  8004213b84:	00 00 00 
  8004213b87:	ff d0                	callq  *%rax
  8004213b89:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
					    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  8004213b8c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004213b90:	74 05                	je     8004213b97 <_dwarf_frame_get_internal_table+0x29b>
                        return (ret);
  8004213b92:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004213b95:	eb 1b                	jmp    8004213bb2 <_dwarf_frame_get_internal_table+0x2b6>
        }

        *ret_rt = rt;
  8004213b97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213b9b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213b9f:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  8004213ba2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213ba6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213baa:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  8004213bad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213bb2:	c9                   	leaveq 
  8004213bb3:	c3                   	retq   

0000008004213bb4 <dwarf_get_fde_info_for_all_regs>:


int
dwarf_get_fde_info_for_all_regs(Dwarf_Fde fde, Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004213bb4:	55                   	push   %rbp
  8004213bb5:	48 89 e5             	mov    %rsp,%rbp
  8004213bb8:	48 83 ec 50          	sub    $0x50,%rsp
  8004213bbc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004213bc0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004213bc4:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213bc8:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213bcc:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL || row_pc == NULL) {
  8004213bd0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213bd5:	74 0e                	je     8004213be5 <dwarf_get_fde_info_for_all_regs+0x31>
  8004213bd7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213bdc:	74 07                	je     8004213be5 <dwarf_get_fde_info_for_all_regs+0x31>
  8004213bde:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004213be3:	75 15                	jne    8004213bfa <dwarf_get_fde_info_for_all_regs+0x46>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		*(int*) 0 =0;
  8004213be5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213bea:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004213bf0:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213bf5:	e9 35 02 00 00       	jmpq   8004213e2f <dwarf_get_fde_info_for_all_regs+0x27b>
        }

        assert(dbg != NULL);
  8004213bfa:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004213c01:	00 00 00 
  8004213c04:	48 8b 00             	mov    (%rax),%rax
  8004213c07:	48 85 c0             	test   %rax,%rax
  8004213c0a:	75 35                	jne    8004213c41 <dwarf_get_fde_info_for_all_regs+0x8d>
  8004213c0c:	48 b9 4f ec 21 04 80 	movabs $0x800421ec4f,%rcx
  8004213c13:	00 00 00 
  8004213c16:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  8004213c1d:	00 00 00 
  8004213c20:	be 39 02 00 00       	mov    $0x239,%esi
  8004213c25:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  8004213c2c:	00 00 00 
  8004213c2f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213c34:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004213c3b:	00 00 00 
  8004213c3e:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  8004213c41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213c45:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213c49:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213c4d:	77 19                	ja     8004213c68 <dwarf_get_fde_info_for_all_regs+0xb4>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004213c4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213c53:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213c57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213c5b:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213c5f:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  8004213c62:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213c66:	77 15                	ja     8004213c7d <dwarf_get_fde_info_for_all_regs+0xc9>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		*(int*) 0 =0;
  8004213c68:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213c6d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004213c73:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213c78:	e9 b2 01 00 00       	jmpq   8004213e2f <dwarf_get_fde_info_for_all_regs+0x27b>
        }

        ret = _dwarf_frame_get_internal_table(fde, pc_requested, &rt, &pc,
  8004213c7d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004213c81:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004213c85:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8004213c89:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213c8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213c91:	49 89 f8             	mov    %rdi,%r8
  8004213c94:	48 89 c7             	mov    %rax,%rdi
  8004213c97:	48 b8 fc 38 21 04 80 	movabs $0x80042138fc,%rax
  8004213c9e:	00 00 00 
  8004213ca1:	ff d0                	callq  *%rax
  8004213ca3:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
        if (ret != DW_DLE_NONE)
  8004213ca6:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004213caa:	74 15                	je     8004213cc1 <dwarf_get_fde_info_for_all_regs+0x10d>
	{

		*(int*)0 = 0;
  8004213cac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213cb1:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004213cb7:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213cbc:	e9 6e 01 00 00       	jmpq   8004213e2f <dwarf_get_fde_info_for_all_regs+0x27b>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  8004213cc1:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004213cc8:	00 00 00 
  8004213ccb:	48 8b 00             	mov    (%rax),%rax
  8004213cce:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004213cd2:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  8004213cd6:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  8004213cdb:	77 5a                	ja     8004213d37 <dwarf_get_fde_info_for_all_regs+0x183>
                reg_table->rules[cfa].dw_offset_relevant =
  8004213cdd:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  8004213ce1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ce5:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  8004213ce8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213cec:	48 63 c9             	movslq %ecx,%rcx
  8004213cef:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213cf3:	48 01 ca             	add    %rcx,%rdx
  8004213cf6:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004213cf8:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213cfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d00:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213d04:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d08:	48 63 c9             	movslq %ecx,%rcx
  8004213d0b:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213d0f:	48 01 ca             	add    %rcx,%rdx
  8004213d12:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004213d16:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004213d1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d1e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213d22:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d26:	48 63 c9             	movslq %ecx,%rcx
  8004213d29:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213d2d:	48 01 ca             	add    %rcx,%rdx
  8004213d30:	48 83 c2 08          	add    $0x8,%rdx
  8004213d34:	48 89 02             	mov    %rax,(%rdx)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004213d37:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004213d3e:	e9 b9 00 00 00       	jmpq   8004213dfc <dwarf_get_fde_info_for_all_regs+0x248>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  8004213d43:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8004213d47:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213d4a:	0f 84 a7 00 00 00    	je     8004213df7 <dwarf_get_fde_info_for_all_regs+0x243>
                        continue;

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004213d50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d54:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213d58:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d5b:	48 63 d0             	movslq %eax,%rdx
  8004213d5e:	48 89 d0             	mov    %rdx,%rax
  8004213d61:	48 01 c0             	add    %rax,%rax
  8004213d64:	48 01 d0             	add    %rdx,%rax
  8004213d67:	48 c1 e0 03          	shl    $0x3,%rax
  8004213d6b:	48 01 c8             	add    %rcx,%rax
  8004213d6e:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  8004213d71:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d75:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213d78:	48 63 c9             	movslq %ecx,%rcx
  8004213d7b:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213d7f:	48 01 ca             	add    %rcx,%rdx
  8004213d82:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004213d84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d88:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213d8c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213d8f:	48 63 d0             	movslq %eax,%rdx
  8004213d92:	48 89 d0             	mov    %rdx,%rax
  8004213d95:	48 01 c0             	add    %rax,%rax
  8004213d98:	48 01 d0             	add    %rdx,%rax
  8004213d9b:	48 c1 e0 03          	shl    $0x3,%rax
  8004213d9f:	48 01 c8             	add    %rcx,%rax
  8004213da2:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213da6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213daa:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213dad:	48 63 c9             	movslq %ecx,%rcx
  8004213db0:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213db4:	48 01 ca             	add    %rcx,%rdx
  8004213db7:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  8004213dbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dbf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213dc3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213dc6:	48 63 d0             	movslq %eax,%rdx
  8004213dc9:	48 89 d0             	mov    %rdx,%rax
  8004213dcc:	48 01 c0             	add    %rax,%rax
  8004213dcf:	48 01 d0             	add    %rdx,%rax
  8004213dd2:	48 c1 e0 03          	shl    $0x3,%rax
  8004213dd6:	48 01 c8             	add    %rcx,%rax
  8004213dd9:	48 8b 40 08          	mov    0x8(%rax),%rax
                        continue;

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  8004213ddd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213de1:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213de4:	48 63 c9             	movslq %ecx,%rcx
  8004213de7:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213deb:	48 01 ca             	add    %rcx,%rdx
  8004213dee:	48 83 c2 08          	add    $0x8,%rdx
  8004213df2:	48 89 02             	mov    %rax,(%rdx)
  8004213df5:	eb 01                	jmp    8004213df8 <dwarf_get_fde_info_for_all_regs+0x244>
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;
  8004213df7:	90                   	nop

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  8004213df8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004213dfc:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  8004213e00:	7f 1d                	jg     8004213e1f <dwarf_get_fde_info_for_all_regs+0x26b>
  8004213e02:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004213e09:	00 00 00 
  8004213e0c:	48 8b 00             	mov    (%rax),%rax
  8004213e0f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8004213e13:	0f b7 c0             	movzwl %ax,%eax
  8004213e16:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004213e19:	0f 8f 24 ff ff ff    	jg     8004213d43 <dwarf_get_fde_info_for_all_regs+0x18f>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
        }

        *row_pc = pc;
  8004213e1f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213e23:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213e27:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLV_OK);
  8004213e2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213e2f:	c9                   	leaveq 
  8004213e30:	c3                   	retq   

0000008004213e31 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213e31:	55                   	push   %rbp
  8004213e32:	48 89 e5             	mov    %rsp,%rbp
  8004213e35:	48 83 ec 40          	sub    $0x40,%rsp
  8004213e39:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213e3d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213e41:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213e45:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213e49:	44 89 c0             	mov    %r8d,%eax
  8004213e4c:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004213e50:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004213e53:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004213e57:	75 0a                	jne    8004213e63 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004213e59:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213e5e:	e9 05 02 00 00       	jmpq   8004214068 <_dwarf_frame_read_lsb_encoded+0x237>

	application = encode & 0xf0;
  8004213e63:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213e67:	83 e0 f0             	and    $0xfffffff0,%eax
  8004213e6a:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004213e6d:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004213e71:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213e75:	83 f8 0c             	cmp    $0xc,%eax
  8004213e78:	0f 87 91 01 00 00    	ja     800421400f <_dwarf_frame_read_lsb_encoded+0x1de>
  8004213e7e:	89 c0                	mov    %eax,%eax
  8004213e80:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213e87:	00 
  8004213e88:	48 b8 68 ec 21 04 80 	movabs $0x800421ec68,%rax
  8004213e8f:	00 00 00 
  8004213e92:	48 01 d0             	add    %rdx,%rax
  8004213e95:	48 8b 00             	mov    (%rax),%rax
  8004213e98:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004213e9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e9e:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213ea2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ea6:	8b 50 28             	mov    0x28(%rax),%edx
  8004213ea9:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213ead:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213eb1:	48 89 ce             	mov    %rcx,%rsi
  8004213eb4:	48 89 c7             	mov    %rax,%rdi
  8004213eb7:	41 ff d0             	callq  *%r8
  8004213eba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213ebe:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213ec1:	e9 50 01 00 00       	jmpq   8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004213ec6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213eca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213ece:	48 89 d6             	mov    %rdx,%rsi
  8004213ed1:	48 89 c7             	mov    %rax,%rdi
  8004213ed4:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  8004213edb:	00 00 00 
  8004213ede:	ff d0                	callq  *%rax
  8004213ee0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213ee4:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213ee7:	e9 2a 01 00 00       	jmpq   8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  8004213eec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ef0:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213ef4:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213ef8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213efc:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213f01:	48 89 ce             	mov    %rcx,%rsi
  8004213f04:	48 89 c7             	mov    %rax,%rdi
  8004213f07:	41 ff d0             	callq  *%r8
  8004213f0a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f0e:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f11:	e9 00 01 00 00       	jmpq   8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004213f16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f1a:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213f1e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213f22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213f26:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213f2b:	48 89 ce             	mov    %rcx,%rsi
  8004213f2e:	48 89 c7             	mov    %rax,%rdi
  8004213f31:	41 ff d0             	callq  *%r8
  8004213f34:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f38:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f3b:	e9 d6 00 00 00       	jmpq   8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004213f40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f44:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213f48:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213f4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213f50:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213f55:	48 89 ce             	mov    %rcx,%rsi
  8004213f58:	48 89 c7             	mov    %rax,%rdi
  8004213f5b:	41 ff d0             	callq  *%r8
  8004213f5e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213f62:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213f65:	e9 ac 00 00 00       	jmpq   8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004213f6a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213f72:	48 89 d6             	mov    %rdx,%rsi
  8004213f75:	48 89 c7             	mov    %rax,%rdi
  8004213f78:	48 b8 ac 0d 21 04 80 	movabs $0x8004210dac,%rax
  8004213f7f:	00 00 00 
  8004213f82:	ff d0                	callq  *%rax
  8004213f84:	48 89 c2             	mov    %rax,%rdx
  8004213f87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213f8b:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213f8e:	e9 83 00 00 00       	jmpq   8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004213f93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f97:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213f9b:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213f9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213fa3:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213fa8:	48 89 ce             	mov    %rcx,%rsi
  8004213fab:	48 89 c7             	mov    %rax,%rdi
  8004213fae:	41 ff d0             	callq  *%r8
  8004213fb1:	48 0f bf d0          	movswq %ax,%rdx
  8004213fb5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213fb9:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213fbc:	eb 58                	jmp    8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004213fbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fc2:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213fc6:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213fca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213fce:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213fd3:	48 89 ce             	mov    %rcx,%rsi
  8004213fd6:	48 89 c7             	mov    %rax,%rdi
  8004213fd9:	41 ff d0             	callq  *%r8
  8004213fdc:	48 63 d0             	movslq %eax,%rdx
  8004213fdf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213fe3:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213fe6:	eb 2e                	jmp    8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004213fe8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fec:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213ff0:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004213ff4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213ff8:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213ffd:	48 89 ce             	mov    %rcx,%rsi
  8004214000:	48 89 c7             	mov    %rax,%rdi
  8004214003:	41 ff d0             	callq  *%r8
  8004214006:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421400a:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421400d:	eb 07                	jmp    8004214016 <_dwarf_frame_read_lsb_encoded+0x1e5>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  800421400f:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214014:	eb 52                	jmp    8004214068 <_dwarf_frame_read_lsb_encoded+0x237>
	}

	if (application == DW_EH_PE_pcrel) {
  8004214016:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  800421401a:	75 47                	jne    8004214063 <_dwarf_frame_read_lsb_encoded+0x232>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  800421401c:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214020:	83 f8 01             	cmp    $0x1,%eax
  8004214023:	7c 3d                	jl     8004214062 <_dwarf_frame_read_lsb_encoded+0x231>
  8004214025:	83 f8 04             	cmp    $0x4,%eax
  8004214028:	7e 0a                	jle    8004214034 <_dwarf_frame_read_lsb_encoded+0x203>
  800421402a:	83 e8 09             	sub    $0x9,%eax
  800421402d:	83 f8 03             	cmp    $0x3,%eax
  8004214030:	77 30                	ja     8004214062 <_dwarf_frame_read_lsb_encoded+0x231>
  8004214032:	eb 17                	jmp    800421404b <_dwarf_frame_read_lsb_encoded+0x21a>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004214034:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214038:	48 8b 00             	mov    (%rax),%rax
  800421403b:	48 89 c2             	mov    %rax,%rdx
  800421403e:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  8004214042:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214046:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214049:	eb 18                	jmp    8004214063 <_dwarf_frame_read_lsb_encoded+0x232>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421404b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421404f:	48 8b 00             	mov    (%rax),%rax
  8004214052:	48 89 c2             	mov    %rax,%rdx
  8004214055:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  8004214059:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421405d:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214060:	eb 01                	jmp    8004214063 <_dwarf_frame_read_lsb_encoded+0x232>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004214062:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004214063:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214068:	c9                   	leaveq 
  8004214069:	c3                   	retq   

000000800421406a <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  800421406a:	55                   	push   %rbp
  800421406b:	48 89 e5             	mov    %rsp,%rbp
  800421406e:	48 83 ec 60          	sub    $0x60,%rsp
  8004214072:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214076:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421407a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800421407e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214082:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214086:	48 85 c0             	test   %rax,%rax
  8004214089:	74 0f                	je     800421409a <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421408b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421408f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214093:	0f b6 00             	movzbl (%rax),%eax
  8004214096:	3c 7a                	cmp    $0x7a,%al
  8004214098:	74 35                	je     80042140cf <_dwarf_frame_parse_lsb_cie_augment+0x65>
  800421409a:	48 b9 d0 ec 21 04 80 	movabs $0x800421ecd0,%rcx
  80042140a1:	00 00 00 
  80042140a4:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  80042140ab:	00 00 00 
  80042140ae:	be c0 02 00 00       	mov    $0x2c0,%esi
  80042140b3:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  80042140ba:	00 00 00 
  80042140bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140c2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042140c9:	00 00 00 
  80042140cc:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042140cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140d3:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042140d7:	48 83 c0 01          	add    $0x1,%rax
  80042140db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042140df:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140e3:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042140e7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042140eb:	e9 a2 00 00 00       	jmpq   8004214192 <_dwarf_frame_parse_lsb_cie_augment+0x128>
		switch (*aug_p) {
  80042140f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042140f4:	0f b6 00             	movzbl (%rax),%eax
  80042140f7:	0f b6 c0             	movzbl %al,%eax
  80042140fa:	83 f8 50             	cmp    $0x50,%eax
  80042140fd:	74 11                	je     8004214110 <_dwarf_frame_parse_lsb_cie_augment+0xa6>
  80042140ff:	83 f8 52             	cmp    $0x52,%eax
  8004214102:	74 6d                	je     8004214171 <_dwarf_frame_parse_lsb_cie_augment+0x107>
  8004214104:	83 f8 4c             	cmp    $0x4c,%eax
  8004214107:	75 7d                	jne    8004214186 <_dwarf_frame_parse_lsb_cie_augment+0x11c>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004214109:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  800421410e:	eb 7d                	jmp    800421418d <_dwarf_frame_parse_lsb_cie_augment+0x123>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004214110:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214114:	0f b6 00             	movzbl (%rax),%eax
  8004214117:	88 45 ef             	mov    %al,-0x11(%rbp)
  800421411a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			offset = 0;
  800421411f:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004214126:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004214127:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  800421412c:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214130:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214134:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004214138:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421413c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214140:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214144:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421414a:	48 89 c7             	mov    %rax,%rdi
  800421414d:	48 b8 31 3e 21 04 80 	movabs $0x8004213e31,%rax
  8004214154:	00 00 00 
  8004214157:	ff d0                	callq  *%rax
  8004214159:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  800421415c:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004214160:	74 05                	je     8004214167 <_dwarf_frame_parse_lsb_cie_augment+0xfd>
				return (ret);
  8004214162:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004214165:	eb 3f                	jmp    80042141a6 <_dwarf_frame_parse_lsb_cie_augment+0x13c>
			augdata_p += offset;
  8004214167:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421416b:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421416f:	eb 1c                	jmp    800421418d <_dwarf_frame_parse_lsb_cie_augment+0x123>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004214171:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214175:	0f b6 10             	movzbl (%rax),%edx
  8004214178:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421417c:	88 50 60             	mov    %dl,0x60(%rax)
  800421417f:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004214184:	eb 07                	jmp    800421418d <_dwarf_frame_parse_lsb_cie_augment+0x123>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214186:	b8 14 00 00 00       	mov    $0x14,%eax
  800421418b:	eb 19                	jmp    80042141a6 <_dwarf_frame_parse_lsb_cie_augment+0x13c>
		}
		aug_p++;
  800421418d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004214192:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214196:	0f b6 00             	movzbl (%rax),%eax
  8004214199:	84 c0                	test   %al,%al
  800421419b:	0f 85 4f ff ff ff    	jne    80042140f0 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042141a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042141a6:	c9                   	leaveq 
  80042141a7:	c3                   	retq   

00000080042141a8 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042141a8:	55                   	push   %rbp
  80042141a9:	48 89 e5             	mov    %rsp,%rbp
  80042141ac:	48 83 ec 60          	sub    $0x60,%rsp
  80042141b0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042141b4:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042141b8:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042141bc:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042141c0:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042141c4:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042141c9:	75 35                	jne    8004214200 <_dwarf_frame_set_cie+0x58>
  80042141cb:	48 b9 05 ed 21 04 80 	movabs $0x800421ed05,%rcx
  80042141d2:	00 00 00 
  80042141d5:	48 ba 27 eb 21 04 80 	movabs $0x800421eb27,%rdx
  80042141dc:	00 00 00 
  80042141df:	be f1 02 00 00       	mov    $0x2f1,%esi
  80042141e4:	48 bf 3c eb 21 04 80 	movabs $0x800421eb3c,%rdi
  80042141eb:	00 00 00 
  80042141ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042141f3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042141fa:	00 00 00 
  80042141fd:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004214200:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214204:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004214208:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421420c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214210:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004214213:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214217:	48 8b 10             	mov    (%rax),%rdx
  800421421a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421421e:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read(ds->ds_data, off, 4);
  8004214222:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214226:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421422a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421422e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214232:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214236:	ba 04 00 00 00       	mov    $0x4,%edx
  800421423b:	48 89 ce             	mov    %rcx,%rsi
  800421423e:	48 89 c7             	mov    %rax,%rdi
  8004214241:	41 ff d0             	callq  *%r8
  8004214244:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004214248:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421424d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214251:	75 2f                	jne    8004214282 <_dwarf_frame_set_cie+0xda>
		dwarf_size = 8;
  8004214253:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read(ds->ds_data, off, 8);
  800421425a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421425e:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004214262:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214266:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421426a:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421426e:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214273:	48 89 ce             	mov    %rcx,%rsi
  8004214276:	48 89 c7             	mov    %rax,%rdi
  8004214279:	41 ff d0             	callq  *%r8
  800421427c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214280:	eb 07                	jmp    8004214289 <_dwarf_frame_set_cie+0xe1>
	} else
		dwarf_size = 4;
  8004214282:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > ds->ds_size - *off) {
  8004214289:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421428d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214291:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214295:	48 8b 00             	mov    (%rax),%rax
  8004214298:	48 89 d1             	mov    %rdx,%rcx
  800421429b:	48 29 c1             	sub    %rax,%rcx
  800421429e:	48 89 c8             	mov    %rcx,%rax
  80042142a1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042142a5:	73 0a                	jae    80042142b1 <_dwarf_frame_set_cie+0x109>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042142a7:	b8 12 00 00 00       	mov    $0x12,%eax
  80042142ac:	e9 66 03 00 00       	jmpq   8004214617 <_dwarf_frame_set_cie+0x46f>
	}

	(void) dbg->read(ds->ds_data, off, dwarf_size); /* Skip CIE id. */
  80042142b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142b5:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042142b9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042142bd:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042142c1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042142c4:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042142c8:	48 89 ce             	mov    %rcx,%rsi
  80042142cb:	48 89 c7             	mov    %rax,%rdi
  80042142ce:	41 ff d0             	callq  *%r8
	cie->cie_length = length;
  80042142d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042142d5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042142d9:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read(ds->ds_data, off, 1);
  80042142dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142e1:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042142e5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042142e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042142ed:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042142f1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042142f6:	48 89 ce             	mov    %rcx,%rsi
  80042142f9:	48 89 c7             	mov    %rax,%rdi
  80042142fc:	41 ff d0             	callq  *%r8
  80042142ff:	89 c2                	mov    %eax,%edx
  8004214301:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214305:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214309:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421430d:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214311:	66 83 f8 01          	cmp    $0x1,%ax
  8004214315:	74 26                	je     800421433d <_dwarf_frame_set_cie+0x195>
  8004214317:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421431b:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421431f:	66 83 f8 03          	cmp    $0x3,%ax
  8004214323:	74 18                	je     800421433d <_dwarf_frame_set_cie+0x195>
	    cie->cie_version != 4) {
  8004214325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214329:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read(ds->ds_data, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read(ds->ds_data, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  800421432d:	66 83 f8 04          	cmp    $0x4,%ax
  8004214331:	74 0a                	je     800421433d <_dwarf_frame_set_cie+0x195>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004214333:	b8 16 00 00 00       	mov    $0x16,%eax
  8004214338:	e9 da 02 00 00       	jmpq   8004214617 <_dwarf_frame_set_cie+0x46f>
	}

	cie->cie_augment = ds->ds_data + *off;
  800421433d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214341:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214345:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214349:	48 8b 00             	mov    (%rax),%rax
  800421434c:	48 01 c2             	add    %rax,%rdx
  800421434f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214353:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *) ds->ds_data;
  8004214357:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421435b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421435f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004214363:	90                   	nop
  8004214364:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214368:	48 8b 00             	mov    (%rax),%rax
  800421436b:	48 89 c2             	mov    %rax,%rdx
  800421436e:	48 03 55 e0          	add    -0x20(%rbp),%rdx
  8004214372:	0f b6 12             	movzbl (%rdx),%edx
  8004214375:	84 d2                	test   %dl,%dl
  8004214377:	0f 95 c2             	setne  %dl
  800421437a:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800421437e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214382:	48 89 08             	mov    %rcx,(%rax)
  8004214385:	84 d2                	test   %dl,%dl
  8004214387:	75 db                	jne    8004214364 <_dwarf_frame_set_cie+0x1bc>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004214389:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421438d:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214391:	0f b6 00             	movzbl (%rax),%eax
  8004214394:	84 c0                	test   %al,%al
  8004214396:	74 48                	je     80042143e0 <_dwarf_frame_set_cie+0x238>
  8004214398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421439c:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042143a0:	0f b6 00             	movzbl (%rax),%eax
  80042143a3:	3c 7a                	cmp    $0x7a,%al
  80042143a5:	74 39                	je     80042143e0 <_dwarf_frame_set_cie+0x238>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042143a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143ab:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042143af:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042143b3:	75 07                	jne    80042143bc <_dwarf_frame_set_cie+0x214>
  80042143b5:	b8 04 00 00 00       	mov    $0x4,%eax
  80042143ba:	eb 05                	jmp    80042143c1 <_dwarf_frame_set_cie+0x219>
  80042143bc:	b8 0c 00 00 00       	mov    $0xc,%eax
  80042143c1:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  80042143c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143c8:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042143cc:	48 01 c2             	add    %rax,%rdx
  80042143cf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042143d3:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  80042143d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143db:	e9 37 02 00 00       	jmpq   8004214617 <_dwarf_frame_set_cie+0x46f>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  80042143e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143e4:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042143e8:	48 be 0d ed 21 04 80 	movabs $0x800421ed0d,%rsi
  80042143ef:	00 00 00 
  80042143f2:	48 89 c7             	mov    %rax,%rdi
  80042143f5:	48 b8 6e 07 21 04 80 	movabs $0x800421076e,%rax
  80042143fc:	00 00 00 
  80042143ff:	ff d0                	callq  *%rax
  8004214401:	48 85 c0             	test   %rax,%rax
  8004214404:	74 2c                	je     8004214432 <_dwarf_frame_set_cie+0x28a>
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004214406:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421440a:	4c 8b 40 18          	mov    0x18(%rax),%r8
					    dbg->dbg_pointer_size);
  800421440e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
		return (DW_DLE_NONE);
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004214412:	8b 50 28             	mov    0x28(%rax),%edx
  8004214415:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214419:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421441d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004214421:	48 89 ce             	mov    %rcx,%rsi
  8004214424:	48 89 c7             	mov    %rax,%rdi
  8004214427:	41 ff d0             	callq  *%r8
  800421442a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421442e:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128(ds->ds_data, off);
  8004214432:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214436:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421443a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421443e:	48 89 d6             	mov    %rdx,%rsi
  8004214441:	48 89 c7             	mov    %rax,%rdi
  8004214444:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  800421444b:	00 00 00 
  800421444e:	ff d0                	callq  *%rax
  8004214450:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214454:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128(ds->ds_data, off);
  8004214458:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421445c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214460:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214464:	48 89 d6             	mov    %rdx,%rsi
  8004214467:	48 89 c7             	mov    %rax,%rdi
  800421446a:	48 b8 ac 0d 21 04 80 	movabs $0x8004210dac,%rax
  8004214471:	00 00 00 
  8004214474:	ff d0                	callq  *%rax
  8004214476:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421447a:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  800421447e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214482:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214486:	66 83 f8 01          	cmp    $0x1,%ax
  800421448a:	75 2c                	jne    80042144b8 <_dwarf_frame_set_cie+0x310>
		cie->cie_ra = dbg->read(ds->ds_data, off, 1);
  800421448c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214490:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004214494:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214498:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421449c:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042144a0:	ba 01 00 00 00       	mov    $0x1,%edx
  80042144a5:	48 89 ce             	mov    %rcx,%rsi
  80042144a8:	48 89 c7             	mov    %rax,%rdi
  80042144ab:	41 ff d0             	callq  *%r8
  80042144ae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042144b2:	48 89 42 48          	mov    %rax,0x48(%rdx)
  80042144b6:	eb 26                	jmp    80042144de <_dwarf_frame_set_cie+0x336>
	else
		cie->cie_ra = _dwarf_read_uleb128(ds->ds_data, off);
  80042144b8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042144c0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042144c4:	48 89 d6             	mov    %rdx,%rsi
  80042144c7:	48 89 c7             	mov    %rax,%rdi
  80042144ca:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  80042144d1:	00 00 00 
  80042144d4:	ff d0                	callq  *%rax
  80042144d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042144da:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  80042144de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042144e2:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042144e6:	0f b6 00             	movzbl (%rax),%eax
  80042144e9:	3c 7a                	cmp    $0x7a,%al
  80042144eb:	0f 85 90 00 00 00    	jne    8004214581 <_dwarf_frame_set_cie+0x3d9>
		cie->cie_auglen = _dwarf_read_uleb128(ds->ds_data, off);
  80042144f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042144f9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042144fd:	48 89 d6             	mov    %rdx,%rsi
  8004214500:	48 89 c7             	mov    %rax,%rdi
  8004214503:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  800421450a:	00 00 00 
  800421450d:	ff d0                	callq  *%rax
  800421450f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214513:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = ds->ds_data + *off;
  8004214517:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421451b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421451f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214523:	48 8b 00             	mov    (%rax),%rax
  8004214526:	48 01 c2             	add    %rax,%rdx
  8004214529:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421452d:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004214531:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214535:	48 8b 10             	mov    (%rax),%rdx
  8004214538:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421453c:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004214540:	48 01 c2             	add    %rax,%rdx
  8004214543:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214547:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  800421454a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421454e:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004214552:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004214556:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421455a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421455e:	48 89 ce             	mov    %rcx,%rsi
  8004214561:	48 89 c7             	mov    %rax,%rdi
  8004214564:	48 b8 6a 40 21 04 80 	movabs $0x800421406a,%rax
  800421456b:	00 00 00 
  800421456e:	ff d0                	callq  *%rax
  8004214570:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004214573:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214577:	74 08                	je     8004214581 <_dwarf_frame_set_cie+0x3d9>
			return (ret);
  8004214579:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421457c:	e9 96 00 00 00       	jmpq   8004214617 <_dwarf_frame_set_cie+0x46f>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = ds->ds_data + *off;
  8004214581:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214585:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214589:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421458d:	48 8b 00             	mov    (%rax),%rax
  8004214590:	48 01 c2             	add    %rax,%rdx
  8004214593:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214597:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  800421459b:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421459f:	75 2d                	jne    80042145ce <_dwarf_frame_set_cie+0x426>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  80042145a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145a5:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042145a9:	48 89 c2             	mov    %rax,%rdx
  80042145ac:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  80042145b0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145b4:	48 8b 00             	mov    (%rax),%rax
  80042145b7:	48 89 d1             	mov    %rdx,%rcx
  80042145ba:	48 29 c1             	sub    %rax,%rcx
  80042145bd:	48 89 c8             	mov    %rcx,%rax
  80042145c0:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042145c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145c8:	48 89 50 70          	mov    %rdx,0x70(%rax)
  80042145cc:	eb 2b                	jmp    80042145f9 <_dwarf_frame_set_cie+0x451>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  80042145ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145d2:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042145d6:	48 89 c2             	mov    %rax,%rdx
  80042145d9:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  80042145dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145e1:	48 8b 00             	mov    (%rax),%rax
  80042145e4:	48 89 d1             	mov    %rdx,%rcx
  80042145e7:	48 29 c1             	sub    %rax,%rcx
  80042145ea:	48 89 c8             	mov    %rcx,%rax
  80042145ed:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042145f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145f5:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  80042145f9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042145fd:	48 8b 10             	mov    (%rax),%rdx
  8004214600:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214604:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004214608:	48 01 c2             	add    %rax,%rdx
  800421460b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421460f:	48 89 10             	mov    %rdx,(%rax)
	       cie->cie_daf, *off);

	printf("%x %lx\n", (unsigned int)cie->cie_ra, (unsigned long)cie->cie_initinst);
#endif

	return (DW_DLE_NONE);
  8004214612:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214617:	c9                   	leaveq 
  8004214618:	c3                   	retq   

0000008004214619 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde retfde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004214619:	55                   	push   %rbp
  800421461a:	48 89 e5             	mov    %rsp,%rbp
  800421461d:	48 83 ec 70          	sub    $0x70,%rsp
  8004214621:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214625:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214629:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421462d:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004214631:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004214635:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = retfde;
  8004214639:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421463d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	fde->fde_dbg = dbg;
  8004214641:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214645:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214649:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = ds->ds_data + *off;
  800421464c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214650:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214654:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214658:	48 8b 00             	mov    (%rax),%rax
  800421465b:	48 01 c2             	add    %rax,%rdx
  800421465e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214662:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004214666:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421466a:	48 8b 10             	mov    (%rax),%rdx
  800421466d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214671:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read(ds->ds_data, off, 4);
  8004214675:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214679:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421467d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214681:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214685:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214689:	ba 04 00 00 00       	mov    $0x4,%edx
  800421468e:	48 89 ce             	mov    %rcx,%rsi
  8004214691:	48 89 c7             	mov    %rax,%rdi
  8004214694:	41 ff d0             	callq  *%r8
  8004214697:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  800421469b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042146a0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042146a4:	75 2f                	jne    80042146d5 <_dwarf_frame_set_fde+0xbc>
		dwarf_size = 8;
  80042146a6:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read(ds->ds_data, off, 8);
  80042146ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042146b1:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042146b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042146bd:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042146c1:	ba 08 00 00 00       	mov    $0x8,%edx
  80042146c6:	48 89 ce             	mov    %rcx,%rsi
  80042146c9:	48 89 c7             	mov    %rax,%rdi
  80042146cc:	41 ff d0             	callq  *%r8
  80042146cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042146d3:	eb 07                	jmp    80042146dc <_dwarf_frame_set_fde+0xc3>
	} else
		dwarf_size = 4;
  80042146d5:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > ds->ds_size - *off) {
  80042146dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146e0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042146e4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042146e8:	48 8b 00             	mov    (%rax),%rax
  80042146eb:	48 89 d1             	mov    %rdx,%rcx
  80042146ee:	48 29 c1             	sub    %rax,%rcx
  80042146f1:	48 89 c8             	mov    %rcx,%rax
  80042146f4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042146f8:	73 0a                	jae    8004214704 <_dwarf_frame_set_fde+0xeb>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042146fa:	b8 12 00 00 00       	mov    $0x12,%eax
  80042146ff:	e9 d1 02 00 00       	jmpq   80042149d5 <_dwarf_frame_set_fde+0x3bc>
	}

	fde->fde_length = length;
  8004214704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214708:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421470c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004214710:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004214714:	74 62                	je     8004214778 <_dwarf_frame_set_fde+0x15f>
		fde->fde_cieoff = dbg->read(ds->ds_data, off, 4);
  8004214716:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421471a:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421471e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214722:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214726:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421472a:	ba 04 00 00 00       	mov    $0x4,%edx
  800421472f:	48 89 ce             	mov    %rcx,%rsi
  8004214732:	48 89 c7             	mov    %rax,%rdi
  8004214735:	41 ff d0             	callq  *%r8
  8004214738:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421473c:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004214740:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214744:	48 8b 10             	mov    (%rax),%rdx
  8004214747:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421474b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421474f:	48 89 d1             	mov    %rdx,%rcx
  8004214752:	48 29 c1             	sub    %rax,%rcx
  8004214755:	48 89 c8             	mov    %rcx,%rax
  8004214758:	48 83 e8 04          	sub    $0x4,%rax
  800421475c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004214760:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214764:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214768:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421476c:	75 3e                	jne    80042147ac <_dwarf_frame_set_fde+0x193>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  800421476e:	b8 13 00 00 00       	mov    $0x13,%eax
  8004214773:	e9 5d 02 00 00       	jmpq   80042149d5 <_dwarf_frame_set_fde+0x3bc>
		}
	} else {
		fde->fde_cieoff = dbg->read(ds->ds_data, off, dwarf_size);
  8004214778:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421477c:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004214780:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214784:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214788:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421478b:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421478f:	48 89 ce             	mov    %rcx,%rsi
  8004214792:	48 89 c7             	mov    %rax,%rdi
  8004214795:	41 ff d0             	callq  *%r8
  8004214798:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421479c:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  80042147a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147a4:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042147a8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  80042147ac:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042147b0:	0f 84 c3 00 00 00    	je     8004214879 <_dwarf_frame_set_fde+0x260>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042147b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042147ba:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042147be:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042147c2:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  80042147c5:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  80042147c9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042147cd:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  80042147d1:	44 0f b6 c0          	movzbl %al,%r8d
  80042147d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042147d9:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042147dd:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042147e1:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80042147e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042147e9:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042147ed:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042147f1:	48 89 c7             	mov    %rax,%rdi
  80042147f4:	48 b8 31 3e 21 04 80 	movabs $0x8004213e31,%rax
  80042147fb:	00 00 00 
  80042147fe:	ff d0                	callq  *%rax
  8004214800:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004214803:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214807:	74 08                	je     8004214811 <_dwarf_frame_set_fde+0x1f8>
			return (ret);
  8004214809:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421480c:	e9 c4 01 00 00       	jmpq   80042149d5 <_dwarf_frame_set_fde+0x3bc>
		fde->fde_initloc = val;
  8004214811:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214815:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214819:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, 0, error);
  800421481d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214821:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004214825:	44 0f b6 c0          	movzbl %al,%r8d
  8004214829:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421482d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214831:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214835:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004214839:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421483d:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004214841:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214845:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421484b:	48 89 c7             	mov    %rax,%rdi
  800421484e:	48 b8 31 3e 21 04 80 	movabs $0x8004213e31,%rax
  8004214855:	00 00 00 
  8004214858:	ff d0                	callq  *%rax
  800421485a:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  800421485d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214861:	74 08                	je     800421486b <_dwarf_frame_set_fde+0x252>
			return (ret);
  8004214863:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214866:	e9 6a 01 00 00       	jmpq   80042149d5 <_dwarf_frame_set_fde+0x3bc>
		fde->fde_adrange = val;
  800421486b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421486f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214873:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214877:	eb 58                	jmp    80042148d1 <_dwarf_frame_set_fde+0x2b8>
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004214879:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421487d:	4c 8b 40 18          	mov    0x18(%rax),%r8
					     dbg->dbg_pointer_size);
  8004214881:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
			return (ret);
		fde->fde_adrange = val;
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004214885:	8b 50 28             	mov    0x28(%rax),%edx
  8004214888:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421488c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214890:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214894:	48 89 ce             	mov    %rcx,%rsi
  8004214897:	48 89 c7             	mov    %rax,%rdi
  800421489a:	41 ff d0             	callq  *%r8
  800421489d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042148a1:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  80042148a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042148a9:	4c 8b 40 18          	mov    0x18(%rax),%r8
					     dbg->dbg_pointer_size);
  80042148ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
			return (ret);
		fde->fde_adrange = val;
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  80042148b1:	8b 50 28             	mov    0x28(%rax),%edx
  80042148b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042148b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042148bc:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042148c0:	48 89 ce             	mov    %rcx,%rsi
  80042148c3:	48 89 c7             	mov    %rax,%rdi
  80042148c6:	41 ff d0             	callq  *%r8
  80042148c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042148cd:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  80042148d1:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042148d5:	74 68                	je     800421493f <_dwarf_frame_set_fde+0x326>
  80042148d7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042148db:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042148df:	0f b6 00             	movzbl (%rax),%eax
  80042148e2:	3c 7a                	cmp    $0x7a,%al
  80042148e4:	75 59                	jne    800421493f <_dwarf_frame_set_fde+0x326>
		fde->fde_auglen = _dwarf_read_uleb128(ds->ds_data, off);
  80042148e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042148ea:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042148ee:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042148f2:	48 89 d6             	mov    %rdx,%rsi
  80042148f5:	48 89 c7             	mov    %rax,%rdi
  80042148f8:	48 b8 54 0e 21 04 80 	movabs $0x8004210e54,%rax
  80042148ff:	00 00 00 
  8004214902:	ff d0                	callq  *%rax
  8004214904:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214908:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = ds->ds_data + *off;
  800421490c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214910:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214914:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214918:	48 8b 00             	mov    (%rax),%rax
  800421491b:	48 01 c2             	add    %rax,%rdx
  800421491e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214922:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004214926:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421492a:	48 8b 10             	mov    (%rax),%rdx
  800421492d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214931:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004214935:	48 01 c2             	add    %rax,%rdx
  8004214938:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421493c:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = ds->ds_data + *off;
  800421493f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214943:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214947:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421494b:	48 8b 00             	mov    (%rax),%rax
  800421494e:	48 01 c2             	add    %rax,%rdx
  8004214951:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214955:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004214959:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421495d:	75 2d                	jne    800421498c <_dwarf_frame_set_fde+0x373>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  800421495f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214963:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214967:	48 89 c2             	mov    %rax,%rdx
  800421496a:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  800421496e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214972:	48 8b 00             	mov    (%rax),%rax
  8004214975:	48 89 d1             	mov    %rdx,%rcx
  8004214978:	48 29 c1             	sub    %rax,%rcx
  800421497b:	48 89 c8             	mov    %rcx,%rax
  800421497e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004214982:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214986:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421498a:	eb 2b                	jmp    80042149b7 <_dwarf_frame_set_fde+0x39e>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  800421498c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214990:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214994:	48 89 c2             	mov    %rax,%rdx
  8004214997:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  800421499b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421499f:	48 8b 00             	mov    (%rax),%rax
  80042149a2:	48 89 d1             	mov    %rdx,%rcx
  80042149a5:	48 29 c1             	sub    %rax,%rcx
  80042149a8:	48 89 c8             	mov    %rcx,%rax
  80042149ab:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042149af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149b3:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  80042149b7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042149bb:	48 8b 10             	mov    (%rax),%rdx
  80042149be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149c2:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042149c6:	48 01 c2             	add    %rax,%rdx
  80042149c9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042149cd:	48 89 10             	mov    %rdx,(%rax)
	printf("\tfde_offset=%ju fde_length=%ju fde_cieoff=%ju"
	       " fde_instlen=%ju off=%ju\n", fde->fde_offset, fde->fde_length,
	       fde->fde_cieoff, fde->fde_instlen, *off);
#endif

	return (DW_DLE_NONE);
  80042149d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042149d5:	c9                   	leaveq 
  80042149d6:	c3                   	retq   

00000080042149d7 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  80042149d7:	55                   	push   %rbp
  80042149d8:	48 89 e5             	mov    %rsp,%rbp
  80042149db:	48 83 ec 20          	sub    $0x20,%rsp
  80042149df:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042149e3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  80042149e7:	48 b8 a0 36 48 04 80 	movabs $0x80044836a0,%rax
  80042149ee:	00 00 00 
  80042149f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  80042149f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149f9:	48 8b 40 50          	mov    0x50(%rax),%rax
  80042149fd:	48 85 c0             	test   %rax,%rax
  8004214a00:	74 07                	je     8004214a09 <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  8004214a02:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214a07:	eb 33                	jmp    8004214a3c <_dwarf_frame_interal_table_init+0x65>
        /*if ((rt = calloc(1, sizeof(Dwarf_Regtable3))) == NULL) {
	  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
	  return (DW_DLE_MEMORY);
	  }*/

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004214a09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a0d:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  8004214a11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214a15:	66 89 50 18          	mov    %dx,0x18(%rax)

	//assert(!strcmp(section_info[0].ds_name,".debug_info"));
	//cprintf("Table size:%x\n", rt->rt3_reg_table_size);

	rt->rt3_rules = global_rules;
  8004214a19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214a1d:	48 ba a0 3e 48 04 80 	movabs $0x8004483ea0,%rdx
  8004214a24:	00 00 00 
  8004214a27:	48 89 50 20          	mov    %rdx,0x20(%rax)
	  free(rt);
	  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
	  return (DW_DLE_MEMORY);
	  }*/

        dbg->dbg_internal_reg_table = rt;
  8004214a2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a2f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214a33:	48 89 50 50          	mov    %rdx,0x50(%rax)

        return (DW_DLE_NONE);
  8004214a37:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214a3c:	c9                   	leaveq 
  8004214a3d:	c3                   	retq   

0000008004214a3e <_dwarf_get_next_fde>:


static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004214a3e:	55                   	push   %rbp
  8004214a3f:	48 89 e5             	mov    %rsp,%rbp
  8004214a42:	48 83 ec 60          	sub    $0x60,%rsp
  8004214a46:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214a4a:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004214a4d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214a51:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004214a55:	48 b8 20 06 23 04 80 	movabs $0x8004230620,%rax
  8004214a5c:	00 00 00 
  8004214a5f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004214a63:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->dbg_eh_offset;
  8004214a6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a6e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214a72:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < ds->ds_size) {
  8004214a76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a7a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a82:	48 39 c2             	cmp    %rax,%rdx
  8004214a85:	0f 86 04 02 00 00    	jbe    8004214c8f <_dwarf_get_next_fde+0x251>
		entry_off = offset;
  8004214a8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a8f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read(ds->ds_data, &offset, 4);
  8004214a93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a97:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004214a9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214aa3:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214aa7:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214aac:	48 89 ce             	mov    %rcx,%rsi
  8004214aaf:	48 89 c7             	mov    %rax,%rdi
  8004214ab2:	41 ff d0             	callq  *%r8
  8004214ab5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004214ab9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214abe:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214ac2:	75 2f                	jne    8004214af3 <_dwarf_get_next_fde+0xb5>
			dwarf_size = 8;
  8004214ac4:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read(ds->ds_data, &offset, 8);
  8004214acb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214acf:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004214ad3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ad7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214adb:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214adf:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214ae4:	48 89 ce             	mov    %rcx,%rsi
  8004214ae7:	48 89 c7             	mov    %rax,%rdi
  8004214aea:	41 ff d0             	callq  *%r8
  8004214aed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214af1:	eb 07                	jmp    8004214afa <_dwarf_get_next_fde+0xbc>
		} else
			dwarf_size = 4;
  8004214af3:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > ds->ds_size - offset ||
  8004214afa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214afe:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214b06:	48 89 d1             	mov    %rdx,%rcx
  8004214b09:	48 29 c1             	sub    %rax,%rcx
  8004214b0c:	48 89 c8             	mov    %rcx,%rax
  8004214b0f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214b13:	72 0d                	jb     8004214b22 <_dwarf_get_next_fde+0xe4>
  8004214b15:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214b1a:	75 10                	jne    8004214b2c <_dwarf_get_next_fde+0xee>
		    (length == 0 && !eh_frame)) {
  8004214b1c:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214b20:	75 0a                	jne    8004214b2c <_dwarf_get_next_fde+0xee>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214b22:	b8 12 00 00 00       	mov    $0x12,%eax
  8004214b27:	e9 68 01 00 00       	jmpq   8004214c94 <_dwarf_get_next_fde+0x256>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004214b2c:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214b30:	74 11                	je     8004214b43 <_dwarf_get_next_fde+0x105>
  8004214b32:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214b37:	75 0a                	jne    8004214b43 <_dwarf_get_next_fde+0x105>
			return(-1);
  8004214b39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214b3e:	e9 51 01 00 00       	jmpq   8004214c94 <_dwarf_get_next_fde+0x256>

		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004214b43:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214b47:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004214b4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b4f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214b53:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214b56:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214b5a:	48 89 ce             	mov    %rcx,%rsi
  8004214b5d:	48 89 c7             	mov    %rax,%rdi
  8004214b60:	41 ff d0             	callq  *%r8
  8004214b63:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004214b67:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214b6b:	74 79                	je     8004214be6 <_dwarf_get_next_fde+0x1a8>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004214b6d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004214b72:	75 32                	jne    8004214ba6 <_dwarf_get_next_fde+0x168>
				ret = _dwarf_frame_set_cie(dbg, ds,
							   &entry_off, ret_fde->fde_cie, error);
  8004214b74:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);

		if (eh_frame) {
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214b78:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214b7c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
							   &entry_off, ret_fde->fde_cie, error);
  8004214b80:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);

		if (eh_frame) {
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214b84:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004214b88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214b8c:	49 89 f8             	mov    %rdi,%r8
  8004214b8f:	48 89 c7             	mov    %rax,%rdi
  8004214b92:	48 b8 a8 41 21 04 80 	movabs $0x80042141a8,%rax
  8004214b99:	00 00 00 
  8004214b9c:	ff d0                	callq  *%rax
  8004214b9e:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214ba1:	e9 c8 00 00 00       	jmpq   8004214c6e <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
							   &entry_off, 1, ret_fde->fde_cie, error);
  8004214ba6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004214baa:	4c 8b 40 08          	mov    0x8(%rax),%r8
							   &entry_off, 1, ret_fde->fde_cie, error);
  8004214bae:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004214bb2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214bb6:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214bba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214bbe:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214bc2:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214bc6:	4d 89 c1             	mov    %r8,%r9
  8004214bc9:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004214bcf:	48 89 c7             	mov    %rax,%rdi
  8004214bd2:	48 b8 19 46 21 04 80 	movabs $0x8004214619,%rax
  8004214bd9:	00 00 00 
  8004214bdc:	ff d0                	callq  *%rax
  8004214bde:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214be1:	e9 88 00 00 00       	jmpq   8004214c6e <_dwarf_get_next_fde+0x230>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004214be6:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214bea:	75 0b                	jne    8004214bf7 <_dwarf_get_next_fde+0x1b9>
  8004214bec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214bf1:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004214bf5:	74 0d                	je     8004214c04 <_dwarf_get_next_fde+0x1c6>
  8004214bf7:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004214bfb:	75 36                	jne    8004214c33 <_dwarf_get_next_fde+0x1f5>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004214bfd:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004214c02:	75 2f                	jne    8004214c33 <_dwarf_get_next_fde+0x1f5>
				ret = _dwarf_frame_set_cie(dbg, ds,
							   &entry_off, ret_fde->fde_cie, error);
  8004214c04:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214c08:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214c0c:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
							   &entry_off, ret_fde->fde_cie, error);
  8004214c10:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004214c14:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004214c18:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c1c:	49 89 f8             	mov    %rdi,%r8
  8004214c1f:	48 89 c7             	mov    %rax,%rdi
  8004214c22:	48 b8 a8 41 21 04 80 	movabs $0x80042141a8,%rax
  8004214c29:	00 00 00 
  8004214c2c:	ff d0                	callq  *%rax
  8004214c2e:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004214c31:	eb 3b                	jmp    8004214c6e <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
							   &entry_off, 0, ret_fde->fde_cie, error);
  8004214c33:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004214c37:	4c 8b 40 08          	mov    0x8(%rax),%r8
							   &entry_off, 0, ret_fde->fde_cie, error);
  8004214c3b:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004214c3f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c43:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214c47:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c4b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214c4f:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214c53:	4d 89 c1             	mov    %r8,%r9
  8004214c56:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004214c5c:	48 89 c7             	mov    %rax,%rdi
  8004214c5f:	48 b8 19 46 21 04 80 	movabs $0x8004214619,%rax
  8004214c66:	00 00 00 
  8004214c69:	ff d0                	callq  *%rax
  8004214c6b:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004214c6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004214c72:	74 07                	je     8004214c7b <_dwarf_get_next_fde+0x23d>
			return(-1);
  8004214c74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214c79:	eb 19                	jmp    8004214c94 <_dwarf_get_next_fde+0x256>

		offset = entry_off;
  8004214c7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214c7f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->dbg_eh_offset = offset;
  8004214c83:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214c87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c8b:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214c8f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214c94:	c9                   	leaveq 
  8004214c95:	c3                   	retq   

0000008004214c96 <dwarf_set_frame_cfa_value>:


Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004214c96:	55                   	push   %rbp
  8004214c97:	48 89 e5             	mov    %rsp,%rbp
  8004214c9a:	48 83 ec 20          	sub    $0x20,%rsp
  8004214c9e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214ca2:	89 f0                	mov    %esi,%eax
  8004214ca4:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  8004214ca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214cac:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004214cb0:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  8004214cb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214cb8:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004214cbc:	66 89 50 44          	mov    %dx,0x44(%rax)

        return (old_value);
  8004214cc0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004214cc4:	c9                   	leaveq 
  8004214cc5:	c3                   	retq   

0000008004214cc6 <_dwarf_frame_section_load_eh>:

int
_dwarf_frame_section_load_eh(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214cc6:	55                   	push   %rbp
  8004214cc7:	48 89 e5             	mov    %rsp,%rbp
  8004214cca:	48 83 ec 20          	sub    $0x20,%rsp
  8004214cce:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214cd2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int status;
	Dwarf_Section *ds = &debug_frame_sec;
  8004214cd6:	48 b8 20 06 23 04 80 	movabs $0x8004230620,%rax
  8004214cdd:	00 00 00 
  8004214ce0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        status  = _dwarf_find_section_enhanced(&debug_frame_sec);
  8004214ce4:	48 bf 20 06 23 04 80 	movabs $0x8004230620,%rdi
  8004214ceb:	00 00 00 
  8004214cee:	48 b8 33 27 21 04 80 	movabs $0x8004212733,%rax
  8004214cf5:	00 00 00 
  8004214cf8:	ff d0                	callq  *%rax
  8004214cfa:	89 45 f4             	mov    %eax,-0xc(%rbp)
        return (DW_DLE_NONE);
  8004214cfd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214d02:	c9                   	leaveq 
  8004214d03:	c3                   	retq   

0000008004214d04 <dwarf_init_eh_section>:


int
dwarf_init_eh_section(Dwarf_Debug dbg,
                      Dwarf_Error *error)
{
  8004214d04:	55                   	push   %rbp
  8004214d05:	48 89 e5             	mov    %rsp,%rbp
  8004214d08:	48 83 ec 10          	sub    $0x10,%rsp
  8004214d0c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004214d10:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

        if (dbg == NULL) {
  8004214d14:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214d19:	75 07                	jne    8004214d22 <dwarf_init_eh_section+0x1e>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  8004214d1b:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214d20:	eb 7e                	jmp    8004214da0 <dwarf_init_eh_section+0x9c>
        }

        if (dbg->dbg_internal_reg_table == NULL) {
  8004214d22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d26:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004214d2a:	48 85 c0             	test   %rax,%rax
  8004214d2d:	75 25                	jne    8004214d54 <dwarf_init_eh_section+0x50>
                if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004214d2f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214d33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d37:	48 89 d6             	mov    %rdx,%rsi
  8004214d3a:	48 89 c7             	mov    %rax,%rdi
  8004214d3d:	48 b8 d7 49 21 04 80 	movabs $0x80042149d7,%rax
  8004214d44:	00 00 00 
  8004214d47:	ff d0                	callq  *%rax
  8004214d49:	85 c0                	test   %eax,%eax
  8004214d4b:	74 07                	je     8004214d54 <dwarf_init_eh_section+0x50>
                        return (DW_DLV_ERROR);
  8004214d4d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214d52:	eb 4c                	jmp    8004214da0 <dwarf_init_eh_section+0x9c>
	}

	if (_dwarf_frame_section_load_eh(dbg, error) != DW_DLE_NONE)
  8004214d54:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004214d58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d5c:	48 89 d6             	mov    %rdx,%rsi
  8004214d5f:	48 89 c7             	mov    %rax,%rdi
  8004214d62:	48 b8 c6 4c 21 04 80 	movabs $0x8004214cc6,%rax
  8004214d69:	00 00 00 
  8004214d6c:	ff d0                	callq  *%rax
  8004214d6e:	85 c0                	test   %eax,%eax
  8004214d70:	74 07                	je     8004214d79 <dwarf_init_eh_section+0x75>
		return (DW_DLV_ERROR);
  8004214d72:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214d77:	eb 27                	jmp    8004214da0 <dwarf_init_eh_section+0x9c>

	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004214d79:	48 b8 20 06 23 04 80 	movabs $0x8004230620,%rax
  8004214d80:	00 00 00 
  8004214d83:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214d87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d8b:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_offset = 0;
  8004214d8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d93:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004214d9a:	00 

	return (DW_DLV_OK);
  8004214d9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214da0:	c9                   	leaveq 
  8004214da1:	c3                   	retq   
	...

0000008004214da4 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214da4:	55                   	push   %rbp
  8004214da5:	48 89 e5             	mov    %rsp,%rbp
  8004214da8:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004214daf:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004214db3:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004214db7:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004214dbb:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004214dbf:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004214dc6:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004214dcd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214dd1:	48 83 c0 48          	add    $0x48,%rax
  8004214dd5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004214dd9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004214de0:	00 
  8004214de1:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004214de8:	00 
  8004214de9:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004214df0:	00 
  8004214df1:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004214df8:	00 
  8004214df9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214dfd:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214e01:	0f b6 c0             	movzbl %al,%eax
  8004214e04:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004214e07:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004214e0e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004214e15:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214e1c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004214e23:	e9 cf 04 00 00       	jmpq   80042152f7 <_dwarf_lineno_run_program+0x553>
		if (*p == 0) {
  8004214e28:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e2c:	0f b6 00             	movzbl (%rax),%eax
  8004214e2f:	84 c0                	test   %al,%al
  8004214e31:	0f 85 47 01 00 00    	jne    8004214f7e <_dwarf_lineno_run_program+0x1da>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004214e37:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e3b:	48 83 c0 01          	add    $0x1,%rax
  8004214e3f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004214e43:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004214e47:	48 89 c7             	mov    %rax,%rdi
  8004214e4a:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004214e51:	00 00 00 
  8004214e54:	ff d0                	callq  *%rax
  8004214e56:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			switch (*p) {
  8004214e5a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e5e:	0f b6 00             	movzbl (%rax),%eax
  8004214e61:	0f b6 c0             	movzbl %al,%eax
  8004214e64:	83 f8 02             	cmp    $0x2,%eax
  8004214e67:	74 74                	je     8004214edd <_dwarf_lineno_run_program+0x139>
  8004214e69:	83 f8 03             	cmp    $0x3,%eax
  8004214e6c:	0f 84 a7 00 00 00    	je     8004214f19 <_dwarf_lineno_run_program+0x175>
  8004214e72:	83 f8 01             	cmp    $0x1,%eax
  8004214e75:	0f 85 f2 00 00 00    	jne    8004214f6d <_dwarf_lineno_run_program+0x1c9>
			case DW_LNE_end_sequence:
				p++;
  8004214e7b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e7f:	48 83 c0 01          	add    $0x1,%rax
  8004214e83:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				end_sequence = 1;
  8004214e87:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
				RESET_REGISTERS;
  8004214e8e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004214e95:	00 
  8004214e96:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004214e9d:	00 
  8004214e9e:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  8004214ea5:	00 
  8004214ea6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004214ead:	00 
  8004214eae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214eb2:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214eb6:	0f b6 c0             	movzbl %al,%eax
  8004214eb9:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004214ebc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004214ec3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004214eca:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214ed1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  8004214ed8:	e9 1a 04 00 00       	jmpq   80042152f7 <_dwarf_lineno_run_program+0x553>
			case DW_LNE_set_address:
				p++;
  8004214edd:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214ee1:	48 83 c0 01          	add    $0x1,%rax
  8004214ee5:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004214ee9:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004214ef0:	00 00 00 
  8004214ef3:	48 8b 00             	mov    (%rax),%rax
  8004214ef6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214efa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214efe:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  8004214f02:	0f b6 d0             	movzbl %al,%edx
  8004214f05:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004214f09:	89 d6                	mov    %edx,%esi
  8004214f0b:	48 89 c7             	mov    %rax,%rdi
  8004214f0e:	ff d1                	callq  *%rcx
  8004214f10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				break;
  8004214f14:	e9 de 03 00 00       	jmpq   80042152f7 <_dwarf_lineno_run_program+0x553>
			case DW_LNE_define_file:
				p++;
  8004214f19:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214f1d:	48 83 c0 01          	add    $0x1,%rax
  8004214f21:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004214f25:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004214f2c:	00 00 00 
  8004214f2f:	48 8b 08             	mov    (%rax),%rcx
  8004214f32:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004214f39:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  8004214f3d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214f41:	49 89 c8             	mov    %rcx,%r8
  8004214f44:	48 89 d1             	mov    %rdx,%rcx
  8004214f47:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214f4c:	48 89 c7             	mov    %rax,%rdi
  8004214f4f:	48 b8 11 53 21 04 80 	movabs $0x8004215311,%rax
  8004214f56:	00 00 00 
  8004214f59:	ff d0                	callq  *%rax
  8004214f5b:	89 45 b4             	mov    %eax,-0x4c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004214f5e:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004214f62:	0f 84 8e 03 00 00    	je     80042152f6 <_dwarf_lineno_run_program+0x552>
					goto prog_fail;
  8004214f68:	e9 9f 03 00 00       	jmpq   800421530c <_dwarf_lineno_run_program+0x568>
				break;
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  8004214f6d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214f71:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004214f75:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004214f79:	e9 79 03 00 00       	jmpq   80042152f7 <_dwarf_lineno_run_program+0x553>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004214f7e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214f82:	0f b6 00             	movzbl (%rax),%eax
  8004214f85:	84 c0                	test   %al,%al
  8004214f87:	0f 84 2f 02 00 00    	je     80042151bc <_dwarf_lineno_run_program+0x418>
  8004214f8d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214f91:	0f b6 10             	movzbl (%rax),%edx
  8004214f94:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214f98:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214f9c:	38 c2                	cmp    %al,%dl
  8004214f9e:	0f 83 18 02 00 00    	jae    80042151bc <_dwarf_lineno_run_program+0x418>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004214fa4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214fa8:	0f b6 10             	movzbl (%rax),%edx
  8004214fab:	0f b6 d2             	movzbl %dl,%edx
  8004214fae:	48 83 c0 01          	add    $0x1,%rax
  8004214fb2:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004214fb6:	83 fa 0c             	cmp    $0xc,%edx
  8004214fb9:	0f 87 f7 01 00 00    	ja     80042151b6 <_dwarf_lineno_run_program+0x412>
  8004214fbf:	89 d0                	mov    %edx,%eax
  8004214fc1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214fc8:	00 
  8004214fc9:	48 b8 10 ed 21 04 80 	movabs $0x800421ed10,%rax
  8004214fd0:	00 00 00 
  8004214fd3:	48 01 d0             	add    %rdx,%rax
  8004214fd6:	48 8b 00             	mov    (%rax),%rax
  8004214fd9:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004214fdb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214fe2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214fe6:	73 0a                	jae    8004214ff2 <_dwarf_lineno_run_program+0x24e>
  8004214fe8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fed:	e9 1d 03 00 00       	jmpq   800421530f <_dwarf_lineno_run_program+0x56b>
  8004214ff2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214ff6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214ffa:	48 89 10             	mov    %rdx,(%rax)
  8004214ffd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215001:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215008:	00 
  8004215009:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421500d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215011:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215015:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215019:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421501d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215021:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215025:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215029:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421502d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215031:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004215034:	89 50 28             	mov    %edx,0x28(%rax)
  8004215037:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421503b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421503e:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215041:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215045:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215048:	89 50 30             	mov    %edx,0x30(%rax)
  800421504b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421504f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215056:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421505a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421505e:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004215065:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				prologue_end = 0;
  800421506c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
				epilogue_begin = 0;
  8004215073:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  800421507a:	e9 38 01 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  800421507f:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004215083:	48 89 c7             	mov    %rax,%rdi
  8004215086:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  800421508d:	00 00 00 
  8004215090:	ff d0                	callq  *%rax
					li->li_minlen;
  8004215092:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004215096:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  800421509a:	0f b6 d2             	movzbl %dl,%edx
  800421509d:	48 0f af c2          	imul   %rdx,%rax
  80042150a1:	48 01 45 f8          	add    %rax,-0x8(%rbp)
					li->li_minlen;
				break;
  80042150a5:	e9 0d 01 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  80042150aa:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042150ae:	48 89 c7             	mov    %rax,%rdi
  80042150b1:	48 b8 d5 0e 21 04 80 	movabs $0x8004210ed5,%rax
  80042150b8:	00 00 00 
  80042150bb:	ff d0                	callq  *%rax
  80042150bd:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  80042150c1:	e9 f1 00 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  80042150c6:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042150ca:	48 89 c7             	mov    %rax,%rdi
  80042150cd:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042150d4:	00 00 00 
  80042150d7:	ff d0                	callq  *%rax
  80042150d9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
				break;
  80042150dd:	e9 d5 00 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042150e2:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042150e6:	48 89 c7             	mov    %rax,%rdi
  80042150e9:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042150f0:	00 00 00 
  80042150f3:	ff d0                	callq  *%rax
  80042150f5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  80042150f9:	e9 b9 00 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  80042150fe:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004215102:	0f 94 c0             	sete   %al
  8004215105:	0f b6 c0             	movzbl %al,%eax
  8004215108:	89 45 dc             	mov    %eax,-0x24(%rbp)
				break;
  800421510b:	e9 a7 00 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004215110:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
				break;
  8004215117:	e9 9b 00 00 00       	jmpq   80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  800421511c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215120:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215124:	0f b6 c0             	movzbl %al,%eax
  8004215127:	ba ff 00 00 00       	mov    $0xff,%edx
  800421512c:	89 d1                	mov    %edx,%ecx
  800421512e:	29 c1                	sub    %eax,%ecx
  8004215130:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215134:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004215138:	0f b6 c0             	movzbl %al,%eax
  800421513b:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  8004215141:	89 c8                	mov    %ecx,%eax
  8004215143:	89 c2                	mov    %eax,%edx
  8004215145:	c1 fa 1f             	sar    $0x1f,%edx
  8004215148:	f7 bd 6c ff ff ff    	idivl  -0x94(%rbp)
  800421514e:	89 c2                	mov    %eax,%edx
  8004215150:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215154:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215158:	0f b6 c0             	movzbl %al,%eax
  800421515b:	0f af c2             	imul   %edx,%eax
  800421515e:	48 98                	cltq   
  8004215160:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004215164:	eb 51                	jmp    80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004215166:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800421516d:	00 00 00 
  8004215170:	48 8b 00             	mov    (%rax),%rax
  8004215173:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215177:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421517b:	be 02 00 00 00       	mov    $0x2,%esi
  8004215180:	48 89 c7             	mov    %rax,%rdi
  8004215183:	ff d2                	callq  *%rdx
  8004215185:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004215189:	eb 2c                	jmp    80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  800421518b:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				break;
  8004215192:	eb 23                	jmp    80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004215194:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%rbp)
				break;
  800421519b:	eb 1a                	jmp    80042151b7 <_dwarf_lineno_run_program+0x413>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  800421519d:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042151a1:	48 89 c7             	mov    %rax,%rdi
  80042151a4:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  80042151ab:	00 00 00 
  80042151ae:	ff d0                	callq  *%rax
  80042151b0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				break;
  80042151b4:	eb 01                	jmp    80042151b7 <_dwarf_lineno_run_program+0x413>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  80042151b6:	90                   	nop
			}

		} else {
  80042151b7:	e9 3b 01 00 00       	jmpq   80042152f7 <_dwarf_lineno_run_program+0x553>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  80042151bc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042151c0:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042151c4:	0f be c8             	movsbl %al,%ecx
  80042151c7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042151cb:	0f b6 00             	movzbl (%rax),%eax
  80042151ce:	0f b6 d0             	movzbl %al,%edx
  80042151d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042151d5:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042151d9:	0f b6 c0             	movzbl %al,%eax
  80042151dc:	29 c2                	sub    %eax,%edx
  80042151de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042151e2:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042151e6:	0f b6 f0             	movzbl %al,%esi
  80042151e9:	89 d0                	mov    %edx,%eax
  80042151eb:	89 c2                	mov    %eax,%edx
  80042151ed:	c1 fa 1f             	sar    $0x1f,%edx
  80042151f0:	f7 fe                	idiv   %esi
  80042151f2:	89 d0                	mov    %edx,%eax
  80042151f4:	01 c8                	add    %ecx,%eax
  80042151f6:	48 98                	cltq   
  80042151f8:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			address += ADDRESS(*p);
  80042151fc:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215200:	0f b6 00             	movzbl (%rax),%eax
  8004215203:	0f b6 d0             	movzbl %al,%edx
  8004215206:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421520a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421520e:	0f b6 c0             	movzbl %al,%eax
  8004215211:	89 d1                	mov    %edx,%ecx
  8004215213:	29 c1                	sub    %eax,%ecx
  8004215215:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215219:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  800421521d:	0f b6 c0             	movzbl %al,%eax
  8004215220:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  8004215226:	89 c8                	mov    %ecx,%eax
  8004215228:	89 c2                	mov    %eax,%edx
  800421522a:	c1 fa 1f             	sar    $0x1f,%edx
  800421522d:	f7 bd 6c ff ff ff    	idivl  -0x94(%rbp)
  8004215233:	89 c2                	mov    %eax,%edx
  8004215235:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004215239:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  800421523d:	0f b6 c0             	movzbl %al,%eax
  8004215240:	0f af c2             	imul   %edx,%eax
  8004215243:	48 98                	cltq   
  8004215245:	48 01 45 f8          	add    %rax,-0x8(%rbp)
			APPEND_ROW;
  8004215249:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215250:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004215254:	73 0a                	jae    8004215260 <_dwarf_lineno_run_program+0x4bc>
  8004215256:	b8 00 00 00 00       	mov    $0x0,%eax
  800421525b:	e9 af 00 00 00       	jmpq   800421530f <_dwarf_lineno_run_program+0x56b>
  8004215260:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215264:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215268:	48 89 10             	mov    %rdx,(%rax)
  800421526b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421526f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215276:	00 
  8004215277:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421527b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421527f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215283:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215287:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421528b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421528f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215293:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215297:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421529b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421529f:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80042152a2:	89 50 28             	mov    %edx,0x28(%rax)
  80042152a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042152a9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042152ac:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042152af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042152b3:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042152b6:	89 50 30             	mov    %edx,0x30(%rax)
  80042152b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042152bd:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042152c4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042152c8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042152cc:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  80042152d3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
			prologue_end = 0;
  80042152da:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
			epilogue_begin = 0;
  80042152e1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
			p++;
  80042152e8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042152ec:	48 83 c0 01          	add    $0x1,%rax
  80042152f0:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042152f4:	eb 01                	jmp    80042152f7 <_dwarf_lineno_run_program+0x553>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  80042152f6:	90                   	nop
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042152f7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042152fb:	48 3b 45 80          	cmp    -0x80(%rbp),%rax
  80042152ff:	0f 82 23 fb ff ff    	jb     8004214e28 <_dwarf_lineno_run_program+0x84>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004215305:	b8 00 00 00 00       	mov    $0x0,%eax
  800421530a:	eb 03                	jmp    800421530f <_dwarf_lineno_run_program+0x56b>

prog_fail:

	return (ret);
  800421530c:	8b 45 b4             	mov    -0x4c(%rbp),%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  800421530f:	c9                   	leaveq 
  8004215310:	c3                   	retq   

0000008004215311 <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004215311:	55                   	push   %rbp
  8004215312:	48 89 e5             	mov    %rsp,%rbp
  8004215315:	53                   	push   %rbx
  8004215316:	48 83 ec 48          	sub    $0x48,%rsp
  800421531a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421531e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004215322:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004215326:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  800421532a:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  800421532e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215332:	48 8b 00             	mov    (%rax),%rax
  8004215335:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004215339:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421533d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004215341:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004215345:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215349:	48 89 c7             	mov    %rax,%rdi
  800421534c:	48 b8 44 00 21 04 80 	movabs $0x8004210044,%rax
  8004215353:	00 00 00 
  8004215356:	ff d0                	callq  *%rax
  8004215358:	48 98                	cltq   
  800421535a:	48 83 c0 01          	add    $0x1,%rax
  800421535e:	48 01 d8             	add    %rbx,%rax
  8004215361:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004215365:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215369:	48 89 c7             	mov    %rax,%rdi
  800421536c:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004215373:	00 00 00 
  8004215376:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004215378:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421537c:	48 89 c7             	mov    %rax,%rdi
  800421537f:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004215386:	00 00 00 
  8004215389:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  800421538b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421538f:	48 89 c7             	mov    %rax,%rdi
  8004215392:	48 b8 6e 0f 21 04 80 	movabs $0x8004210f6e,%rax
  8004215399:	00 00 00 
  800421539c:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  800421539e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042153a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153a6:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042153a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042153ae:	48 83 c4 48          	add    $0x48,%rsp
  80042153b2:	5b                   	pop    %rbx
  80042153b3:	5d                   	pop    %rbp
  80042153b4:	c3                   	retq   

00000080042153b5 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  80042153b5:	55                   	push   %rbp
  80042153b6:	48 89 e5             	mov    %rsp,%rbp
  80042153b9:	53                   	push   %rbx
  80042153ba:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  80042153c1:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80042153c8:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  80042153cf:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  80042153d6:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  80042153dd:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  80042153e4:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80042153eb:	00 
  80042153ec:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  80042153f3:	00 
  80042153f4:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  80042153fb:	00 
  80042153fc:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004215403:	00 
  8004215404:	48 b8 78 ed 21 04 80 	movabs $0x800421ed78,%rax
  800421540b:	00 00 00 
  800421540e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004215412:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004215416:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  800421541a:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004215421:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004215428:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  800421542c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004215431:	75 35                	jne    8004215468 <_dwarf_lineno_init+0xb3>
  8004215433:	48 b9 84 ed 21 04 80 	movabs $0x800421ed84,%rcx
  800421543a:	00 00 00 
  800421543d:	48 ba 8f ed 21 04 80 	movabs $0x800421ed8f,%rdx
  8004215444:	00 00 00 
  8004215447:	be 17 01 00 00       	mov    $0x117,%esi
  800421544c:	48 bf a4 ed 21 04 80 	movabs $0x800421eda4,%rdi
  8004215453:	00 00 00 
  8004215456:	b8 00 00 00 00       	mov    $0x0,%eax
  800421545b:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004215462:	00 00 00 
  8004215465:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004215468:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800421546f:	00 00 00 
  8004215472:	48 8b 00             	mov    (%rax),%rax
  8004215475:	48 85 c0             	test   %rax,%rax
  8004215478:	75 35                	jne    80042154af <_dwarf_lineno_init+0xfa>
  800421547a:	48 b9 bb ed 21 04 80 	movabs $0x800421edbb,%rcx
  8004215481:	00 00 00 
  8004215484:	48 ba 8f ed 21 04 80 	movabs $0x800421ed8f,%rdx
  800421548b:	00 00 00 
  800421548e:	be 18 01 00 00       	mov    $0x118,%esi
  8004215493:	48 bf a4 ed 21 04 80 	movabs $0x800421eda4,%rdi
  800421549a:	00 00 00 
  800421549d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154a2:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042154a9:	00 00 00 
  80042154ac:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  80042154af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042154b3:	48 89 c7             	mov    %rax,%rdi
  80042154b6:	48 b8 33 27 21 04 80 	movabs $0x8004212733,%rax
  80042154bd:	00 00 00 
  80042154c0:	ff d0                	callq  *%rax
  80042154c2:	85 c0                	test   %eax,%eax
  80042154c4:	74 0a                	je     80042154d0 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  80042154c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154cb:	e9 7d 04 00 00       	jmpq   800421594d <_dwarf_lineno_init+0x598>

	li = linfo;
  80042154d0:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042154d7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  80042154db:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042154e2:	00 00 00 
  80042154e5:	48 8b 00             	mov    (%rax),%rax
  80042154e8:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042154ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042154f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042154f4:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042154fb:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215500:	48 89 ce             	mov    %rcx,%rsi
  8004215503:	48 89 c7             	mov    %rax,%rdi
  8004215506:	41 ff d0             	callq  *%r8
  8004215509:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  800421550d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215512:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004215516:	75 3b                	jne    8004215553 <_dwarf_lineno_init+0x19e>
		dwarf_size = 8;
  8004215518:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  800421551f:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004215526:	00 00 00 
  8004215529:	48 8b 00             	mov    (%rax),%rax
  800421552c:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004215530:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215534:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215538:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  800421553f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004215544:	48 89 ce             	mov    %rcx,%rsi
  8004215547:	48 89 c7             	mov    %rax,%rdi
  800421554a:	41 ff d0             	callq  *%r8
  800421554d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004215551:	eb 07                	jmp    800421555a <_dwarf_lineno_init+0x1a5>
	} else
		dwarf_size = 4;
  8004215553:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  800421555a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421555e:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215562:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215569:	48 89 d1             	mov    %rdx,%rcx
  800421556c:	48 29 c1             	sub    %rax,%rcx
  800421556f:	48 89 c8             	mov    %rcx,%rax
  8004215572:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004215576:	73 0a                	jae    8004215582 <_dwarf_lineno_init+0x1cd>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004215578:	b8 0f 00 00 00       	mov    $0xf,%eax
  800421557d:	e9 cb 03 00 00       	jmpq   800421594d <_dwarf_lineno_init+0x598>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004215582:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215586:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421558a:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  800421558d:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215594:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004215598:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  800421559c:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042155a3:	00 00 00 
  80042155a6:	48 8b 00             	mov    (%rax),%rax
  80042155a9:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042155ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042155b1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042155b5:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042155bc:	ba 02 00 00 00       	mov    $0x2,%edx
  80042155c1:	48 89 ce             	mov    %rcx,%rsi
  80042155c4:	48 89 c7             	mov    %rax,%rdi
  80042155c7:	41 ff d0             	callq  *%r8
  80042155ca:	89 c2                	mov    %eax,%edx
  80042155cc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042155d0:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  80042155d4:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042155db:	00 00 00 
  80042155de:	48 8b 00             	mov    (%rax),%rax
  80042155e1:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042155e5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042155e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042155ed:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042155f0:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042155f7:	48 89 ce             	mov    %rcx,%rsi
  80042155fa:	48 89 c7             	mov    %rax,%rdi
  80042155fd:	41 ff d0             	callq  *%r8
  8004215600:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004215604:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004215608:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800421560f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004215613:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800421561a:	00 00 00 
  800421561d:	48 8b 00             	mov    (%rax),%rax
  8004215620:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004215624:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215628:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421562c:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  8004215633:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215638:	48 89 ce             	mov    %rcx,%rsi
  800421563b:	48 89 c7             	mov    %rax,%rdi
  800421563e:	41 ff d0             	callq  *%r8
  8004215641:	89 c2                	mov    %eax,%edx
  8004215643:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215647:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  800421564a:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004215651:	00 00 00 
  8004215654:	48 8b 00             	mov    (%rax),%rax
  8004215657:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421565b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421565f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215663:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  800421566a:	ba 01 00 00 00       	mov    $0x1,%edx
  800421566f:	48 89 ce             	mov    %rcx,%rsi
  8004215672:	48 89 c7             	mov    %rax,%rdi
  8004215675:	41 ff d0             	callq  *%r8
  8004215678:	89 c2                	mov    %eax,%edx
  800421567a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421567e:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004215681:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004215688:	00 00 00 
  800421568b:	48 8b 00             	mov    (%rax),%rax
  800421568e:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004215692:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215696:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421569a:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042156a1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042156a6:	48 89 ce             	mov    %rcx,%rsi
  80042156a9:	48 89 c7             	mov    %rax,%rdi
  80042156ac:	41 ff d0             	callq  *%r8
  80042156af:	89 c2                	mov    %eax,%edx
  80042156b1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042156b5:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  80042156b8:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042156bf:	00 00 00 
  80042156c2:	48 8b 00             	mov    (%rax),%rax
  80042156c5:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042156c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042156cd:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042156d1:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042156d8:	ba 01 00 00 00       	mov    $0x1,%edx
  80042156dd:	48 89 ce             	mov    %rcx,%rsi
  80042156e0:	48 89 c7             	mov    %rax,%rdi
  80042156e3:	41 ff d0             	callq  *%r8
  80042156e6:	89 c2                	mov    %eax,%edx
  80042156e8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042156ec:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042156ef:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  80042156f6:	00 00 00 
  80042156f9:	48 8b 00             	mov    (%rax),%rax
  80042156fc:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004215700:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215704:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215708:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  800421570f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215714:	48 89 ce             	mov    %rcx,%rsi
  8004215717:	48 89 c7             	mov    %rax,%rdi
  800421571a:	41 ff d0             	callq  *%r8
  800421571d:	89 c2                	mov    %eax,%edx
  800421571f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215723:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004215726:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421572a:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421572e:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004215731:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215735:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215739:	0f b6 c0             	movzbl %al,%eax
  800421573c:	83 e8 01             	sub    $0x1,%eax
  800421573f:	39 c2                	cmp    %eax,%edx
  8004215741:	7d 0c                	jge    800421574f <_dwarf_lineno_init+0x39a>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004215743:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421574a:	e9 fb 01 00 00       	jmpq   800421594a <_dwarf_lineno_init+0x595>
	}

	li->li_oplen = global_std_op;
  800421574f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215753:	48 ba e0 44 48 04 80 	movabs $0x80044844e0,%rdx
  800421575a:	00 00 00 
  800421575d:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004215761:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004215768:	eb 45                	jmp    80042157af <_dwarf_lineno_init+0x3fa>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  800421576a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421576e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215772:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004215775:	48 98                	cltq   
  8004215777:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800421577b:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  8004215782:	00 00 00 
  8004215785:	48 8b 00             	mov    (%rax),%rax
  8004215788:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421578c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215790:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215794:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  800421579b:	ba 01 00 00 00       	mov    $0x1,%edx
  80042157a0:	48 89 ce             	mov    %rcx,%rsi
  80042157a3:	48 89 c7             	mov    %rax,%rdi
  80042157a6:	41 ff d0             	callq  *%r8
  80042157a9:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  80042157ab:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  80042157af:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042157b3:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042157b7:	0f b6 c0             	movzbl %al,%eax
  80042157ba:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  80042157bd:	7f ab                	jg     800421576a <_dwarf_lineno_init+0x3b5>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  80042157bf:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042157c6:	00 
	p = ds->ds_data + offset;
  80042157c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042157cb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042157cf:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042157d6:	48 01 d0             	add    %rdx,%rax
  80042157d9:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  80042157e0:	eb 24                	jmp    8004215806 <_dwarf_lineno_init+0x451>
		while (*p++ != '\0')
  80042157e2:	90                   	nop
  80042157e3:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042157ea:	0f b6 10             	movzbl (%rax),%edx
  80042157ed:	84 d2                	test   %dl,%dl
  80042157ef:	0f 95 c2             	setne  %dl
  80042157f2:	48 83 c0 01          	add    $0x1,%rax
  80042157f6:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  80042157fd:	84 d2                	test   %dl,%dl
  80042157ff:	75 e2                	jne    80042157e3 <_dwarf_lineno_init+0x42e>
			;
		length++;
  8004215801:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004215806:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421580d:	0f b6 00             	movzbl (%rax),%eax
  8004215810:	84 c0                	test   %al,%al
  8004215812:	75 ce                	jne    80042157e2 <_dwarf_lineno_init+0x42d>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004215814:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215818:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421581c:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004215820:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215827:	48 89 c2             	mov    %rax,%rdx
  800421582a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421582e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215832:	48 29 c2             	sub    %rax,%rdx
  8004215835:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215839:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421583d:	48 98                	cltq   
  800421583f:	48 39 c2             	cmp    %rax,%rdx
  8004215842:	7e 0c                	jle    8004215850 <_dwarf_lineno_init+0x49b>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004215844:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  800421584b:	e9 fa 00 00 00       	jmpq   800421594a <_dwarf_lineno_init+0x595>
  li->li_incdirs[i++] = (char *) p;
  while (*p++ != '\0')
  ;
  }
*/
	p++;
  8004215850:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215857:	48 83 c0 01          	add    $0x1,%rax
  800421585b:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004215862:	eb 3c                	jmp    80042158a0 <_dwarf_lineno_init+0x4eb>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004215864:	48 b8 08 06 23 04 80 	movabs $0x8004230608,%rax
  800421586b:	00 00 00 
  800421586e:	48 8b 08             	mov    (%rax),%rcx
  8004215871:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004215878:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  800421587f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215883:	49 89 c8             	mov    %rcx,%r8
  8004215886:	48 89 d1             	mov    %rdx,%rcx
  8004215889:	ba 00 00 00 00       	mov    $0x0,%edx
  800421588e:	48 89 c7             	mov    %rax,%rdi
  8004215891:	48 b8 11 53 21 04 80 	movabs $0x8004215311,%rax
  8004215898:	00 00 00 
  800421589b:	ff d0                	callq  *%rax
  800421589d:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  80042158a0:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042158a7:	0f b6 00             	movzbl (%rax),%eax
  80042158aa:	84 c0                	test   %al,%al
  80042158ac:	75 b6                	jne    8004215864 <_dwarf_lineno_init+0x4af>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  80042158ae:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042158b5:	48 83 c0 01          	add    $0x1,%rax
  80042158b9:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  80042158c0:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042158c7:	48 89 c2             	mov    %rax,%rdx
  80042158ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042158d2:	48 89 d1             	mov    %rdx,%rcx
  80042158d5:	48 29 c1             	sub    %rax,%rcx
  80042158d8:	48 89 c8             	mov    %rcx,%rax
  80042158db:	48 89 c2             	mov    %rax,%rdx
  80042158de:	48 2b 55 b0          	sub    -0x50(%rbp),%rdx
  80042158e2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042158e6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042158ea:	48 39 c2             	cmp    %rax,%rdx
  80042158ed:	74 09                	je     80042158f8 <_dwarf_lineno_init+0x543>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042158ef:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042158f6:	eb 52                	jmp    800421594a <_dwarf_lineno_init+0x595>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042158f8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215900:	48 89 c1             	mov    %rax,%rcx
  8004215903:	48 03 4d b8          	add    -0x48(%rbp),%rcx
  8004215907:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421590e:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004215915:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  800421591c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004215920:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215924:	4d 89 c1             	mov    %r8,%r9
  8004215927:	49 89 f8             	mov    %rdi,%r8
  800421592a:	48 89 c7             	mov    %rax,%rdi
  800421592d:	48 b8 a4 4d 21 04 80 	movabs $0x8004214da4,%rax
  8004215934:	00 00 00 
  8004215937:	ff d0                	callq  *%rax
  8004215939:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  800421593c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004215940:	75 07                	jne    8004215949 <_dwarf_lineno_init+0x594>
		goto fail_cleanup;

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004215942:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215947:	eb 04                	jmp    800421594d <_dwarf_lineno_init+0x598>
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
					error);
	if (ret != DW_DLE_NONE)
		goto fail_cleanup;
  8004215949:	90                   	nop
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  800421594a:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  800421594d:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004215954:	5b                   	pop    %rbx
  8004215955:	5d                   	pop    %rbp
  8004215956:	c3                   	retq   

0000008004215957 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004215957:	55                   	push   %rbp
  8004215958:	48 89 e5             	mov    %rsp,%rbp
  800421595b:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004215962:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004215969:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004215970:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004215977:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  800421597e:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004215985:	00 
  8004215986:	75 35                	jne    80042159bd <dwarf_srclines+0x66>
  8004215988:	48 b9 c7 ed 21 04 80 	movabs $0x800421edc7,%rcx
  800421598f:	00 00 00 
  8004215992:	48 ba 8f ed 21 04 80 	movabs $0x800421ed8f,%rdx
  8004215999:	00 00 00 
  800421599c:	be ae 01 00 00       	mov    $0x1ae,%esi
  80042159a1:	48 bf a4 ed 21 04 80 	movabs $0x800421eda4,%rdi
  80042159a8:	00 00 00 
  80042159ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042159b0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042159b7:	00 00 00 
  80042159ba:	41 ff d0             	callq  *%r8
	assert(linebuf);
  80042159bd:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  80042159c4:	00 
  80042159c5:	75 35                	jne    80042159fc <dwarf_srclines+0xa5>
  80042159c7:	48 b9 cb ed 21 04 80 	movabs $0x800421edcb,%rcx
  80042159ce:	00 00 00 
  80042159d1:	48 ba 8f ed 21 04 80 	movabs $0x800421ed8f,%rdx
  80042159d8:	00 00 00 
  80042159db:	be af 01 00 00       	mov    $0x1af,%esi
  80042159e0:	48 bf a4 ed 21 04 80 	movabs $0x800421eda4,%rdi
  80042159e7:	00 00 00 
  80042159ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042159ef:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042159f6:	00 00 00 
  80042159f9:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042159fc:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004215a03:	ba 88 00 00 00       	mov    $0x88,%edx
  8004215a08:	be 00 00 00 00       	mov    $0x0,%esi
  8004215a0d:	48 89 c7             	mov    %rax,%rdi
  8004215a10:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004215a17:	00 00 00 
  8004215a1a:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004215a1c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215a23:	be 10 00 00 00       	mov    $0x10,%esi
  8004215a28:	48 89 c7             	mov    %rax,%rdi
  8004215a2b:	48 b8 b8 22 21 04 80 	movabs $0x80042122b8,%rax
  8004215a32:	00 00 00 
  8004215a35:	ff d0                	callq  *%rax
  8004215a37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215a3b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215a40:	75 0a                	jne    8004215a4c <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004215a42:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215a47:	e9 84 00 00 00       	jmpq   8004215ad0 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004215a4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215a50:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004215a54:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004215a5b:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004215a62:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004215a69:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215a70:	49 89 f8             	mov    %rdi,%r8
  8004215a73:	48 89 c7             	mov    %rax,%rdi
  8004215a76:	48 b8 b5 53 21 04 80 	movabs $0x80042153b5,%rax
  8004215a7d:	00 00 00 
  8004215a80:	ff d0                	callq  *%rax
  8004215a82:	85 c0                	test   %eax,%eax
  8004215a84:	74 07                	je     8004215a8d <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004215a86:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215a8b:	eb 43                	jmp    8004215ad0 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004215a8d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004215a94:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004215a98:	48 89 10             	mov    %rdx,(%rax)
  8004215a9b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004215a9f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004215aa3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215aa7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215aab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215aaf:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215ab3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215ab7:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215abb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215abf:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004215ac3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215ac7:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004215acb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ad0:	c9                   	leaveq 
  8004215ad1:	c3                   	retq   
	...

0000008004215ad4 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004215ad4:	55                   	push   %rbp
  8004215ad5:	48 89 e5             	mov    %rsp,%rbp
  8004215ad8:	48 83 ec 20          	sub    $0x20,%rsp
  8004215adc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004215ae0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004215ae7:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215ae8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215aef:	eb 57                	jmp    8004215b48 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  8004215af1:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215af8:	00 00 00 
  8004215afb:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215afe:	48 63 d2             	movslq %edx,%rdx
  8004215b01:	48 c1 e2 05          	shl    $0x5,%rdx
  8004215b05:	48 01 d0             	add    %rdx,%rax
  8004215b08:	48 8b 00             	mov    (%rax),%rax
  8004215b0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215b0f:	48 89 d6             	mov    %rdx,%rsi
  8004215b12:	48 89 c7             	mov    %rax,%rdi
  8004215b15:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004215b1c:	00 00 00 
  8004215b1f:	ff d0                	callq  *%rax
  8004215b21:	85 c0                	test   %eax,%eax
  8004215b23:	75 1f                	jne    8004215b44 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  8004215b25:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b28:	48 98                	cltq   
  8004215b2a:	48 89 c2             	mov    %rax,%rdx
  8004215b2d:	48 c1 e2 05          	shl    $0x5,%rdx
  8004215b31:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215b38:	00 00 00 
  8004215b3b:	48 01 d0             	add    %rdx,%rax
  8004215b3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004215b42:	eb 0a                	jmp    8004215b4e <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215b44:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215b48:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004215b4c:	7e a3                	jle    8004215af1 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  8004215b4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004215b52:	c9                   	leaveq 
  8004215b53:	c3                   	retq   

0000008004215b54 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004215b54:	55                   	push   %rbp
  8004215b55:	48 89 e5             	mov    %rsp,%rbp
  8004215b58:	48 83 ec 40          	sub    $0x40,%rsp
  8004215b5c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004215b60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215b64:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004215b68:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004215b6f:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004215b70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b74:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215b78:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004215b7c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004215b80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b84:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215b88:	0f b7 c0             	movzwl %ax,%eax
  8004215b8b:	48 c1 e0 06          	shl    $0x6,%rax
  8004215b8f:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004215b93:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004215b97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b9b:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215b9f:	0f b7 c0             	movzwl %ax,%eax
  8004215ba2:	48 c1 e0 06          	shl    $0x6,%rax
  8004215ba6:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004215baa:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004215bae:	e9 48 02 00 00       	jmpq   8004215dfb <find_debug_sections+0x2a7>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004215bb3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215bb7:	8b 00                	mov    (%rax),%eax
  8004215bb9:	89 c2                	mov    %eax,%edx
  8004215bbb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215bbf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215bc3:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004215bc7:	48 01 d0             	add    %rdx,%rax
  8004215bca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004215bce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215bd2:	48 be d3 ed 21 04 80 	movabs $0x800421edd3,%rsi
  8004215bd9:	00 00 00 
  8004215bdc:	48 89 c7             	mov    %rax,%rdi
  8004215bdf:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004215be6:	00 00 00 
  8004215be9:	ff d0                	callq  *%rax
  8004215beb:	85 c0                	test   %eax,%eax
  8004215bed:	75 4b                	jne    8004215c3a <find_debug_sections+0xe6>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004215bef:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215bf3:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215bfa:	00 00 00 
  8004215bfd:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004215c01:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215c08:	00 00 00 
  8004215c0b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215c0f:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004215c13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c17:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215c1b:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215c22:	00 00 00 
  8004215c25:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  8004215c29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c2d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215c31:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215c35:	e9 bc 01 00 00       	jmpq   8004215df6 <find_debug_sections+0x2a2>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004215c3a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c3e:	48 be df ed 21 04 80 	movabs $0x800421eddf,%rsi
  8004215c45:	00 00 00 
  8004215c48:	48 89 c7             	mov    %rax,%rdi
  8004215c4b:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004215c52:	00 00 00 
  8004215c55:	ff d0                	callq  *%rax
  8004215c57:	85 c0                	test   %eax,%eax
  8004215c59:	75 4b                	jne    8004215ca6 <find_debug_sections+0x152>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004215c5b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215c5f:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215c66:	00 00 00 
  8004215c69:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004215c6d:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215c74:	00 00 00 
  8004215c77:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215c7b:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004215c7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c83:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215c87:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215c8e:	00 00 00 
  8004215c91:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004215c95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c99:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215c9d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215ca1:	e9 50 01 00 00       	jmpq   8004215df6 <find_debug_sections+0x2a2>
		} else if(!strcmp(name, ".debug_line")){
  8004215ca6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215caa:	48 be f7 ed 21 04 80 	movabs $0x800421edf7,%rsi
  8004215cb1:	00 00 00 
  8004215cb4:	48 89 c7             	mov    %rax,%rdi
  8004215cb7:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004215cbe:	00 00 00 
  8004215cc1:	ff d0                	callq  *%rax
  8004215cc3:	85 c0                	test   %eax,%eax
  8004215cc5:	75 4b                	jne    8004215d12 <find_debug_sections+0x1be>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004215cc7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215ccb:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215cd2:	00 00 00 
  8004215cd5:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004215cd9:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215ce0:	00 00 00 
  8004215ce3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215ce7:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004215ceb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215cef:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215cf3:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215cfa:	00 00 00 
  8004215cfd:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  8004215d01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d05:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215d09:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215d0d:	e9 e4 00 00 00       	jmpq   8004215df6 <find_debug_sections+0x2a2>
		} else if(!strcmp(name, ".eh_frame")){
  8004215d12:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215d16:	48 be ed ed 21 04 80 	movabs $0x800421eded,%rsi
  8004215d1d:	00 00 00 
  8004215d20:	48 89 c7             	mov    %rax,%rdi
  8004215d23:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004215d2a:	00 00 00 
  8004215d2d:	ff d0                	callq  *%rax
  8004215d2f:	85 c0                	test   %eax,%eax
  8004215d31:	75 53                	jne    8004215d86 <find_debug_sections+0x232>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  8004215d33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d37:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215d3b:	48 89 c2             	mov    %rax,%rdx
  8004215d3e:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215d45:	00 00 00 
  8004215d48:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004215d4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d50:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215d54:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215d5b:	00 00 00 
  8004215d5e:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004215d62:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d66:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215d6a:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215d71:	00 00 00 
  8004215d74:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004215d78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215d7c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215d80:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215d84:	eb 70                	jmp    8004215df6 <find_debug_sections+0x2a2>
		} else if(!strcmp(name, ".debug_str")) {
  8004215d86:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215d8a:	48 be 03 ee 21 04 80 	movabs $0x800421ee03,%rsi
  8004215d91:	00 00 00 
  8004215d94:	48 89 c7             	mov    %rax,%rdi
  8004215d97:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  8004215d9e:	00 00 00 
  8004215da1:	ff d0                	callq  *%rax
  8004215da3:	85 c0                	test   %eax,%eax
  8004215da5:	75 4f                	jne    8004215df6 <find_debug_sections+0x2a2>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215da7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215dab:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215db2:	00 00 00 
  8004215db5:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004215dbc:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215dc3:	00 00 00 
  8004215dc6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215dca:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004215dd1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215dd5:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215dd9:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004215de0:	00 00 00 
  8004215de3:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  8004215dea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215dee:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215df2:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004215df6:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004215dfb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215dff:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004215e03:	0f 82 aa fd ff ff    	jb     8004215bb3 <find_debug_sections+0x5f>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  8004215e09:	c9                   	leaveq 
  8004215e0a:	c3                   	retq   

0000008004215e0b <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004215e0b:	55                   	push   %rbp
  8004215e0c:	48 89 e5             	mov    %rsp,%rbp
  8004215e0f:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004215e16:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004215e1d:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004215e24:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  8004215e2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e30:	ba 14 00 00 00       	mov    $0x14,%edx
  8004215e35:	48 89 f7             	mov    %rsi,%rdi
  8004215e38:	48 89 d1             	mov    %rdx,%rcx
  8004215e3b:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004215e3e:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004215e45:	00 
  8004215e46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e4a:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004215e51:	48 01 d0             	add    %rdx,%rax
  8004215e54:	48 83 e8 01          	sub    $0x1,%rax
  8004215e58:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215e5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215e60:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215e65:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004215e69:	48 89 d0             	mov    %rdx,%rax
  8004215e6c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215e70:	48 89 d1             	mov    %rdx,%rcx
  8004215e73:	48 29 c1             	sub    %rax,%rcx
  8004215e76:	48 89 c8             	mov    %rcx,%rax
  8004215e79:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004215e7d:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004215e84:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004215e88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215e8c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004215e90:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004215e97:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004215e98:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004215e9f:	00 00 00 
  8004215ea2:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215ea9:	75 11                	jne    8004215ebc <read_section_headers+0xb1>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004215eab:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215eb2:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215eb6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215eba:	eb 26                	jmp    8004215ee2 <read_section_headers+0xd7>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004215ebc:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215ec3:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215ec7:	48 89 c2             	mov    %rax,%rdx
  8004215eca:	48 03 95 a8 fe ff ff 	add    -0x158(%rbp),%rdx
  8004215ed1:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215ed8:	ff ff ff 
  8004215edb:	48 01 d0             	add    %rdx,%rax
  8004215ede:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004215ee2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215ee9:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215eed:	0f b7 c0             	movzwl %ax,%eax
  8004215ef0:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004215ef3:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215efa:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  8004215efe:	0f b7 c0             	movzwl %ax,%eax
  8004215f01:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004215f04:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215f0b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004215f0f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215f12:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004215f16:	48 63 f0             	movslq %eax,%rsi
  8004215f19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215f1d:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215f24:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215f28:	48 89 c7             	mov    %rax,%rdi
  8004215f2b:	48 b8 3f 65 21 04 80 	movabs $0x800421653f,%rax
  8004215f32:	00 00 00 
  8004215f35:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004215f37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f3b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004215f3f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215f43:	48 89 c2             	mov    %rax,%rdx
  8004215f46:	48 81 e2 00 fe ff ff 	and    $0xfffffffffffffe00,%rdx
  8004215f4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f51:	48 29 d0             	sub    %rdx,%rax
  8004215f54:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004215f58:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004215f5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215f63:	eb 21                	jmp    8004215f86 <read_section_headers+0x17b>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004215f65:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215f68:	48 98                	cltq   
  8004215f6a:	48 c1 e0 06          	shl    $0x6,%rax
  8004215f6e:	48 89 c2             	mov    %rax,%rdx
  8004215f71:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8004215f75:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215f78:	48 98                	cltq   
  8004215f7a:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004215f81:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004215f82:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215f86:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215f89:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215f8c:	7c d7                	jl     8004215f65 <read_section_headers+0x15a>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004215f8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215f92:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004215f96:	0f b7 c0             	movzwl %ax,%eax
  8004215f99:	48 98                	cltq   
  8004215f9b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215fa2:	ff 
  8004215fa3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004215fa7:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215fae:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
  8004215fb2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004215fb6:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215fba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fbe:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215fc2:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215fc9:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004215fcd:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215fd4:	48 89 c7             	mov    %rax,%rdi
  8004215fd7:	48 b8 3f 65 21 04 80 	movabs $0x800421653f,%rax
  8004215fde:	00 00 00 
  8004215fe1:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004215fe3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fe7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215feb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215fef:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215ff3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004215ff7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004215ffb:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216001:	48 89 d7             	mov    %rdx,%rdi
  8004216004:	48 29 c7             	sub    %rax,%rdi
  8004216007:	48 89 f8             	mov    %rdi,%rax
  800421600a:	48 03 45 a0          	add    -0x60(%rbp),%rax
  800421600e:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004216012:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  8004216016:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421601d:	e9 01 05 00 00       	jmpq   8004216523 <read_section_headers+0x718>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004216022:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216025:	48 98                	cltq   
  8004216027:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421602e:	ff 
  800421602f:	8b 00                	mov    (%rax),%eax
  8004216031:	89 c0                	mov    %eax,%eax
  8004216033:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004216037:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  800421603b:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216042:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216047:	48 85 c0             	test   %rax,%rax
  800421604a:	74 35                	je     8004216081 <read_section_headers+0x276>
  800421604c:	48 b9 0e ee 21 04 80 	movabs $0x800421ee0e,%rcx
  8004216053:	00 00 00 
  8004216056:	48 ba 27 ee 21 04 80 	movabs $0x800421ee27,%rdx
  800421605d:	00 00 00 
  8004216060:	be 87 00 00 00       	mov    $0x87,%esi
  8004216065:	48 bf 3c ee 21 04 80 	movabs $0x800421ee3c,%rdi
  800421606c:	00 00 00 
  800421606f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216074:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421607b:	00 00 00 
  800421607e:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004216081:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216088:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  800421608c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216090:	48 be d3 ed 21 04 80 	movabs $0x800421edd3,%rsi
  8004216097:	00 00 00 
  800421609a:	48 89 c7             	mov    %rax,%rdi
  800421609d:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  80042160a4:	00 00 00 
  80042160a7:	ff d0                	callq  *%rax
  80042160a9:	85 c0                	test   %eax,%eax
  80042160ab:	0f 85 d8 00 00 00    	jne    8004216189 <read_section_headers+0x37e>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042160b1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160b4:	48 98                	cltq   
  80042160b6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042160bd:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042160be:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042160c2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160c5:	48 98                	cltq   
  80042160c7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042160ce:	ff 
  80042160cf:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042160d3:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042160da:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042160de:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042160e5:	48 89 c7             	mov    %rax,%rdi
  80042160e8:	48 b8 3f 65 21 04 80 	movabs $0x800421653f,%rax
  80042160ef:	00 00 00 
  80042160f2:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042160f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160f7:	48 98                	cltq   
  80042160f9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216100:	ff 
  8004216101:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216105:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216108:	48 98                	cltq   
  800421610a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216111:	ff 
  8004216112:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216116:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  800421611a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421611e:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216124:	48 89 d1             	mov    %rdx,%rcx
  8004216127:	48 29 c1             	sub    %rax,%rcx
  800421612a:	48 89 c8             	mov    %rcx,%rax
  800421612d:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004216131:	48 89 c2             	mov    %rax,%rdx
  8004216134:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  8004216138:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  800421613f:	00 00 00 
  8004216142:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004216146:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  800421614d:	00 00 00 
  8004216150:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216154:	48 89 c2             	mov    %rax,%rdx
  8004216157:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  800421615e:	00 00 00 
  8004216161:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004216165:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216168:	48 98                	cltq   
  800421616a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216171:	ff 
  8004216172:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216176:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  800421617d:	00 00 00 
  8004216180:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004216184:	e9 96 03 00 00       	jmpq   800421651f <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004216189:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421618d:	48 be df ed 21 04 80 	movabs $0x800421eddf,%rsi
  8004216194:	00 00 00 
  8004216197:	48 89 c7             	mov    %rax,%rdi
  800421619a:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  80042161a1:	00 00 00 
  80042161a4:	ff d0                	callq  *%rax
  80042161a6:	85 c0                	test   %eax,%eax
  80042161a8:	0f 85 de 00 00 00    	jne    800421628c <read_section_headers+0x481>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042161ae:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161b1:	48 98                	cltq   
  80042161b3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042161ba:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042161bb:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042161bf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161c2:	48 98                	cltq   
  80042161c4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042161cb:	ff 
  80042161cc:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042161d0:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042161d7:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042161db:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042161e2:	48 89 c7             	mov    %rax,%rdi
  80042161e5:	48 b8 3f 65 21 04 80 	movabs $0x800421653f,%rax
  80042161ec:	00 00 00 
  80042161ef:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042161f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042161f4:	48 98                	cltq   
  80042161f6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042161fd:	ff 
  80042161fe:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216202:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216205:	48 98                	cltq   
  8004216207:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421620e:	ff 
  800421620f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216213:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800421621a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004216221:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216227:	48 89 d7             	mov    %rdx,%rdi
  800421622a:	48 29 c7             	sub    %rax,%rdi
  800421622d:	48 89 f8             	mov    %rdi,%rax
  8004216230:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004216234:	48 89 c2             	mov    %rax,%rdx
  8004216237:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  800421623b:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216242:	00 00 00 
  8004216245:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004216249:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216250:	00 00 00 
  8004216253:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216257:	48 89 c2             	mov    %rax,%rdx
  800421625a:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216261:	00 00 00 
  8004216264:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004216268:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421626b:	48 98                	cltq   
  800421626d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216274:	ff 
  8004216275:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216279:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216280:	00 00 00 
  8004216283:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004216287:	e9 93 02 00 00       	jmpq   800421651f <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".debug_line"))
  800421628c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216290:	48 be f7 ed 21 04 80 	movabs $0x800421edf7,%rsi
  8004216297:	00 00 00 
  800421629a:	48 89 c7             	mov    %rax,%rdi
  800421629d:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  80042162a4:	00 00 00 
  80042162a7:	ff d0                	callq  *%rax
  80042162a9:	85 c0                	test   %eax,%eax
  80042162ab:	0f 85 de 00 00 00    	jne    800421638f <read_section_headers+0x584>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042162b1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162b4:	48 98                	cltq   
  80042162b6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042162bd:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042162be:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042162c2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162c5:	48 98                	cltq   
  80042162c7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042162ce:	ff 
  80042162cf:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042162d3:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042162da:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042162de:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042162e5:	48 89 c7             	mov    %rax,%rdi
  80042162e8:	48 b8 3f 65 21 04 80 	movabs $0x800421653f,%rax
  80042162ef:	00 00 00 
  80042162f2:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042162f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162f7:	48 98                	cltq   
  80042162f9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216300:	ff 
  8004216301:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216305:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216308:	48 98                	cltq   
  800421630a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216311:	ff 
  8004216312:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216316:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  800421631d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004216324:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421632a:	48 89 d1             	mov    %rdx,%rcx
  800421632d:	48 29 c1             	sub    %rax,%rcx
  8004216330:	48 89 c8             	mov    %rcx,%rax
  8004216333:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004216337:	48 89 c2             	mov    %rax,%rdx
  800421633a:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  800421633e:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216345:	00 00 00 
  8004216348:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  800421634c:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216353:	00 00 00 
  8004216356:	48 8b 40 68          	mov    0x68(%rax),%rax
  800421635a:	48 89 c2             	mov    %rax,%rdx
  800421635d:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216364:	00 00 00 
  8004216367:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  800421636b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421636e:	48 98                	cltq   
  8004216370:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216377:	ff 
  8004216378:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421637c:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216383:	00 00 00 
  8004216386:	48 89 50 78          	mov    %rdx,0x78(%rax)
  800421638a:	e9 90 01 00 00       	jmpq   800421651f <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".eh_frame"))
  800421638f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216393:	48 be ed ed 21 04 80 	movabs $0x800421eded,%rsi
  800421639a:	00 00 00 
  800421639d:	48 89 c7             	mov    %rax,%rdi
  80042163a0:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  80042163a7:	00 00 00 
  80042163aa:	ff d0                	callq  *%rax
  80042163ac:	85 c0                	test   %eax,%eax
  80042163ae:	75 65                	jne    8004216415 <read_section_headers+0x60a>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  80042163b0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042163b3:	48 98                	cltq   
  80042163b5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042163bc:	ff 
  80042163bd:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042163c1:	48 89 c2             	mov    %rax,%rdx
  80042163c4:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  80042163cb:	00 00 00 
  80042163ce:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  80042163d2:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  80042163d9:	00 00 00 
  80042163dc:	48 8b 40 48          	mov    0x48(%rax),%rax
  80042163e0:	48 89 c2             	mov    %rax,%rdx
  80042163e3:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  80042163ea:	00 00 00 
  80042163ed:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  80042163f1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042163f4:	48 98                	cltq   
  80042163f6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042163fd:	ff 
  80042163fe:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216402:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216409:	00 00 00 
  800421640c:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004216410:	e9 0a 01 00 00       	jmpq   800421651f <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".debug_str"))
  8004216415:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216419:	48 be 03 ee 21 04 80 	movabs $0x800421ee03,%rsi
  8004216420:	00 00 00 
  8004216423:	48 89 c7             	mov    %rax,%rdi
  8004216426:	48 b8 0b 02 21 04 80 	movabs $0x800421020b,%rax
  800421642d:	00 00 00 
  8004216430:	ff d0                	callq  *%rax
  8004216432:	85 c0                	test   %eax,%eax
  8004216434:	0f 85 e5 00 00 00    	jne    800421651f <read_section_headers+0x714>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421643a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421643d:	48 98                	cltq   
  800421643f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216446:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216447:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421644b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421644e:	48 98                	cltq   
  8004216450:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216457:	ff 
  8004216458:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421645c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216463:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004216467:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421646e:	48 89 c7             	mov    %rax,%rdi
  8004216471:	48 b8 3f 65 21 04 80 	movabs $0x800421653f,%rax
  8004216478:	00 00 00 
  800421647b:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  800421647d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216480:	48 98                	cltq   
  8004216482:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216489:	ff 
  800421648a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421648e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216491:	48 98                	cltq   
  8004216493:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421649a:	ff 
  800421649b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421649f:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042164a6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042164ad:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042164b3:	48 89 d7             	mov    %rdx,%rdi
  80042164b6:	48 29 c7             	sub    %rax,%rdi
  80042164b9:	48 89 f8             	mov    %rdi,%rax
  80042164bc:	48 03 45 a0          	add    -0x60(%rbp),%rax
  80042164c0:	48 89 c2             	mov    %rax,%rdx
  80042164c3:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  80042164c7:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  80042164ce:	00 00 00 
  80042164d1:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  80042164d8:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  80042164df:	00 00 00 
  80042164e2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042164e9:	48 89 c2             	mov    %rax,%rdx
  80042164ec:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  80042164f3:	00 00 00 
  80042164f6:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  80042164fd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216500:	48 98                	cltq   
  8004216502:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216509:	ff 
  800421650a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421650e:	48 b8 60 06 23 04 80 	movabs $0x8004230660,%rax
  8004216515:	00 00 00 
  8004216518:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  800421651f:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216523:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216526:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004216529:	0f 8c f3 fa ff ff    	jl     8004216022 <read_section_headers+0x217>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  800421652f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216533:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421653a:	48 01 d0             	add    %rdx,%rax
}
  800421653d:	c9                   	leaveq 
  800421653e:	c3                   	retq   

000000800421653f <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  800421653f:	55                   	push   %rbp
  8004216540:	48 89 e5             	mov    %rsp,%rbp
  8004216543:	48 83 ec 30          	sub    $0x30,%rsp
  8004216547:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421654b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421654f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004216553:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004216557:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421655b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  800421655f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216563:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216567:	48 01 d0             	add    %rdx,%rax
  800421656a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  800421656e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216572:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216577:	48 85 c0             	test   %rax,%rax
  800421657a:	74 35                	je     80042165b1 <readseg+0x72>
  800421657c:	48 b9 4a ee 21 04 80 	movabs $0x800421ee4a,%rcx
  8004216583:	00 00 00 
  8004216586:	48 ba 27 ee 21 04 80 	movabs $0x800421ee27,%rdx
  800421658d:	00 00 00 
  8004216590:	be c1 00 00 00       	mov    $0xc1,%esi
  8004216595:	48 bf 3c ee 21 04 80 	movabs $0x800421ee3c,%rdi
  800421659c:	00 00 00 
  800421659f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042165a4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042165ab:	00 00 00 
  80042165ae:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  80042165b1:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  80042165b8:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  80042165b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165bd:	48 c1 e8 09          	shr    $0x9,%rax
  80042165c1:	48 83 c0 01          	add    $0x1,%rax
  80042165c5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042165c9:	eb 3c                	jmp    8004216607 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  80042165cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042165cf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042165d3:	48 89 d6             	mov    %rdx,%rsi
  80042165d6:	48 89 c7             	mov    %rax,%rdi
  80042165d9:	48 b8 d4 66 21 04 80 	movabs $0x80042166d4,%rax
  80042165e0:	00 00 00 
  80042165e3:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  80042165e5:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  80042165ec:	00 
		*kvoffset += SECTSIZE;
  80042165ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165f1:	48 8b 00             	mov    (%rax),%rax
  80042165f4:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  80042165fb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165ff:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004216602:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004216607:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421660b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800421660f:	72 ba                	jb     80042165cb <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004216611:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216615:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421661a:	48 03 45 e0          	add    -0x20(%rbp),%rax
  800421661e:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004216624:	76 2f                	jbe    8004216655 <readseg+0x116>
	{
		readsect((uint8_t*) pa, offset);
  8004216626:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421662a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421662e:	48 89 d6             	mov    %rdx,%rsi
  8004216631:	48 89 c7             	mov    %rax,%rdi
  8004216634:	48 b8 d4 66 21 04 80 	movabs $0x80042166d4,%rax
  800421663b:	00 00 00 
  800421663e:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004216640:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216644:	48 8b 00             	mov    (%rax),%rax
  8004216647:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  800421664e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216652:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004216655:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216659:	48 8b 00             	mov    (%rax),%rax
  800421665c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216661:	48 85 c0             	test   %rax,%rax
  8004216664:	74 35                	je     800421669b <readseg+0x15c>
  8004216666:	48 b9 5d ee 21 04 80 	movabs $0x800421ee5d,%rcx
  800421666d:	00 00 00 
  8004216670:	48 ba 27 ee 21 04 80 	movabs $0x800421ee27,%rdx
  8004216677:	00 00 00 
  800421667a:	be d7 00 00 00       	mov    $0xd7,%esi
  800421667f:	48 bf 3c ee 21 04 80 	movabs $0x800421ee3c,%rdi
  8004216686:	00 00 00 
  8004216689:	b8 00 00 00 00       	mov    $0x0,%eax
  800421668e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004216695:	00 00 00 
  8004216698:	41 ff d0             	callq  *%r8
}
  800421669b:	c9                   	leaveq 
  800421669c:	c3                   	retq   

000000800421669d <waitdisk>:

void
waitdisk(void)
{
  800421669d:	55                   	push   %rbp
  800421669e:	48 89 e5             	mov    %rsp,%rbp
  80042166a1:	53                   	push   %rbx
  80042166a2:	48 83 ec 18          	sub    $0x18,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  80042166a6:	c7 45 f4 f7 01 00 00 	movl   $0x1f7,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042166ad:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042166b0:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  80042166b3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042166b6:	ec                   	in     (%dx),%al
  80042166b7:	89 c3                	mov    %eax,%ebx
  80042166b9:	88 5d f3             	mov    %bl,-0xd(%rbp)
    return data;
  80042166bc:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042166c0:	0f b6 c0             	movzbl %al,%eax
  80042166c3:	25 c0 00 00 00       	and    $0xc0,%eax
  80042166c8:	83 f8 40             	cmp    $0x40,%eax
  80042166cb:	75 d9                	jne    80042166a6 <waitdisk+0x9>
		/* do nothing */;
}
  80042166cd:	48 83 c4 18          	add    $0x18,%rsp
  80042166d1:	5b                   	pop    %rbx
  80042166d2:	5d                   	pop    %rbp
  80042166d3:	c3                   	retq   

00000080042166d4 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042166d4:	55                   	push   %rbp
  80042166d5:	48 89 e5             	mov    %rsp,%rbp
  80042166d8:	41 54                	push   %r12
  80042166da:	53                   	push   %rbx
  80042166db:	48 83 ec 60          	sub    $0x60,%rsp
  80042166df:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042166e3:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042166e7:	48 b8 9d 66 21 04 80 	movabs $0x800421669d,%rax
  80042166ee:	00 00 00 
  80042166f1:	ff d0                	callq  *%rax
  80042166f3:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%rbp)
  80042166fa:	c6 45 eb 01          	movb   $0x1,-0x15(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042166fe:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004216702:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216705:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004216706:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421670a:	0f b6 c0             	movzbl %al,%eax
  800421670d:	c7 45 e4 f3 01 00 00 	movl   $0x1f3,-0x1c(%rbp)
  8004216714:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004216717:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800421671b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421671e:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  800421671f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004216723:	48 c1 e8 08          	shr    $0x8,%rax
  8004216727:	0f b6 c0             	movzbl %al,%eax
  800421672a:	c7 45 dc f4 01 00 00 	movl   $0x1f4,-0x24(%rbp)
  8004216731:	88 45 db             	mov    %al,-0x25(%rbp)
  8004216734:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004216738:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421673b:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  800421673c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004216740:	48 c1 e8 10          	shr    $0x10,%rax
  8004216744:	0f b6 c0             	movzbl %al,%eax
  8004216747:	c7 45 d4 f5 01 00 00 	movl   $0x1f5,-0x2c(%rbp)
  800421674e:	88 45 d3             	mov    %al,-0x2d(%rbp)
  8004216751:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004216755:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004216758:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004216759:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421675d:	48 c1 e8 18          	shr    $0x18,%rax
  8004216761:	83 c8 e0             	or     $0xffffffe0,%eax
  8004216764:	0f b6 c0             	movzbl %al,%eax
  8004216767:	c7 45 cc f6 01 00 00 	movl   $0x1f6,-0x34(%rbp)
  800421676e:	88 45 cb             	mov    %al,-0x35(%rbp)
  8004216771:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004216775:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004216778:	ee                   	out    %al,(%dx)
  8004216779:	c7 45 c4 f7 01 00 00 	movl   $0x1f7,-0x3c(%rbp)
  8004216780:	c6 45 c3 20          	movb   $0x20,-0x3d(%rbp)
  8004216784:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004216788:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800421678b:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  800421678c:	48 b8 9d 66 21 04 80 	movabs $0x800421669d,%rax
  8004216793:	00 00 00 
  8004216796:	ff d0                	callq  *%rax
  8004216798:	c7 45 bc f0 01 00 00 	movl   $0x1f0,-0x44(%rbp)
  800421679f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042167a3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042167a7:	c7 45 ac 80 00 00 00 	movl   $0x80,-0x54(%rbp)
}

    static __inline void
insl(int port, void *addr, int cnt)
{
    __asm __volatile("cld\n\trepne\n\tinsl"			:
  80042167ae:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042167b1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042167b5:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042167b8:	49 89 cc             	mov    %rcx,%r12
  80042167bb:	89 d3                	mov    %edx,%ebx
  80042167bd:	4c 89 e7             	mov    %r12,%rdi
  80042167c0:	89 d9                	mov    %ebx,%ecx
  80042167c2:	89 c2                	mov    %eax,%edx
  80042167c4:	fc                   	cld    
  80042167c5:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  80042167c7:	89 cb                	mov    %ecx,%ebx
  80042167c9:	49 89 fc             	mov    %rdi,%r12
  80042167cc:	4c 89 65 b0          	mov    %r12,-0x50(%rbp)
  80042167d0:	89 5d ac             	mov    %ebx,-0x54(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  80042167d3:	48 83 c4 60          	add    $0x60,%rsp
  80042167d7:	5b                   	pop    %rbx
  80042167d8:	41 5c                	pop    %r12
  80042167da:	5d                   	pop    %rbp
  80042167db:	c3                   	retq   
  80042167dc:	00 00                	add    %al,(%rax)
	...

00000080042167e0 <mpentry_start>:
.set pml4, pml4virt

.code16           
.globl mpentry_start
mpentry_start:
	cli
  80042167e0:	fa                   	cli    
	xorw    %ax, %ax
  80042167e1:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  80042167e3:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042167e5:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042167e7:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  80042167e9:	0f 01 16             	lgdt   (%rsi)
  80042167ec:	e0 70                	loopne 800421685e <start64+0x10>
	movl    %cr0, %eax
  80042167ee:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  80042167f1:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  80042167f5:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  80042167f8:	ea                   	(bad)  
  80042167f9:	1d 70 08 00 66       	sbb    $0x66000870,%eax

00000080042167fd <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  80042167fd:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004216801:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004216803:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004216805:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004216807:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  800421680b:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  800421680d:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  800421680f:	b8 20 00 00 00       	mov    $0x20,%eax
	movl %eax,%cr4
  8004216814:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004216817:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421d8de <etext+0x14f2>
	movl    %cr0, %eax
  800421681e:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004216821:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004216824:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004216827:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  800421682c:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  800421682f:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004216834:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004216836:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  800421683a:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  800421683c:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  800421683f:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004216844:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004216847:	ea                   	(bad)  
  8004216848:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004216849:	70 00                	jo     800421684b <start32+0x4e>
  800421684b:	00 08                	add    %cl,(%rax)
	...

000000800421684e <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  800421684e:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004216852:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004216854:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004216856:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004216858:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  800421685c:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  800421685e:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004216860:	48 a1 58 37 48 04 80 	movabs 0x8004483758,%rax
  8004216867:	00 00 00 
	movq    %rax,%rsp
  800421686a:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  800421686d:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004216874:	48 b8 fc 03 20 04 80 	movabs $0x80042003fc,%rax
  800421687b:	00 00 00 
	call    *%rax
  800421687e:	ff d0                	callq  *%rax

0000008004216880 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004216880:	eb fe                	jmp    8004216880 <spin>
  8004216882:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004216888 <gdt>:
	...
  8004216890:	ff                   	(bad)  
  8004216891:	ff 00                	incl   (%rax)
  8004216893:	00 00                	add    %al,(%rax)
  8004216895:	9a                   	(bad)  
  8004216896:	af                   	scas   %es:(%rdi),%eax
  8004216897:	00 ff                	add    %bh,%bh
  8004216899:	ff 00                	incl   (%rax)
  800421689b:	00 00                	add    %al,(%rax)
  800421689d:	92                   	xchg   %eax,%edx
  800421689e:	af                   	scas   %es:(%rdi),%eax
	...

00000080042168a0 <gdtdesc>:
  80042168a0:	17                   	(bad)  
  80042168a1:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  80042168a7:	90                   	nop

00000080042168a8 <gdt32>:
	...
  80042168b0:	ff                   	(bad)  
  80042168b1:	ff 00                	incl   (%rax)
  80042168b3:	00 00                	add    %al,(%rax)
  80042168b5:	9a                   	(bad)  
  80042168b6:	cf                   	iret   
  80042168b7:	00 ff                	add    %bh,%bh
  80042168b9:	ff 00                	incl   (%rax)
  80042168bb:	00 00                	add    %al,(%rax)
  80042168bd:	92                   	xchg   %eax,%edx
  80042168be:	cf                   	iret   
	...

00000080042168c0 <gdt32desc>:
  80042168c0:	17                   	(bad)  
  80042168c1:	00 c8                	add    %cl,%al
  80042168c3:	70 00                	jo     80042168c5 <gdt32desc+0x5>
	...

00000080042168c6 <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  80042168c6:	90                   	nop
	...

00000080042168c8 <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  80042168c8:	55                   	push   %rbp
  80042168c9:	48 89 e5             	mov    %rsp,%rbp
  80042168cc:	48 83 ec 20          	sub    $0x20,%rsp
  80042168d0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042168d4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  80042168d7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042168de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042168e5:	eb 16                	jmp    80042168fd <sum+0x35>
		sum += ((uint8_t *)addr)[i];
  80042168e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042168ea:	48 98                	cltq   
  80042168ec:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042168f0:	0f b6 00             	movzbl (%rax),%eax
  80042168f3:	0f b6 c0             	movzbl %al,%eax
  80042168f6:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042168f9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042168fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216900:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004216903:	7c e2                	jl     80042168e7 <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004216905:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004216908:	c9                   	leaveq 
  8004216909:	c3                   	retq   

000000800421690a <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  800421690a:	55                   	push   %rbp
  800421690b:	48 89 e5             	mov    %rsp,%rbp
  800421690e:	48 83 ec 40          	sub    $0x40,%rsp
  8004216912:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004216916:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004216919:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421691d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004216921:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216925:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216929:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421692c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421692f:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004216936:	00 00 00 
  8004216939:	48 8b 00             	mov    (%rax),%rax
  800421693c:	48 39 c2             	cmp    %rax,%rdx
  800421693f:	72 32                	jb     8004216973 <mpsearch1+0x69>
  8004216941:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216945:	48 89 c1             	mov    %rax,%rcx
  8004216948:	48 ba 78 ee 21 04 80 	movabs $0x800421ee78,%rdx
  800421694f:	00 00 00 
  8004216952:	be 57 00 00 00       	mov    $0x57,%esi
  8004216957:	48 bf 9b ee 21 04 80 	movabs $0x800421ee9b,%rdi
  800421695e:	00 00 00 
  8004216961:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216966:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421696d:	00 00 00 
  8004216970:	41 ff d0             	callq  *%r8
  8004216973:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800421697a:	00 00 00 
  800421697d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004216981:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216985:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004216988:	48 98                	cltq   
  800421698a:	48 03 45 c8          	add    -0x38(%rbp),%rax
  800421698e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004216992:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216996:	48 c1 e8 0c          	shr    $0xc,%rax
  800421699a:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421699d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042169a0:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042169a7:	00 00 00 
  80042169aa:	48 8b 00             	mov    (%rax),%rax
  80042169ad:	48 39 c2             	cmp    %rax,%rdx
  80042169b0:	72 32                	jb     80042169e4 <mpsearch1+0xda>
  80042169b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042169b6:	48 89 c1             	mov    %rax,%rcx
  80042169b9:	48 ba 78 ee 21 04 80 	movabs $0x800421ee78,%rdx
  80042169c0:	00 00 00 
  80042169c3:	be 57 00 00 00       	mov    $0x57,%esi
  80042169c8:	48 bf 9b ee 21 04 80 	movabs $0x800421ee9b,%rdi
  80042169cf:	00 00 00 
  80042169d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042169d7:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042169de:	00 00 00 
  80042169e1:	41 ff d0             	callq  *%r8
  80042169e4:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042169eb:	00 00 00 
  80042169ee:	48 03 45 e0          	add    -0x20(%rbp),%rax
  80042169f2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042169f6:	eb 4d                	jmp    8004216a45 <mpsearch1+0x13b>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042169f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042169fc:	ba 04 00 00 00       	mov    $0x4,%edx
  8004216a01:	48 be ab ee 21 04 80 	movabs $0x800421eeab,%rsi
  8004216a08:	00 00 00 
  8004216a0b:	48 89 c7             	mov    %rax,%rdi
  8004216a0e:	48 b8 1d 05 21 04 80 	movabs $0x800421051d,%rax
  8004216a15:	00 00 00 
  8004216a18:	ff d0                	callq  *%rax
  8004216a1a:	85 c0                	test   %eax,%eax
  8004216a1c:	75 22                	jne    8004216a40 <mpsearch1+0x136>
		    sum(mp, sizeof(*mp)) == 0)
  8004216a1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a22:	be 10 00 00 00       	mov    $0x10,%esi
  8004216a27:	48 89 c7             	mov    %rax,%rdi
  8004216a2a:	48 b8 c8 68 21 04 80 	movabs $0x80042168c8,%rax
  8004216a31:	00 00 00 
  8004216a34:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004216a36:	84 c0                	test   %al,%al
  8004216a38:	75 06                	jne    8004216a40 <mpsearch1+0x136>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004216a3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a3e:	eb 14                	jmp    8004216a54 <mpsearch1+0x14a>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004216a40:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004216a45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a49:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004216a4d:	72 a9                	jb     80042169f8 <mpsearch1+0xee>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004216a4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216a54:	c9                   	leaveq 
  8004216a55:	c3                   	retq   

0000008004216a56 <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004216a56:	55                   	push   %rbp
  8004216a57:	48 89 e5             	mov    %rsp,%rbp
  8004216a5a:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004216a5e:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004216a65:	00 
  8004216a66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a6a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216a6e:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004216a71:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216a74:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004216a7b:	00 00 00 
  8004216a7e:	48 8b 00             	mov    (%rax),%rax
  8004216a81:	48 39 c2             	cmp    %rax,%rdx
  8004216a84:	72 32                	jb     8004216ab8 <mpsearch+0x62>
  8004216a86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216a8a:	48 89 c1             	mov    %rax,%rcx
  8004216a8d:	48 ba 78 ee 21 04 80 	movabs $0x800421ee78,%rdx
  8004216a94:	00 00 00 
  8004216a97:	be 6f 00 00 00       	mov    $0x6f,%esi
  8004216a9c:	48 bf 9b ee 21 04 80 	movabs $0x800421ee9b,%rdi
  8004216aa3:	00 00 00 
  8004216aa6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216aab:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004216ab2:	00 00 00 
  8004216ab5:	41 ff d0             	callq  *%r8
  8004216ab8:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004216abf:	00 00 00 
  8004216ac2:	48 03 45 f8          	add    -0x8(%rbp),%rax
  8004216ac6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004216aca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216ace:	48 83 c0 0e          	add    $0xe,%rax
  8004216ad2:	0f b7 00             	movzwl (%rax),%eax
  8004216ad5:	0f b7 c0             	movzwl %ax,%eax
  8004216ad8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004216adb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004216adf:	74 2c                	je     8004216b0d <mpsearch+0xb7>
		p <<= 4;	// Translate from segment to PA
  8004216ae1:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004216ae5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216ae8:	be 00 04 00 00       	mov    $0x400,%esi
  8004216aed:	48 89 c7             	mov    %rax,%rdi
  8004216af0:	48 b8 0a 69 21 04 80 	movabs $0x800421690a,%rax
  8004216af7:	00 00 00 
  8004216afa:	ff d0                	callq  *%rax
  8004216afc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216b00:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216b05:	74 49                	je     8004216b50 <mpsearch+0xfa>
			return mp;
  8004216b07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b0b:	eb 59                	jmp    8004216b66 <mpsearch+0x110>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004216b0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216b11:	48 83 c0 13          	add    $0x13,%rax
  8004216b15:	0f b7 00             	movzwl (%rax),%eax
  8004216b18:	0f b7 c0             	movzwl %ax,%eax
  8004216b1b:	c1 e0 0a             	shl    $0xa,%eax
  8004216b1e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004216b21:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216b24:	2d 00 04 00 00       	sub    $0x400,%eax
  8004216b29:	89 c0                	mov    %eax,%eax
  8004216b2b:	be 00 04 00 00       	mov    $0x400,%esi
  8004216b30:	48 89 c7             	mov    %rax,%rdi
  8004216b33:	48 b8 0a 69 21 04 80 	movabs $0x800421690a,%rax
  8004216b3a:	00 00 00 
  8004216b3d:	ff d0                	callq  *%rax
  8004216b3f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216b43:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216b48:	74 06                	je     8004216b50 <mpsearch+0xfa>
			return mp;
  8004216b4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b4e:	eb 16                	jmp    8004216b66 <mpsearch+0x110>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004216b50:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216b55:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004216b5a:	48 b8 0a 69 21 04 80 	movabs $0x800421690a,%rax
  8004216b61:	00 00 00 
  8004216b64:	ff d0                	callq  *%rax
}
  8004216b66:	c9                   	leaveq 
  8004216b67:	c3                   	retq   

0000008004216b68 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004216b68:	55                   	push   %rbp
  8004216b69:	48 89 e5             	mov    %rsp,%rbp
  8004216b6c:	48 83 ec 30          	sub    $0x30,%rsp
  8004216b70:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  8004216b74:	48 b8 56 6a 21 04 80 	movabs $0x8004216a56,%rax
  8004216b7b:	00 00 00 
  8004216b7e:	ff d0                	callq  *%rax
  8004216b80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216b84:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216b89:	75 0a                	jne    8004216b95 <mpconfig+0x2d>
		return NULL;
  8004216b8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b90:	e9 f0 01 00 00       	jmpq   8004216d85 <mpconfig+0x21d>
	if (mp->physaddr == 0 || mp->type != 0) {
  8004216b95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216b99:	8b 40 04             	mov    0x4(%rax),%eax
  8004216b9c:	85 c0                	test   %eax,%eax
  8004216b9e:	74 0c                	je     8004216bac <mpconfig+0x44>
  8004216ba0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216ba4:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004216ba8:	84 c0                	test   %al,%al
  8004216baa:	74 25                	je     8004216bd1 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004216bac:	48 bf b0 ee 21 04 80 	movabs $0x800421eeb0,%rdi
  8004216bb3:	00 00 00 
  8004216bb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216bbb:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216bc2:	00 00 00 
  8004216bc5:	ff d2                	callq  *%rdx
		return NULL;
  8004216bc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216bcc:	e9 b4 01 00 00       	jmpq   8004216d85 <mpconfig+0x21d>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004216bd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216bd5:	8b 40 04             	mov    0x4(%rax),%eax
  8004216bd8:	89 c0                	mov    %eax,%eax
  8004216bda:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004216bde:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216be2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216be6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216be9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216bec:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004216bf3:	00 00 00 
  8004216bf6:	48 8b 00             	mov    (%rax),%rax
  8004216bf9:	48 39 c2             	cmp    %rax,%rdx
  8004216bfc:	72 32                	jb     8004216c30 <mpconfig+0xc8>
  8004216bfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216c02:	48 89 c1             	mov    %rax,%rcx
  8004216c05:	48 ba 78 ee 21 04 80 	movabs $0x800421ee78,%rdx
  8004216c0c:	00 00 00 
  8004216c0f:	be 90 00 00 00       	mov    $0x90,%esi
  8004216c14:	48 bf 9b ee 21 04 80 	movabs $0x800421ee9b,%rdi
  8004216c1b:	00 00 00 
  8004216c1e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c23:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004216c2a:	00 00 00 
  8004216c2d:	41 ff d0             	callq  *%r8
  8004216c30:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004216c37:	00 00 00 
  8004216c3a:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004216c3e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  8004216c42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216c46:	ba 04 00 00 00       	mov    $0x4,%edx
  8004216c4b:	48 be dd ee 21 04 80 	movabs $0x800421eedd,%rsi
  8004216c52:	00 00 00 
  8004216c55:	48 89 c7             	mov    %rax,%rdi
  8004216c58:	48 b8 1d 05 21 04 80 	movabs $0x800421051d,%rax
  8004216c5f:	00 00 00 
  8004216c62:	ff d0                	callq  *%rax
  8004216c64:	85 c0                	test   %eax,%eax
  8004216c66:	74 25                	je     8004216c8d <mpconfig+0x125>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004216c68:	48 bf e8 ee 21 04 80 	movabs $0x800421eee8,%rdi
  8004216c6f:	00 00 00 
  8004216c72:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c77:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216c7e:	00 00 00 
  8004216c81:	ff d2                	callq  *%rdx
		return NULL;
  8004216c83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c88:	e9 f8 00 00 00       	jmpq   8004216d85 <mpconfig+0x21d>
	}
	if (sum(conf, conf->length) != 0) {
  8004216c8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216c91:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216c95:	0f b7 d0             	movzwl %ax,%edx
  8004216c98:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216c9c:	89 d6                	mov    %edx,%esi
  8004216c9e:	48 89 c7             	mov    %rax,%rdi
  8004216ca1:	48 b8 c8 68 21 04 80 	movabs $0x80042168c8,%rax
  8004216ca8:	00 00 00 
  8004216cab:	ff d0                	callq  *%rax
  8004216cad:	84 c0                	test   %al,%al
  8004216caf:	74 25                	je     8004216cd6 <mpconfig+0x16e>
		cprintf("SMP: Bad MP configuration checksum\n");
  8004216cb1:	48 bf 20 ef 21 04 80 	movabs $0x800421ef20,%rdi
  8004216cb8:	00 00 00 
  8004216cbb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216cc0:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216cc7:	00 00 00 
  8004216cca:	ff d2                	callq  *%rdx
		return NULL;
  8004216ccc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216cd1:	e9 af 00 00 00       	jmpq   8004216d85 <mpconfig+0x21d>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004216cd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216cda:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216cde:	3c 01                	cmp    $0x1,%al
  8004216ce0:	74 3b                	je     8004216d1d <mpconfig+0x1b5>
  8004216ce2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216ce6:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216cea:	3c 04                	cmp    $0x4,%al
  8004216cec:	74 2f                	je     8004216d1d <mpconfig+0x1b5>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004216cee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216cf2:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216cf6:	0f b6 c0             	movzbl %al,%eax
  8004216cf9:	89 c6                	mov    %eax,%esi
  8004216cfb:	48 bf 48 ef 21 04 80 	movabs $0x800421ef48,%rdi
  8004216d02:	00 00 00 
  8004216d05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d0a:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216d11:	00 00 00 
  8004216d14:	ff d2                	callq  *%rdx
		return NULL;
  8004216d16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d1b:	eb 68                	jmp    8004216d85 <mpconfig+0x21d>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004216d1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216d21:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004216d25:	0f b7 d0             	movzwl %ax,%edx
  8004216d28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216d2c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216d30:	0f b7 c0             	movzwl %ax,%eax
  8004216d33:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004216d37:	89 d6                	mov    %edx,%esi
  8004216d39:	48 89 c7             	mov    %rax,%rdi
  8004216d3c:	48 b8 c8 68 21 04 80 	movabs $0x80042168c8,%rax
  8004216d43:	00 00 00 
  8004216d46:	ff d0                	callq  *%rax
  8004216d48:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216d4c:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  8004216d50:	38 d0                	cmp    %dl,%al
  8004216d52:	74 22                	je     8004216d76 <mpconfig+0x20e>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004216d54:	48 bf 68 ef 21 04 80 	movabs $0x800421ef68,%rdi
  8004216d5b:	00 00 00 
  8004216d5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d63:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216d6a:	00 00 00 
  8004216d6d:	ff d2                	callq  *%rdx
		return NULL;
  8004216d6f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d74:	eb 0f                	jmp    8004216d85 <mpconfig+0x21d>
	}
	*pmp = mp;
  8004216d76:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d7a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216d7e:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004216d81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004216d85:	c9                   	leaveq 
  8004216d86:	c3                   	retq   

0000008004216d87 <mp_init>:

void
mp_init(void)
{
  8004216d87:	55                   	push   %rbp
  8004216d88:	48 89 e5             	mov    %rsp,%rbp
  8004216d8b:	53                   	push   %rbx
  8004216d8c:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004216d90:	48 b8 a8 50 48 04 80 	movabs $0x80044850a8,%rax
  8004216d97:	00 00 00 
  8004216d9a:	48 ba 20 50 48 04 80 	movabs $0x8004485020,%rdx
  8004216da1:	00 00 00 
  8004216da4:	48 89 10             	mov    %rdx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004216da7:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004216dab:	48 89 c7             	mov    %rax,%rdi
  8004216dae:	48 b8 68 6b 21 04 80 	movabs $0x8004216b68,%rax
  8004216db5:	00 00 00 
  8004216db8:	ff d0                	callq  *%rax
  8004216dba:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004216dbe:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216dc3:	0f 84 1d 03 00 00    	je     80042170e6 <mp_init+0x35f>
		return;
	ismp = 1;
  8004216dc9:	48 b8 00 50 48 04 80 	movabs $0x8004485000,%rax
  8004216dd0:	00 00 00 
  8004216dd3:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004216dd9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216ddd:	8b 40 24             	mov    0x24(%rax),%eax
  8004216de0:	89 c2                	mov    %eax,%edx
  8004216de2:	48 b8 00 60 49 04 80 	movabs $0x8004496000,%rax
  8004216de9:	00 00 00 
  8004216dec:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004216def:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216df3:	48 83 c0 2c          	add    $0x2c,%rax
  8004216df7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004216dfb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004216e02:	e9 5a 01 00 00       	jmpq   8004216f61 <mp_init+0x1da>
		switch (*p) {
  8004216e07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e0b:	0f b6 00             	movzbl (%rax),%eax
  8004216e0e:	0f b6 c0             	movzbl %al,%eax
  8004216e11:	85 c0                	test   %eax,%eax
  8004216e13:	74 16                	je     8004216e2b <mp_init+0xa4>
  8004216e15:	85 c0                	test   %eax,%eax
  8004216e17:	0f 88 fb 00 00 00    	js     8004216f18 <mp_init+0x191>
  8004216e1d:	83 f8 04             	cmp    $0x4,%eax
  8004216e20:	0f 8f f2 00 00 00    	jg     8004216f18 <mp_init+0x191>
  8004216e26:	e9 e6 00 00 00       	jmpq   8004216f11 <mp_init+0x18a>
		case MPPROC:
			proc = (struct mpproc *)p;
  8004216e2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e2f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT)
  8004216e33:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216e37:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004216e3b:	0f b6 c0             	movzbl %al,%eax
  8004216e3e:	83 e0 02             	and    $0x2,%eax
  8004216e41:	85 c0                	test   %eax,%eax
  8004216e43:	74 36                	je     8004216e7b <mp_init+0xf4>
				bootcpu = &cpus[ncpu];
  8004216e45:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004216e4c:	00 00 00 
  8004216e4f:	8b 00                	mov    (%rax),%eax
  8004216e51:	48 98                	cltq   
  8004216e53:	48 c1 e0 03          	shl    $0x3,%rax
  8004216e57:	48 89 c2             	mov    %rax,%rdx
  8004216e5a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216e5e:	48 01 c2             	add    %rax,%rdx
  8004216e61:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004216e68:	00 00 00 
  8004216e6b:	48 01 c2             	add    %rax,%rdx
  8004216e6e:	48 b8 a8 50 48 04 80 	movabs $0x80044850a8,%rax
  8004216e75:	00 00 00 
  8004216e78:	48 89 10             	mov    %rdx,(%rax)
			if (ncpu < NCPU) {
  8004216e7b:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004216e82:	00 00 00 
  8004216e85:	8b 00                	mov    (%rax),%eax
  8004216e87:	85 c0                	test   %eax,%eax
  8004216e89:	7f 57                	jg     8004216ee2 <mp_init+0x15b>
				cpus[ncpu].cpu_id = ncpu;
  8004216e8b:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004216e92:	00 00 00 
  8004216e95:	8b 30                	mov    (%rax),%esi
  8004216e97:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004216e9e:	00 00 00 
  8004216ea1:	8b 00                	mov    (%rax),%eax
  8004216ea3:	89 c2                	mov    %eax,%edx
  8004216ea5:	48 b9 20 50 48 04 80 	movabs $0x8004485020,%rcx
  8004216eac:	00 00 00 
  8004216eaf:	48 63 c6             	movslq %esi,%rax
  8004216eb2:	48 c1 e0 03          	shl    $0x3,%rax
  8004216eb6:	48 89 c6             	mov    %rax,%rsi
  8004216eb9:	48 c1 e6 04          	shl    $0x4,%rsi
  8004216ebd:	48 01 f0             	add    %rsi,%rax
  8004216ec0:	48 01 c8             	add    %rcx,%rax
  8004216ec3:	88 10                	mov    %dl,(%rax)
				ncpu++;
  8004216ec5:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004216ecc:	00 00 00 
  8004216ecf:	8b 00                	mov    (%rax),%eax
  8004216ed1:	8d 50 01             	lea    0x1(%rax),%edx
  8004216ed4:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004216edb:	00 00 00 
  8004216ede:	89 10                	mov    %edx,(%rax)
  8004216ee0:	eb 28                	jmp    8004216f0a <mp_init+0x183>
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004216ee2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216ee6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
				bootcpu = &cpus[ncpu];
			if (ncpu < NCPU) {
				cpus[ncpu].cpu_id = ncpu;
				ncpu++;
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004216eea:	0f b6 c0             	movzbl %al,%eax
  8004216eed:	89 c6                	mov    %eax,%esi
  8004216eef:	48 bf 98 ef 21 04 80 	movabs $0x800421ef98,%rdi
  8004216ef6:	00 00 00 
  8004216ef9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216efe:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216f05:	00 00 00 
  8004216f08:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004216f0a:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  8004216f0f:	eb 4c                	jmp    8004216f5d <mp_init+0x1d6>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  8004216f11:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004216f16:	eb 45                	jmp    8004216f5d <mp_init+0x1d6>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004216f18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216f1c:	0f b6 00             	movzbl (%rax),%eax
  8004216f1f:	0f b6 c0             	movzbl %al,%eax
  8004216f22:	89 c6                	mov    %eax,%esi
  8004216f24:	48 bf c0 ef 21 04 80 	movabs $0x800421efc0,%rdi
  8004216f2b:	00 00 00 
  8004216f2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f33:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004216f3a:	00 00 00 
  8004216f3d:	ff d2                	callq  *%rdx
			ismp = 0;
  8004216f3f:	48 b8 00 50 48 04 80 	movabs $0x8004485000,%rax
  8004216f46:	00 00 00 
  8004216f49:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004216f4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f53:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004216f57:	0f b7 c0             	movzwl %ax,%eax
  8004216f5a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004216f5d:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004216f61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f65:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004216f69:	0f b7 c0             	movzwl %ax,%eax
  8004216f6c:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004216f6f:	0f 87 92 fe ff ff    	ja     8004216e07 <mp_init+0x80>
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004216f75:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004216f7c:	eb 53                	jmp    8004216fd1 <mp_init+0x24a>
		cpus[i].is_vmx_root = false;
  8004216f7e:	48 ba 20 50 48 04 80 	movabs $0x8004485020,%rdx
  8004216f85:	00 00 00 
  8004216f88:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216f8b:	48 c1 e0 03          	shl    $0x3,%rax
  8004216f8f:	48 89 c1             	mov    %rax,%rcx
  8004216f92:	48 c1 e1 04          	shl    $0x4,%rcx
  8004216f96:	48 01 c8             	add    %rcx,%rax
  8004216f99:	48 01 d0             	add    %rdx,%rax
  8004216f9c:	48 83 c0 70          	add    $0x70,%rax
  8004216fa0:	c6 40 08 00          	movb   $0x0,0x8(%rax)
		cpus[i].vmxon_region = 0;
  8004216fa4:	48 ba 20 50 48 04 80 	movabs $0x8004485020,%rdx
  8004216fab:	00 00 00 
  8004216fae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216fb1:	48 c1 e0 03          	shl    $0x3,%rax
  8004216fb5:	48 89 c1             	mov    %rax,%rcx
  8004216fb8:	48 c1 e1 04          	shl    $0x4,%rcx
  8004216fbc:	48 01 c8             	add    %rcx,%rax
  8004216fbf:	48 01 d0             	add    %rdx,%rax
  8004216fc2:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004216fc6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004216fcd:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004216fd1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004216fd5:	74 a7                	je     8004216f7e <mp_init+0x1f7>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}

	bootcpu->cpu_status = CPU_STARTED;
  8004216fd7:	48 b8 a8 50 48 04 80 	movabs $0x80044850a8,%rax
  8004216fde:	00 00 00 
  8004216fe1:	48 8b 00             	mov    (%rax),%rax
  8004216fe4:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004216feb:	48 b8 00 50 48 04 80 	movabs $0x8004485000,%rax
  8004216ff2:	00 00 00 
  8004216ff5:	8b 00                	mov    (%rax),%eax
  8004216ff7:	85 c0                	test   %eax,%eax
  8004216ff9:	75 41                	jne    800421703c <mp_init+0x2b5>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004216ffb:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004217002:	00 00 00 
  8004217005:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  800421700b:	48 b8 00 60 49 04 80 	movabs $0x8004496000,%rax
  8004217012:	00 00 00 
  8004217015:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  800421701c:	48 bf e0 ef 21 04 80 	movabs $0x800421efe0,%rdi
  8004217023:	00 00 00 
  8004217026:	b8 00 00 00 00       	mov    $0x0,%eax
  800421702b:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004217032:	00 00 00 
  8004217035:	ff d2                	callq  *%rdx
		return;
  8004217037:	e9 ab 00 00 00       	jmpq   80042170e7 <mp_init+0x360>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  800421703c:	48 b8 b0 50 48 04 80 	movabs $0x80044850b0,%rax
  8004217043:	00 00 00 
  8004217046:	8b 10                	mov    (%rax),%edx
  8004217048:	48 b8 a8 50 48 04 80 	movabs $0x80044850a8,%rax
  800421704f:	00 00 00 
  8004217052:	48 8b 00             	mov    (%rax),%rax
  8004217055:	0f b6 00             	movzbl (%rax),%eax
  8004217058:	0f b6 c0             	movzbl %al,%eax
  800421705b:	89 c6                	mov    %eax,%esi
  800421705d:	48 bf 0c f0 21 04 80 	movabs $0x800421f00c,%rdi
  8004217064:	00 00 00 
  8004217067:	b8 00 00 00 00       	mov    $0x0,%eax
  800421706c:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  8004217073:	00 00 00 
  8004217076:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004217078:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421707c:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004217080:	84 c0                	test   %al,%al
  8004217082:	74 63                	je     80042170e7 <mp_init+0x360>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004217084:	48 bf 30 f0 21 04 80 	movabs $0x800421f030,%rdi
  800421708b:	00 00 00 
  800421708e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217093:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421709a:	00 00 00 
  800421709d:	ff d2                	callq  *%rdx
  800421709f:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  80042170a6:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042170aa:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042170ae:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042170b1:	ee                   	out    %al,(%dx)
  80042170b2:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042170b9:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042170bc:	89 55 ac             	mov    %edx,-0x54(%rbp)
  80042170bf:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042170c2:	ec                   	in     (%dx),%al
  80042170c3:	89 c3                	mov    %eax,%ebx
  80042170c5:	88 5d c3             	mov    %bl,-0x3d(%rbp)
    return data;
  80042170c8:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  80042170cc:	83 c8 01             	or     $0x1,%eax
  80042170cf:	0f b6 c0             	movzbl %al,%eax
  80042170d2:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  80042170d9:	88 45 bb             	mov    %al,-0x45(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042170dc:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042170e0:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042170e3:	ee                   	out    %al,(%dx)
  80042170e4:	eb 01                	jmp    80042170e7 <mp_init+0x360>
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
	if ((conf = mpconfig(&mp)) == 0)
		return;
  80042170e6:	90                   	nop
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
	}
}
  80042170e7:	48 83 c4 58          	add    $0x58,%rsp
  80042170eb:	5b                   	pop    %rbx
  80042170ec:	5d                   	pop    %rbp
  80042170ed:	c3                   	retq   
	...

00000080042170f0 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  80042170f0:	55                   	push   %rbp
  80042170f1:	48 89 e5             	mov    %rsp,%rbp
  80042170f4:	48 83 ec 08          	sub    $0x8,%rsp
  80042170f8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042170fb:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042170fe:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  8004217105:	00 00 00 
  8004217108:	48 8b 00             	mov    (%rax),%rax
  800421710b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421710e:	48 63 d2             	movslq %edx,%rdx
  8004217111:	48 c1 e2 02          	shl    $0x2,%rdx
  8004217115:	48 01 c2             	add    %rax,%rdx
  8004217118:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421711b:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  800421711d:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  8004217124:	00 00 00 
  8004217127:	48 8b 00             	mov    (%rax),%rax
  800421712a:	48 83 c0 20          	add    $0x20,%rax
  800421712e:	8b 00                	mov    (%rax),%eax
}
  8004217130:	c9                   	leaveq 
  8004217131:	c3                   	retq   

0000008004217132 <lapic_init>:

void
lapic_init(void)
{
  8004217132:	55                   	push   %rbp
  8004217133:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004217136:	48 b8 00 60 49 04 80 	movabs $0x8004496000,%rax
  800421713d:	00 00 00 
  8004217140:	48 8b 00             	mov    (%rax),%rax
  8004217143:	48 85 c0             	test   %rax,%rax
  8004217146:	0f 84 de 01 00 00    	je     800421732a <lapic_init+0x1f8>
		return;

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  800421714c:	48 b8 00 60 49 04 80 	movabs $0x8004496000,%rax
  8004217153:	00 00 00 
  8004217156:	48 8b 00             	mov    (%rax),%rax
  8004217159:	be 00 10 00 00       	mov    $0x1000,%esi
  800421715e:	48 89 c7             	mov    %rax,%rdi
  8004217161:	48 b8 40 37 20 04 80 	movabs $0x8004203740,%rax
  8004217168:	00 00 00 
  800421716b:	ff d0                	callq  *%rax
  800421716d:	48 ba 08 60 49 04 80 	movabs $0x8004496008,%rdx
  8004217174:	00 00 00 
  8004217177:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  800421717a:	be 27 01 00 00       	mov    $0x127,%esi
  800421717f:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004217184:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  800421718b:	00 00 00 
  800421718e:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004217190:	be 0b 00 00 00       	mov    $0xb,%esi
  8004217195:	bf f8 00 00 00       	mov    $0xf8,%edi
  800421719a:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042171a1:	00 00 00 
  80042171a4:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  80042171a6:	be 20 00 02 00       	mov    $0x20020,%esi
  80042171ab:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042171b0:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042171b7:	00 00 00 
  80042171ba:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  80042171bc:	be 80 96 98 00       	mov    $0x989680,%esi
  80042171c1:	bf e0 00 00 00       	mov    $0xe0,%edi
  80042171c6:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042171cd:	00 00 00 
  80042171d0:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  80042171d2:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042171d9:	00 00 00 
  80042171dc:	ff d0                	callq  *%rax
  80042171de:	48 98                	cltq   
  80042171e0:	48 c1 e0 03          	shl    $0x3,%rax
  80042171e4:	48 89 c2             	mov    %rax,%rdx
  80042171e7:	48 c1 e2 04          	shl    $0x4,%rdx
  80042171eb:	48 01 c2             	add    %rax,%rdx
  80042171ee:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  80042171f5:	00 00 00 
  80042171f8:	48 01 c2             	add    %rax,%rdx
  80042171fb:	48 b8 a8 50 48 04 80 	movabs $0x80044850a8,%rax
  8004217202:	00 00 00 
  8004217205:	48 8b 00             	mov    (%rax),%rax
  8004217208:	48 39 c2             	cmp    %rax,%rdx
  800421720b:	74 16                	je     8004217223 <lapic_init+0xf1>
		lapicw(LINT0, MASKED);
  800421720d:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217212:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004217217:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  800421721e:	00 00 00 
  8004217221:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004217223:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217228:	bf d8 00 00 00       	mov    $0xd8,%edi
  800421722d:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  8004217234:	00 00 00 
  8004217237:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004217239:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  8004217240:	00 00 00 
  8004217243:	48 8b 00             	mov    (%rax),%rax
  8004217246:	48 83 c0 30          	add    $0x30,%rax
  800421724a:	8b 00                	mov    (%rax),%eax
  800421724c:	c1 e8 10             	shr    $0x10,%eax
  800421724f:	25 ff 00 00 00       	and    $0xff,%eax
  8004217254:	83 f8 03             	cmp    $0x3,%eax
  8004217257:	76 16                	jbe    800421726f <lapic_init+0x13d>
		lapicw(PCINT, MASKED);
  8004217259:	be 00 00 01 00       	mov    $0x10000,%esi
  800421725e:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004217263:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  800421726a:	00 00 00 
  800421726d:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  800421726f:	be 33 00 00 00       	mov    $0x33,%esi
  8004217274:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004217279:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  8004217280:	00 00 00 
  8004217283:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004217285:	be 00 00 00 00       	mov    $0x0,%esi
  800421728a:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421728f:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  8004217296:	00 00 00 
  8004217299:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  800421729b:	be 00 00 00 00       	mov    $0x0,%esi
  80042172a0:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042172a5:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042172ac:	00 00 00 
  80042172af:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  80042172b1:	be 00 00 00 00       	mov    $0x0,%esi
  80042172b6:	bf 2c 00 00 00       	mov    $0x2c,%edi
  80042172bb:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042172c2:	00 00 00 
  80042172c5:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  80042172c7:	be 00 00 00 00       	mov    $0x0,%esi
  80042172cc:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042172d1:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042172d8:	00 00 00 
  80042172db:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  80042172dd:	be 00 85 08 00       	mov    $0x88500,%esi
  80042172e2:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042172e7:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042172ee:	00 00 00 
  80042172f1:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  80042172f3:	90                   	nop
  80042172f4:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  80042172fb:	00 00 00 
  80042172fe:	48 8b 00             	mov    (%rax),%rax
  8004217301:	48 05 00 03 00 00    	add    $0x300,%rax
  8004217307:	8b 00                	mov    (%rax),%eax
  8004217309:	25 00 10 00 00       	and    $0x1000,%eax
  800421730e:	85 c0                	test   %eax,%eax
  8004217310:	75 e2                	jne    80042172f4 <lapic_init+0x1c2>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004217312:	be 00 00 00 00       	mov    $0x0,%esi
  8004217317:	bf 20 00 00 00       	mov    $0x20,%edi
  800421731c:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  8004217323:	00 00 00 
  8004217326:	ff d0                	callq  *%rax
  8004217328:	eb 01                	jmp    800421732b <lapic_init+0x1f9>

void
lapic_init(void)
{
	if (!lapicaddr)
		return;
  800421732a:	90                   	nop
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
  800421732b:	5d                   	pop    %rbp
  800421732c:	c3                   	retq   

000000800421732d <cpunum>:

int
cpunum(void)
{
  800421732d:	55                   	push   %rbp
  800421732e:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004217331:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  8004217338:	00 00 00 
  800421733b:	48 8b 00             	mov    (%rax),%rax
  800421733e:	48 85 c0             	test   %rax,%rax
  8004217341:	74 18                	je     800421735b <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004217343:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  800421734a:	00 00 00 
  800421734d:	48 8b 00             	mov    (%rax),%rax
  8004217350:	48 83 c0 20          	add    $0x20,%rax
  8004217354:	8b 00                	mov    (%rax),%eax
  8004217356:	c1 e8 18             	shr    $0x18,%eax
  8004217359:	eb 05                	jmp    8004217360 <cpunum+0x33>
	return 0;
  800421735b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217360:	5d                   	pop    %rbp
  8004217361:	c3                   	retq   

0000008004217362 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004217362:	55                   	push   %rbp
  8004217363:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004217366:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  800421736d:	00 00 00 
  8004217370:	48 8b 00             	mov    (%rax),%rax
  8004217373:	48 85 c0             	test   %rax,%rax
  8004217376:	74 16                	je     800421738e <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004217378:	be 00 00 00 00       	mov    $0x0,%esi
  800421737d:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217382:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  8004217389:	00 00 00 
  800421738c:	ff d0                	callq  *%rax
}
  800421738e:	5d                   	pop    %rbp
  800421738f:	c3                   	retq   

0000008004217390 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004217390:	55                   	push   %rbp
  8004217391:	48 89 e5             	mov    %rsp,%rbp
  8004217394:	48 83 ec 08          	sub    $0x8,%rsp
  8004217398:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  800421739b:	c9                   	leaveq 
  800421739c:	c3                   	retq   

000000800421739d <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  800421739d:	55                   	push   %rbp
  800421739e:	48 89 e5             	mov    %rsp,%rbp
  80042173a1:	48 83 ec 40          	sub    $0x40,%rsp
  80042173a5:	89 f8                	mov    %edi,%eax
  80042173a7:	89 75 c8             	mov    %esi,-0x38(%rbp)
  80042173aa:	88 45 cc             	mov    %al,-0x34(%rbp)
  80042173ad:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  80042173b4:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  80042173b8:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042173bc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042173bf:	ee                   	out    %al,(%dx)
  80042173c0:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  80042173c7:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  80042173cb:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042173cf:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042173d2:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  80042173d3:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  80042173da:	00 
  80042173db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042173df:	48 c1 e8 0c          	shr    $0xc,%rax
  80042173e3:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042173e6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042173e9:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042173f0:	00 00 00 
  80042173f3:	48 8b 00             	mov    (%rax),%rax
  80042173f6:	48 39 c2             	cmp    %rax,%rdx
  80042173f9:	72 32                	jb     800421742d <lapic_startap+0x90>
  80042173fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042173ff:	48 89 c1             	mov    %rax,%rcx
  8004217402:	48 ba 78 f0 21 04 80 	movabs $0x800421f078,%rdx
  8004217409:	00 00 00 
  800421740c:	be 98 00 00 00       	mov    $0x98,%esi
  8004217411:	48 bf 9b f0 21 04 80 	movabs $0x800421f09b,%rdi
  8004217418:	00 00 00 
  800421741b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217420:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004217427:	00 00 00 
  800421742a:	41 ff d0             	callq  *%r8
  800421742d:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004217434:	00 00 00 
  8004217437:	48 03 45 f0          	add    -0x10(%rbp),%rax
  800421743b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  800421743f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217443:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004217448:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421744c:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004217450:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004217453:	c1 e8 04             	shr    $0x4,%eax
  8004217456:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004217459:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421745d:	c1 e0 18             	shl    $0x18,%eax
  8004217460:	89 c6                	mov    %eax,%esi
  8004217462:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217467:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  800421746e:	00 00 00 
  8004217471:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004217473:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004217478:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421747d:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  8004217484:	00 00 00 
  8004217487:	ff d0                	callq  *%rax
	microdelay(200);
  8004217489:	bf c8 00 00 00       	mov    $0xc8,%edi
  800421748e:	48 b8 90 73 21 04 80 	movabs $0x8004217390,%rax
  8004217495:	00 00 00 
  8004217498:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  800421749a:	be 00 85 00 00       	mov    $0x8500,%esi
  800421749f:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042174a4:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042174ab:	00 00 00 
  80042174ae:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  80042174b0:	bf 64 00 00 00       	mov    $0x64,%edi
  80042174b5:	48 b8 90 73 21 04 80 	movabs $0x8004217390,%rax
  80042174bc:	00 00 00 
  80042174bf:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  80042174c1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042174c8:	eb 4b                	jmp    8004217515 <lapic_startap+0x178>
		lapicw(ICRHI, apicid << 24);
  80042174ca:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042174ce:	c1 e0 18             	shl    $0x18,%eax
  80042174d1:	89 c6                	mov    %eax,%esi
  80042174d3:	bf c4 00 00 00       	mov    $0xc4,%edi
  80042174d8:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042174df:	00 00 00 
  80042174e2:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  80042174e4:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80042174e7:	c1 e8 0c             	shr    $0xc,%eax
  80042174ea:	80 cc 06             	or     $0x6,%ah
  80042174ed:	89 c6                	mov    %eax,%esi
  80042174ef:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042174f4:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  80042174fb:	00 00 00 
  80042174fe:	ff d0                	callq  *%rax
		microdelay(200);
  8004217500:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217505:	48 b8 90 73 21 04 80 	movabs $0x8004217390,%rax
  800421750c:	00 00 00 
  800421750f:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004217511:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217515:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004217519:	7e af                	jle    80042174ca <lapic_startap+0x12d>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  800421751b:	c9                   	leaveq 
  800421751c:	c3                   	retq   

000000800421751d <lapic_ipi>:

void
lapic_ipi(int vector)
{
  800421751d:	55                   	push   %rbp
  800421751e:	48 89 e5             	mov    %rsp,%rbp
  8004217521:	48 83 ec 08          	sub    $0x8,%rsp
  8004217525:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004217528:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421752b:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004217530:	89 c6                	mov    %eax,%esi
  8004217532:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217537:	48 b8 f0 70 21 04 80 	movabs $0x80042170f0,%rax
  800421753e:	00 00 00 
  8004217541:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004217543:	90                   	nop
  8004217544:	48 b8 08 60 49 04 80 	movabs $0x8004496008,%rax
  800421754b:	00 00 00 
  800421754e:	48 8b 00             	mov    (%rax),%rax
  8004217551:	48 05 00 03 00 00    	add    $0x300,%rax
  8004217557:	8b 00                	mov    (%rax),%eax
  8004217559:	25 00 10 00 00       	and    $0x1000,%eax
  800421755e:	85 c0                	test   %eax,%eax
  8004217560:	75 e2                	jne    8004217544 <lapic_ipi+0x27>
		;
}
  8004217562:	c9                   	leaveq 
  8004217563:	c3                   	retq   

0000008004217564 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004217564:	55                   	push   %rbp
  8004217565:	48 89 e5             	mov    %rsp,%rbp
  8004217568:	53                   	push   %rbx
  8004217569:	48 83 ec 20          	sub    $0x20,%rsp
  800421756d:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  8004217571:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
			 "+m" (*addr), "=a" (result):
  8004217574:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004217578:	8b 45 dc             	mov    -0x24(%rbp),%eax
			 "+m" (*addr), "=a" (result):
  800421757b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800421757f:	89 c3                	mov    %eax,%ebx
  8004217581:	89 d8                	mov    %ebx,%eax
  8004217583:	f0 87 02             	lock xchg %eax,(%rdx)
  8004217586:	89 c3                	mov    %eax,%ebx
  8004217588:	89 5d f4             	mov    %ebx,-0xc(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800421758b:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  800421758e:	48 83 c4 20          	add    $0x20,%rsp
  8004217592:	5b                   	pop    %rbx
  8004217593:	5d                   	pop    %rbp
  8004217594:	c3                   	retq   

0000008004217595 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004217595:	55                   	push   %rbp
  8004217596:	48 89 e5             	mov    %rsp,%rbp
  8004217599:	53                   	push   %rbx
  800421759a:	48 83 ec 28          	sub    $0x28,%rsp
  800421759e:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042175a2:	48 89 eb             	mov    %rbp,%rbx
  80042175a5:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
    return rbp;
  80042175a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  80042175ad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < 10; i++){
  80042175b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042175b8:	eb 3e                	jmp    80042175f8 <get_caller_pcs+0x63>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  80042175ba:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042175bf:	74 57                	je     8004217618 <get_caller_pcs+0x83>
  80042175c1:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042175c8:	00 00 00 
  80042175cb:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042175cf:	76 47                	jbe    8004217618 <get_caller_pcs+0x83>
			break;
		pcs[i] = rbp[1];          // saved %rip
  80042175d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042175d4:	48 98                	cltq   
  80042175d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042175da:	48 03 45 d0          	add    -0x30(%rbp),%rax
  80042175de:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042175e2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042175e6:	48 89 10             	mov    %rdx,(%rax)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  80042175e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042175ed:	48 8b 00             	mov    (%rax),%rax
  80042175f0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  80042175f4:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042175f8:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042175fc:	7e bc                	jle    80042175ba <get_caller_pcs+0x25>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042175fe:	eb 18                	jmp    8004217618 <get_caller_pcs+0x83>
		pcs[i] = 0;
  8004217600:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217603:	48 98                	cltq   
  8004217605:	48 c1 e0 03          	shl    $0x3,%rax
  8004217609:	48 03 45 d0          	add    -0x30(%rbp),%rax
  800421760d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004217614:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004217618:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  800421761c:	7e e2                	jle    8004217600 <get_caller_pcs+0x6b>
		pcs[i] = 0;
}
  800421761e:	48 83 c4 28          	add    $0x28,%rsp
  8004217622:	5b                   	pop    %rbx
  8004217623:	5d                   	pop    %rbp
  8004217624:	c3                   	retq   

0000008004217625 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004217625:	55                   	push   %rbp
  8004217626:	48 89 e5             	mov    %rsp,%rbp
  8004217629:	53                   	push   %rbx
  800421762a:	48 83 ec 18          	sub    $0x18,%rsp
  800421762e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004217632:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217636:	8b 00                	mov    (%rax),%eax
  8004217638:	85 c0                	test   %eax,%eax
  800421763a:	74 3d                	je     8004217679 <holding+0x54>
  800421763c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217640:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004217644:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421764b:	00 00 00 
  800421764e:	ff d0                	callq  *%rax
  8004217650:	48 98                	cltq   
  8004217652:	48 c1 e0 03          	shl    $0x3,%rax
  8004217656:	48 89 c2             	mov    %rax,%rdx
  8004217659:	48 c1 e2 04          	shl    $0x4,%rdx
  800421765d:	48 01 c2             	add    %rax,%rdx
  8004217660:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004217667:	00 00 00 
  800421766a:	48 01 d0             	add    %rdx,%rax
  800421766d:	48 39 c3             	cmp    %rax,%rbx
  8004217670:	75 07                	jne    8004217679 <holding+0x54>
  8004217672:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217677:	eb 05                	jmp    800421767e <holding+0x59>
  8004217679:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421767e:	48 83 c4 18          	add    $0x18,%rsp
  8004217682:	5b                   	pop    %rbx
  8004217683:	5d                   	pop    %rbp
  8004217684:	c3                   	retq   

0000008004217685 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004217685:	55                   	push   %rbp
  8004217686:	48 89 e5             	mov    %rsp,%rbp
  8004217689:	48 83 ec 10          	sub    $0x10,%rsp
  800421768d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004217691:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004217695:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217699:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  800421769f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042176a3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042176a7:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  80042176ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042176af:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042176b6:	00 
#endif
}
  80042176b7:	c9                   	leaveq 
  80042176b8:	c3                   	retq   

00000080042176b9 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  80042176b9:	55                   	push   %rbp
  80042176ba:	48 89 e5             	mov    %rsp,%rbp
  80042176bd:	53                   	push   %rbx
  80042176be:	48 83 ec 18          	sub    $0x18,%rsp
  80042176c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  80042176c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176ca:	48 89 c7             	mov    %rax,%rdi
  80042176cd:	48 b8 25 76 21 04 80 	movabs $0x8004217625,%rax
  80042176d4:	00 00 00 
  80042176d7:	ff d0                	callq  *%rax
  80042176d9:	85 c0                	test   %eax,%eax
  80042176db:	74 48                	je     8004217725 <spin_lock+0x6c>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  80042176dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176e1:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042176e5:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  80042176ec:	00 00 00 
  80042176ef:	ff d0                	callq  *%rax
  80042176f1:	49 89 d8             	mov    %rbx,%r8
  80042176f4:	89 c1                	mov    %eax,%ecx
  80042176f6:	48 ba b8 f0 21 04 80 	movabs $0x800421f0b8,%rdx
  80042176fd:	00 00 00 
  8004217700:	be 41 00 00 00       	mov    $0x41,%esi
  8004217705:	48 bf e2 f0 21 04 80 	movabs $0x800421f0e2,%rdi
  800421770c:	00 00 00 
  800421770f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217714:	49 b9 c2 04 20 04 80 	movabs $0x80042004c2,%r9
  800421771b:	00 00 00 
  800421771e:	41 ff d1             	callq  *%r9

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
		asm volatile ("pause");
  8004217721:	f3 90                	pause  
  8004217723:	eb 01                	jmp    8004217726 <spin_lock+0x6d>
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004217725:	90                   	nop
  8004217726:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421772a:	be 01 00 00 00       	mov    $0x1,%esi
  800421772f:	48 89 c7             	mov    %rax,%rdi
  8004217732:	48 b8 64 75 21 04 80 	movabs $0x8004217564,%rax
  8004217739:	00 00 00 
  800421773c:	ff d0                	callq  *%rax
  800421773e:	85 c0                	test   %eax,%eax
  8004217740:	75 df                	jne    8004217721 <spin_lock+0x68>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004217742:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004217749:	00 00 00 
  800421774c:	ff d0                	callq  *%rax
  800421774e:	48 98                	cltq   
  8004217750:	48 c1 e0 03          	shl    $0x3,%rax
  8004217754:	48 89 c2             	mov    %rax,%rdx
  8004217757:	48 c1 e2 04          	shl    $0x4,%rdx
  800421775b:	48 01 c2             	add    %rax,%rdx
  800421775e:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004217765:	00 00 00 
  8004217768:	48 01 c2             	add    %rax,%rdx
  800421776b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421776f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004217773:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217777:	48 83 c0 18          	add    $0x18,%rax
  800421777b:	48 89 c7             	mov    %rax,%rdi
  800421777e:	48 b8 95 75 21 04 80 	movabs $0x8004217595,%rax
  8004217785:	00 00 00 
  8004217788:	ff d0                	callq  *%rax
#endif
}
  800421778a:	48 83 c4 18          	add    $0x18,%rsp
  800421778e:	5b                   	pop    %rbx
  800421778f:	5d                   	pop    %rbp
  8004217790:	c3                   	retq   

0000008004217791 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004217791:	55                   	push   %rbp
  8004217792:	48 89 e5             	mov    %rsp,%rbp
  8004217795:	41 54                	push   %r12
  8004217797:	53                   	push   %rbx
  8004217798:	48 81 ec d0 04 00 00 	sub    $0x4d0,%rsp
  800421779f:	48 89 bd 38 fb ff ff 	mov    %rdi,-0x4c8(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  80042177a6:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  80042177ad:	48 89 c7             	mov    %rax,%rdi
  80042177b0:	48 b8 25 76 21 04 80 	movabs $0x8004217625,%rax
  80042177b7:	00 00 00 
  80042177ba:	ff d0                	callq  *%rax
  80042177bc:	85 c0                	test   %eax,%eax
  80042177be:	0f 85 c0 01 00 00    	jne    8004217984 <spin_unlock+0x1f3>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  80042177c4:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  80042177cb:	48 8d 48 18          	lea    0x18(%rax),%rcx
  80042177cf:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80042177d3:	ba 28 00 00 00       	mov    $0x28,%edx
  80042177d8:	48 89 ce             	mov    %rcx,%rsi
  80042177db:	48 89 c7             	mov    %rax,%rdi
  80042177de:	48 b8 d2 03 21 04 80 	movabs $0x80042103d2,%rax
  80042177e5:	00 00 00 
  80042177e8:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  80042177ea:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  80042177f1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042177f5:	48 85 c0             	test   %rax,%rax
  80042177f8:	75 39                	jne    8004217833 <spin_unlock+0xa2>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
  80042177fa:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004217801:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004217805:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421780c:	00 00 00 
  800421780f:	ff d0                	callq  *%rax
  8004217811:	48 89 da             	mov    %rbx,%rdx
  8004217814:	89 c6                	mov    %eax,%esi
  8004217816:	48 bf f8 f0 21 04 80 	movabs $0x800421f0f8,%rdi
  800421781d:	00 00 00 
  8004217820:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217825:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800421782c:	00 00 00 
  800421782f:	ff d1                	callq  *%rcx
  8004217831:	eb 4d                	jmp    8004217880 <spin_unlock+0xef>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004217833:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  800421783a:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421783e:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004217841:	44 0f b6 e0          	movzbl %al,%r12d
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004217845:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  800421784c:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004217850:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004217857:	00 00 00 
  800421785a:	ff d0                	callq  *%rax
  800421785c:	44 89 e1             	mov    %r12d,%ecx
  800421785f:	48 89 da             	mov    %rbx,%rdx
  8004217862:	89 c6                	mov    %eax,%esi
  8004217864:	48 bf 38 f1 21 04 80 	movabs $0x800421f138,%rdi
  800421786b:	00 00 00 
  800421786e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217873:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  800421787a:	00 00 00 
  800421787d:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004217880:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004217887:	e9 b7 00 00 00       	jmpq   8004217943 <spin_unlock+0x1b2>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  800421788c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421788f:	48 98                	cltq   
  8004217891:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004217895:	89 c0                	mov    %eax,%eax
  8004217897:	48 8d 95 40 fb ff ff 	lea    -0x4c0(%rbp),%rdx
  800421789e:	48 89 d6             	mov    %rdx,%rsi
  80042178a1:	48 89 c7             	mov    %rax,%rdi
  80042178a4:	48 b8 6f f0 20 04 80 	movabs $0x800420f06f,%rax
  80042178ab:	00 00 00 
  80042178ae:	ff d0                	callq  *%rax
  80042178b0:	85 c0                	test   %eax,%eax
  80042178b2:	78 65                	js     8004217919 <spin_unlock+0x188>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  80042178b4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042178b7:	48 98                	cltq   
  80042178b9:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  80042178bd:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  80042178bf:	48 8b 85 60 fb ff ff 	mov    -0x4a0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  80042178c6:	49 89 d0             	mov    %rdx,%r8
  80042178c9:	49 29 c0             	sub    %rax,%r8
  80042178cc:	48 8b bd 50 fb ff ff 	mov    -0x4b0(%rbp),%rdi
  80042178d3:	8b b5 58 fb ff ff    	mov    -0x4a8(%rbp),%esi
  80042178d9:	8b 8d 48 fb ff ff    	mov    -0x4b8(%rbp),%ecx
  80042178df:	48 8b 95 40 fb ff ff 	mov    -0x4c0(%rbp),%rdx
  80042178e6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042178e9:	48 98                	cltq   
  80042178eb:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  80042178ef:	4c 89 04 24          	mov    %r8,(%rsp)
  80042178f3:	49 89 f9             	mov    %rdi,%r9
  80042178f6:	41 89 f0             	mov    %esi,%r8d
  80042178f9:	89 c6                	mov    %eax,%esi
  80042178fb:	48 bf 6e f1 21 04 80 	movabs $0x800421f16e,%rdi
  8004217902:	00 00 00 
  8004217905:	b8 00 00 00 00       	mov    $0x0,%eax
  800421790a:	49 ba 7a 90 20 04 80 	movabs $0x800420907a,%r10
  8004217911:	00 00 00 
  8004217914:	41 ff d2             	callq  *%r10
  8004217917:	eb 26                	jmp    800421793f <spin_unlock+0x1ae>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004217919:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421791c:	48 98                	cltq   
  800421791e:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004217922:	89 c6                	mov    %eax,%esi
  8004217924:	48 bf 85 f1 21 04 80 	movabs $0x800421f185,%rdi
  800421792b:	00 00 00 
  800421792e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217933:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421793a:	00 00 00 
  800421793d:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  800421793f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004217943:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004217947:	7f 11                	jg     800421795a <spin_unlock+0x1c9>
  8004217949:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421794c:	48 98                	cltq   
  800421794e:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004217952:	85 c0                	test   %eax,%eax
  8004217954:	0f 85 32 ff ff ff    	jne    800421788c <spin_unlock+0xfb>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  800421795a:	48 ba 8d f1 21 04 80 	movabs $0x800421f18d,%rdx
  8004217961:	00 00 00 
  8004217964:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004217969:	48 bf e2 f0 21 04 80 	movabs $0x800421f0e2,%rdi
  8004217970:	00 00 00 
  8004217973:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217978:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800421797f:	00 00 00 
  8004217982:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004217984:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  800421798b:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004217992:	00 
	lk->cpu = 0;
  8004217993:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  800421799a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042179a1:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  80042179a2:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  80042179a9:	be 00 00 00 00       	mov    $0x0,%esi
  80042179ae:	48 89 c7             	mov    %rax,%rdi
  80042179b1:	48 b8 64 75 21 04 80 	movabs $0x8004217564,%rax
  80042179b8:	00 00 00 
  80042179bb:	ff d0                	callq  *%rax
}
  80042179bd:	48 81 c4 d0 04 00 00 	add    $0x4d0,%rsp
  80042179c4:	5b                   	pop    %rbx
  80042179c5:	41 5c                	pop    %r12
  80042179c7:	5d                   	pop    %rbp
  80042179c8:	c3                   	retq   
  80042179c9:	00 00                	add    %al,(%rax)
	...

00000080042179cc <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  80042179cc:	55                   	push   %rbp
  80042179cd:	48 89 e5             	mov    %rsp,%rbp
  80042179d0:	48 83 ec 20          	sub    $0x20,%rsp
  80042179d4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042179d7:	89 75 e8             	mov    %esi,-0x18(%rbp)
  80042179da:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  80042179dd:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  80042179e0:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  80042179e7:	76 35                	jbe    8004217a1e <pci_conf1_set_addr+0x52>
  80042179e9:	48 b9 a0 f1 21 04 80 	movabs $0x800421f1a0,%rcx
  80042179f0:	00 00 00 
  80042179f3:	48 ba aa f1 21 04 80 	movabs $0x800421f1aa,%rdx
  80042179fa:	00 00 00 
  80042179fd:	be 2a 00 00 00       	mov    $0x2a,%esi
  8004217a02:	48 bf bf f1 21 04 80 	movabs $0x800421f1bf,%rdi
  8004217a09:	00 00 00 
  8004217a0c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a11:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004217a18:	00 00 00 
  8004217a1b:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004217a1e:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  8004217a22:	76 35                	jbe    8004217a59 <pci_conf1_set_addr+0x8d>
  8004217a24:	48 b9 ca f1 21 04 80 	movabs $0x800421f1ca,%rcx
  8004217a2b:	00 00 00 
  8004217a2e:	48 ba aa f1 21 04 80 	movabs $0x800421f1aa,%rdx
  8004217a35:	00 00 00 
  8004217a38:	be 2b 00 00 00       	mov    $0x2b,%esi
  8004217a3d:	48 bf bf f1 21 04 80 	movabs $0x800421f1bf,%rdi
  8004217a44:	00 00 00 
  8004217a47:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a4c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004217a53:	00 00 00 
  8004217a56:	41 ff d0             	callq  *%r8
	assert(func < 8);
  8004217a59:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004217a5d:	76 35                	jbe    8004217a94 <pci_conf1_set_addr+0xc8>
  8004217a5f:	48 b9 d3 f1 21 04 80 	movabs $0x800421f1d3,%rcx
  8004217a66:	00 00 00 
  8004217a69:	48 ba aa f1 21 04 80 	movabs $0x800421f1aa,%rdx
  8004217a70:	00 00 00 
  8004217a73:	be 2c 00 00 00       	mov    $0x2c,%esi
  8004217a78:	48 bf bf f1 21 04 80 	movabs $0x800421f1bf,%rdi
  8004217a7f:	00 00 00 
  8004217a82:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a87:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004217a8e:	00 00 00 
  8004217a91:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  8004217a94:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004217a9b:	76 35                	jbe    8004217ad2 <pci_conf1_set_addr+0x106>
  8004217a9d:	48 b9 dc f1 21 04 80 	movabs $0x800421f1dc,%rcx
  8004217aa4:	00 00 00 
  8004217aa7:	48 ba aa f1 21 04 80 	movabs $0x800421f1aa,%rdx
  8004217aae:	00 00 00 
  8004217ab1:	be 2d 00 00 00       	mov    $0x2d,%esi
  8004217ab6:	48 bf bf f1 21 04 80 	movabs $0x800421f1bf,%rdi
  8004217abd:	00 00 00 
  8004217ac0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217ac5:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004217acc:	00 00 00 
  8004217acf:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  8004217ad2:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004217ad5:	83 e0 03             	and    $0x3,%eax
  8004217ad8:	85 c0                	test   %eax,%eax
  8004217ada:	74 35                	je     8004217b11 <pci_conf1_set_addr+0x145>
  8004217adc:	48 b9 e9 f1 21 04 80 	movabs $0x800421f1e9,%rcx
  8004217ae3:	00 00 00 
  8004217ae6:	48 ba aa f1 21 04 80 	movabs $0x800421f1aa,%rdx
  8004217aed:	00 00 00 
  8004217af0:	be 2e 00 00 00       	mov    $0x2e,%esi
  8004217af5:	48 bf bf f1 21 04 80 	movabs $0x800421f1bf,%rdi
  8004217afc:	00 00 00 
  8004217aff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217b04:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004217b0b:	00 00 00 
  8004217b0e:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  8004217b11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217b14:	89 c2                	mov    %eax,%edx
  8004217b16:	c1 e2 10             	shl    $0x10,%edx
  8004217b19:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217b1c:	c1 e0 0b             	shl    $0xb,%eax
  8004217b1f:	09 c2                	or     %eax,%edx
  8004217b21:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217b24:	c1 e0 08             	shl    $0x8,%eax
  8004217b27:	09 d0                	or     %edx,%eax
  8004217b29:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004217b2c:	0d 00 00 00 80       	or     $0x80000000,%eax
  8004217b31:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004217b34:	48 b8 84 07 23 04 80 	movabs $0x8004230784,%rax
  8004217b3b:	00 00 00 
  8004217b3e:	8b 00                	mov    (%rax),%eax
  8004217b40:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004217b43:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217b46:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004217b49:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217b4c:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004217b4f:	ef                   	out    %eax,(%dx)
}
  8004217b50:	c9                   	leaveq 
  8004217b51:	c3                   	retq   

0000008004217b52 <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  8004217b52:	55                   	push   %rbp
  8004217b53:	48 89 e5             	mov    %rsp,%rbp
  8004217b56:	53                   	push   %rbx
  8004217b57:	48 83 ec 28          	sub    $0x28,%rsp
  8004217b5b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004217b5f:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004217b62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b66:	8b 50 0c             	mov    0xc(%rax),%edx
  8004217b69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b6d:	8b 70 08             	mov    0x8(%rax),%esi
  8004217b70:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b74:	48 8b 00             	mov    (%rax),%rax
  8004217b77:	8b 40 08             	mov    0x8(%rax),%eax
  8004217b7a:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  8004217b7d:	89 c7                	mov    %eax,%edi
  8004217b7f:	48 b8 cc 79 21 04 80 	movabs $0x80042179cc,%rax
  8004217b86:	00 00 00 
  8004217b89:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  8004217b8b:	48 b8 88 07 23 04 80 	movabs $0x8004230788,%rax
  8004217b92:	00 00 00 
  8004217b95:	8b 00                	mov    (%rax),%eax
  8004217b97:	89 45 ec             	mov    %eax,-0x14(%rbp)

    static __inline uint32_t
inl(int port)
{
    uint32_t data;
    __asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004217b9a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004217b9d:	89 55 d0             	mov    %edx,-0x30(%rbp)
  8004217ba0:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8004217ba3:	ed                   	in     (%dx),%eax
  8004217ba4:	89 c3                	mov    %eax,%ebx
  8004217ba6:	89 5d e8             	mov    %ebx,-0x18(%rbp)
    return data;
  8004217ba9:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  8004217bac:	48 83 c4 28          	add    $0x28,%rsp
  8004217bb0:	5b                   	pop    %rbx
  8004217bb1:	5d                   	pop    %rbp
  8004217bb2:	c3                   	retq   

0000008004217bb3 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004217bb3:	55                   	push   %rbp
  8004217bb4:	48 89 e5             	mov    %rsp,%rbp
  8004217bb7:	48 83 ec 20          	sub    $0x20,%rsp
  8004217bbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217bbf:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004217bc2:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004217bc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217bc9:	8b 50 0c             	mov    0xc(%rax),%edx
  8004217bcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217bd0:	8b 70 08             	mov    0x8(%rax),%esi
  8004217bd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217bd7:	48 8b 00             	mov    (%rax),%rax
  8004217bda:	8b 40 08             	mov    0x8(%rax),%eax
  8004217bdd:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004217be0:	89 c7                	mov    %eax,%edi
  8004217be2:	48 b8 cc 79 21 04 80 	movabs $0x80042179cc,%rax
  8004217be9:	00 00 00 
  8004217bec:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  8004217bee:	48 b8 88 07 23 04 80 	movabs $0x8004230788,%rax
  8004217bf5:	00 00 00 
  8004217bf8:	8b 00                	mov    (%rax),%eax
  8004217bfa:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004217bfd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004217c00:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004217c03:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217c06:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217c09:	ef                   	out    %eax,(%dx)
}
  8004217c0a:	c9                   	leaveq 
  8004217c0b:	c3                   	retq   

0000008004217c0c <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004217c0c:	55                   	push   %rbp
  8004217c0d:	48 89 e5             	mov    %rsp,%rbp
  8004217c10:	48 83 ec 30          	sub    $0x30,%rsp
  8004217c14:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004217c17:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004217c1a:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8004217c1e:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004217c22:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217c29:	e9 8e 00 00 00       	jmpq   8004217cbc <pci_attach_match+0xb0>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  8004217c2e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217c31:	48 c1 e0 04          	shl    $0x4,%rax
  8004217c35:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004217c39:	8b 00                	mov    (%rax),%eax
  8004217c3b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004217c3e:	75 78                	jne    8004217cb8 <pci_attach_match+0xac>
  8004217c40:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217c43:	48 c1 e0 04          	shl    $0x4,%rax
  8004217c47:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004217c4b:	8b 40 04             	mov    0x4(%rax),%eax
  8004217c4e:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004217c51:	75 65                	jne    8004217cb8 <pci_attach_match+0xac>
			int r = list[i].attachfn(pcif);
  8004217c53:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217c56:	48 c1 e0 04          	shl    $0x4,%rax
  8004217c5a:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004217c5e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004217c62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217c66:	48 89 c7             	mov    %rax,%rdi
  8004217c69:	ff d2                	callq  *%rdx
  8004217c6b:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  8004217c6e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004217c72:	7e 05                	jle    8004217c79 <pci_attach_match+0x6d>
				return r;
  8004217c74:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217c77:	eb 60                	jmp    8004217cd9 <pci_attach_match+0xcd>
			if (r < 0)
  8004217c79:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004217c7d:	79 39                	jns    8004217cb8 <pci_attach_match+0xac>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  8004217c7f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217c82:	48 c1 e0 04          	shl    $0x4,%rax
  8004217c86:	48 03 45 e0          	add    -0x20(%rbp),%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  8004217c8a:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004217c8e:	8b 75 f8             	mov    -0x8(%rbp),%esi
  8004217c91:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004217c94:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217c97:	41 89 f0             	mov    %esi,%r8d
  8004217c9a:	89 c6                	mov    %eax,%esi
  8004217c9c:	48 bf 00 f2 21 04 80 	movabs $0x800421f200,%rdi
  8004217ca3:	00 00 00 
  8004217ca6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217cab:	49 b9 7a 90 20 04 80 	movabs $0x800420907a,%r9
  8004217cb2:	00 00 00 
  8004217cb5:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004217cb8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217cbc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217cbf:	48 c1 e0 04          	shl    $0x4,%rax
  8004217cc3:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004217cc7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004217ccb:	48 85 c0             	test   %rax,%rax
  8004217cce:	0f 85 5a ff ff ff    	jne    8004217c2e <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004217cd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217cd9:	c9                   	leaveq 
  8004217cda:	c3                   	retq   

0000008004217cdb <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004217cdb:	55                   	push   %rbp
  8004217cdc:	48 89 e5             	mov    %rsp,%rbp
  8004217cdf:	48 83 ec 10          	sub    $0x10,%rsp
  8004217ce3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004217ce7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217ceb:	8b 40 14             	mov    0x14(%rax),%eax
  8004217cee:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004217cf1:	0f b6 f0             	movzbl %al,%esi
  8004217cf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217cf8:	8b 40 14             	mov    0x14(%rax),%eax
  8004217cfb:	89 c7                	mov    %eax,%edi
  8004217cfd:	c1 ef 18             	shr    $0x18,%edi
  8004217d00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217d04:	48 89 c1             	mov    %rax,%rcx
  8004217d07:	48 ba a0 07 23 04 80 	movabs $0x80042307a0,%rdx
  8004217d0e:	00 00 00 
  8004217d11:	48 b8 0c 7c 21 04 80 	movabs $0x8004217c0c,%rax
  8004217d18:	00 00 00 
  8004217d1b:	ff d0                	callq  *%rax
}

static int
pci_attach(struct pci_func *f)
{
	return
  8004217d1d:	85 c0                	test   %eax,%eax
  8004217d1f:	75 37                	jne    8004217d58 <pci_attach+0x7d>
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  8004217d21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217d25:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  8004217d28:	89 c6                	mov    %eax,%esi
  8004217d2a:	c1 ee 10             	shr    $0x10,%esi
  8004217d2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217d31:	8b 40 10             	mov    0x10(%rax),%eax
  8004217d34:	0f b7 f8             	movzwl %ax,%edi
  8004217d37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217d3b:	48 89 c1             	mov    %rax,%rcx
  8004217d3e:	48 ba 10 37 48 04 80 	movabs $0x8004483710,%rdx
  8004217d45:	00 00 00 
  8004217d48:	48 b8 0c 7c 21 04 80 	movabs $0x8004217c0c,%rax
  8004217d4f:	00 00 00 
  8004217d52:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004217d54:	85 c0                	test   %eax,%eax
  8004217d56:	74 07                	je     8004217d5f <pci_attach+0x84>
}

static int
pci_attach(struct pci_func *f)
{
	return
  8004217d58:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217d5d:	eb 05                	jmp    8004217d64 <pci_attach+0x89>
  8004217d5f:	b8 00 00 00 00       	mov    $0x0,%eax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  8004217d64:	c9                   	leaveq 
  8004217d65:	c3                   	retq   

0000008004217d66 <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  8004217d66:	55                   	push   %rbp
  8004217d67:	48 89 e5             	mov    %rsp,%rbp
  8004217d6a:	48 83 ec 40          	sub    $0x40,%rsp
  8004217d6e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  8004217d72:	48 b8 c0 07 23 04 80 	movabs $0x80042307c0,%rax
  8004217d79:	00 00 00 
  8004217d7c:	48 8b 00             	mov    (%rax),%rax
  8004217d7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004217d83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d87:	8b 40 14             	mov    0x14(%rax),%eax
  8004217d8a:	c1 e8 18             	shr    $0x18,%eax
  8004217d8d:	83 f8 06             	cmp    $0x6,%eax
  8004217d90:	77 20                	ja     8004217db2 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004217d92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217d96:	8b 40 14             	mov    0x14(%rax),%eax
  8004217d99:	89 c2                	mov    %eax,%edx
  8004217d9b:	c1 ea 18             	shr    $0x18,%edx
  8004217d9e:	48 b8 c0 07 23 04 80 	movabs $0x80042307c0,%rax
  8004217da5:	00 00 00 
  8004217da8:	89 d2                	mov    %edx,%edx
  8004217daa:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004217dae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004217db2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217db6:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217dba:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004217dbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217dc1:	8b 40 14             	mov    0x14(%rax),%eax
  8004217dc4:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217dc7:	44 0f b6 c0          	movzbl %al,%r8d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004217dcb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217dcf:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217dd2:	89 c7                	mov    %eax,%edi
  8004217dd4:	c1 ef 18             	shr    $0x18,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217dd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217ddb:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217dde:	41 89 c1             	mov    %eax,%r9d
  8004217de1:	41 c1 e9 10          	shr    $0x10,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217de5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217de9:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217dec:	44 0f b7 d0          	movzwl %ax,%r10d
		f->bus->busno, f->dev, f->func,
  8004217df0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217df4:	8b 48 0c             	mov    0xc(%rax),%ecx
		f->bus->busno, f->dev, f->func,
  8004217df7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217dfb:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004217dfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217e02:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217e05:	8b 40 08             	mov    0x8(%rax),%eax
  8004217e08:	89 74 24 18          	mov    %esi,0x18(%rsp)
  8004217e0c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004217e10:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004217e15:	44 89 44 24 08       	mov    %r8d,0x8(%rsp)
  8004217e1a:	89 3c 24             	mov    %edi,(%rsp)
  8004217e1d:	45 89 d0             	mov    %r10d,%r8d
  8004217e20:	89 c6                	mov    %eax,%esi
  8004217e22:	48 bf a0 f2 21 04 80 	movabs $0x800421f2a0,%rdi
  8004217e29:	00 00 00 
  8004217e2c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217e31:	49 ba 7a 90 20 04 80 	movabs $0x800420907a,%r10
  8004217e38:	00 00 00 
  8004217e3b:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  8004217e3e:	c9                   	leaveq 
  8004217e3f:	c3                   	retq   

0000008004217e40 <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  8004217e40:	55                   	push   %rbp
  8004217e41:	48 89 e5             	mov    %rsp,%rbp
  8004217e44:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004217e4b:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  8004217e52:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  8004217e59:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004217e5d:	ba 50 00 00 00       	mov    $0x50,%edx
  8004217e62:	be 00 00 00 00       	mov    $0x0,%esi
  8004217e67:	48 89 c7             	mov    %rax,%rdi
  8004217e6a:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  8004217e71:	00 00 00 
  8004217e74:	ff d0                	callq  *%rax
	df.bus = bus;
  8004217e76:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004217e7d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004217e81:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  8004217e88:	e9 2a 02 00 00       	jmpq   80042180b7 <pci_scan_bus+0x277>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004217e8d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004217e91:	be 0c 00 00 00       	mov    $0xc,%esi
  8004217e96:	48 89 c7             	mov    %rax,%rdi
  8004217e99:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  8004217ea0:	00 00 00 
  8004217ea3:	ff d0                	callq  *%rax
  8004217ea5:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  8004217ea8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217eab:	c1 e8 10             	shr    $0x10,%eax
  8004217eae:	83 e0 7f             	and    $0x7f,%eax
  8004217eb1:	83 f8 01             	cmp    $0x1,%eax
  8004217eb4:	0f 87 f3 01 00 00    	ja     80042180ad <pci_scan_bus+0x26d>
			continue;

		totaldev++;
  8004217eba:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004217ebe:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004217ec2:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004217ec9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004217ecd:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004217ed4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004217ed8:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004217edf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004217ee3:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004217eea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004217eee:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004217ef5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004217ef9:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004217f00:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217f04:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004217f0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217f0f:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004217f16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217f1a:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004217f21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217f25:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004217f2c:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  8004217f33:	00 00 00 
  8004217f36:	e9 4a 01 00 00       	jmpq   8004218085 <pci_scan_bus+0x245>
		     f.func++) {
			struct pci_func af = f;
  8004217f3b:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004217f42:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004217f49:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004217f50:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004217f57:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004217f5e:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004217f65:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004217f6c:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004217f73:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004217f7a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004217f81:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004217f88:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004217f8f:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004217f96:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004217f9a:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004217fa1:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004217fa5:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004217fac:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004217fb0:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004217fb7:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004217fbb:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  8004217fc2:	be 00 00 00 00       	mov    $0x0,%esi
  8004217fc7:	48 89 c7             	mov    %rax,%rdi
  8004217fca:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  8004217fd1:	00 00 00 
  8004217fd4:	ff d0                	callq  *%rax
  8004217fd6:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004217fdc:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004217fe2:	25 ff ff 00 00       	and    $0xffff,%eax
  8004217fe7:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004217fec:	0f 84 83 00 00 00    	je     8004218075 <pci_scan_bus+0x235>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004217ff2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004217ff9:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004217ffe:	48 89 c7             	mov    %rax,%rdi
  8004218001:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  8004218008:	00 00 00 
  800421800b:	ff d0                	callq  *%rax
  800421800d:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004218010:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004218013:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004218016:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421801d:	be 08 00 00 00       	mov    $0x8,%esi
  8004218022:	48 89 c7             	mov    %rax,%rdi
  8004218025:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  800421802c:	00 00 00 
  800421802f:	ff d0                	callq  *%rax
  8004218031:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004218037:	48 b8 80 07 23 04 80 	movabs $0x8004230780,%rax
  800421803e:	00 00 00 
  8004218041:	8b 00                	mov    (%rax),%eax
  8004218043:	85 c0                	test   %eax,%eax
  8004218045:	74 16                	je     800421805d <pci_scan_bus+0x21d>
				pci_print_func(&af);
  8004218047:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421804e:	48 89 c7             	mov    %rax,%rdi
  8004218051:	48 b8 66 7d 21 04 80 	movabs $0x8004217d66,%rax
  8004218058:	00 00 00 
  800421805b:	ff d0                	callq  *%rax
			pci_attach(&af);
  800421805d:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004218064:	48 89 c7             	mov    %rax,%rdi
  8004218067:	48 b8 db 7c 21 04 80 	movabs $0x8004217cdb,%rax
  800421806e:	00 00 00 
  8004218071:	ff d0                	callq  *%rax
  8004218073:	eb 01                	jmp    8004218076 <pci_scan_bus+0x236>
		     f.func++) {
			struct pci_func af = f;

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
			if (PCI_VENDOR(af.dev_id) == 0xffff)
				continue;
  8004218075:	90                   	nop

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004218076:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421807c:	83 c0 01             	add    $0x1,%eax
  800421807f:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004218085:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421808b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421808e:	25 00 00 80 00       	and    $0x800000,%eax
  8004218093:	85 c0                	test   %eax,%eax
  8004218095:	74 07                	je     800421809e <pci_scan_bus+0x25e>
  8004218097:	b8 08 00 00 00       	mov    $0x8,%eax
  800421809c:	eb 05                	jmp    80042180a3 <pci_scan_bus+0x263>
  800421809e:	b8 01 00 00 00       	mov    $0x1,%eax
  80042180a3:	39 c2                	cmp    %eax,%edx
  80042180a5:	0f 82 90 fe ff ff    	jb     8004217f3b <pci_scan_bus+0xfb>
  80042180ab:	eb 01                	jmp    80042180ae <pci_scan_bus+0x26e>
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
			continue;
  80042180ad:	90                   	nop
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042180ae:	8b 45 a8             	mov    -0x58(%rbp),%eax
  80042180b1:	83 c0 01             	add    $0x1,%eax
  80042180b4:	89 45 a8             	mov    %eax,-0x58(%rbp)
  80042180b7:	8b 45 a8             	mov    -0x58(%rbp),%eax
  80042180ba:	83 f8 1f             	cmp    $0x1f,%eax
  80042180bd:	0f 86 ca fd ff ff    	jbe    8004217e8d <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  80042180c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042180c6:	c9                   	leaveq 
  80042180c7:	c3                   	retq   

00000080042180c8 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  80042180c8:	55                   	push   %rbp
  80042180c9:	48 89 e5             	mov    %rsp,%rbp
  80042180cc:	48 83 ec 30          	sub    $0x30,%rsp
  80042180d0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  80042180d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042180d8:	be 1c 00 00 00       	mov    $0x1c,%esi
  80042180dd:	48 89 c7             	mov    %rax,%rdi
  80042180e0:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  80042180e7:	00 00 00 
  80042180ea:	ff d0                	callq  *%rax
  80042180ec:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  80042180ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042180f3:	be 18 00 00 00       	mov    $0x18,%esi
  80042180f8:	48 89 c7             	mov    %rax,%rdi
  80042180fb:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  8004218102:	00 00 00 
  8004218105:	ff d0                	callq  *%rax
  8004218107:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  800421810a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421810d:	83 e0 0f             	and    $0xf,%eax
  8004218110:	83 f8 01             	cmp    $0x1,%eax
  8004218113:	75 40                	jne    8004218155 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
			pcif->bus->busno, pcif->dev, pcif->func);
  8004218115:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004218119:	8b 48 0c             	mov    0xc(%rax),%ecx
			pcif->bus->busno, pcif->dev, pcif->func);
  800421811c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004218120:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004218123:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218127:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  800421812a:	8b 40 08             	mov    0x8(%rax),%eax
  800421812d:	89 c6                	mov    %eax,%esi
  800421812f:	48 bf e0 f2 21 04 80 	movabs $0x800421f2e0,%rdi
  8004218136:	00 00 00 
  8004218139:	b8 00 00 00 00       	mov    $0x0,%eax
  800421813e:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  8004218145:	00 00 00 
  8004218148:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  800421814b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218150:	e9 a3 00 00 00       	jmpq   80042181f8 <pci_bridge_attach+0x130>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  8004218155:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004218159:	ba 10 00 00 00       	mov    $0x10,%edx
  800421815e:	be 00 00 00 00       	mov    $0x0,%esi
  8004218163:	48 89 c7             	mov    %rax,%rdi
  8004218166:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  800421816d:	00 00 00 
  8004218170:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  8004218172:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218176:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  800421817a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421817d:	c1 e8 08             	shr    $0x8,%eax
  8004218180:	25 ff 00 00 00       	and    $0xff,%eax
  8004218185:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004218188:	48 b8 80 07 23 04 80 	movabs $0x8004230780,%rax
  800421818f:	00 00 00 
  8004218192:	8b 00                	mov    (%rax),%eax
  8004218194:	85 c0                	test   %eax,%eax
  8004218196:	74 48                	je     80042181e0 <pci_bridge_attach+0x118>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004218198:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421819b:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  800421819e:	0f b6 f8             	movzbl %al,%edi
  80042181a1:	8b 75 e8             	mov    -0x18(%rbp),%esi
			pcif->bus->busno, pcif->dev, pcif->func,
  80042181a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042181a8:	8b 48 0c             	mov    0xc(%rax),%ecx
			pcif->bus->busno, pcif->dev, pcif->func,
  80042181ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042181af:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  80042181b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042181b6:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  80042181b9:	8b 40 08             	mov    0x8(%rax),%eax
  80042181bc:	41 89 f9             	mov    %edi,%r9d
  80042181bf:	41 89 f0             	mov    %esi,%r8d
  80042181c2:	89 c6                	mov    %eax,%esi
  80042181c4:	48 bf 18 f3 21 04 80 	movabs $0x800421f318,%rdi
  80042181cb:	00 00 00 
  80042181ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042181d3:	49 ba 7a 90 20 04 80 	movabs $0x800420907a,%r10
  80042181da:	00 00 00 
  80042181dd:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  80042181e0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042181e4:	48 89 c7             	mov    %rax,%rdi
  80042181e7:	48 b8 40 7e 21 04 80 	movabs $0x8004217e40,%rax
  80042181ee:	00 00 00 
  80042181f1:	ff d0                	callq  *%rax
	return 1;
  80042181f3:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042181f8:	c9                   	leaveq 
  80042181f9:	c3                   	retq   

00000080042181fa <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  80042181fa:	55                   	push   %rbp
  80042181fb:	48 89 e5             	mov    %rsp,%rbp
  80042181fe:	48 83 ec 50          	sub    $0x50,%rsp
  8004218202:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004218206:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421820a:	ba 07 00 00 00       	mov    $0x7,%edx
  800421820f:	be 04 00 00 00       	mov    $0x4,%esi
  8004218214:	48 89 c7             	mov    %rax,%rdi
  8004218217:	48 b8 b3 7b 21 04 80 	movabs $0x8004217bb3,%rax
  800421821e:	00 00 00 
  8004218221:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218223:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  800421822a:	e9 f1 01 00 00       	jmpq   8004218420 <pci_func_enable+0x226>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  800421822f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218232:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218236:	89 d6                	mov    %edx,%esi
  8004218238:	48 89 c7             	mov    %rax,%rdi
  800421823b:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  8004218242:	00 00 00 
  8004218245:	ff d0                	callq  *%rax
  8004218247:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  800421824a:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004218251:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218254:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218258:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800421825d:	89 ce                	mov    %ecx,%esi
  800421825f:	48 89 c7             	mov    %rax,%rdi
  8004218262:	48 b8 b3 7b 21 04 80 	movabs $0x8004217bb3,%rax
  8004218269:	00 00 00 
  800421826c:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  800421826e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218271:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218275:	89 d6                	mov    %edx,%esi
  8004218277:	48 89 c7             	mov    %rax,%rdi
  800421827a:	48 b8 52 7b 21 04 80 	movabs $0x8004217b52,%rax
  8004218281:	00 00 00 
  8004218284:	ff d0                	callq  *%rax
  8004218286:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004218289:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421828d:	0f 84 86 01 00 00    	je     8004218419 <pci_func_enable+0x21f>
			continue;

		int regnum = PCI_MAPREG_NUM(bar);
  8004218293:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218296:	83 e8 10             	sub    $0x10,%eax
  8004218299:	c1 e8 02             	shr    $0x2,%eax
  800421829c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  800421829f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042182a2:	83 e0 01             	and    $0x1,%eax
  80042182a5:	85 c0                	test   %eax,%eax
  80042182a7:	75 65                	jne    800421830e <pci_func_enable+0x114>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  80042182a9:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042182ac:	83 e0 06             	and    $0x6,%eax
  80042182af:	83 f8 04             	cmp    $0x4,%eax
  80042182b2:	75 07                	jne    80042182bb <pci_func_enable+0xc1>
				bar_width = 8;
  80042182b4:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  80042182bb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042182be:	83 e0 f0             	and    $0xfffffff0,%eax
  80042182c1:	f7 d8                	neg    %eax
  80042182c3:	23 45 e8             	and    -0x18(%rbp),%eax
  80042182c6:	83 e0 f0             	and    $0xfffffff0,%eax
  80042182c9:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  80042182cc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042182cf:	83 e0 f0             	and    $0xfffffff0,%eax
  80042182d2:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  80042182d5:	48 b8 20 37 48 04 80 	movabs $0x8004483720,%rax
  80042182dc:	00 00 00 
  80042182df:	8b 00                	mov    (%rax),%eax
  80042182e1:	85 c0                	test   %eax,%eax
  80042182e3:	74 7a                	je     800421835f <pci_func_enable+0x165>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  80042182e5:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  80042182e8:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042182eb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042182ee:	89 c6                	mov    %eax,%esi
  80042182f0:	48 bf 48 f3 21 04 80 	movabs $0x800421f348,%rdi
  80042182f7:	00 00 00 
  80042182fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042182ff:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  8004218306:	00 00 00 
  8004218309:	41 ff d0             	callq  *%r8
  800421830c:	eb 51                	jmp    800421835f <pci_func_enable+0x165>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  800421830e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218311:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218314:	f7 d8                	neg    %eax
  8004218316:	23 45 e8             	and    -0x18(%rbp),%eax
  8004218319:	83 e0 fc             	and    $0xfffffffc,%eax
  800421831c:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  800421831f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218322:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218325:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004218328:	48 b8 20 37 48 04 80 	movabs $0x8004483720,%rax
  800421832f:	00 00 00 
  8004218332:	8b 00                	mov    (%rax),%eax
  8004218334:	85 c0                	test   %eax,%eax
  8004218336:	74 27                	je     800421835f <pci_func_enable+0x165>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004218338:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421833b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421833e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218341:	89 c6                	mov    %eax,%esi
  8004218343:	48 bf 70 f3 21 04 80 	movabs $0x800421f370,%rdi
  800421834a:	00 00 00 
  800421834d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218352:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  8004218359:	00 00 00 
  800421835c:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  800421835f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004218362:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218365:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218369:	89 ce                	mov    %ecx,%esi
  800421836b:	48 89 c7             	mov    %rax,%rdi
  800421836e:	48 b8 b3 7b 21 04 80 	movabs $0x8004217bb3,%rax
  8004218375:	00 00 00 
  8004218378:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  800421837a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421837e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218381:	48 63 d2             	movslq %edx,%rdx
  8004218384:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004218388:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421838b:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  800421838f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218393:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218396:	48 63 d2             	movslq %edx,%rdx
  8004218399:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  800421839d:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042183a0:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  80042183a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042183a7:	74 71                	je     800421841a <pci_func_enable+0x220>
  80042183a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042183ad:	75 6b                	jne    800421841a <pci_func_enable+0x220>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  80042183af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042183b3:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042183b6:	41 89 c0             	mov    %eax,%r8d
  80042183b9:	41 c1 e8 10          	shr    $0x10,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  80042183bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042183c1:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042183c4:	0f b7 f8             	movzwl %ax,%edi
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  80042183c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042183cb:	8b 48 0c             	mov    0xc(%rax),%ecx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  80042183ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042183d2:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  80042183d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042183d9:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  80042183dc:	8b 40 08             	mov    0x8(%rax),%eax
  80042183df:	8b 75 f0             	mov    -0x10(%rbp),%esi
  80042183e2:	89 74 24 10          	mov    %esi,0x10(%rsp)
  80042183e6:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80042183e9:	89 74 24 08          	mov    %esi,0x8(%rsp)
  80042183ed:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  80042183f0:	89 34 24             	mov    %esi,(%rsp)
  80042183f3:	45 89 c1             	mov    %r8d,%r9d
  80042183f6:	41 89 f8             	mov    %edi,%r8d
  80042183f9:	89 c6                	mov    %eax,%esi
  80042183fb:	48 bf 98 f3 21 04 80 	movabs $0x800421f398,%rdi
  8004218402:	00 00 00 
  8004218405:	b8 00 00 00 00       	mov    $0x0,%eax
  800421840a:	49 ba 7a 90 20 04 80 	movabs $0x800420907a,%r10
  8004218411:	00 00 00 
  8004218414:	41 ff d2             	callq  *%r10
  8004218417:	eb 01                	jmp    800421841a <pci_func_enable+0x220>
		bar_width = 4;
		pci_conf_write(f, bar, 0xffffffff);
		uint32_t rv = pci_conf_read(f, bar);

		if (rv == 0)
			continue;
  8004218419:	90                   	nop
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  800421841a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421841d:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218420:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004218424:	0f 86 05 fe ff ff    	jbe    800421822f <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  800421842a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421842e:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218431:	89 c7                	mov    %eax,%edi
  8004218433:	c1 ef 10             	shr    $0x10,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004218436:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421843a:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  800421843d:	0f b7 f0             	movzwl %ax,%esi
		f->bus->busno, f->dev, f->func,
  8004218440:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218444:	8b 48 0c             	mov    0xc(%rax),%ecx
		f->bus->busno, f->dev, f->func,
  8004218447:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  800421844b:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  800421844e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218452:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218455:	8b 40 08             	mov    0x8(%rax),%eax
  8004218458:	41 89 f9             	mov    %edi,%r9d
  800421845b:	41 89 f0             	mov    %esi,%r8d
  800421845e:	89 c6                	mov    %eax,%esi
  8004218460:	48 bf f8 f3 21 04 80 	movabs $0x800421f3f8,%rdi
  8004218467:	00 00 00 
  800421846a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421846f:	49 ba 7a 90 20 04 80 	movabs $0x800420907a,%r10
  8004218476:	00 00 00 
  8004218479:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  800421847c:	c9                   	leaveq 
  800421847d:	c3                   	retq   

000000800421847e <pci_init>:

int
pci_init(void)
{
  800421847e:	55                   	push   %rbp
  800421847f:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004218482:	ba 10 00 00 00       	mov    $0x10,%edx
  8004218487:	be 00 00 00 00       	mov    $0x0,%esi
  800421848c:	48 bf 30 37 48 04 80 	movabs $0x8004483730,%rdi
  8004218493:	00 00 00 
  8004218496:	48 b8 47 03 21 04 80 	movabs $0x8004210347,%rax
  800421849d:	00 00 00 
  80042184a0:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  80042184a2:	48 bf 30 37 48 04 80 	movabs $0x8004483730,%rdi
  80042184a9:	00 00 00 
  80042184ac:	48 b8 40 7e 21 04 80 	movabs $0x8004217e40,%rax
  80042184b3:	00 00 00 
  80042184b6:	ff d0                	callq  *%rax
}
  80042184b8:	5d                   	pop    %rbp
  80042184b9:	c3                   	retq   
	...

00000080042184bc <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  80042184bc:	55                   	push   %rbp
  80042184bd:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  80042184c0:	48 b8 40 37 48 04 80 	movabs $0x8004483740,%rax
  80042184c7:	00 00 00 
  80042184ca:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  80042184d0:	5d                   	pop    %rbp
  80042184d1:	c3                   	retq   

00000080042184d2 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  80042184d2:	55                   	push   %rbp
  80042184d3:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  80042184d6:	48 b8 40 37 48 04 80 	movabs $0x8004483740,%rax
  80042184dd:	00 00 00 
  80042184e0:	8b 00                	mov    (%rax),%eax
  80042184e2:	8d 50 01             	lea    0x1(%rax),%edx
  80042184e5:	48 b8 40 37 48 04 80 	movabs $0x8004483740,%rax
  80042184ec:	00 00 00 
  80042184ef:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  80042184f1:	48 b8 40 37 48 04 80 	movabs $0x8004483740,%rax
  80042184f8:	00 00 00 
  80042184fb:	8b 10                	mov    (%rax),%edx
  80042184fd:	89 d0                	mov    %edx,%eax
  80042184ff:	c1 e0 02             	shl    $0x2,%eax
  8004218502:	01 d0                	add    %edx,%eax
  8004218504:	01 c0                	add    %eax,%eax
  8004218506:	89 c2                	mov    %eax,%edx
  8004218508:	48 b8 40 37 48 04 80 	movabs $0x8004483740,%rax
  800421850f:	00 00 00 
  8004218512:	8b 00                	mov    (%rax),%eax
  8004218514:	39 c2                	cmp    %eax,%edx
  8004218516:	73 2a                	jae    8004218542 <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004218518:	48 ba 27 f4 21 04 80 	movabs $0x800421f427,%rdx
  800421851f:	00 00 00 
  8004218522:	be 13 00 00 00       	mov    $0x13,%esi
  8004218527:	48 bf 42 f4 21 04 80 	movabs $0x800421f442,%rdi
  800421852e:	00 00 00 
  8004218531:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218536:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  800421853d:	00 00 00 
  8004218540:	ff d1                	callq  *%rcx
}
  8004218542:	5d                   	pop    %rbp
  8004218543:	c3                   	retq   

0000008004218544 <time_msec>:

unsigned int
time_msec(void)
{
  8004218544:	55                   	push   %rbp
  8004218545:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004218548:	48 b8 40 37 48 04 80 	movabs $0x8004483740,%rax
  800421854f:	00 00 00 
  8004218552:	8b 10                	mov    (%rax),%edx
  8004218554:	89 d0                	mov    %edx,%eax
  8004218556:	c1 e0 02             	shl    $0x2,%eax
  8004218559:	01 d0                	add    %edx,%eax
  800421855b:	01 c0                	add    %eax,%eax
}
  800421855d:	5d                   	pop    %rbp
  800421855e:	c3                   	retq   
	...

0000008004218560 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004218560:	55                   	push   %rbp
  8004218561:	48 89 e5             	mov    %rsp,%rbp
  8004218564:	48 83 ec 08          	sub    $0x8,%rsp
  8004218568:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421856c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218570:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004218577:	00 00 00 
  800421857a:	48 8b 00             	mov    (%rax),%rax
  800421857d:	48 89 d1             	mov    %rdx,%rcx
  8004218580:	48 29 c1             	sub    %rax,%rcx
  8004218583:	48 89 c8             	mov    %rcx,%rax
  8004218586:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421858a:	c9                   	leaveq 
  800421858b:	c3                   	retq   

000000800421858c <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421858c:	55                   	push   %rbp
  800421858d:	48 89 e5             	mov    %rsp,%rbp
  8004218590:	48 83 ec 08          	sub    $0x8,%rsp
  8004218594:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004218598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421859c:	48 89 c7             	mov    %rax,%rdi
  800421859f:	48 b8 60 85 21 04 80 	movabs $0x8004218560,%rax
  80042185a6:	00 00 00 
  80042185a9:	ff d0                	callq  *%rax
  80042185ab:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042185af:	c9                   	leaveq 
  80042185b0:	c3                   	retq   

00000080042185b1 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042185b1:	55                   	push   %rbp
  80042185b2:	48 89 e5             	mov    %rsp,%rbp
  80042185b5:	48 83 ec 10          	sub    $0x10,%rsp
  80042185b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042185bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042185c1:	48 89 c2             	mov    %rax,%rdx
  80042185c4:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042185c8:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042185cf:	00 00 00 
  80042185d2:	48 8b 00             	mov    (%rax),%rax
  80042185d5:	48 39 c2             	cmp    %rax,%rdx
  80042185d8:	72 2a                	jb     8004218604 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042185da:	48 ba 50 f4 21 04 80 	movabs $0x800421f450,%rdx
  80042185e1:	00 00 00 
  80042185e4:	be 54 00 00 00       	mov    $0x54,%esi
  80042185e9:	48 bf 6f f4 21 04 80 	movabs $0x800421f46f,%rdi
  80042185f0:	00 00 00 
  80042185f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042185f8:	48 b9 c2 04 20 04 80 	movabs $0x80042004c2,%rcx
  80042185ff:	00 00 00 
  8004218602:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004218604:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  800421860b:	00 00 00 
  800421860e:	48 8b 00             	mov    (%rax),%rax
  8004218611:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218615:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004218619:	48 c1 e2 04          	shl    $0x4,%rdx
  800421861d:	48 01 d0             	add    %rdx,%rax
}
  8004218620:	c9                   	leaveq 
  8004218621:	c3                   	retq   

0000008004218622 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004218622:	55                   	push   %rbp
  8004218623:	48 89 e5             	mov    %rsp,%rbp
  8004218626:	48 83 ec 20          	sub    $0x20,%rsp
  800421862a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421862e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218632:	48 89 c7             	mov    %rax,%rdi
  8004218635:	48 b8 8c 85 21 04 80 	movabs $0x800421858c,%rax
  800421863c:	00 00 00 
  800421863f:	ff d0                	callq  *%rax
  8004218641:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004218645:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218649:	48 c1 e8 0c          	shr    $0xc,%rax
  800421864d:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004218650:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004218653:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800421865a:	00 00 00 
  800421865d:	48 8b 00             	mov    (%rax),%rax
  8004218660:	48 39 c2             	cmp    %rax,%rdx
  8004218663:	72 32                	jb     8004218697 <page2kva+0x75>
  8004218665:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218669:	48 89 c1             	mov    %rax,%rcx
  800421866c:	48 ba 80 f4 21 04 80 	movabs $0x800421f480,%rdx
  8004218673:	00 00 00 
  8004218676:	be 5b 00 00 00       	mov    $0x5b,%esi
  800421867b:	48 bf 6f f4 21 04 80 	movabs $0x800421f46f,%rdi
  8004218682:	00 00 00 
  8004218685:	b8 00 00 00 00       	mov    $0x0,%eax
  800421868a:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004218691:	00 00 00 
  8004218694:	41 ff d0             	callq  *%r8
  8004218697:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800421869e:	00 00 00 
  80042186a1:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  80042186a5:	c9                   	leaveq 
  80042186a6:	c3                   	retq   

00000080042186a7 <epte_addr>:
#include <kern/pmap.h>
#include <inc/string.h>

// Return the physical address of an ept entry
static inline uintptr_t epte_addr(epte_t epte)
{
  80042186a7:	55                   	push   %rbp
  80042186a8:	48 89 e5             	mov    %rsp,%rbp
  80042186ab:	48 83 ec 08          	sub    $0x8,%rsp
  80042186af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & EPTE_ADDR);
  80042186b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042186b7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042186bd:	c9                   	leaveq 
  80042186be:	c3                   	retq   

00000080042186bf <epte_present>:
	return (epte & EPTE_FLAGS);
}

// Return true if an ept entry's mapping is present
static inline int epte_present(epte_t epte)
{
  80042186bf:	55                   	push   %rbp
  80042186c0:	48 89 e5             	mov    %rsp,%rbp
  80042186c3:	48 83 ec 08          	sub    $0x8,%rsp
  80042186c7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & __EPTE_FULL) > 0;
  80042186cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042186cf:	83 e0 07             	and    $0x7,%eax
  80042186d2:	48 85 c0             	test   %rax,%rax
  80042186d5:	0f 95 c0             	setne  %al
  80042186d8:	0f b6 c0             	movzbl %al,%eax
}
  80042186db:	c9                   	leaveq 
  80042186dc:	c3                   	retq   

00000080042186dd <ept_lookup_gpa>:
//
// Hint: Set the permissions of intermediate ept entries to __EPTE_FULL.
//       The hardware ANDs the permissions at each level, so removing a permission
//       bit at the last level entry is sufficient (and the bookkeeping is much simpler).
static int ept_lookup_gpa(epte_t* eptrt, void *gpa, 
			  int create, epte_t **epte_out) {
  80042186dd:	55                   	push   %rbp
  80042186de:	48 89 e5             	mov    %rsp,%rbp
  80042186e1:	48 83 ec 60          	sub    $0x60,%rsp
  80042186e5:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042186e9:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042186ed:	89 55 ac             	mov    %edx,-0x54(%rbp)
  80042186f0:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    /* Your code here */
	if(!eptrt) {
  80042186f4:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042186f9:	75 0a                	jne    8004218705 <ept_lookup_gpa+0x28>
		return -E_INVAL;
  80042186fb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004218700:	e9 03 02 00 00       	jmpq   8004218908 <ept_lookup_gpa+0x22b>
	}
	
	pte_t* pte = pml4e_walk((pml4e_t*)eptrt, gpa, create);
  8004218705:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004218708:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421870c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004218710:	48 89 ce             	mov    %rcx,%rsi
  8004218713:	48 89 c7             	mov    %rax,%rdi
  8004218716:	48 b8 69 2d 20 04 80 	movabs $0x8004202d69,%rax
  800421871d:	00 00 00 
  8004218720:	ff d0                	callq  *%rax
  8004218722:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(!pte)
  8004218726:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421872b:	75 0a                	jne    8004218737 <ept_lookup_gpa+0x5a>
		return -E_NO_ENT;
  800421872d:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
  8004218732:	e9 d1 01 00 00       	jmpq   8004218908 <ept_lookup_gpa+0x22b>

	// change permissions, now that pages are created.
	pml4e_t* pml = &eptrt[PML4(gpa)];
  8004218737:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421873b:	48 c1 e8 27          	shr    $0x27,%rax
  800421873f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004218744:	48 c1 e0 03          	shl    $0x3,%rax
  8004218748:	48 03 45 b8          	add    -0x48(%rbp),%rax
  800421874c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	pdpe_t* pdpe = (pdpe_t*)KADDR(PTE_ADDR(*pml));
  8004218750:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004218754:	48 8b 00             	mov    (%rax),%rax
  8004218757:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800421875d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004218761:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218765:	48 c1 e8 0c          	shr    $0xc,%rax
  8004218769:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421876c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421876f:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004218776:	00 00 00 
  8004218779:	48 8b 00             	mov    (%rax),%rax
  800421877c:	48 39 c2             	cmp    %rax,%rdx
  800421877f:	72 32                	jb     80042187b3 <ept_lookup_gpa+0xd6>
  8004218781:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218785:	48 89 c1             	mov    %rax,%rcx
  8004218788:	48 ba 80 f4 21 04 80 	movabs $0x800421f480,%rdx
  800421878f:	00 00 00 
  8004218792:	be 3d 00 00 00       	mov    $0x3d,%esi
  8004218797:	48 bf a3 f4 21 04 80 	movabs $0x800421f4a3,%rdi
  800421879e:	00 00 00 
  80042187a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042187a6:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042187ad:	00 00 00 
  80042187b0:	41 ff d0             	callq  *%r8
  80042187b3:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042187ba:	00 00 00 
  80042187bd:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042187c1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pdpe = &pdpe[PDPE(gpa)];	
  80042187c5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042187c9:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042187cd:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042187d2:	48 c1 e0 03          	shl    $0x3,%rax
  80042187d6:	48 01 45 d8          	add    %rax,-0x28(%rbp)
	pde_t* pde = (pde_t*) KADDR(PTE_ADDR(*pdpe)); 
  80042187da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042187de:	48 8b 00             	mov    (%rax),%rax
  80042187e1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042187e7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042187eb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042187ef:	48 c1 e8 0c          	shr    $0xc,%rax
  80042187f3:	89 45 cc             	mov    %eax,-0x34(%rbp)
  80042187f6:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042187f9:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004218800:	00 00 00 
  8004218803:	48 8b 00             	mov    (%rax),%rax
  8004218806:	48 39 c2             	cmp    %rax,%rdx
  8004218809:	72 32                	jb     800421883d <ept_lookup_gpa+0x160>
  800421880b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421880f:	48 89 c1             	mov    %rax,%rcx
  8004218812:	48 ba 80 f4 21 04 80 	movabs $0x800421f480,%rdx
  8004218819:	00 00 00 
  800421881c:	be 3f 00 00 00       	mov    $0x3f,%esi
  8004218821:	48 bf a3 f4 21 04 80 	movabs $0x800421f4a3,%rdi
  8004218828:	00 00 00 
  800421882b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218830:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004218837:	00 00 00 
  800421883a:	41 ff d0             	callq  *%r8
  800421883d:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004218844:	00 00 00 
  8004218847:	48 03 45 d0          	add    -0x30(%rbp),%rax
  800421884b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	
	eptrt[PML4(gpa)] = PTE_ADDR(*pml) | __EPTE_FULL;
  800421884f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004218853:	48 c1 e8 27          	shr    $0x27,%rax
  8004218857:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421885c:	48 c1 e0 03          	shl    $0x3,%rax
  8004218860:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004218864:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004218868:	48 8b 12             	mov    (%rdx),%rdx
  800421886b:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  8004218872:	48 83 ca 07          	or     $0x7,%rdx
  8004218876:	48 89 10             	mov    %rdx,(%rax)
	pdpe[PDPE(gpa)] = PTE_ADDR(pdpe[PDPE(gpa)]) | __EPTE_FULL;
  8004218879:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421887d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004218881:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004218886:	48 c1 e0 03          	shl    $0x3,%rax
  800421888a:	48 03 45 d8          	add    -0x28(%rbp),%rax
  800421888e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004218892:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004218896:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  800421889c:	48 c1 e2 03          	shl    $0x3,%rdx
  80042188a0:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  80042188a4:	48 8b 12             	mov    (%rdx),%rdx
  80042188a7:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  80042188ae:	48 83 ca 07          	or     $0x7,%rdx
  80042188b2:	48 89 10             	mov    %rdx,(%rax)
	pde[PDX(gpa)] = PTE_ADDR(pde[PDX(gpa)]) | __EPTE_FULL;
  80042188b5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042188b9:	48 c1 e8 15          	shr    $0x15,%rax
  80042188bd:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042188c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042188c6:	48 03 45 c0          	add    -0x40(%rbp),%rax
  80042188ca:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042188ce:	48 c1 ea 15          	shr    $0x15,%rdx
  80042188d2:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042188d8:	48 c1 e2 03          	shl    $0x3,%rdx
  80042188dc:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  80042188e0:	48 8b 12             	mov    (%rdx),%rdx
  80042188e3:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  80042188ea:	48 83 ca 07          	or     $0x7,%rdx
  80042188ee:	48 89 10             	mov    %rdx,(%rax)
	
	if (epte_out) {
  80042188f1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  80042188f6:	74 0b                	je     8004218903 <ept_lookup_gpa+0x226>
		*epte_out = (epte_t*) pte;
  80042188f8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042188fc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218900:	48 89 10             	mov    %rdx,(%rax)
	}
	return 0;
  8004218903:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218908:	c9                   	leaveq 
  8004218909:	c3                   	retq   

000000800421890a <ept_gpa2hva>:

void ept_gpa2hva(epte_t* eptrt, void *gpa, void **hva) {
  800421890a:	55                   	push   %rbp
  800421890b:	48 89 e5             	mov    %rsp,%rbp
  800421890e:	48 83 ec 40          	sub    $0x40,%rsp
  8004218912:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004218916:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421891a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    epte_t* pte;
    int ret = ept_lookup_gpa(eptrt, gpa, 0, &pte);
  800421891e:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  8004218922:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004218926:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421892a:	48 89 d1             	mov    %rdx,%rcx
  800421892d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004218932:	48 89 c7             	mov    %rax,%rdi
  8004218935:	48 b8 dd 86 21 04 80 	movabs $0x80042186dd,%rax
  800421893c:	00 00 00 
  800421893f:	ff d0                	callq  *%rax
  8004218941:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(ret < 0) {
  8004218944:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004218948:	79 10                	jns    800421895a <ept_gpa2hva+0x50>
        *hva = NULL;
  800421894a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421894e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004218955:	e9 ae 00 00 00       	jmpq   8004218a08 <ept_gpa2hva+0xfe>
    } else {
        if(!epte_present(*pte)) {
  800421895a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421895e:	48 8b 00             	mov    (%rax),%rax
  8004218961:	48 89 c7             	mov    %rax,%rdi
  8004218964:	48 b8 bf 86 21 04 80 	movabs $0x80042186bf,%rax
  800421896b:	00 00 00 
  800421896e:	ff d0                	callq  *%rax
  8004218970:	85 c0                	test   %eax,%eax
  8004218972:	75 10                	jne    8004218984 <ept_gpa2hva+0x7a>
           *hva = NULL;
  8004218974:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004218978:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  800421897f:	e9 84 00 00 00       	jmpq   8004218a08 <ept_gpa2hva+0xfe>
        } else {
           *hva = KADDR(epte_addr(*pte));
  8004218984:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218988:	48 8b 00             	mov    (%rax),%rax
  800421898b:	48 89 c7             	mov    %rax,%rdi
  800421898e:	48 b8 a7 86 21 04 80 	movabs $0x80042186a7,%rax
  8004218995:	00 00 00 
  8004218998:	ff d0                	callq  *%rax
  800421899a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421899e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042189a2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042189a6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042189a9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042189ac:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  80042189b3:	00 00 00 
  80042189b6:	48 8b 00             	mov    (%rax),%rax
  80042189b9:	48 39 c2             	cmp    %rax,%rdx
  80042189bc:	72 32                	jb     80042189f0 <ept_gpa2hva+0xe6>
  80042189be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042189c2:	48 89 c1             	mov    %rax,%rcx
  80042189c5:	48 ba 80 f4 21 04 80 	movabs $0x800421f480,%rdx
  80042189cc:	00 00 00 
  80042189cf:	be 54 00 00 00       	mov    $0x54,%esi
  80042189d4:	48 bf a3 f4 21 04 80 	movabs $0x800421f4a3,%rdi
  80042189db:	00 00 00 
  80042189de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042189e3:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042189ea:	00 00 00 
  80042189ed:	41 ff d0             	callq  *%r8
  80042189f0:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042189f7:	00 00 00 
  80042189fa:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80042189fe:	48 89 c2             	mov    %rax,%rdx
  8004218a01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004218a05:	48 89 10             	mov    %rdx,(%rax)
        }
    }
}
  8004218a08:	c9                   	leaveq 
  8004218a09:	c3                   	retq   

0000008004218a0a <free_ept_level>:

static void free_ept_level(epte_t* eptrt, int level) {
  8004218a0a:	55                   	push   %rbp
  8004218a0b:	48 89 e5             	mov    %rsp,%rbp
  8004218a0e:	48 83 ec 40          	sub    $0x40,%rsp
  8004218a12:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004218a16:	89 75 c4             	mov    %esi,-0x3c(%rbp)
    epte_t* dir = eptrt;
  8004218a19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004218a1d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004218a21:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004218a28:	e9 63 01 00 00       	jmpq   8004218b90 <free_ept_level+0x186>
        if(level != 0) {
  8004218a2d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004218a31:	0f 84 ed 00 00 00    	je     8004218b24 <free_ept_level+0x11a>
            if(epte_present(dir[i])) {
  8004218a37:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218a3a:	48 98                	cltq   
  8004218a3c:	48 c1 e0 03          	shl    $0x3,%rax
  8004218a40:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004218a44:	48 8b 00             	mov    (%rax),%rax
  8004218a47:	48 89 c7             	mov    %rax,%rdi
  8004218a4a:	48 b8 bf 86 21 04 80 	movabs $0x80042186bf,%rax
  8004218a51:	00 00 00 
  8004218a54:	ff d0                	callq  *%rax
  8004218a56:	85 c0                	test   %eax,%eax
  8004218a58:	0f 84 2e 01 00 00    	je     8004218b8c <free_ept_level+0x182>
                physaddr_t pa = epte_addr(dir[i]);
  8004218a5e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218a61:	48 98                	cltq   
  8004218a63:	48 c1 e0 03          	shl    $0x3,%rax
  8004218a67:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004218a6b:	48 8b 00             	mov    (%rax),%rax
  8004218a6e:	48 89 c7             	mov    %rax,%rdi
  8004218a71:	48 b8 a7 86 21 04 80 	movabs $0x80042186a7,%rax
  8004218a78:	00 00 00 
  8004218a7b:	ff d0                	callq  *%rax
  8004218a7d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                free_ept_level((epte_t*) KADDR(pa), level-1);
  8004218a81:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004218a84:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004218a87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218a8b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004218a8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218a93:	48 c1 e8 0c          	shr    $0xc,%rax
  8004218a97:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004218a9a:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8004218a9d:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  8004218aa4:	00 00 00 
  8004218aa7:	48 8b 00             	mov    (%rax),%rax
  8004218aaa:	48 39 c1             	cmp    %rax,%rcx
  8004218aad:	72 32                	jb     8004218ae1 <free_ept_level+0xd7>
  8004218aaf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218ab3:	48 89 c1             	mov    %rax,%rcx
  8004218ab6:	48 ba 80 f4 21 04 80 	movabs $0x800421f480,%rdx
  8004218abd:	00 00 00 
  8004218ac0:	be 61 00 00 00       	mov    $0x61,%esi
  8004218ac5:	48 bf a3 f4 21 04 80 	movabs $0x800421f4a3,%rdi
  8004218acc:	00 00 00 
  8004218acf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218ad4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004218adb:	00 00 00 
  8004218ade:	41 ff d0             	callq  *%r8
  8004218ae1:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004218ae8:	00 00 00 
  8004218aeb:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004218aef:	89 d6                	mov    %edx,%esi
  8004218af1:	48 89 c7             	mov    %rax,%rdi
  8004218af4:	48 b8 0a 8a 21 04 80 	movabs $0x8004218a0a,%rax
  8004218afb:	00 00 00 
  8004218afe:	ff d0                	callq  *%rax
                // free the table.
                page_decref(pa2page(pa));
  8004218b00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218b04:	48 89 c7             	mov    %rax,%rdi
  8004218b07:	48 b8 b1 85 21 04 80 	movabs $0x80042185b1,%rax
  8004218b0e:	00 00 00 
  8004218b11:	ff d0                	callq  *%rax
  8004218b13:	48 89 c7             	mov    %rax,%rdi
  8004218b16:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004218b1d:	00 00 00 
  8004218b20:	ff d0                	callq  *%rax
  8004218b22:	eb 68                	jmp    8004218b8c <free_ept_level+0x182>
            }
        } else {
            // Last level, free the guest physical page.
            if(epte_present(dir[i])) {
  8004218b24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218b27:	48 98                	cltq   
  8004218b29:	48 c1 e0 03          	shl    $0x3,%rax
  8004218b2d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004218b31:	48 8b 00             	mov    (%rax),%rax
  8004218b34:	48 89 c7             	mov    %rax,%rdi
  8004218b37:	48 b8 bf 86 21 04 80 	movabs $0x80042186bf,%rax
  8004218b3e:	00 00 00 
  8004218b41:	ff d0                	callq  *%rax
  8004218b43:	85 c0                	test   %eax,%eax
  8004218b45:	74 45                	je     8004218b8c <free_ept_level+0x182>
                physaddr_t pa = epte_addr(dir[i]);
  8004218b47:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218b4a:	48 98                	cltq   
  8004218b4c:	48 c1 e0 03          	shl    $0x3,%rax
  8004218b50:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004218b54:	48 8b 00             	mov    (%rax),%rax
  8004218b57:	48 89 c7             	mov    %rax,%rdi
  8004218b5a:	48 b8 a7 86 21 04 80 	movabs $0x80042186a7,%rax
  8004218b61:	00 00 00 
  8004218b64:	ff d0                	callq  *%rax
  8004218b66:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                page_decref(pa2page(pa));
  8004218b6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004218b6e:	48 89 c7             	mov    %rax,%rdi
  8004218b71:	48 b8 b1 85 21 04 80 	movabs $0x80042185b1,%rax
  8004218b78:	00 00 00 
  8004218b7b:	ff d0                	callq  *%rax
  8004218b7d:	48 89 c7             	mov    %rax,%rdi
  8004218b80:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004218b87:	00 00 00 
  8004218b8a:	ff d0                	callq  *%rax

static void free_ept_level(epte_t* eptrt, int level) {
    epte_t* dir = eptrt;
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004218b8c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004218b90:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%rbp)
  8004218b97:	0f 8e 90 fe ff ff    	jle    8004218a2d <free_ept_level+0x23>
                page_decref(pa2page(pa));
            }
        }
    }
    return;
}
  8004218b9d:	c9                   	leaveq 
  8004218b9e:	c3                   	retq   

0000008004218b9f <free_guest_mem>:

// Free the EPT table entries and the EPT tables.
// NOTE: Does not deallocate EPT PML4 page.
void free_guest_mem(epte_t* eptrt) {
  8004218b9f:	55                   	push   %rbp
  8004218ba0:	48 89 e5             	mov    %rsp,%rbp
  8004218ba3:	48 83 ec 10          	sub    $0x10,%rsp
  8004218ba7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    free_ept_level(eptrt, EPT_LEVELS - 1);
  8004218bab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218baf:	be 03 00 00 00       	mov    $0x3,%esi
  8004218bb4:	48 89 c7             	mov    %rax,%rdi
  8004218bb7:	48 b8 0a 8a 21 04 80 	movabs $0x8004218a0a,%rax
  8004218bbe:	00 00 00 
  8004218bc1:	ff d0                	callq  *%rax
}
  8004218bc3:	c9                   	leaveq 
  8004218bc4:	c3                   	retq   

0000008004218bc5 <ept_page_insert>:
// Add Page pp to a guest's EPT at guest physical address gpa
//  with permission perm.  eptrt is the EPT root.
// 
// Return 0 on success, <0 on failure.
//
int ept_page_insert(epte_t* eptrt, struct PageInfo* pp, void* gpa, int perm) {
  8004218bc5:	55                   	push   %rbp
  8004218bc6:	48 89 e5             	mov    %rsp,%rbp
  8004218bc9:	48 83 ec 30          	sub    $0x30,%rsp
  8004218bcd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218bd1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004218bd5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004218bd9:	89 4d d4             	mov    %ecx,-0x2c(%rbp)

    /* Your code here */
    // do a page_look up so that intermediate page tables are set up properly just in case.
	epte_t *epte_out;
	if (ept_lookup_gpa(eptrt, gpa, 1, &epte_out) == 0) {
  8004218bdc:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  8004218be0:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8004218be4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218be8:	48 89 d1             	mov    %rdx,%rcx
  8004218beb:	ba 01 00 00 00       	mov    $0x1,%edx
  8004218bf0:	48 89 c7             	mov    %rax,%rdi
  8004218bf3:	48 b8 dd 86 21 04 80 	movabs $0x80042186dd,%rax
  8004218bfa:	00 00 00 
  8004218bfd:	ff d0                	callq  *%rax
  8004218bff:	85 c0                	test   %eax,%eax
  8004218c01:	75 4f                	jne    8004218c52 <ept_page_insert+0x8d>
		epte_out[PTX(gpa)] = PTE_ADDR(epte_out[PTX(gpa)]) | perm | __EPTE_IPAT;
  8004218c03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218c07:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004218c0b:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004218c0f:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004218c15:	48 c1 e2 03          	shl    $0x3,%rdx
  8004218c19:	48 01 d0             	add    %rdx,%rax
  8004218c1c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218c20:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004218c24:	48 c1 e9 0c          	shr    $0xc,%rcx
  8004218c28:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
  8004218c2e:	48 c1 e1 03          	shl    $0x3,%rcx
  8004218c32:	48 01 ca             	add    %rcx,%rdx
  8004218c35:	48 8b 12             	mov    (%rdx),%rdx
  8004218c38:	48 89 d1             	mov    %rdx,%rcx
  8004218c3b:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
  8004218c42:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004218c45:	48 63 d2             	movslq %edx,%rdx
  8004218c48:	48 09 ca             	or     %rcx,%rdx
  8004218c4b:	48 83 ca 40          	or     $0x40,%rdx
  8004218c4f:	48 89 10             	mov    %rdx,(%rax)
	}
	return 0;
  8004218c52:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218c57:	c9                   	leaveq 
  8004218c58:	c3                   	retq   

0000008004218c59 <ept_map_hva2gpa>:
// 
// Hint: use ept_lookup_gpa to create the intermediate 
//       ept levels, and return the final epte_t pointer.
//       You should set the type to EPTE_TYPE_WB and set __EPTE_IPAT flag.
int ept_map_hva2gpa(epte_t* eptrt, void* hva, void* gpa, int perm, 
        int overwrite) {
  8004218c59:	55                   	push   %rbp
  8004218c5a:	48 89 e5             	mov    %rsp,%rbp
  8004218c5d:	48 83 ec 40          	sub    $0x40,%rsp
  8004218c61:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004218c65:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004218c69:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004218c6d:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  8004218c70:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)

    /* Your code here */
	epte_t* ept;
	if(ept_lookup_gpa(eptrt, gpa, 1, &ept) == 0)
  8004218c74:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8004218c78:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  8004218c7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c80:	48 89 d1             	mov    %rdx,%rcx
  8004218c83:	ba 01 00 00 00       	mov    $0x1,%edx
  8004218c88:	48 89 c7             	mov    %rax,%rdi
  8004218c8b:	48 b8 dd 86 21 04 80 	movabs $0x80042186dd,%rax
  8004218c92:	00 00 00 
  8004218c95:	ff d0                	callq  *%rax
  8004218c97:	85 c0                	test   %eax,%eax
  8004218c99:	0f 85 07 01 00 00    	jne    8004218da6 <ept_map_hva2gpa+0x14d>
	{
		if (*ept) {
  8004218c9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218ca3:	48 8b 00             	mov    (%rax),%rax
  8004218ca6:	48 85 c0             	test   %rax,%rax
  8004218ca9:	0f 84 81 00 00 00    	je     8004218d30 <ept_map_hva2gpa+0xd7>
			if (overwrite==0) 
  8004218caf:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
  8004218cb3:	75 0a                	jne    8004218cbf <ept_map_hva2gpa+0x66>
				return -E_INVAL;
  8004218cb5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004218cba:	e9 07 01 00 00       	jmpq   8004218dc6 <ept_map_hva2gpa+0x16d>
		 	else 
				*ept = PADDR(hva)| perm | __EPTE_IPAT;
  8004218cbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218cc3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004218cc7:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  8004218ccb:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004218cd2:	00 00 00 
  8004218cd5:	48 39 55 f8          	cmp    %rdx,-0x8(%rbp)
  8004218cd9:	77 32                	ja     8004218d0d <ept_map_hva2gpa+0xb4>
  8004218cdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218cdf:	48 89 c1             	mov    %rax,%rcx
  8004218ce2:	48 ba b0 f4 21 04 80 	movabs $0x800421f4b0,%rdx
  8004218ce9:	00 00 00 
  8004218cec:	be 9d 00 00 00       	mov    $0x9d,%esi
  8004218cf1:	48 bf a3 f4 21 04 80 	movabs $0x800421f4a3,%rdi
  8004218cf8:	00 00 00 
  8004218cfb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218d00:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004218d07:	00 00 00 
  8004218d0a:	41 ff d0             	callq  *%r8
  8004218d0d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004218d14:	ff ff ff 
  8004218d17:	48 89 d1             	mov    %rdx,%rcx
  8004218d1a:	48 03 4d f8          	add    -0x8(%rbp),%rcx
  8004218d1e:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004218d21:	48 63 d2             	movslq %edx,%rdx
  8004218d24:	48 09 ca             	or     %rcx,%rdx
  8004218d27:	48 83 ca 40          	or     $0x40,%rdx
  8004218d2b:	48 89 10             	mov    %rdx,(%rax)
  8004218d2e:	eb 6f                	jmp    8004218d9f <ept_map_hva2gpa+0x146>
		}
		else 
			*ept = PADDR(hva)| perm | __EPTE_IPAT;
  8004218d30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218d34:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004218d38:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004218d3c:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004218d43:	00 00 00 
  8004218d46:	48 39 55 f0          	cmp    %rdx,-0x10(%rbp)
  8004218d4a:	77 32                	ja     8004218d7e <ept_map_hva2gpa+0x125>
  8004218d4c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004218d50:	48 89 c1             	mov    %rax,%rcx
  8004218d53:	48 ba b0 f4 21 04 80 	movabs $0x800421f4b0,%rdx
  8004218d5a:	00 00 00 
  8004218d5d:	be a0 00 00 00       	mov    $0xa0,%esi
  8004218d62:	48 bf a3 f4 21 04 80 	movabs $0x800421f4a3,%rdi
  8004218d69:	00 00 00 
  8004218d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218d71:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004218d78:	00 00 00 
  8004218d7b:	41 ff d0             	callq  *%r8
  8004218d7e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004218d85:	ff ff ff 
  8004218d88:	48 89 d1             	mov    %rdx,%rcx
  8004218d8b:	48 03 4d f0          	add    -0x10(%rbp),%rcx
  8004218d8f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004218d92:	48 63 d2             	movslq %edx,%rdx
  8004218d95:	48 09 ca             	or     %rcx,%rdx
  8004218d98:	48 83 ca 40          	or     $0x40,%rdx
  8004218d9c:	48 89 10             	mov    %rdx,(%rax)

		return 0;
  8004218d9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218da4:	eb 20                	jmp    8004218dc6 <ept_map_hva2gpa+0x16d>
	}
	cprintf("\n something wrong in look up ept_map_hva2gpa");
  8004218da6:	48 bf d8 f4 21 04 80 	movabs $0x800421f4d8,%rdi
  8004218dad:	00 00 00 
  8004218db0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218db5:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004218dbc:	00 00 00 
  8004218dbf:	ff d2                	callq  *%rdx
    return -E_INVAL;
  8004218dc1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  8004218dc6:	c9                   	leaveq 
  8004218dc7:	c3                   	retq   

0000008004218dc8 <ept_alloc_static>:

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
  8004218dc8:	55                   	push   %rbp
  8004218dc9:	48 89 e5             	mov    %rsp,%rbp
  8004218dcc:	53                   	push   %rbx
  8004218dcd:	48 83 ec 48          	sub    $0x48,%rsp
  8004218dd1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004218dd5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  8004218dd9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004218de0:	00 
  8004218de1:	eb 6e                	jmp    8004218e51 <ept_alloc_static+0x89>
        struct PageInfo *p = page_alloc(0);
  8004218de3:	bf 00 00 00 00       	mov    $0x0,%edi
  8004218de8:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004218def:	00 00 00 
  8004218df2:	ff d0                	callq  *%rax
  8004218df4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        p->pp_ref += 1;
  8004218df8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218dfc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004218e00:	8d 50 01             	lea    0x1(%rax),%edx
  8004218e03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218e07:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  8004218e0b:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  8004218e0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218e13:	48 89 c7             	mov    %rax,%rdi
  8004218e16:	48 b8 22 86 21 04 80 	movabs $0x8004218622,%rax
  8004218e1d:	00 00 00 
  8004218e20:	ff d0                	callq  *%rax
  8004218e22:	48 89 c6             	mov    %rax,%rsi
  8004218e25:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004218e29:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004218e2f:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004218e34:	48 89 da             	mov    %rbx,%rdx
  8004218e37:	48 89 c7             	mov    %rax,%rdi
  8004218e3a:	48 b8 59 8c 21 04 80 	movabs $0x8004218c59,%rax
  8004218e41:	00 00 00 
  8004218e44:	ff d0                	callq  *%rax
  8004218e46:	89 45 dc             	mov    %eax,-0x24(%rbp)
}

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  8004218e49:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004218e50:	00 
  8004218e51:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  8004218e58:	00 
  8004218e59:	76 88                	jbe    8004218de3 <ept_alloc_static+0x1b>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  8004218e5b:	48 c7 45 e8 00 00 10 	movq   $0x100000,-0x18(%rbp)
  8004218e62:	00 
  8004218e63:	eb 6e                	jmp    8004218ed3 <ept_alloc_static+0x10b>
        struct PageInfo *p = page_alloc(0);
  8004218e65:	bf 00 00 00 00       	mov    $0x0,%edi
  8004218e6a:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  8004218e71:	00 00 00 
  8004218e74:	ff d0                	callq  *%rax
  8004218e76:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        p->pp_ref += 1;
  8004218e7a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004218e7e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004218e82:	8d 50 01             	lea    0x1(%rax),%edx
  8004218e85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004218e89:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  8004218e8d:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  8004218e91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004218e95:	48 89 c7             	mov    %rax,%rdi
  8004218e98:	48 b8 22 86 21 04 80 	movabs $0x8004218622,%rax
  8004218e9f:	00 00 00 
  8004218ea2:	ff d0                	callq  *%rax
  8004218ea4:	48 89 c6             	mov    %rax,%rsi
  8004218ea7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004218eab:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004218eb1:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004218eb6:	48 89 da             	mov    %rbx,%rdx
  8004218eb9:	48 89 c7             	mov    %rax,%rdi
  8004218ebc:	48 b8 59 8c 21 04 80 	movabs $0x8004218c59,%rax
  8004218ec3:	00 00 00 
  8004218ec6:	ff d0                	callq  *%rax
  8004218ec8:	89 45 cc             	mov    %eax,-0x34(%rbp)
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  8004218ecb:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004218ed2:	00 
  8004218ed3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004218ed7:	48 8b 00             	mov    (%rax),%rax
  8004218eda:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004218ede:	77 85                	ja     8004218e65 <ept_alloc_static+0x9d>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }
    return 0;
  8004218ee0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218ee5:	48 83 c4 48          	add    $0x48,%rsp
  8004218ee9:	5b                   	pop    %rbx
  8004218eea:	5d                   	pop    %rbp
  8004218eeb:	c3                   	retq   

0000008004218eec <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  8004218eec:	55                   	push   %rbp
  8004218eed:	48 89 e5             	mov    %rsp,%rbp
  8004218ef0:	53                   	push   %rbx
  8004218ef1:	48 83 ec 20          	sub    $0x20,%rsp
  8004218ef5:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  8004218ef8:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  8004218efc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218f00:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218f03:	f8                   	clc    
  8004218f04:	0f 79 d0             	vmwrite %rax,%rdx
  8004218f07:	0f 96 c3             	setbe  %bl
  8004218f0a:	88 5d f7             	mov    %bl,-0x9(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  8004218f0d:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  8004218f11:	48 83 c4 20          	add    $0x20,%rsp
  8004218f15:	5b                   	pop    %rbx
  8004218f16:	5d                   	pop    %rbp
  8004218f17:	c3                   	retq   

0000008004218f18 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  8004218f18:	55                   	push   %rbp
  8004218f19:	48 89 e5             	mov    %rsp,%rbp
  8004218f1c:	53                   	push   %rbx
  8004218f1d:	48 83 ec 18          	sub    $0x18,%rsp
  8004218f21:	89 7d e4             	mov    %edi,-0x1c(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  8004218f24:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218f27:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004218f2a:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004218f2d:	0f 78 d0             	vmread %rdx,%rax
  8004218f30:	48 89 c3             	mov    %rax,%rbx
  8004218f33:	48 89 5d f0          	mov    %rbx,-0x10(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  8004218f37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004218f3b:	48 83 c4 18          	add    $0x18,%rsp
  8004218f3f:	5b                   	pop    %rbx
  8004218f40:	5d                   	pop    %rbp
  8004218f41:	c3                   	retq   

0000008004218f42 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  8004218f42:	55                   	push   %rbp
  8004218f43:	48 89 e5             	mov    %rsp,%rbp
  8004218f46:	41 56                	push   %r14
  8004218f48:	41 55                	push   %r13
  8004218f4a:	41 54                	push   %r12
  8004218f4c:	53                   	push   %rbx
  8004218f4d:	48 83 ec 38          	sub    $0x38,%rsp
  8004218f51:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8004218f54:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004218f58:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004218f5c:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004218f60:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  8004218f64:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004218f67:	89 45 c8             	mov    %eax,-0x38(%rbp)
  8004218f6a:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004218f6d:	0f a2                	cpuid  
  8004218f6f:	41 89 d4             	mov    %edx,%r12d
  8004218f72:	41 89 cd             	mov    %ecx,%r13d
  8004218f75:	41 89 c6             	mov    %eax,%r14d
  8004218f78:	44 89 75 dc          	mov    %r14d,-0x24(%rbp)
  8004218f7c:	89 5d d8             	mov    %ebx,-0x28(%rbp)
  8004218f7f:	44 89 6d d4          	mov    %r13d,-0x2c(%rbp)
  8004218f83:	44 89 65 d0          	mov    %r12d,-0x30(%rbp)
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
	if (eaxp)
  8004218f87:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004218f8c:	74 09                	je     8004218f97 <cpuid+0x55>
		*eaxp = eax;
  8004218f8e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004218f92:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004218f95:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  8004218f97:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004218f9c:	74 09                	je     8004218fa7 <cpuid+0x65>
		*ebxp = ebx;
  8004218f9e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004218fa2:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004218fa5:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  8004218fa7:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004218fac:	74 09                	je     8004218fb7 <cpuid+0x75>
		*ecxp = ecx;
  8004218fae:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004218fb2:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004218fb5:	89 10                	mov    %edx,(%rax)
	if (edxp)
  8004218fb7:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004218fbc:	74 09                	je     8004218fc7 <cpuid+0x85>
		*edxp = edx;
  8004218fbe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004218fc2:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8004218fc5:	89 10                	mov    %edx,(%rax)
}
  8004218fc7:	48 83 c4 38          	add    $0x38,%rsp
  8004218fcb:	5b                   	pop    %rbx
  8004218fcc:	41 5c                	pop    %r12
  8004218fce:	41 5d                	pop    %r13
  8004218fd0:	41 5e                	pop    %r14
  8004218fd2:	5d                   	pop    %rbp
  8004218fd3:	c3                   	retq   

0000008004218fd4 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004218fd4:	55                   	push   %rbp
  8004218fd5:	48 89 e5             	mov    %rsp,%rbp
  8004218fd8:	48 83 ec 08          	sub    $0x8,%rsp
  8004218fdc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004218fe0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218fe4:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  8004218feb:	00 00 00 
  8004218fee:	48 8b 00             	mov    (%rax),%rax
  8004218ff1:	48 89 d1             	mov    %rdx,%rcx
  8004218ff4:	48 29 c1             	sub    %rax,%rcx
  8004218ff7:	48 89 c8             	mov    %rcx,%rax
  8004218ffa:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004218ffe:	c9                   	leaveq 
  8004218fff:	c3                   	retq   

0000008004219000 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004219000:	55                   	push   %rbp
  8004219001:	48 89 e5             	mov    %rsp,%rbp
  8004219004:	48 83 ec 08          	sub    $0x8,%rsp
  8004219008:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421900c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219010:	48 89 c7             	mov    %rax,%rdi
  8004219013:	48 b8 d4 8f 21 04 80 	movabs $0x8004218fd4,%rax
  800421901a:	00 00 00 
  800421901d:	ff d0                	callq  *%rax
  800421901f:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004219023:	c9                   	leaveq 
  8004219024:	c3                   	retq   

0000008004219025 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  8004219025:	55                   	push   %rbp
  8004219026:	48 89 e5             	mov    %rsp,%rbp
  8004219029:	48 83 ec 20          	sub    $0x20,%rsp
  800421902d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004219031:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219035:	48 89 c7             	mov    %rax,%rdi
  8004219038:	48 b8 00 90 21 04 80 	movabs $0x8004219000,%rax
  800421903f:	00 00 00 
  8004219042:	ff d0                	callq  *%rax
  8004219044:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004219048:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421904c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004219050:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004219053:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004219056:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800421905d:	00 00 00 
  8004219060:	48 8b 00             	mov    (%rax),%rax
  8004219063:	48 39 c2             	cmp    %rax,%rdx
  8004219066:	72 32                	jb     800421909a <page2kva+0x75>
  8004219068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421906c:	48 89 c1             	mov    %rax,%rcx
  800421906f:	48 ba 08 f5 21 04 80 	movabs $0x800421f508,%rdx
  8004219076:	00 00 00 
  8004219079:	be 5b 00 00 00       	mov    $0x5b,%esi
  800421907e:	48 bf 2b f5 21 04 80 	movabs $0x800421f52b,%rdi
  8004219085:	00 00 00 
  8004219088:	b8 00 00 00 00       	mov    $0x0,%eax
  800421908d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004219094:	00 00 00 
  8004219097:	41 ff d0             	callq  *%r8
  800421909a:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042190a1:	00 00 00 
  80042190a4:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  80042190a8:	c9                   	leaveq 
  80042190a9:	c3                   	retq   

00000080042190aa <vmx_check_support>:
 * See Section 23.6 of the Intel manual.
 * 
 * Hint: the TA solution uses the BIT() macro 
 *  to simplify the implementation.
 */
static inline bool vmx_check_support() {
  80042190aa:	55                   	push   %rbp
  80042190ab:	48 89 e5             	mov    %rsp,%rbp
  80042190ae:	48 83 ec 10          	sub    $0x10,%rsp
    uint32_t eax, ebx, ecx, edx;
    cpuid( 1, &eax, &ebx, &ecx, &edx );
  80042190b2:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042190b6:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
  80042190ba:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  80042190be:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042190c2:	49 89 f0             	mov    %rsi,%r8
  80042190c5:	48 89 c6             	mov    %rax,%rsi
  80042190c8:	bf 01 00 00 00       	mov    $0x1,%edi
  80042190cd:	48 b8 42 8f 21 04 80 	movabs $0x8004218f42,%rax
  80042190d4:	00 00 00 
  80042190d7:	ff d0                	callq  *%rax
    /* Your code here */
	// ECX Bit 5 has to be 1 in order to support CMX extension -- Qemu doesn't support VMX.
	if (BIT(ecx, 5) == 1) {
  80042190d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042190dc:	83 e0 20             	and    $0x20,%eax
  80042190df:	85 c0                	test   %eax,%eax
  80042190e1:	74 22                	je     8004219105 <vmx_check_support+0x5b>
		cprintf("[VMM] VMX extension supported.\n");
  80042190e3:	48 bf 40 f5 21 04 80 	movabs $0x800421f540,%rdi
  80042190ea:	00 00 00 
  80042190ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042190f2:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042190f9:	00 00 00 
  80042190fc:	ff d2                	callq  *%rdx
		return true;
  80042190fe:	b8 01 00 00 00       	mov    $0x1,%eax
  8004219103:	eb 20                	jmp    8004219125 <vmx_check_support+0x7b>
	}
    cprintf("[VMM] VMX extension not supported.\n");
  8004219105:	48 bf 60 f5 21 04 80 	movabs $0x800421f560,%rdi
  800421910c:	00 00 00 
  800421910f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219114:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421911b:	00 00 00 
  800421911e:	ff d2                	callq  *%rdx
    return false;
  8004219120:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219125:	c9                   	leaveq 
  8004219126:	c3                   	retq   

0000008004219127 <vmx_check_ept>:
 *
 * Hint: This needs to check two MSR bits---first verifying
 *   that secondary VMX controls are enabled, and then that
 *   EPT is available.
 */
static inline bool vmx_check_ept() {
  8004219127:	55                   	push   %rbp
  8004219128:	48 89 e5             	mov    %rsp,%rbp
  800421912b:	41 54                	push   %r12
  800421912d:	53                   	push   %rbx
  800421912e:	48 83 ec 40          	sub    $0x40,%rsp
  8004219132:	c7 45 ec 82 04 00 00 	movl   $0x482,-0x14(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219139:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  800421913c:	89 4d bc             	mov    %ecx,-0x44(%rbp)
  800421913f:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  8004219142:	0f 32                	rdmsr  
  8004219144:	89 c3                	mov    %eax,%ebx
  8004219146:	41 89 d4             	mov    %edx,%r12d
  8004219149:	44 89 65 e8          	mov    %r12d,-0x18(%rbp)
  800421914d:	89 5d e4             	mov    %ebx,-0x1c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219150:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004219157:	00 
    ret = edx;
  8004219158:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421915b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    ret = ret << 32;
  800421915f:	48 c1 65 d8 20       	shlq   $0x20,-0x28(%rbp)
    ret |= eax;
  8004219164:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004219167:	48 09 45 d8          	or     %rax,-0x28(%rbp)

    return ret;
  800421916b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    /* Your code here */
	// This is for the normal VM entry check -- Appendix A.3.3 (last line)
    if (BIT(read_msr(IA32_VMX_PROCBASED_CTLS), 63) == 1) {
  800421916f:	48 c1 e8 3f          	shr    $0x3f,%rax
  8004219173:	48 83 f8 01          	cmp    $0x1,%rax
  8004219177:	75 74                	jne    80042191ed <vmx_check_ept+0xc6>
  8004219179:	c7 45 d4 8b 04 00 00 	movl   $0x48b,-0x2c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219180:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  8004219183:	89 4d bc             	mov    %ecx,-0x44(%rbp)
  8004219186:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  8004219189:	0f 32                	rdmsr  
  800421918b:	89 c3                	mov    %eax,%ebx
  800421918d:	41 89 d4             	mov    %edx,%r12d
  8004219190:	44 89 65 d0          	mov    %r12d,-0x30(%rbp)
  8004219194:	89 5d cc             	mov    %ebx,-0x34(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219197:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800421919e:	00 
    ret = edx;
  800421919f:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80042191a2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    ret = ret << 32;
  80042191a6:	48 c1 65 c0 20       	shlq   $0x20,-0x40(%rbp)
    ret |= eax;
  80042191ab:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042191ae:	48 09 45 c0          	or     %rax,-0x40(%rbp)

    return ret;
  80042191b2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
		if(BIT(read_msr(IA32_VMX_PROCBASED_CTLS2), 33) == 1) { //Enable EPT bit offset by 32.
  80042191b6:	48 89 c2             	mov    %rax,%rdx
  80042191b9:	48 b8 00 00 00 00 02 	movabs $0x200000000,%rax
  80042191c0:	00 00 00 
  80042191c3:	48 21 d0             	and    %rdx,%rax
  80042191c6:	48 85 c0             	test   %rax,%rax
  80042191c9:	74 22                	je     80042191ed <vmx_check_ept+0xc6>
			cprintf("[VMM] EPT extension supported.\n"); 
  80042191cb:	48 bf 88 f5 21 04 80 	movabs $0x800421f588,%rdi
  80042191d2:	00 00 00 
  80042191d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042191da:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  80042191e1:	00 00 00 
  80042191e4:	ff d2                	callq  *%rdx
			return true;
  80042191e6:	b8 01 00 00 00       	mov    $0x1,%eax
  80042191eb:	eb 20                	jmp    800421920d <vmx_check_ept+0xe6>
		}
	}
	cprintf("[VMM] EPT extension not supported.\n"); 
  80042191ed:	48 bf a8 f5 21 04 80 	movabs $0x800421f5a8,%rdi
  80042191f4:	00 00 00 
  80042191f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042191fc:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  8004219203:	00 00 00 
  8004219206:	ff d2                	callq  *%rdx
	return false;
  8004219208:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421920d:	48 83 c4 40          	add    $0x40,%rsp
  8004219211:	5b                   	pop    %rbx
  8004219212:	41 5c                	pop    %r12
  8004219214:	5d                   	pop    %rbp
  8004219215:	c3                   	retq   

0000008004219216 <check_fixed_bits>:

/* Checks if curr_val is compatible with fixed0 and fixed1 
* (allowed values read from the MSR). This is to ensure current processor
* operating mode meets the required fixed bit requirement of VMX.  
*/
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
  8004219216:	55                   	push   %rbp
  8004219217:	48 89 e5             	mov    %rsp,%rbp
  800421921a:	53                   	push   %rbx
  800421921b:	48 83 ec 38          	sub    $0x38,%rsp
  800421921f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219223:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219227:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    // TODO: Simplify this code.
    int i;
    for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  800421922b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004219232:	e9 9e 00 00 00       	jmpq   80042192d5 <check_fixed_bits+0xbf>
        int bit = BIT( curr_val, i );
  8004219237:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421923a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421923e:	48 89 d3             	mov    %rdx,%rbx
  8004219241:	89 c1                	mov    %eax,%ecx
  8004219243:	48 d3 eb             	shr    %cl,%rbx
  8004219246:	48 89 d8             	mov    %rbx,%rax
  8004219249:	83 e0 01             	and    $0x1,%eax
  800421924c:	89 45 e8             	mov    %eax,-0x18(%rbp)
        if ( bit == 1 ) {
  800421924f:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  8004219253:	75 21                	jne    8004219276 <check_fixed_bits+0x60>
            // Check if this bit is fixed to 0.
            if ( BIT( fixed1, i ) == 0 ) {
  8004219255:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219258:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421925c:	48 89 d3             	mov    %rdx,%rbx
  800421925f:	89 c1                	mov    %eax,%ecx
  8004219261:	48 d3 eb             	shr    %cl,%rbx
  8004219264:	48 89 d8             	mov    %rbx,%rax
  8004219267:	83 e0 01             	and    $0x1,%eax
  800421926a:	48 85 c0             	test   %rax,%rax
  800421926d:	75 62                	jne    80042192d1 <check_fixed_bits+0xbb>
                return false;
  800421926f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219274:	eb 70                	jmp    80042192e6 <check_fixed_bits+0xd0>
            }
        } else if ( bit == 0 ) {
  8004219276:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421927a:	75 20                	jne    800421929c <check_fixed_bits+0x86>
            // Check if this bit is fixed to 1.
            if ( BIT( fixed0, i ) == 1 ) {
  800421927c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421927f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004219283:	48 89 d3             	mov    %rdx,%rbx
  8004219286:	89 c1                	mov    %eax,%ecx
  8004219288:	48 d3 eb             	shr    %cl,%rbx
  800421928b:	48 89 d8             	mov    %rbx,%rax
  800421928e:	83 e0 01             	and    $0x1,%eax
  8004219291:	84 c0                	test   %al,%al
  8004219293:	74 3c                	je     80042192d1 <check_fixed_bits+0xbb>
                return false;
  8004219295:	b8 00 00 00 00       	mov    $0x0,%eax
  800421929a:	eb 4a                	jmp    80042192e6 <check_fixed_bits+0xd0>
            }
        } else {
            assert(false);
  800421929c:	48 b9 cc f5 21 04 80 	movabs $0x800421f5cc,%rcx
  80042192a3:	00 00 00 
  80042192a6:	48 ba d2 f5 21 04 80 	movabs $0x800421f5d2,%rdx
  80042192ad:	00 00 00 
  80042192b0:	be 56 00 00 00       	mov    $0x56,%esi
  80042192b5:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  80042192bc:	00 00 00 
  80042192bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042192c4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  80042192cb:	00 00 00 
  80042192ce:	41 ff d0             	callq  *%r8
* operating mode meets the required fixed bit requirement of VMX.  
*/
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
    // TODO: Simplify this code.
    int i;
    for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  80042192d1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042192d5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042192d8:	83 f8 3f             	cmp    $0x3f,%eax
  80042192db:	0f 86 56 ff ff ff    	jbe    8004219237 <check_fixed_bits+0x21>
            }
        } else {
            assert(false);
        }
    }
    return true;
  80042192e1:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042192e6:	48 83 c4 38          	add    $0x38,%rsp
  80042192ea:	5b                   	pop    %rbx
  80042192eb:	5d                   	pop    %rbp
  80042192ec:	c3                   	retq   

00000080042192ed <vmx_init_vmcs>:

/* 
 * Allocate a page for the VMCS region and write the VMCS Rev. ID in the first 
 * 31 bits.
 */
struct PageInfo * vmx_init_vmcs() {
  80042192ed:	55                   	push   %rbp
  80042192ee:	48 89 e5             	mov    %rsp,%rbp
  80042192f1:	41 54                	push   %r12
  80042192f3:	53                   	push   %rbx
  80042192f4:	48 83 ec 50          	sub    $0x50,%rsp
  80042192f8:	c7 45 cc 80 04 00 00 	movl   $0x480,-0x34(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  80042192ff:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  8004219302:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  8004219305:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  8004219308:	0f 32                	rdmsr  
  800421930a:	89 c3                	mov    %eax,%ebx
  800421930c:	41 89 d4             	mov    %edx,%r12d
  800421930f:	44 89 65 c8          	mov    %r12d,-0x38(%rbp)
  8004219313:	89 5d c4             	mov    %ebx,-0x3c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219316:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800421931d:	00 
    ret = edx;
  800421931e:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004219321:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    ret = ret << 32;
  8004219325:	48 c1 65 b8 20       	shlq   $0x20,-0x48(%rbp)
    ret |= eax;
  800421932a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421932d:	48 09 45 b8          	or     %rax,-0x48(%rbp)

    return ret;
  8004219331:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    // Read the VMX_BASIC MSR.
    uint64_t vmx_basic_msr =  read_msr( IA32_VMX_BASIC );
  8004219335:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint32_t vmcs_rev_id = (uint32_t) vmx_basic_msr; // Bits 30:0, Bit 31 is always 0.
  8004219339:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421933d:	89 45 b4             	mov    %eax,-0x4c(%rbp)

    uint32_t vmcs_num_bytes =  ( vmx_basic_msr >> 32 ) & 0xfff; // Bits 44:32.
  8004219340:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219344:	48 c1 e8 20          	shr    $0x20,%rax
  8004219348:	25 ff 0f 00 00       	and    $0xfff,%eax
  800421934d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    assert( vmcs_num_bytes <= 4096 ); // VMCS can have a max size of 4096.
  8004219350:	81 7d e4 00 10 00 00 	cmpl   $0x1000,-0x1c(%rbp)
  8004219357:	76 35                	jbe    800421938e <vmx_init_vmcs+0xa1>
  8004219359:	48 b9 f1 f5 21 04 80 	movabs $0x800421f5f1,%rcx
  8004219360:	00 00 00 
  8004219363:	48 ba d2 f5 21 04 80 	movabs $0x800421f5d2,%rdx
  800421936a:	00 00 00 
  800421936d:	be 66 00 00 00       	mov    $0x66,%esi
  8004219372:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  8004219379:	00 00 00 
  800421937c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219381:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  8004219388:	00 00 00 
  800421938b:	41 ff d0             	callq  *%r8

    //Alocate mem for VMCS region.
    struct PageInfo *p_vmxon_region = page_alloc( ALLOC_ZERO );
  800421938e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004219393:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800421939a:	00 00 00 
  800421939d:	ff d0                	callq  *%rax
  800421939f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if(!p_vmxon_region) {
  80042193a3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042193a8:	75 07                	jne    80042193b1 <vmx_init_vmcs+0xc4>
        return NULL;
  80042193aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042193af:	eb 4d                	jmp    80042193fe <vmx_init_vmcs+0x111>
    }
    p_vmxon_region->pp_ref += 1; 
  80042193b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042193b5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042193b9:	8d 50 01             	lea    0x1(%rax),%edx
  80042193bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042193c0:	66 89 50 08          	mov    %dx,0x8(%rax)
    
    unsigned char* vmxon_region = (unsigned char *) page2kva( p_vmxon_region );
  80042193c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042193c8:	48 89 c7             	mov    %rax,%rdi
  80042193cb:	48 b8 25 90 21 04 80 	movabs $0x8004219025,%rax
  80042193d2:	00 00 00 
  80042193d5:	ff d0                	callq  *%rax
  80042193d7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    memcpy( vmxon_region, &vmcs_rev_id, sizeof( vmcs_rev_id ) );
  80042193db:	48 8d 4d b4          	lea    -0x4c(%rbp),%rcx
  80042193df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042193e3:	ba 04 00 00 00       	mov    $0x4,%edx
  80042193e8:	48 89 ce             	mov    %rcx,%rsi
  80042193eb:	48 89 c7             	mov    %rax,%rdi
  80042193ee:	48 b8 e9 04 21 04 80 	movabs $0x80042104e9,%rax
  80042193f5:	00 00 00 
  80042193f8:	ff d0                	callq  *%rax

    return p_vmxon_region;
  80042193fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80042193fe:	48 83 c4 50          	add    $0x50,%rsp
  8004219402:	5b                   	pop    %rbx
  8004219403:	41 5c                	pop    %r12
  8004219405:	5d                   	pop    %rbp
  8004219406:	c3                   	retq   

0000008004219407 <vmx_init_vmxon>:

/* 
 * Sets up a VMXON region and executes VMXON to put the processor in VMX root 
 * operation. Returns a >=0 value if VMX root operation is achieved.
 */
int vmx_init_vmxon() {
  8004219407:	55                   	push   %rbp
  8004219408:	48 89 e5             	mov    %rsp,%rbp
  800421940b:	41 54                	push   %r12
  800421940d:	53                   	push   %rbx
  800421940e:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
    // Check if the processor has VMX support.
    if ( !vmx_check_support() ) {
  8004219415:	b8 00 00 00 00       	mov    $0x0,%eax
  800421941a:	48 ba aa 90 21 04 80 	movabs $0x80042190aa,%rdx
  8004219421:	00 00 00 
  8004219424:	ff d2                	callq  *%rdx
  8004219426:	83 f0 01             	xor    $0x1,%eax
  8004219429:	84 c0                	test   %al,%al
  800421942b:	74 0a                	je     8004219437 <vmx_init_vmxon+0x30>
        return -E_NO_VMX;
  800421942d:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  8004219432:	e9 44 04 00 00       	jmpq   800421987b <vmx_init_vmxon+0x474>
    } else if ( !vmx_check_ept() ) {
  8004219437:	b8 00 00 00 00       	mov    $0x0,%eax
  800421943c:	48 ba 27 91 21 04 80 	movabs $0x8004219127,%rdx
  8004219443:	00 00 00 
  8004219446:	ff d2                	callq  *%rdx
  8004219448:	83 f0 01             	xor    $0x1,%eax
  800421944b:	84 c0                	test   %al,%al
  800421944d:	74 0a                	je     8004219459 <vmx_init_vmxon+0x52>
       return -E_NO_EPT;
  800421944f:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
  8004219454:	e9 22 04 00 00       	jmpq   800421987b <vmx_init_vmxon+0x474>
    } 
    
    //Alocate mem and init the VMXON region.
    struct PageInfo *p_vmxon_region = vmx_init_vmcs();
  8004219459:	b8 00 00 00 00       	mov    $0x0,%eax
  800421945e:	48 ba ed 92 21 04 80 	movabs $0x80042192ed,%rdx
  8004219465:	00 00 00 
  8004219468:	ff d2                	callq  *%rdx
  800421946a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(!p_vmxon_region)
  800421946e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004219473:	75 0a                	jne    800421947f <vmx_init_vmxon+0x78>
        return -E_NO_MEM;
  8004219475:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800421947a:	e9 fc 03 00 00       	jmpq   800421987b <vmx_init_vmxon+0x474>

    static __inline uint64_t
rcr0(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr0,%0" : "=r" (val));
  800421947f:	0f 20 c3             	mov    %cr0,%rbx
  8004219482:	48 89 5d b8          	mov    %rbx,-0x48(%rbp)
    return val;
  8004219486:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    uint64_t cr0 = rcr0();
  800421948a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

    static __inline uint64_t
rcr4(void)
{
    uint64_t cr4;
    __asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  800421948e:	0f 20 e3             	mov    %cr4,%rbx
  8004219491:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
    return cr4;
  8004219495:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    uint64_t cr4 = rcr4();
  8004219499:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    // Paging and protected mode are enabled in JOS.
    
    // FIXME: Workaround for CR0.NE (bochs needs this to be set to 1)
    cr0 = cr0 | CR0_NE;
  800421949d:	48 83 4d e0 20       	orq    $0x20,-0x20(%rbp)
  80042194a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042194a6:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

    static __inline void
lcr0(uint64_t val)
{
    __asm __volatile("movq %0,%%cr0" : : "r" (val));
  80042194aa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042194ae:	0f 22 c0             	mov    %rax,%cr0
  80042194b1:	c7 45 a4 87 04 00 00 	movl   $0x487,-0x5c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  80042194b8:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  80042194bb:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
  80042194c1:	8b 8d fc fe ff ff    	mov    -0x104(%rbp),%ecx
  80042194c7:	0f 32                	rdmsr  
  80042194c9:	89 c3                	mov    %eax,%ebx
  80042194cb:	41 89 d4             	mov    %edx,%r12d
  80042194ce:	44 89 65 a0          	mov    %r12d,-0x60(%rbp)
  80042194d2:	89 5d 9c             	mov    %ebx,-0x64(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  80042194d5:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80042194dc:	00 
    ret = edx;
  80042194dd:	8b 45 a0             	mov    -0x60(%rbp),%eax
  80042194e0:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    ret = ret << 32;
  80042194e4:	48 c1 65 90 20       	shlq   $0x20,-0x70(%rbp)
    ret |= eax;
  80042194e9:	8b 45 9c             	mov    -0x64(%rbp),%eax
  80042194ec:	48 09 45 90          	or     %rax,-0x70(%rbp)

    return ret;
  80042194f0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    lcr0( cr0 );

    bool ret =  check_fixed_bits( cr0,
  80042194f4:	48 89 c6             	mov    %rax,%rsi
  80042194f7:	c7 45 8c 86 04 00 00 	movl   $0x486,-0x74(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  80042194fe:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
  8004219501:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
  8004219507:	8b 8d fc fe ff ff    	mov    -0x104(%rbp),%ecx
  800421950d:	0f 32                	rdmsr  
  800421950f:	89 c3                	mov    %eax,%ebx
  8004219511:	41 89 d4             	mov    %edx,%r12d
  8004219514:	44 89 65 88          	mov    %r12d,-0x78(%rbp)
  8004219518:	89 5d 84             	mov    %ebx,-0x7c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  800421951b:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
  8004219522:	00 00 00 00 
    ret = edx;
  8004219526:	8b 45 88             	mov    -0x78(%rbp),%eax
  8004219529:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    ret = ret << 32;
  8004219530:	48 c1 a5 78 ff ff ff 	shlq   $0x20,-0x88(%rbp)
  8004219537:	20 
    ret |= eax;
  8004219538:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421953b:	48 09 85 78 ff ff ff 	or     %rax,-0x88(%rbp)

    return ret;
  8004219542:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004219549:	48 89 c1             	mov    %rax,%rcx
  800421954c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219550:	48 89 f2             	mov    %rsi,%rdx
  8004219553:	48 89 ce             	mov    %rcx,%rsi
  8004219556:	48 89 c7             	mov    %rax,%rdi
  8004219559:	48 b8 16 92 21 04 80 	movabs $0x8004219216,%rax
  8004219560:	00 00 00 
  8004219563:	ff d0                	callq  *%rax
  8004219565:	88 45 d7             	mov    %al,-0x29(%rbp)
                                  read_msr( IA32_VMX_CR0_FIXED0 ), 
                                  read_msr( IA32_VMX_CR0_FIXED1 ) );
    if ( !ret ) {
  8004219568:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
  800421956c:	83 f0 01             	xor    $0x1,%eax
  800421956f:	84 c0                	test   %al,%al
  8004219571:	74 1d                	je     8004219590 <vmx_init_vmxon+0x189>
        page_decref( p_vmxon_region );
  8004219573:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219577:	48 89 c7             	mov    %rax,%rdi
  800421957a:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004219581:	00 00 00 
  8004219584:	ff d0                	callq  *%rax
        return -E_VMX_ON;
  8004219586:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421958b:	e9 eb 02 00 00       	jmpq   800421987b <vmx_init_vmxon+0x474>
    }
    // Enable VMX in CR4.
    cr4 = cr4 | CR4_VMXE;
  8004219590:	48 81 4d d8 00 20 00 	orq    $0x2000,-0x28(%rbp)
  8004219597:	00 
  8004219598:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421959c:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

    static __inline void
lcr4(uint64_t val)
{
    __asm __volatile("movq %0,%%cr4" : : "r" (val));
  80042195a3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042195aa:	0f 22 e0             	mov    %rax,%cr4
  80042195ad:	c7 85 6c ff ff ff 89 	movl   $0x489,-0x94(%rbp)
  80042195b4:	04 00 00 
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  80042195b7:	8b 8d 6c ff ff ff    	mov    -0x94(%rbp),%ecx
  80042195bd:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
  80042195c3:	8b 8d fc fe ff ff    	mov    -0x104(%rbp),%ecx
  80042195c9:	0f 32                	rdmsr  
  80042195cb:	89 c3                	mov    %eax,%ebx
  80042195cd:	41 89 d4             	mov    %edx,%r12d
  80042195d0:	44 89 a5 68 ff ff ff 	mov    %r12d,-0x98(%rbp)
  80042195d7:	89 9d 64 ff ff ff    	mov    %ebx,-0x9c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  80042195dd:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  80042195e4:	00 00 00 00 
    ret = edx;
  80042195e8:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  80042195ee:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    ret = ret << 32;
  80042195f5:	48 c1 a5 58 ff ff ff 	shlq   $0x20,-0xa8(%rbp)
  80042195fc:	20 
    ret |= eax;
  80042195fd:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  8004219603:	48 09 85 58 ff ff ff 	or     %rax,-0xa8(%rbp)

    return ret;
  800421960a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    lcr4( cr4 );
    ret =  check_fixed_bits( cr4,
  8004219611:	48 89 c6             	mov    %rax,%rsi
  8004219614:	c7 85 54 ff ff ff 88 	movl   $0x488,-0xac(%rbp)
  800421961b:	04 00 00 
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  800421961e:	8b 8d 54 ff ff ff    	mov    -0xac(%rbp),%ecx
  8004219624:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
  800421962a:	8b 8d fc fe ff ff    	mov    -0x104(%rbp),%ecx
  8004219630:	0f 32                	rdmsr  
  8004219632:	89 c3                	mov    %eax,%ebx
  8004219634:	41 89 d4             	mov    %edx,%r12d
  8004219637:	44 89 a5 50 ff ff ff 	mov    %r12d,-0xb0(%rbp)
  800421963e:	89 9d 4c ff ff ff    	mov    %ebx,-0xb4(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219644:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  800421964b:	00 00 00 00 
    ret = edx;
  800421964f:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
  8004219655:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    ret = ret << 32;
  800421965c:	48 c1 a5 40 ff ff ff 	shlq   $0x20,-0xc0(%rbp)
  8004219663:	20 
    ret |= eax;
  8004219664:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421966a:	48 09 85 40 ff ff ff 	or     %rax,-0xc0(%rbp)

    return ret;
  8004219671:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004219678:	48 89 c1             	mov    %rax,%rcx
  800421967b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421967f:	48 89 f2             	mov    %rsi,%rdx
  8004219682:	48 89 ce             	mov    %rcx,%rsi
  8004219685:	48 89 c7             	mov    %rax,%rdi
  8004219688:	48 b8 16 92 21 04 80 	movabs $0x8004219216,%rax
  800421968f:	00 00 00 
  8004219692:	ff d0                	callq  *%rax
  8004219694:	88 45 d7             	mov    %al,-0x29(%rbp)
                             read_msr( IA32_VMX_CR4_FIXED0 ), 
                             read_msr( IA32_VMX_CR4_FIXED1 ) );
    if ( !ret ) {
  8004219697:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
  800421969b:	83 f0 01             	xor    $0x1,%eax
  800421969e:	84 c0                	test   %al,%al
  80042196a0:	74 1d                	je     80042196bf <vmx_init_vmxon+0x2b8>
        page_decref( p_vmxon_region );
  80042196a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042196a6:	48 89 c7             	mov    %rax,%rdi
  80042196a9:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042196b0:	00 00 00 
  80042196b3:	ff d0                	callq  *%rax
        return -E_VMX_ON;
  80042196b5:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  80042196ba:	e9 bc 01 00 00       	jmpq   800421987b <vmx_init_vmxon+0x474>
  80042196bf:	c7 85 3c ff ff ff 3a 	movl   $0x3a,-0xc4(%rbp)
  80042196c6:	00 00 00 
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  80042196c9:	8b 8d 3c ff ff ff    	mov    -0xc4(%rbp),%ecx
  80042196cf:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
  80042196d5:	8b 8d fc fe ff ff    	mov    -0x104(%rbp),%ecx
  80042196db:	0f 32                	rdmsr  
  80042196dd:	89 c3                	mov    %eax,%ebx
  80042196df:	41 89 d4             	mov    %edx,%r12d
  80042196e2:	44 89 a5 38 ff ff ff 	mov    %r12d,-0xc8(%rbp)
  80042196e9:	89 9d 34 ff ff ff    	mov    %ebx,-0xcc(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  80042196ef:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  80042196f6:	00 00 00 00 
    ret = edx;
  80042196fa:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  8004219700:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    ret = ret << 32;
  8004219707:	48 c1 a5 28 ff ff ff 	shlq   $0x20,-0xd8(%rbp)
  800421970e:	20 
    ret |= eax;
  800421970f:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
  8004219715:	48 09 85 28 ff ff ff 	or     %rax,-0xd8(%rbp)

    return ret;
  800421971c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
    }
    // Ensure that IA32_FEATURE_CONTROL MSR has been properly programmed and 
    // and that it's lock bit has been set.
    uint64_t feature_control = read_msr( IA32_FEATURE_CONTROL );
  8004219723:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if ( !BIT( feature_control, 2 )) {
  8004219727:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421972b:	83 e0 04             	and    $0x4,%eax
  800421972e:	48 85 c0             	test   %rax,%rax
  8004219731:	75 1d                	jne    8004219750 <vmx_init_vmxon+0x349>
        page_decref( p_vmxon_region );
  8004219733:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219737:	48 89 c7             	mov    %rax,%rdi
  800421973a:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  8004219741:	00 00 00 
  8004219744:	ff d0                	callq  *%rax
        // VMX disabled in BIOS.
        return -E_NO_VMX;
  8004219746:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800421974b:	e9 2b 01 00 00       	jmpq   800421987b <vmx_init_vmxon+0x474>
    }
    if ( !BIT( feature_control, 0 )) {
  8004219750:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219754:	83 e0 01             	and    $0x1,%eax
  8004219757:	48 85 c0             	test   %rax,%rax
  800421975a:	75 4c                	jne    80042197a8 <vmx_init_vmxon+0x3a1>
        // Lock bit not set, try setting it.
        feature_control |= 0x1;
  800421975c:	48 83 4d c8 01       	orq    $0x1,-0x38(%rbp)
  8004219761:	c7 85 24 ff ff ff 3a 	movl   $0x3a,-0xdc(%rbp)
  8004219768:	00 00 00 
  800421976b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421976f:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
    uint32_t edx, eax;
    eax = (uint32_t) val;
  8004219776:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421977d:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
    edx = (uint32_t) ( val >> 32 );
  8004219783:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421978a:	48 c1 e8 20          	shr    $0x20,%rax
  800421978e:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
    __asm __volatile("wrmsr"
  8004219794:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  800421979a:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
  80042197a0:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  80042197a6:	0f 30                	wrmsr  
        write_msr( IA32_FEATURE_CONTROL, feature_control );   
    }
    
    uint8_t error = vmxon( (physaddr_t) page2pa( p_vmxon_region ) );
  80042197a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042197ac:	48 89 c7             	mov    %rax,%rdi
  80042197af:	48 b8 00 90 21 04 80 	movabs $0x8004219000,%rax
  80042197b6:	00 00 00 
  80042197b9:	ff d0                	callq  *%rax
  80042197bb:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
static __inline uint8_t vmptrld( physaddr_t vmcs_region ) __attribute((always_inline));


static __inline uint8_t
vmxon( physaddr_t vmxon_region ) {
	uint8_t error = 0;
  80042197c2:	c6 85 0f ff ff ff 00 	movb   $0x0,-0xf1(%rbp)

    __asm __volatile("clc; vmxon %1; setna %0"
  80042197c9:	f8                   	clc    
  80042197ca:	f3 0f c7 b5 00 ff ff 	vmxon  -0x100(%rbp)
  80042197d1:	ff 
  80042197d2:	0f 96 c3             	setbe  %bl
  80042197d5:	88 9d 0f ff ff ff    	mov    %bl,-0xf1(%rbp)
            : "=q"( error ) : "m" ( vmxon_region ): "cc" );
    return error;
  80042197db:	0f b6 85 0f ff ff ff 	movzbl -0xf1(%rbp),%eax
  80042197e2:	88 45 c7             	mov    %al,-0x39(%rbp)
    if ( error ) { 
  80042197e5:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  80042197e9:	74 1a                	je     8004219805 <vmx_init_vmxon+0x3fe>
        page_decref( p_vmxon_region );
  80042197eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042197ef:	48 89 c7             	mov    %rax,%rdi
  80042197f2:	48 b8 28 2d 20 04 80 	movabs $0x8004202d28,%rax
  80042197f9:	00 00 00 
  80042197fc:	ff d0                	callq  *%rax
        return -E_VMX_ON; 
  80042197fe:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  8004219803:	eb 76                	jmp    800421987b <vmx_init_vmxon+0x474>
    }

    thiscpu->is_vmx_root = true;
  8004219805:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421980c:	00 00 00 
  800421980f:	ff d0                	callq  *%rax
  8004219811:	48 98                	cltq   
  8004219813:	48 c1 e0 03          	shl    $0x3,%rax
  8004219817:	48 89 c2             	mov    %rax,%rdx
  800421981a:	48 c1 e2 04          	shl    $0x4,%rdx
  800421981e:	48 01 c2             	add    %rax,%rdx
  8004219821:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004219828:	00 00 00 
  800421982b:	48 01 d0             	add    %rdx,%rax
  800421982e:	c6 40 78 01          	movb   $0x1,0x78(%rax)
    thiscpu->vmxon_region = (uintptr_t) page2kva( p_vmxon_region );
  8004219832:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004219839:	00 00 00 
  800421983c:	ff d0                	callq  *%rax
  800421983e:	48 98                	cltq   
  8004219840:	48 c1 e0 03          	shl    $0x3,%rax
  8004219844:	48 89 c2             	mov    %rax,%rdx
  8004219847:	48 c1 e2 04          	shl    $0x4,%rdx
  800421984b:	48 01 c2             	add    %rax,%rdx
  800421984e:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004219855:	00 00 00 
  8004219858:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800421985c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219860:	48 89 c7             	mov    %rax,%rdi
  8004219863:	48 b8 25 90 21 04 80 	movabs $0x8004219025,%rax
  800421986a:	00 00 00 
  800421986d:	ff d0                	callq  *%rax
  800421986f:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)

    return 0;
  8004219876:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421987b:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
  8004219882:	5b                   	pop    %rbx
  8004219883:	41 5c                	pop    %r12
  8004219885:	5d                   	pop    %rbp
  8004219886:	c3                   	retq   

0000008004219887 <vmcs_host_init>:

void vmcs_host_init() {
  8004219887:	55                   	push   %rbp
  8004219888:	48 89 e5             	mov    %rsp,%rbp
  800421988b:	53                   	push   %rbx
  800421988c:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp

    static __inline uint64_t
rcr0(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr0,%0" : "=r" (val));
  8004219893:	0f 20 c3             	mov    %cr0,%rbx
  8004219896:	48 89 5d d8          	mov    %rbx,-0x28(%rbp)
    return val;
  800421989a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    vmcs_write64( VMCS_HOST_CR0, rcr0() ); 
  800421989e:	c7 45 d4 00 6c 00 00 	movl   $0x6c00,-0x2c(%rbp)
  80042198a5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  80042198a9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042198ad:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80042198b0:	48 89 d6             	mov    %rdx,%rsi
  80042198b3:	89 c7                	mov    %eax,%edi
  80042198b5:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  80042198bc:	00 00 00 
  80042198bf:	ff d0                	callq  *%rax

    static __inline uint64_t
rcr3(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr3,%0" : "=r" (val));
  80042198c1:	0f 20 db             	mov    %cr3,%rbx
  80042198c4:	48 89 5d c0          	mov    %rbx,-0x40(%rbp)
    return val;
  80042198c8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    vmcs_write64( VMCS_HOST_CR3, rcr3() ); 
  80042198cc:	c7 45 bc 02 6c 00 00 	movl   $0x6c02,-0x44(%rbp)
  80042198d3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042198d7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042198db:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042198de:	48 89 d6             	mov    %rdx,%rsi
  80042198e1:	89 c7                	mov    %eax,%edi
  80042198e3:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  80042198ea:	00 00 00 
  80042198ed:	ff d0                	callq  *%rax

    static __inline uint64_t
rcr4(void)
{
    uint64_t cr4;
    __asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  80042198ef:	0f 20 e3             	mov    %cr4,%rbx
  80042198f2:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
    return cr4;
  80042198f6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    vmcs_write64( VMCS_HOST_CR4, rcr4() );
  80042198fa:	c7 45 a4 04 6c 00 00 	movl   $0x6c04,-0x5c(%rbp)
  8004219901:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004219905:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004219909:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421990c:	48 89 d6             	mov    %rdx,%rsi
  800421990f:	89 c7                	mov    %eax,%edi
  8004219911:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219918:	00 00 00 
  800421991b:	ff d0                	callq  *%rax
  800421991d:	c7 45 94 00 0c 00 00 	movl   $0xc00,-0x6c(%rbp)
  8004219924:	66 c7 45 92 10 00    	movw   $0x10,-0x6e(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421992a:	0f b7 55 92          	movzwl -0x6e(%rbp),%edx
  800421992e:	8b 45 94             	mov    -0x6c(%rbp),%eax
  8004219931:	48 89 d6             	mov    %rdx,%rsi
  8004219934:	89 c7                	mov    %eax,%edi
  8004219936:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421993d:	00 00 00 
  8004219940:	ff d0                	callq  *%rax
  8004219942:	c7 45 8c 04 0c 00 00 	movl   $0xc04,-0x74(%rbp)
  8004219949:	66 c7 45 8a 10 00    	movw   $0x10,-0x76(%rbp)
  800421994f:	0f b7 55 8a          	movzwl -0x76(%rbp),%edx
  8004219953:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8004219956:	48 89 d6             	mov    %rdx,%rsi
  8004219959:	89 c7                	mov    %eax,%edi
  800421995b:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219962:	00 00 00 
  8004219965:	ff d0                	callq  *%rax
  8004219967:	c7 45 84 06 0c 00 00 	movl   $0xc06,-0x7c(%rbp)
  800421996e:	66 c7 45 82 10 00    	movw   $0x10,-0x7e(%rbp)
  8004219974:	0f b7 55 82          	movzwl -0x7e(%rbp),%edx
  8004219978:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421997b:	48 89 d6             	mov    %rdx,%rsi
  800421997e:	89 c7                	mov    %eax,%edi
  8004219980:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219987:	00 00 00 
  800421998a:	ff d0                	callq  *%rax
  800421998c:	c7 85 7c ff ff ff 08 	movl   $0xc08,-0x84(%rbp)
  8004219993:	0c 00 00 
  8004219996:	66 c7 85 7a ff ff ff 	movw   $0x10,-0x86(%rbp)
  800421999d:	10 00 
  800421999f:	0f b7 95 7a ff ff ff 	movzwl -0x86(%rbp),%edx
  80042199a6:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  80042199ac:	48 89 d6             	mov    %rdx,%rsi
  80042199af:	89 c7                	mov    %eax,%edi
  80042199b1:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  80042199b8:	00 00 00 
  80042199bb:	ff d0                	callq  *%rax
  80042199bd:	c7 85 74 ff ff ff 0a 	movl   $0xc0a,-0x8c(%rbp)
  80042199c4:	0c 00 00 
  80042199c7:	66 c7 85 72 ff ff ff 	movw   $0x10,-0x8e(%rbp)
  80042199ce:	10 00 
  80042199d0:	0f b7 95 72 ff ff ff 	movzwl -0x8e(%rbp),%edx
  80042199d7:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  80042199dd:	48 89 d6             	mov    %rdx,%rsi
  80042199e0:	89 c7                	mov    %eax,%edi
  80042199e2:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  80042199e9:	00 00 00 
  80042199ec:	ff d0                	callq  *%rax
  80042199ee:	c7 85 6c ff ff ff 02 	movl   $0xc02,-0x94(%rbp)
  80042199f5:	0c 00 00 
  80042199f8:	66 c7 85 6a ff ff ff 	movw   $0x8,-0x96(%rbp)
  80042199ff:	08 00 
  8004219a01:	0f b7 95 6a ff ff ff 	movzwl -0x96(%rbp),%edx
  8004219a08:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  8004219a0e:	48 89 d6             	mov    %rdx,%rsi
  8004219a11:	89 c7                	mov    %eax,%edi
  8004219a13:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219a1a:	00 00 00 
  8004219a1d:	ff d0                	callq  *%rax
    vmcs_write16( VMCS_16BIT_HOST_DS_SELECTOR, GD_KD );
    vmcs_write16( VMCS_16BIT_HOST_FS_SELECTOR, GD_KD );
    vmcs_write16( VMCS_16BIT_HOST_GS_SELECTOR, GD_KD );
    vmcs_write16( VMCS_16BIT_HOST_CS_SELECTOR, GD_KT );

	int gd_tss = (GD_TSS0 >> 3) + thiscpu->cpu_id*2;
  8004219a1f:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004219a26:	00 00 00 
  8004219a29:	ff d0                	callq  *%rax
  8004219a2b:	48 98                	cltq   
  8004219a2d:	48 c1 e0 03          	shl    $0x3,%rax
  8004219a31:	48 89 c2             	mov    %rax,%rdx
  8004219a34:	48 c1 e2 04          	shl    $0x4,%rdx
  8004219a38:	48 01 c2             	add    %rax,%rdx
  8004219a3b:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004219a42:	00 00 00 
  8004219a45:	48 01 d0             	add    %rdx,%rax
  8004219a48:	0f b6 00             	movzbl (%rax),%eax
  8004219a4b:	0f b6 c0             	movzbl %al,%eax
  8004219a4e:	01 c0                	add    %eax,%eax
  8004219a50:	83 c0 05             	add    $0x5,%eax
  8004219a53:	89 45 ec             	mov    %eax,-0x14(%rbp)
    vmcs_write16( VMCS_16BIT_HOST_TR_SELECTOR, gd_tss << 3 );
  8004219a56:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219a59:	c1 e0 03             	shl    $0x3,%eax
  8004219a5c:	0f b7 c0             	movzwl %ax,%eax
  8004219a5f:	c7 85 64 ff ff ff 0c 	movl   $0xc0c,-0x9c(%rbp)
  8004219a66:	0c 00 00 
  8004219a69:	66 89 85 62 ff ff ff 	mov    %ax,-0x9e(%rbp)
  8004219a70:	0f b7 95 62 ff ff ff 	movzwl -0x9e(%rbp),%edx
  8004219a77:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  8004219a7d:	48 89 d6             	mov    %rdx,%rsi
  8004219a80:	89 c7                	mov    %eax,%edi
  8004219a82:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219a89:	00 00 00 
  8004219a8c:	ff d0                	callq  *%rax
    
    uint16_t xdtr_limit;
    uint64_t xdtr_base;
    read_idtr( &xdtr_base, &xdtr_limit );
  8004219a8e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  8004219a95:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004219a9c:	48 8d 85 ee fe ff ff 	lea    -0x112(%rbp),%rax
  8004219aa3:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
    static __inline void
read_idtr (uint64_t *idtbase, uint16_t *idtlimit)
{
    struct Pseudodesc idtr;

    asm volatile ("sidt %0"
  8004219aaa:	0f 01 8d c0 fe ff ff 	sidt   -0x140(%rbp)
            : "=m" (idtr));
    *idtbase = idtr.pd_base;
  8004219ab1:	48 8b 95 c2 fe ff ff 	mov    -0x13e(%rbp),%rdx
  8004219ab8:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004219abf:	48 89 10             	mov    %rdx,(%rax)
    *idtlimit = idtr.pd_lim;
  8004219ac2:	0f b7 95 c0 fe ff ff 	movzwl -0x140(%rbp),%edx
  8004219ac9:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004219ad0:	66 89 10             	mov    %dx,(%rax)
    vmcs_write64( VMCS_HOST_IDTR_BASE, xdtr_base );
  8004219ad3:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004219ada:	c7 85 4c ff ff ff 0e 	movl   $0x6c0e,-0xb4(%rbp)
  8004219ae1:	6c 00 00 
  8004219ae4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  8004219aeb:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  8004219af2:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  8004219af8:	48 89 d6             	mov    %rdx,%rsi
  8004219afb:	89 c7                	mov    %eax,%edi
  8004219afd:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219b04:	00 00 00 
  8004219b07:	ff d0                	callq  *%rax

    read_gdtr( &xdtr_base, &xdtr_limit );
  8004219b09:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  8004219b10:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004219b17:	48 8d 85 ee fe ff ff 	lea    -0x112(%rbp),%rax
  8004219b1e:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
    static __inline void
read_gdtr (uint64_t *gdtbase, uint16_t *gdtlimit)
{
    struct Pseudodesc gdtr;

    asm volatile ("sgdt %0"
  8004219b25:	0f 01 85 d0 fe ff ff 	sgdt   -0x130(%rbp)
            : "=m" (gdtr));
    *gdtbase = gdtr.pd_base;
  8004219b2c:	48 8b 95 d2 fe ff ff 	mov    -0x12e(%rbp),%rdx
  8004219b33:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004219b3a:	48 89 10             	mov    %rdx,(%rax)
    *gdtlimit = gdtr.pd_lim;
  8004219b3d:	0f b7 95 d0 fe ff ff 	movzwl -0x130(%rbp),%edx
  8004219b44:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004219b4b:	66 89 10             	mov    %dx,(%rax)
    vmcs_write64( VMCS_HOST_GDTR_BASE, xdtr_base );
  8004219b4e:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004219b55:	c7 85 2c ff ff ff 0c 	movl   $0x6c0c,-0xd4(%rbp)
  8004219b5c:	6c 00 00 
  8004219b5f:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004219b66:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  8004219b6d:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  8004219b73:	48 89 d6             	mov    %rdx,%rsi
  8004219b76:	89 c7                	mov    %eax,%edi
  8004219b78:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219b7f:	00 00 00 
  8004219b82:	ff d0                	callq  *%rax
  8004219b84:	c7 85 1c ff ff ff 06 	movl   $0x6c06,-0xe4(%rbp)
  8004219b8b:	6c 00 00 
  8004219b8e:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  8004219b95:	00 00 00 00 
  8004219b99:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004219ba0:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  8004219ba6:	48 89 d6             	mov    %rdx,%rsi
  8004219ba9:	89 c7                	mov    %eax,%edi
  8004219bab:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219bb2:	00 00 00 
  8004219bb5:	ff d0                	callq  *%rax
  8004219bb7:	c7 85 0c ff ff ff 08 	movl   $0x6c08,-0xf4(%rbp)
  8004219bbe:	6c 00 00 
  8004219bc1:	48 c7 85 00 ff ff ff 	movq   $0x0,-0x100(%rbp)
  8004219bc8:	00 00 00 00 
  8004219bcc:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
  8004219bd3:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004219bd9:	48 89 d6             	mov    %rdx,%rsi
  8004219bdc:	89 c7                	mov    %eax,%edi
  8004219bde:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219be5:	00 00 00 
  8004219be8:	ff d0                	callq  *%rax

    vmcs_write64( VMCS_HOST_FS_BASE, 0x0 );
    vmcs_write64( VMCS_HOST_GS_BASE, 0x0 );
    vmcs_write64( VMCS_HOST_TR_BASE, (uint64_t) &thiscpu->cpu_ts );
  8004219bea:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  8004219bf1:	00 00 00 
  8004219bf4:	ff d0                	callq  *%rax
  8004219bf6:	48 98                	cltq   
  8004219bf8:	48 c1 e0 03          	shl    $0x3,%rax
  8004219bfc:	48 89 c2             	mov    %rax,%rdx
  8004219bff:	48 c1 e2 04          	shl    $0x4,%rdx
  8004219c03:	48 01 c2             	add    %rax,%rdx
  8004219c06:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  8004219c0d:	00 00 00 
  8004219c10:	48 01 d0             	add    %rdx,%rax
  8004219c13:	48 83 c0 10          	add    $0x10,%rax
  8004219c17:	c7 85 fc fe ff ff 0a 	movl   $0x6c0a,-0x104(%rbp)
  8004219c1e:	6c 00 00 
  8004219c21:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
  8004219c28:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004219c2f:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  8004219c35:	48 89 d6             	mov    %rdx,%rsi
  8004219c38:	89 c7                	mov    %eax,%edi
  8004219c3a:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219c41:	00 00 00 
  8004219c44:	ff d0                	callq  *%rax

    uint64_t tmpl;
	asm("movabs $.Lvmx_return, %0" : "=r"(tmpl));
  8004219c46:	48 bb cd b1 21 04 80 	movabs $0x800421b1cd,%rbx
  8004219c4d:	00 00 00 
  8004219c50:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
	vmcs_writel(VMCS_HOST_RIP, tmpl);
  8004219c54:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219c58:	48 89 c6             	mov    %rax,%rsi
  8004219c5b:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  8004219c60:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219c67:	00 00 00 
  8004219c6a:	ff d0                	callq  *%rax
}
  8004219c6c:	48 81 c4 38 01 00 00 	add    $0x138,%rsp
  8004219c73:	5b                   	pop    %rbx
  8004219c74:	5d                   	pop    %rbp
  8004219c75:	c3                   	retq   

0000008004219c76 <vmcs_guest_init>:

void vmcs_guest_init() {
  8004219c76:	55                   	push   %rbp
  8004219c77:	48 89 e5             	mov    %rsp,%rbp
  8004219c7a:	48 81 ec f0 01 00 00 	sub    $0x1f0,%rsp
  8004219c81:	c7 45 fc 02 08 00 00 	movl   $0x802,-0x4(%rbp)
  8004219c88:	66 c7 45 fa 00 00    	movw   $0x0,-0x6(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  8004219c8e:	0f b7 55 fa          	movzwl -0x6(%rbp),%edx
  8004219c92:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219c95:	48 89 d6             	mov    %rdx,%rsi
  8004219c98:	89 c7                	mov    %eax,%edi
  8004219c9a:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219ca1:	00 00 00 
  8004219ca4:	ff d0                	callq  *%rax
  8004219ca6:	c7 45 f4 00 08 00 00 	movl   $0x800,-0xc(%rbp)
  8004219cad:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)
  8004219cb3:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
  8004219cb7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004219cba:	48 89 d6             	mov    %rdx,%rsi
  8004219cbd:	89 c7                	mov    %eax,%edi
  8004219cbf:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219cc6:	00 00 00 
  8004219cc9:	ff d0                	callq  *%rax
  8004219ccb:	c7 45 ec 04 08 00 00 	movl   $0x804,-0x14(%rbp)
  8004219cd2:	66 c7 45 ea 00 00    	movw   $0x0,-0x16(%rbp)
  8004219cd8:	0f b7 55 ea          	movzwl -0x16(%rbp),%edx
  8004219cdc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219cdf:	48 89 d6             	mov    %rdx,%rsi
  8004219ce2:	89 c7                	mov    %eax,%edi
  8004219ce4:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219ceb:	00 00 00 
  8004219cee:	ff d0                	callq  *%rax
  8004219cf0:	c7 45 e4 06 08 00 00 	movl   $0x806,-0x1c(%rbp)
  8004219cf7:	66 c7 45 e2 00 00    	movw   $0x0,-0x1e(%rbp)
  8004219cfd:	0f b7 55 e2          	movzwl -0x1e(%rbp),%edx
  8004219d01:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004219d04:	48 89 d6             	mov    %rdx,%rsi
  8004219d07:	89 c7                	mov    %eax,%edi
  8004219d09:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219d10:	00 00 00 
  8004219d13:	ff d0                	callq  *%rax
  8004219d15:	c7 45 dc 08 08 00 00 	movl   $0x808,-0x24(%rbp)
  8004219d1c:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%rbp)
  8004219d22:	0f b7 55 da          	movzwl -0x26(%rbp),%edx
  8004219d26:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004219d29:	48 89 d6             	mov    %rdx,%rsi
  8004219d2c:	89 c7                	mov    %eax,%edi
  8004219d2e:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219d35:	00 00 00 
  8004219d38:	ff d0                	callq  *%rax
  8004219d3a:	c7 45 d4 0a 08 00 00 	movl   $0x80a,-0x2c(%rbp)
  8004219d41:	66 c7 45 d2 00 00    	movw   $0x0,-0x2e(%rbp)
  8004219d47:	0f b7 55 d2          	movzwl -0x2e(%rbp),%edx
  8004219d4b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004219d4e:	48 89 d6             	mov    %rdx,%rsi
  8004219d51:	89 c7                	mov    %eax,%edi
  8004219d53:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219d5a:	00 00 00 
  8004219d5d:	ff d0                	callq  *%rax
  8004219d5f:	c7 45 cc 0e 08 00 00 	movl   $0x80e,-0x34(%rbp)
  8004219d66:	66 c7 45 ca 00 00    	movw   $0x0,-0x36(%rbp)
  8004219d6c:	0f b7 55 ca          	movzwl -0x36(%rbp),%edx
  8004219d70:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004219d73:	48 89 d6             	mov    %rdx,%rsi
  8004219d76:	89 c7                	mov    %eax,%edi
  8004219d78:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219d7f:	00 00 00 
  8004219d82:	ff d0                	callq  *%rax
  8004219d84:	c7 45 c4 0c 08 00 00 	movl   $0x80c,-0x3c(%rbp)
  8004219d8b:	66 c7 45 c2 00 00    	movw   $0x0,-0x3e(%rbp)
  8004219d91:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  8004219d95:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004219d98:	48 89 d6             	mov    %rdx,%rsi
  8004219d9b:	89 c7                	mov    %eax,%edi
  8004219d9d:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219da4:	00 00 00 
  8004219da7:	ff d0                	callq  *%rax
  8004219da9:	c7 45 bc 08 68 00 00 	movl   $0x6808,-0x44(%rbp)
  8004219db0:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  8004219db7:	00 
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  8004219db8:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004219dbc:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004219dbf:	48 89 d6             	mov    %rdx,%rsi
  8004219dc2:	89 c7                	mov    %eax,%edi
  8004219dc4:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219dcb:	00 00 00 
  8004219dce:	ff d0                	callq  *%rax
  8004219dd0:	c7 45 ac 06 68 00 00 	movl   $0x6806,-0x54(%rbp)
  8004219dd7:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004219dde:	00 
  8004219ddf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004219de3:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8004219de6:	48 89 d6             	mov    %rdx,%rsi
  8004219de9:	89 c7                	mov    %eax,%edi
  8004219deb:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219df2:	00 00 00 
  8004219df5:	ff d0                	callq  *%rax
  8004219df7:	c7 45 9c 0a 68 00 00 	movl   $0x680a,-0x64(%rbp)
  8004219dfe:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004219e05:	00 
  8004219e06:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004219e0a:	8b 45 9c             	mov    -0x64(%rbp),%eax
  8004219e0d:	48 89 d6             	mov    %rdx,%rsi
  8004219e10:	89 c7                	mov    %eax,%edi
  8004219e12:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219e19:	00 00 00 
  8004219e1c:	ff d0                	callq  *%rax
  8004219e1e:	c7 45 8c 0c 68 00 00 	movl   $0x680c,-0x74(%rbp)
  8004219e25:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
  8004219e2c:	00 
  8004219e2d:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004219e31:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8004219e34:	48 89 d6             	mov    %rdx,%rsi
  8004219e37:	89 c7                	mov    %eax,%edi
  8004219e39:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219e40:	00 00 00 
  8004219e43:	ff d0                	callq  *%rax
  8004219e45:	c7 85 7c ff ff ff 0e 	movl   $0x680e,-0x84(%rbp)
  8004219e4c:	68 00 00 
  8004219e4f:	48 c7 85 70 ff ff ff 	movq   $0x0,-0x90(%rbp)
  8004219e56:	00 00 00 00 
  8004219e5a:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004219e61:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  8004219e67:	48 89 d6             	mov    %rdx,%rsi
  8004219e6a:	89 c7                	mov    %eax,%edi
  8004219e6c:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219e73:	00 00 00 
  8004219e76:	ff d0                	callq  *%rax
  8004219e78:	c7 85 6c ff ff ff 10 	movl   $0x6810,-0x94(%rbp)
  8004219e7f:	68 00 00 
  8004219e82:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  8004219e89:	00 00 00 00 
  8004219e8d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004219e94:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  8004219e9a:	48 89 d6             	mov    %rdx,%rsi
  8004219e9d:	89 c7                	mov    %eax,%edi
  8004219e9f:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219ea6:	00 00 00 
  8004219ea9:	ff d0                	callq  *%rax
  8004219eab:	c7 85 5c ff ff ff 12 	movl   $0x6812,-0xa4(%rbp)
  8004219eb2:	68 00 00 
  8004219eb5:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  8004219ebc:	00 00 00 00 
  8004219ec0:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004219ec7:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  8004219ecd:	48 89 d6             	mov    %rdx,%rsi
  8004219ed0:	89 c7                	mov    %eax,%edi
  8004219ed2:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219ed9:	00 00 00 
  8004219edc:	ff d0                	callq  *%rax
  8004219ede:	c7 85 4c ff ff ff 16 	movl   $0x6816,-0xb4(%rbp)
  8004219ee5:	68 00 00 
  8004219ee8:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  8004219eef:	00 00 00 00 
  8004219ef3:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  8004219efa:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  8004219f00:	48 89 d6             	mov    %rdx,%rsi
  8004219f03:	89 c7                	mov    %eax,%edi
  8004219f05:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219f0c:	00 00 00 
  8004219f0f:	ff d0                	callq  *%rax
  8004219f11:	c7 85 3c ff ff ff 18 	movl   $0x6818,-0xc4(%rbp)
  8004219f18:	68 00 00 
  8004219f1b:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
  8004219f22:	00 00 00 00 
  8004219f26:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  8004219f2d:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  8004219f33:	48 89 d6             	mov    %rdx,%rsi
  8004219f36:	89 c7                	mov    %eax,%edi
  8004219f38:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219f3f:	00 00 00 
  8004219f42:	ff d0                	callq  *%rax
  8004219f44:	c7 85 2c ff ff ff 14 	movl   $0x6814,-0xd4(%rbp)
  8004219f4b:	68 00 00 
  8004219f4e:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  8004219f55:	00 00 00 00 
  8004219f59:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  8004219f60:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  8004219f66:	48 89 d6             	mov    %rdx,%rsi
  8004219f69:	89 c7                	mov    %eax,%edi
  8004219f6b:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219f72:	00 00 00 
  8004219f75:	ff d0                	callq  *%rax
  8004219f77:	c7 85 1c ff ff ff 02 	movl   $0x4802,-0xe4(%rbp)
  8004219f7e:	48 00 00 
  8004219f81:	c7 85 18 ff ff ff ff 	movl   $0xffff,-0xe8(%rbp)
  8004219f88:	ff 00 00 
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  8004219f8b:	8b 95 18 ff ff ff    	mov    -0xe8(%rbp),%edx
  8004219f91:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  8004219f97:	48 89 d6             	mov    %rdx,%rsi
  8004219f9a:	89 c7                	mov    %eax,%edi
  8004219f9c:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219fa3:	00 00 00 
  8004219fa6:	ff d0                	callq  *%rax
  8004219fa8:	c7 85 14 ff ff ff 00 	movl   $0x4800,-0xec(%rbp)
  8004219faf:	48 00 00 
  8004219fb2:	c7 85 10 ff ff ff ff 	movl   $0xffff,-0xf0(%rbp)
  8004219fb9:	ff 00 00 
  8004219fbc:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
  8004219fc2:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  8004219fc8:	48 89 d6             	mov    %rdx,%rsi
  8004219fcb:	89 c7                	mov    %eax,%edi
  8004219fcd:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  8004219fd4:	00 00 00 
  8004219fd7:	ff d0                	callq  *%rax
  8004219fd9:	c7 85 0c ff ff ff 04 	movl   $0x4804,-0xf4(%rbp)
  8004219fe0:	48 00 00 
  8004219fe3:	c7 85 08 ff ff ff ff 	movl   $0xffff,-0xf8(%rbp)
  8004219fea:	ff 00 00 
  8004219fed:	8b 95 08 ff ff ff    	mov    -0xf8(%rbp),%edx
  8004219ff3:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004219ff9:	48 89 d6             	mov    %rdx,%rsi
  8004219ffc:	89 c7                	mov    %eax,%edi
  8004219ffe:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a005:	00 00 00 
  800421a008:	ff d0                	callq  *%rax
  800421a00a:	c7 85 04 ff ff ff 06 	movl   $0x4806,-0xfc(%rbp)
  800421a011:	48 00 00 
  800421a014:	c7 85 00 ff ff ff ff 	movl   $0xffff,-0x100(%rbp)
  800421a01b:	ff 00 00 
  800421a01e:	8b 95 00 ff ff ff    	mov    -0x100(%rbp),%edx
  800421a024:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  800421a02a:	48 89 d6             	mov    %rdx,%rsi
  800421a02d:	89 c7                	mov    %eax,%edi
  800421a02f:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a036:	00 00 00 
  800421a039:	ff d0                	callq  *%rax
  800421a03b:	c7 85 fc fe ff ff 08 	movl   $0x4808,-0x104(%rbp)
  800421a042:	48 00 00 
  800421a045:	c7 85 f8 fe ff ff ff 	movl   $0xffff,-0x108(%rbp)
  800421a04c:	ff 00 00 
  800421a04f:	8b 95 f8 fe ff ff    	mov    -0x108(%rbp),%edx
  800421a055:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  800421a05b:	48 89 d6             	mov    %rdx,%rsi
  800421a05e:	89 c7                	mov    %eax,%edi
  800421a060:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a067:	00 00 00 
  800421a06a:	ff d0                	callq  *%rax
  800421a06c:	c7 85 f4 fe ff ff 0a 	movl   $0x480a,-0x10c(%rbp)
  800421a073:	48 00 00 
  800421a076:	c7 85 f0 fe ff ff ff 	movl   $0xffff,-0x110(%rbp)
  800421a07d:	ff 00 00 
  800421a080:	8b 95 f0 fe ff ff    	mov    -0x110(%rbp),%edx
  800421a086:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
  800421a08c:	48 89 d6             	mov    %rdx,%rsi
  800421a08f:	89 c7                	mov    %eax,%edi
  800421a091:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a098:	00 00 00 
  800421a09b:	ff d0                	callq  *%rax
  800421a09d:	c7 85 ec fe ff ff 0c 	movl   $0x480c,-0x114(%rbp)
  800421a0a4:	48 00 00 
  800421a0a7:	c7 85 e8 fe ff ff ff 	movl   $0xffff,-0x118(%rbp)
  800421a0ae:	ff 00 00 
  800421a0b1:	8b 95 e8 fe ff ff    	mov    -0x118(%rbp),%edx
  800421a0b7:	8b 85 ec fe ff ff    	mov    -0x114(%rbp),%eax
  800421a0bd:	48 89 d6             	mov    %rdx,%rsi
  800421a0c0:	89 c7                	mov    %eax,%edi
  800421a0c2:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a0c9:	00 00 00 
  800421a0cc:	ff d0                	callq  *%rax
  800421a0ce:	c7 85 e4 fe ff ff 0e 	movl   $0x480e,-0x11c(%rbp)
  800421a0d5:	48 00 00 
  800421a0d8:	c7 85 e0 fe ff ff ff 	movl   $0xfffff,-0x120(%rbp)
  800421a0df:	ff 0f 00 
  800421a0e2:	8b 95 e0 fe ff ff    	mov    -0x120(%rbp),%edx
  800421a0e8:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
  800421a0ee:	48 89 d6             	mov    %rdx,%rsi
  800421a0f1:	89 c7                	mov    %eax,%edi
  800421a0f3:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a0fa:	00 00 00 
  800421a0fd:	ff d0                	callq  *%rax
  800421a0ff:	c7 85 dc fe ff ff 10 	movl   $0x4810,-0x124(%rbp)
  800421a106:	48 00 00 
  800421a109:	c7 85 d8 fe ff ff 30 	movl   $0x30,-0x128(%rbp)
  800421a110:	00 00 00 
  800421a113:	8b 95 d8 fe ff ff    	mov    -0x128(%rbp),%edx
  800421a119:	8b 85 dc fe ff ff    	mov    -0x124(%rbp),%eax
  800421a11f:	48 89 d6             	mov    %rdx,%rsi
  800421a122:	89 c7                	mov    %eax,%edi
  800421a124:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a12b:	00 00 00 
  800421a12e:	ff d0                	callq  *%rax
  800421a130:	c7 85 d4 fe ff ff 12 	movl   $0x4812,-0x12c(%rbp)
  800421a137:	48 00 00 
  800421a13a:	c7 85 d0 fe ff ff ff 	movl   $0x3ff,-0x130(%rbp)
  800421a141:	03 00 00 
  800421a144:	8b 95 d0 fe ff ff    	mov    -0x130(%rbp),%edx
  800421a14a:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
  800421a150:	48 89 d6             	mov    %rdx,%rsi
  800421a153:	89 c7                	mov    %eax,%edi
  800421a155:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a15c:	00 00 00 
  800421a15f:	ff d0                	callq  *%rax
  800421a161:	c7 85 cc fe ff ff 16 	movl   $0x4816,-0x134(%rbp)
  800421a168:	48 00 00 
  800421a16b:	c7 85 c8 fe ff ff 93 	movl   $0x93,-0x138(%rbp)
  800421a172:	00 00 00 
  800421a175:	8b 95 c8 fe ff ff    	mov    -0x138(%rbp),%edx
  800421a17b:	8b 85 cc fe ff ff    	mov    -0x134(%rbp),%eax
  800421a181:	48 89 d6             	mov    %rdx,%rsi
  800421a184:	89 c7                	mov    %eax,%edi
  800421a186:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a18d:	00 00 00 
  800421a190:	ff d0                	callq  *%rax
  800421a192:	c7 85 c4 fe ff ff 14 	movl   $0x4814,-0x13c(%rbp)
  800421a199:	48 00 00 
  800421a19c:	c7 85 c0 fe ff ff 93 	movl   $0x93,-0x140(%rbp)
  800421a1a3:	00 00 00 
  800421a1a6:	8b 95 c0 fe ff ff    	mov    -0x140(%rbp),%edx
  800421a1ac:	8b 85 c4 fe ff ff    	mov    -0x13c(%rbp),%eax
  800421a1b2:	48 89 d6             	mov    %rdx,%rsi
  800421a1b5:	89 c7                	mov    %eax,%edi
  800421a1b7:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a1be:	00 00 00 
  800421a1c1:	ff d0                	callq  *%rax
  800421a1c3:	c7 85 bc fe ff ff 18 	movl   $0x4818,-0x144(%rbp)
  800421a1ca:	48 00 00 
  800421a1cd:	c7 85 b8 fe ff ff 93 	movl   $0x93,-0x148(%rbp)
  800421a1d4:	00 00 00 
  800421a1d7:	8b 95 b8 fe ff ff    	mov    -0x148(%rbp),%edx
  800421a1dd:	8b 85 bc fe ff ff    	mov    -0x144(%rbp),%eax
  800421a1e3:	48 89 d6             	mov    %rdx,%rsi
  800421a1e6:	89 c7                	mov    %eax,%edi
  800421a1e8:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a1ef:	00 00 00 
  800421a1f2:	ff d0                	callq  *%rax
  800421a1f4:	c7 85 b4 fe ff ff 1a 	movl   $0x481a,-0x14c(%rbp)
  800421a1fb:	48 00 00 
  800421a1fe:	c7 85 b0 fe ff ff 93 	movl   $0x93,-0x150(%rbp)
  800421a205:	00 00 00 
  800421a208:	8b 95 b0 fe ff ff    	mov    -0x150(%rbp),%edx
  800421a20e:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
  800421a214:	48 89 d6             	mov    %rdx,%rsi
  800421a217:	89 c7                	mov    %eax,%edi
  800421a219:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a220:	00 00 00 
  800421a223:	ff d0                	callq  *%rax
  800421a225:	c7 85 ac fe ff ff 1c 	movl   $0x481c,-0x154(%rbp)
  800421a22c:	48 00 00 
  800421a22f:	c7 85 a8 fe ff ff 93 	movl   $0x93,-0x158(%rbp)
  800421a236:	00 00 00 
  800421a239:	8b 95 a8 fe ff ff    	mov    -0x158(%rbp),%edx
  800421a23f:	8b 85 ac fe ff ff    	mov    -0x154(%rbp),%eax
  800421a245:	48 89 d6             	mov    %rdx,%rsi
  800421a248:	89 c7                	mov    %eax,%edi
  800421a24a:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a251:	00 00 00 
  800421a254:	ff d0                	callq  *%rax
  800421a256:	c7 85 a4 fe ff ff 1e 	movl   $0x481e,-0x15c(%rbp)
  800421a25d:	48 00 00 
  800421a260:	c7 85 a0 fe ff ff 93 	movl   $0x93,-0x160(%rbp)
  800421a267:	00 00 00 
  800421a26a:	8b 95 a0 fe ff ff    	mov    -0x160(%rbp),%edx
  800421a270:	8b 85 a4 fe ff ff    	mov    -0x15c(%rbp),%eax
  800421a276:	48 89 d6             	mov    %rdx,%rsi
  800421a279:	89 c7                	mov    %eax,%edi
  800421a27b:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a282:	00 00 00 
  800421a285:	ff d0                	callq  *%rax
  800421a287:	c7 85 9c fe ff ff 20 	movl   $0x4820,-0x164(%rbp)
  800421a28e:	48 00 00 
  800421a291:	c7 85 98 fe ff ff 82 	movl   $0x82,-0x168(%rbp)
  800421a298:	00 00 00 
  800421a29b:	8b 95 98 fe ff ff    	mov    -0x168(%rbp),%edx
  800421a2a1:	8b 85 9c fe ff ff    	mov    -0x164(%rbp),%eax
  800421a2a7:	48 89 d6             	mov    %rdx,%rsi
  800421a2aa:	89 c7                	mov    %eax,%edi
  800421a2ac:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a2b3:	00 00 00 
  800421a2b6:	ff d0                	callq  *%rax
  800421a2b8:	c7 85 94 fe ff ff 22 	movl   $0x4822,-0x16c(%rbp)
  800421a2bf:	48 00 00 
  800421a2c2:	c7 85 90 fe ff ff 8b 	movl   $0x8b,-0x170(%rbp)
  800421a2c9:	00 00 00 
  800421a2cc:	8b 95 90 fe ff ff    	mov    -0x170(%rbp),%edx
  800421a2d2:	8b 85 94 fe ff ff    	mov    -0x16c(%rbp),%eax
  800421a2d8:	48 89 d6             	mov    %rdx,%rsi
  800421a2db:	89 c7                	mov    %eax,%edi
  800421a2dd:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a2e4:	00 00 00 
  800421a2e7:	ff d0                	callq  *%rax
  800421a2e9:	c7 85 8c fe ff ff 26 	movl   $0x4826,-0x174(%rbp)
  800421a2f0:	48 00 00 
  800421a2f3:	c7 85 88 fe ff ff 00 	movl   $0x0,-0x178(%rbp)
  800421a2fa:	00 00 00 
  800421a2fd:	8b 95 88 fe ff ff    	mov    -0x178(%rbp),%edx
  800421a303:	8b 85 8c fe ff ff    	mov    -0x174(%rbp),%eax
  800421a309:	48 89 d6             	mov    %rdx,%rsi
  800421a30c:	89 c7                	mov    %eax,%edi
  800421a30e:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a315:	00 00 00 
  800421a318:	ff d0                	callq  *%rax
  800421a31a:	c7 85 84 fe ff ff 24 	movl   $0x4824,-0x17c(%rbp)
  800421a321:	48 00 00 
  800421a324:	c7 85 80 fe ff ff 00 	movl   $0x0,-0x180(%rbp)
  800421a32b:	00 00 00 
  800421a32e:	8b 95 80 fe ff ff    	mov    -0x180(%rbp),%edx
  800421a334:	8b 85 84 fe ff ff    	mov    -0x17c(%rbp),%eax
  800421a33a:	48 89 d6             	mov    %rdx,%rsi
  800421a33d:	89 c7                	mov    %eax,%edi
  800421a33f:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a346:	00 00 00 
  800421a349:	ff d0                	callq  *%rax
  800421a34b:	c7 85 7c fe ff ff 02 	movl   $0x6802,-0x184(%rbp)
  800421a352:	68 00 00 
  800421a355:	48 c7 85 70 fe ff ff 	movq   $0x0,-0x190(%rbp)
  800421a35c:	00 00 00 00 
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a360:	48 8b 95 70 fe ff ff 	mov    -0x190(%rbp),%rdx
  800421a367:	8b 85 7c fe ff ff    	mov    -0x184(%rbp),%eax
  800421a36d:	48 89 d6             	mov    %rdx,%rsi
  800421a370:	89 c7                	mov    %eax,%edi
  800421a372:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a379:	00 00 00 
  800421a37c:	ff d0                	callq  *%rax
  800421a37e:	c7 85 6c fe ff ff 00 	movl   $0x6800,-0x194(%rbp)
  800421a385:	68 00 00 
  800421a388:	48 c7 85 60 fe ff ff 	movq   $0x20,-0x1a0(%rbp)
  800421a38f:	20 00 00 00 
  800421a393:	48 8b 95 60 fe ff ff 	mov    -0x1a0(%rbp),%rdx
  800421a39a:	8b 85 6c fe ff ff    	mov    -0x194(%rbp),%eax
  800421a3a0:	48 89 d6             	mov    %rdx,%rsi
  800421a3a3:	89 c7                	mov    %eax,%edi
  800421a3a5:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a3ac:	00 00 00 
  800421a3af:	ff d0                	callq  *%rax
  800421a3b1:	c7 85 5c fe ff ff 04 	movl   $0x6804,-0x1a4(%rbp)
  800421a3b8:	68 00 00 
  800421a3bb:	48 c7 85 50 fe ff ff 	movq   $0x2000,-0x1b0(%rbp)
  800421a3c2:	00 20 00 00 
  800421a3c6:	48 8b 95 50 fe ff ff 	mov    -0x1b0(%rbp),%rdx
  800421a3cd:	8b 85 5c fe ff ff    	mov    -0x1a4(%rbp),%eax
  800421a3d3:	48 89 d6             	mov    %rdx,%rsi
  800421a3d6:	89 c7                	mov    %eax,%edi
  800421a3d8:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a3df:	00 00 00 
  800421a3e2:	ff d0                	callq  *%rax
  800421a3e4:	c7 85 4c fe ff ff 00 	movl   $0x2800,-0x1b4(%rbp)
  800421a3eb:	28 00 00 
  800421a3ee:	c7 85 40 fe ff ff ff 	movl   $0xffffffff,-0x1c0(%rbp)
  800421a3f5:	ff ff ff 
  800421a3f8:	c7 85 44 fe ff ff 00 	movl   $0x0,-0x1bc(%rbp)
  800421a3ff:	00 00 00 
  800421a402:	48 8b 95 40 fe ff ff 	mov    -0x1c0(%rbp),%rdx
  800421a409:	8b 85 4c fe ff ff    	mov    -0x1b4(%rbp),%eax
  800421a40f:	48 89 d6             	mov    %rdx,%rsi
  800421a412:	89 c7                	mov    %eax,%edi
  800421a414:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a41b:	00 00 00 
  800421a41e:	ff d0                	callq  *%rax
  800421a420:	c7 85 3c fe ff ff 01 	movl   $0x2801,-0x1c4(%rbp)
  800421a427:	28 00 00 
  800421a42a:	c7 85 30 fe ff ff ff 	movl   $0xffffffff,-0x1d0(%rbp)
  800421a431:	ff ff ff 
  800421a434:	c7 85 34 fe ff ff 00 	movl   $0x0,-0x1cc(%rbp)
  800421a43b:	00 00 00 
  800421a43e:	48 8b 95 30 fe ff ff 	mov    -0x1d0(%rbp),%rdx
  800421a445:	8b 85 3c fe ff ff    	mov    -0x1c4(%rbp),%eax
  800421a44b:	48 89 d6             	mov    %rdx,%rsi
  800421a44e:	89 c7                	mov    %eax,%edi
  800421a450:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a457:	00 00 00 
  800421a45a:	ff d0                	callq  *%rax
  800421a45c:	c7 85 2c fe ff ff 1a 	movl   $0x681a,-0x1d4(%rbp)
  800421a463:	68 00 00 
  800421a466:	48 c7 85 20 fe ff ff 	movq   $0x0,-0x1e0(%rbp)
  800421a46d:	00 00 00 00 
  800421a471:	48 8b 95 20 fe ff ff 	mov    -0x1e0(%rbp),%rdx
  800421a478:	8b 85 2c fe ff ff    	mov    -0x1d4(%rbp),%eax
  800421a47e:	48 89 d6             	mov    %rdx,%rsi
  800421a481:	89 c7                	mov    %eax,%edi
  800421a483:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a48a:	00 00 00 
  800421a48d:	ff d0                	callq  *%rax
  800421a48f:	c7 85 1c fe ff ff 20 	movl   $0x6820,-0x1e4(%rbp)
  800421a496:	68 00 00 
  800421a499:	48 c7 85 10 fe ff ff 	movq   $0x2,-0x1f0(%rbp)
  800421a4a0:	02 00 00 00 
  800421a4a4:	48 8b 95 10 fe ff ff 	mov    -0x1f0(%rbp),%rdx
  800421a4ab:	8b 85 1c fe ff ff    	mov    -0x1e4(%rbp),%eax
  800421a4b1:	48 89 d6             	mov    %rdx,%rsi
  800421a4b4:	89 c7                	mov    %eax,%edi
  800421a4b6:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a4bd:	00 00 00 
  800421a4c0:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER, 0xffffffff );
    vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER_HI, 0xffffffff ); 
    vmcs_write64( VMCS_GUEST_DR7, 0x0 );
    vmcs_write64( VMCS_GUEST_RFLAGS, 0x2 );

}
  800421a4c2:	c9                   	leaveq 
  800421a4c3:	c3                   	retq   

000000800421a4c4 <vmx_read_capability_msr>:

void vmx_read_capability_msr( uint32_t msr, uint32_t* hi, uint32_t* lo ) {
  800421a4c4:	55                   	push   %rbp
  800421a4c5:	48 89 e5             	mov    %rsp,%rbp
  800421a4c8:	41 54                	push   %r12
  800421a4ca:	53                   	push   %rbx
  800421a4cb:	48 83 ec 38          	sub    $0x38,%rsp
  800421a4cf:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800421a4d2:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421a4d6:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421a4da:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421a4dd:	89 45 e4             	mov    %eax,-0x1c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  800421a4e0:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421a4e3:	89 4d c8             	mov    %ecx,-0x38(%rbp)
  800421a4e6:	8b 4d c8             	mov    -0x38(%rbp),%ecx
  800421a4e9:	0f 32                	rdmsr  
  800421a4eb:	89 c3                	mov    %eax,%ebx
  800421a4ed:	41 89 d4             	mov    %edx,%r12d
  800421a4f0:	44 89 65 e0          	mov    %r12d,-0x20(%rbp)
  800421a4f4:	89 5d dc             	mov    %ebx,-0x24(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  800421a4f7:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421a4fe:	00 
    ret = edx;
  800421a4ff:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421a502:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    ret = ret << 32;
  800421a506:	48 c1 65 d0 20       	shlq   $0x20,-0x30(%rbp)
    ret |= eax;
  800421a50b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a50e:	48 09 45 d0          	or     %rax,-0x30(%rbp)

    return ret;
  800421a512:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    uint64_t msr_val = read_msr( msr );
  800421a516:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    *hi = (uint32_t)( msr_val >> 32 );
  800421a51a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a51e:	48 c1 e8 20          	shr    $0x20,%rax
  800421a522:	89 c2                	mov    %eax,%edx
  800421a524:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421a528:	89 10                	mov    %edx,(%rax)
    *lo = (uint32_t)( msr_val );
  800421a52a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a52e:	89 c2                	mov    %eax,%edx
  800421a530:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421a534:	89 10                	mov    %edx,(%rax)
}
  800421a536:	48 83 c4 38          	add    $0x38,%rsp
  800421a53a:	5b                   	pop    %rbx
  800421a53b:	41 5c                	pop    %r12
  800421a53d:	5d                   	pop    %rbp
  800421a53e:	c3                   	retq   

000000800421a53f <vmcs_ctls_init>:

static void 
vmcs_ctls_init( struct Env* e ) {
  800421a53f:	55                   	push   %rbp
  800421a540:	48 89 e5             	mov    %rsp,%rbp
  800421a543:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800421a54a:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
    // Set pin based vm exec controls.
    uint32_t pinbased_ctls_or, pinbased_ctls_and;
    vmx_read_capability_msr( IA32_VMX_PINBASED_CTLS, 
  800421a551:	48 8d 95 24 ff ff ff 	lea    -0xdc(%rbp),%rdx
  800421a558:	48 8d 85 20 ff ff ff 	lea    -0xe0(%rbp),%rax
  800421a55f:	48 89 c6             	mov    %rax,%rsi
  800421a562:	bf 81 04 00 00       	mov    $0x481,%edi
  800421a567:	48 b8 c4 a4 21 04 80 	movabs $0x800421a4c4,%rax
  800421a56e:	00 00 00 
  800421a571:	ff d0                	callq  *%rax
            &pinbased_ctls_and, &pinbased_ctls_or );

    vmcs_write32( VMCS_32BIT_CONTROL_PIN_BASED_EXEC_CONTROLS, 
  800421a573:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800421a579:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421a57f:	21 d0                	and    %edx,%eax
  800421a581:	c7 45 cc 00 40 00 00 	movl   $0x4000,-0x34(%rbp)
  800421a588:	89 45 c8             	mov    %eax,-0x38(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421a58b:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421a58e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421a591:	48 89 d6             	mov    %rdx,%rsi
  800421a594:	89 c7                	mov    %eax,%edi
  800421a596:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a59d:	00 00 00 
  800421a5a0:	ff d0                	callq  *%rax
            pinbased_ctls_or & pinbased_ctls_and );

    // Set proc-based controls.
    uint32_t procbased_ctls_or, procbased_ctls_and;
    vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS, 
  800421a5a2:	48 8d 95 1c ff ff ff 	lea    -0xe4(%rbp),%rdx
  800421a5a9:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800421a5b0:	48 89 c6             	mov    %rax,%rsi
  800421a5b3:	bf 82 04 00 00       	mov    $0x482,%edi
  800421a5b8:	48 b8 c4 a4 21 04 80 	movabs $0x800421a4c4,%rax
  800421a5bf:	00 00 00 
  800421a5c2:	ff d0                	callq  *%rax
            &procbased_ctls_and, &procbased_ctls_or );
    // Make sure there are secondary controls.
    assert( BIT( procbased_ctls_and, 31 ) == 0x1 ); 
  800421a5c4:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421a5ca:	c1 e8 1f             	shr    $0x1f,%eax
  800421a5cd:	83 f8 01             	cmp    $0x1,%eax
  800421a5d0:	74 35                	je     800421a607 <vmcs_ctls_init+0xc8>
  800421a5d2:	48 b9 08 f6 21 04 80 	movabs $0x800421f608,%rcx
  800421a5d9:	00 00 00 
  800421a5dc:	48 ba d2 f5 21 04 80 	movabs $0x800421f5d2,%rdx
  800421a5e3:	00 00 00 
  800421a5e6:	be 26 01 00 00       	mov    $0x126,%esi
  800421a5eb:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421a5f2:	00 00 00 
  800421a5f5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a5fa:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421a601:	00 00 00 
  800421a604:	41 ff d0             	callq  *%r8
   
    procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_ACTIVESECCTL; 
  800421a607:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421a60d:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421a612:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_HLTEXIT;
  800421a618:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421a61e:	0c 80                	or     $0x80,%al
  800421a620:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_USEIOBMP;
  800421a626:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421a62c:	0d 00 00 00 02       	or     $0x2000000,%eax
  800421a631:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    /* CR3 accesses and invlpg don't need to cause VM Exits when EPT
       enabled */
    procbased_ctls_or &= ~( VMCS_PROC_BASED_VMEXEC_CTL_CR3LOADEXIT |
  800421a637:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421a63d:	25 ff 7d fe ff       	and    $0xfffe7dff,%eax
  800421a642:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
            VMCS_PROC_BASED_VMEXEC_CTL_CR3STOREXIT | 
            VMCS_PROC_BASED_VMEXEC_CTL_INVLPGEXIT );

    vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
  800421a648:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800421a64e:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421a654:	21 d0                	and    %edx,%eax
  800421a656:	c7 45 c4 02 40 00 00 	movl   $0x4002,-0x3c(%rbp)
  800421a65d:	89 45 c0             	mov    %eax,-0x40(%rbp)
  800421a660:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421a663:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421a666:	48 89 d6             	mov    %rdx,%rsi
  800421a669:	89 c7                	mov    %eax,%edi
  800421a66b:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a672:	00 00 00 
  800421a675:	ff d0                	callq  *%rax
            procbased_ctls_or & procbased_ctls_and );

    // Set Proc based secondary controls.
    uint32_t procbased_ctls2_or, procbased_ctls2_and;
    vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS2, 
  800421a677:	48 8d 95 14 ff ff ff 	lea    -0xec(%rbp),%rdx
  800421a67e:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
  800421a685:	48 89 c6             	mov    %rax,%rsi
  800421a688:	bf 8b 04 00 00       	mov    $0x48b,%edi
  800421a68d:	48 b8 c4 a4 21 04 80 	movabs $0x800421a4c4,%rax
  800421a694:	00 00 00 
  800421a697:	ff d0                	callq  *%rax
            &procbased_ctls2_and, &procbased_ctls2_or );
    
    // Enable EPT.
    procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_ENABLE_EPT;
  800421a699:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421a69f:	83 c8 02             	or     $0x2,%eax
  800421a6a2:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
    procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_UNRESTRICTED_GUEST;
  800421a6a8:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421a6ae:	0c 80                	or     $0x80,%al
  800421a6b0:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
    vmcs_write32( VMCS_32BIT_CONTROL_SECONDARY_VMEXEC_CONTROLS, 
  800421a6b6:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  800421a6bc:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  800421a6c2:	21 d0                	and    %edx,%eax
  800421a6c4:	c7 45 bc 1e 40 00 00 	movl   $0x401e,-0x44(%rbp)
  800421a6cb:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800421a6ce:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421a6d1:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421a6d4:	48 89 d6             	mov    %rdx,%rsi
  800421a6d7:	89 c7                	mov    %eax,%edi
  800421a6d9:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a6e0:	00 00 00 
  800421a6e3:	ff d0                	callq  *%rax
            procbased_ctls2_or & procbased_ctls2_and );

    // Set VM exit controls.
    uint32_t exit_ctls_or, exit_ctls_and;
    vmx_read_capability_msr( IA32_VMX_EXIT_CTLS, 
  800421a6e5:	48 8d 95 0c ff ff ff 	lea    -0xf4(%rbp),%rdx
  800421a6ec:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421a6f3:	48 89 c6             	mov    %rax,%rsi
  800421a6f6:	bf 83 04 00 00       	mov    $0x483,%edi
  800421a6fb:	48 b8 c4 a4 21 04 80 	movabs $0x800421a4c4,%rax
  800421a702:	00 00 00 
  800421a705:	ff d0                	callq  *%rax
            &exit_ctls_and, &exit_ctls_or );

    exit_ctls_or |= VMCS_VMEXIT_HOST_ADDR_SIZE;
  800421a707:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421a70d:	80 cc 02             	or     $0x2,%ah
  800421a710:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_CONTROLS, 
  800421a716:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421a71c:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  800421a722:	21 d0                	and    %edx,%eax
  800421a724:	c7 45 b4 0c 40 00 00 	movl   $0x400c,-0x4c(%rbp)
  800421a72b:	89 45 b0             	mov    %eax,-0x50(%rbp)
  800421a72e:	8b 55 b0             	mov    -0x50(%rbp),%edx
  800421a731:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421a734:	48 89 d6             	mov    %rdx,%rsi
  800421a737:	89 c7                	mov    %eax,%edi
  800421a739:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a740:	00 00 00 
  800421a743:	ff d0                	callq  *%rax
            exit_ctls_or & exit_ctls_and );

    vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_STORE_ADDR,
            PADDR(e->env_vmxinfo.msr_guest_area));
  800421a745:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a74c:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421a753:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421a757:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421a75e:	00 00 00 
  800421a761:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421a765:	77 32                	ja     800421a799 <vmcs_ctls_init+0x25a>
  800421a767:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421a76b:	48 89 c1             	mov    %rax,%rcx
  800421a76e:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421a775:	00 00 00 
  800421a778:	be 49 01 00 00       	mov    $0x149,%esi
  800421a77d:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421a784:	00 00 00 
  800421a787:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a78c:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421a793:	00 00 00 
  800421a796:	41 ff d0             	callq  *%r8
  800421a799:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421a7a0:	ff ff ff 
  800421a7a3:	48 03 45 f8          	add    -0x8(%rbp),%rax
  800421a7a7:	c7 45 ac 06 20 00 00 	movl   $0x2006,-0x54(%rbp)
  800421a7ae:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a7b2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421a7b6:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421a7b9:	48 89 d6             	mov    %rdx,%rsi
  800421a7bc:	89 c7                	mov    %eax,%edi
  800421a7be:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a7c5:	00 00 00 
  800421a7c8:	ff d0                	callq  *%rax
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_STORE_COUNT,
            e->env_vmxinfo.msr_count);
  800421a7ca:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a7d1:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_CONTROLS, 
            exit_ctls_or & exit_ctls_and );

    vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_STORE_ADDR,
            PADDR(e->env_vmxinfo.msr_guest_area));
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_STORE_COUNT,
  800421a7d7:	c7 45 9c 0e 40 00 00 	movl   $0x400e,-0x64(%rbp)
  800421a7de:	89 45 98             	mov    %eax,-0x68(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421a7e1:	8b 55 98             	mov    -0x68(%rbp),%edx
  800421a7e4:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421a7e7:	48 89 d6             	mov    %rdx,%rsi
  800421a7ea:	89 c7                	mov    %eax,%edi
  800421a7ec:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a7f3:	00 00 00 
  800421a7f6:	ff d0                	callq  *%rax
            e->env_vmxinfo.msr_count);
    vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_LOAD_ADDR,
            PADDR(e->env_vmxinfo.msr_host_area));
  800421a7f8:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a7ff:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  800421a806:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421a80a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421a811:	00 00 00 
  800421a814:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800421a818:	77 32                	ja     800421a84c <vmcs_ctls_init+0x30d>
  800421a81a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421a81e:	48 89 c1             	mov    %rax,%rcx
  800421a821:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421a828:	00 00 00 
  800421a82b:	be 4d 01 00 00       	mov    $0x14d,%esi
  800421a830:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421a837:	00 00 00 
  800421a83a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a83f:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421a846:	00 00 00 
  800421a849:	41 ff d0             	callq  *%r8
  800421a84c:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421a853:	ff ff ff 
  800421a856:	48 03 45 f0          	add    -0x10(%rbp),%rax
  800421a85a:	c7 45 94 08 20 00 00 	movl   $0x2008,-0x6c(%rbp)
  800421a861:	48 89 45 88          	mov    %rax,-0x78(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a865:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421a869:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421a86c:	48 89 d6             	mov    %rdx,%rsi
  800421a86f:	89 c7                	mov    %eax,%edi
  800421a871:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a878:	00 00 00 
  800421a87b:	ff d0                	callq  *%rax
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_LOAD_COUNT,
            e->env_vmxinfo.msr_count);
  800421a87d:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a884:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
            PADDR(e->env_vmxinfo.msr_guest_area));
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_STORE_COUNT,
            e->env_vmxinfo.msr_count);
    vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_LOAD_ADDR,
            PADDR(e->env_vmxinfo.msr_host_area));
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_LOAD_COUNT,
  800421a88a:	c7 45 84 10 40 00 00 	movl   $0x4010,-0x7c(%rbp)
  800421a891:	89 45 80             	mov    %eax,-0x80(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421a894:	8b 55 80             	mov    -0x80(%rbp),%edx
  800421a897:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421a89a:	48 89 d6             	mov    %rdx,%rsi
  800421a89d:	89 c7                	mov    %eax,%edi
  800421a89f:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a8a6:	00 00 00 
  800421a8a9:	ff d0                	callq  *%rax
            e->env_vmxinfo.msr_count);

    // Set VM entry controls.
    uint32_t entry_ctls_or, entry_ctls_and;
    vmx_read_capability_msr( IA32_VMX_ENTRY_CTLS, 
  800421a8ab:	48 8d 95 04 ff ff ff 	lea    -0xfc(%rbp),%rdx
  800421a8b2:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  800421a8b9:	48 89 c6             	mov    %rax,%rsi
  800421a8bc:	bf 84 04 00 00       	mov    $0x484,%edi
  800421a8c1:	48 b8 c4 a4 21 04 80 	movabs $0x800421a4c4,%rax
  800421a8c8:	00 00 00 
  800421a8cb:	ff d0                	callq  *%rax
            &entry_ctls_and, &entry_ctls_or );

    vmcs_write64( VMCS_64BIT_CONTROL_VMENTRY_MSR_LOAD_ADDR,
            PADDR(e->env_vmxinfo.msr_guest_area));
  800421a8cd:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a8d4:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421a8db:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421a8df:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421a8e6:	00 00 00 
  800421a8e9:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421a8ed:	77 32                	ja     800421a921 <vmcs_ctls_init+0x3e2>
  800421a8ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a8f3:	48 89 c1             	mov    %rax,%rcx
  800421a8f6:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421a8fd:	00 00 00 
  800421a900:	be 57 01 00 00       	mov    $0x157,%esi
  800421a905:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421a90c:	00 00 00 
  800421a90f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421a914:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421a91b:	00 00 00 
  800421a91e:	41 ff d0             	callq  *%r8
  800421a921:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421a928:	ff ff ff 
  800421a92b:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800421a92f:	c7 85 7c ff ff ff 0a 	movl   $0x200a,-0x84(%rbp)
  800421a936:	20 00 00 
  800421a939:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a940:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421a947:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421a94d:	48 89 d6             	mov    %rdx,%rsi
  800421a950:	89 c7                	mov    %eax,%edi
  800421a952:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a959:	00 00 00 
  800421a95c:	ff d0                	callq  *%rax
    vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_MSR_LOAD_COUNT,
            e->env_vmxinfo.msr_count);
  800421a95e:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a965:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
    vmx_read_capability_msr( IA32_VMX_ENTRY_CTLS, 
            &entry_ctls_and, &entry_ctls_or );

    vmcs_write64( VMCS_64BIT_CONTROL_VMENTRY_MSR_LOAD_ADDR,
            PADDR(e->env_vmxinfo.msr_guest_area));
    vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_MSR_LOAD_COUNT,
  800421a96b:	c7 85 6c ff ff ff 14 	movl   $0x4014,-0x94(%rbp)
  800421a972:	40 00 00 
  800421a975:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421a97b:	8b 95 68 ff ff ff    	mov    -0x98(%rbp),%edx
  800421a981:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421a987:	48 89 d6             	mov    %rdx,%rsi
  800421a98a:	89 c7                	mov    %eax,%edi
  800421a98c:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a993:	00 00 00 
  800421a996:	ff d0                	callq  *%rax
            e->env_vmxinfo.msr_count);

    vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
  800421a998:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  800421a99e:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  800421a9a4:	21 d0                	and    %edx,%eax
  800421a9a6:	c7 85 64 ff ff ff 12 	movl   $0x4012,-0x9c(%rbp)
  800421a9ad:	40 00 00 
  800421a9b0:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
  800421a9b6:	8b 95 60 ff ff ff    	mov    -0xa0(%rbp),%edx
  800421a9bc:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  800421a9c2:	48 89 d6             	mov    %rdx,%rsi
  800421a9c5:	89 c7                	mov    %eax,%edi
  800421a9c7:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421a9ce:	00 00 00 
  800421a9d1:	ff d0                	callq  *%rax
            entry_ctls_or & entry_ctls_and );
    
    uint64_t ept_ptr = e->env_cr3 | ( ( EPT_LEVELS - 1 ) << 3 );
  800421a9d3:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421a9da:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800421a9e1:	48 83 c8 18          	or     $0x18,%rax
  800421a9e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421a9e9:	c7 85 5c ff ff ff 1a 	movl   $0x201a,-0xa4(%rbp)
  800421a9f0:	20 00 00 
  800421a9f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421a9f7:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a9fe:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421aa05:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421aa0b:	48 89 d6             	mov    %rdx,%rsi
  800421aa0e:	89 c7                	mov    %eax,%edi
  800421aa10:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421aa17:	00 00 00 
  800421aa1a:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_CONTROL_EPTPTR, ept_ptr );

    vmcs_write32( VMCS_32BIT_CONTROL_EXCEPTION_BITMAP, 
            e->env_vmxinfo.exception_bmap);
  800421aa1c:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
            entry_ctls_or & entry_ctls_and );
    
    uint64_t ept_ptr = e->env_cr3 | ( ( EPT_LEVELS - 1 ) << 3 );
    vmcs_write64( VMCS_64BIT_CONTROL_EPTPTR, ept_ptr );

    vmcs_write32( VMCS_32BIT_CONTROL_EXCEPTION_BITMAP, 
  800421aa23:	8b 80 30 01 00 00    	mov    0x130(%rax),%eax
  800421aa29:	c7 85 4c ff ff ff 04 	movl   $0x4004,-0xb4(%rbp)
  800421aa30:	40 00 00 
  800421aa33:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421aa39:	8b 95 48 ff ff ff    	mov    -0xb8(%rbp),%edx
  800421aa3f:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421aa45:	48 89 d6             	mov    %rdx,%rsi
  800421aa48:	89 c7                	mov    %eax,%edi
  800421aa4a:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421aa51:	00 00 00 
  800421aa54:	ff d0                	callq  *%rax
            e->env_vmxinfo.exception_bmap);
    vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_A,
            PADDR(e->env_vmxinfo.io_bmap_a));
  800421aa56:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421aa5d:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  800421aa64:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421aa68:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421aa6f:	00 00 00 
  800421aa72:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800421aa76:	77 32                	ja     800421aaaa <vmcs_ctls_init+0x56b>
  800421aa78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421aa7c:	48 89 c1             	mov    %rax,%rcx
  800421aa7f:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421aa86:	00 00 00 
  800421aa89:	be 64 01 00 00       	mov    $0x164,%esi
  800421aa8e:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421aa95:	00 00 00 
  800421aa98:	b8 00 00 00 00       	mov    $0x0,%eax
  800421aa9d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421aaa4:	00 00 00 
  800421aaa7:	41 ff d0             	callq  *%r8
  800421aaaa:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421aab1:	ff ff ff 
  800421aab4:	48 03 45 d8          	add    -0x28(%rbp),%rax
  800421aab8:	c7 85 44 ff ff ff 00 	movl   $0x2000,-0xbc(%rbp)
  800421aabf:	20 00 00 
  800421aac2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421aac9:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  800421aad0:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  800421aad6:	48 89 d6             	mov    %rdx,%rsi
  800421aad9:	89 c7                	mov    %eax,%edi
  800421aadb:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421aae2:	00 00 00 
  800421aae5:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_B,
            PADDR(e->env_vmxinfo.io_bmap_b));
  800421aae7:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421aaee:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  800421aaf5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421aaf9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421ab00:	00 00 00 
  800421ab03:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800421ab07:	77 32                	ja     800421ab3b <vmcs_ctls_init+0x5fc>
  800421ab09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ab0d:	48 89 c1             	mov    %rax,%rcx
  800421ab10:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421ab17:	00 00 00 
  800421ab1a:	be 66 01 00 00       	mov    $0x166,%esi
  800421ab1f:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421ab26:	00 00 00 
  800421ab29:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ab2e:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421ab35:	00 00 00 
  800421ab38:	41 ff d0             	callq  *%r8
  800421ab3b:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421ab42:	ff ff ff 
  800421ab45:	48 03 45 d0          	add    -0x30(%rbp),%rax
  800421ab49:	c7 85 34 ff ff ff 02 	movl   $0x2002,-0xcc(%rbp)
  800421ab50:	20 00 00 
  800421ab53:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421ab5a:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421ab61:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
  800421ab67:	48 89 d6             	mov    %rdx,%rsi
  800421ab6a:	89 c7                	mov    %eax,%edi
  800421ab6c:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421ab73:	00 00 00 
  800421ab76:	ff d0                	callq  *%rax

}
  800421ab78:	c9                   	leaveq 
  800421ab79:	c3                   	retq   

000000800421ab7a <vmcs_dump_cpu>:

void vmcs_dump_cpu() {
  800421ab7a:	55                   	push   %rbp
  800421ab7b:	48 89 e5             	mov    %rsp,%rbp
  800421ab7e:	53                   	push   %rbx
  800421ab7f:	48 83 ec 28          	sub    $0x28,%rsp
	uint64_t flags = vmcs_readl(VMCS_GUEST_RFLAGS);
  800421ab83:	bf 20 68 00 00       	mov    $0x6820,%edi
  800421ab88:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421ab8f:	00 00 00 
  800421ab92:	ff d0                	callq  *%rax
  800421ab94:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    // TODO: print all the regs.
	cprintf( "vmx: --- Begin VCPU Dump ---\n");
  800421ab98:	48 bf 54 f6 21 04 80 	movabs $0x800421f654,%rdi
  800421ab9f:	00 00 00 
  800421aba2:	b8 00 00 00 00       	mov    $0x0,%eax
  800421aba7:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421abae:	00 00 00 
  800421abb1:	ff d2                	callq  *%rdx
  800421abb3:	c7 45 e4 1c 68 00 00 	movl   $0x681c,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421abba:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421abbd:	89 c7                	mov    %eax,%edi
  800421abbf:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421abc6:	00 00 00 
  800421abc9:	ff d0                	callq  *%rax
	cprintf( "vmx: RIP 0x%016llx RSP 0x%016llx RFLAGS 0x%016llx\n",
  800421abcb:	48 89 c3             	mov    %rax,%rbx
  800421abce:	c7 45 e0 1e 68 00 00 	movl   $0x681e,-0x20(%rbp)
  800421abd5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421abd8:	89 c7                	mov    %eax,%edi
  800421abda:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421abe1:	00 00 00 
  800421abe4:	ff d0                	callq  *%rax
  800421abe6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421abea:	48 89 d1             	mov    %rdx,%rcx
  800421abed:	48 89 da             	mov    %rbx,%rdx
  800421abf0:	48 89 c6             	mov    %rax,%rsi
  800421abf3:	48 bf 78 f6 21 04 80 	movabs $0x800421f678,%rdi
  800421abfa:	00 00 00 
  800421abfd:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ac02:	49 b8 7a 90 20 04 80 	movabs $0x800420907a,%r8
  800421ac09:	00 00 00 
  800421ac0c:	41 ff d0             	callq  *%r8
  800421ac0f:	c7 45 dc 02 68 00 00 	movl   $0x6802,-0x24(%rbp)
  800421ac16:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421ac19:	89 c7                	mov    %eax,%edi
  800421ac1b:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421ac22:	00 00 00 
  800421ac25:	ff d0                	callq  *%rax
	       vmcs_read64( VMCS_GUEST_RIP ) , vmcs_read64( VMCS_GUEST_RSP ), flags);
	cprintf( "vmx: CR0 0x%016llx CR3 0x%016llx\n",
  800421ac27:	48 89 c3             	mov    %rax,%rbx
  800421ac2a:	c7 45 d8 00 68 00 00 	movl   $0x6800,-0x28(%rbp)
  800421ac31:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421ac34:	89 c7                	mov    %eax,%edi
  800421ac36:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421ac3d:	00 00 00 
  800421ac40:	ff d0                	callq  *%rax
  800421ac42:	48 89 da             	mov    %rbx,%rdx
  800421ac45:	48 89 c6             	mov    %rax,%rsi
  800421ac48:	48 bf b0 f6 21 04 80 	movabs $0x800421f6b0,%rdi
  800421ac4f:	00 00 00 
  800421ac52:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ac57:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800421ac5e:	00 00 00 
  800421ac61:	ff d1                	callq  *%rcx
  800421ac63:	c7 45 d4 04 68 00 00 	movl   $0x6804,-0x2c(%rbp)
  800421ac6a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421ac6d:	89 c7                	mov    %eax,%edi
  800421ac6f:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421ac76:	00 00 00 
  800421ac79:	ff d0                	callq  *%rax
            vmcs_read64( VMCS_GUEST_CR0 ), vmcs_read64( VMCS_GUEST_CR3 ) );
    cprintf( "vmx: CR4 0x%016llx \n",
  800421ac7b:	48 89 c6             	mov    %rax,%rsi
  800421ac7e:	48 bf d2 f6 21 04 80 	movabs $0x800421f6d2,%rdi
  800421ac85:	00 00 00 
  800421ac88:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ac8d:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421ac94:	00 00 00 
  800421ac97:	ff d2                	callq  *%rdx
            vmcs_read64( VMCS_GUEST_CR4 ) );

    cprintf( "vmx: --- End VCPU Dump ---\n");
  800421ac99:	48 bf e7 f6 21 04 80 	movabs $0x800421f6e7,%rdi
  800421aca0:	00 00 00 
  800421aca3:	b8 00 00 00 00       	mov    $0x0,%eax
  800421aca8:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421acaf:	00 00 00 
  800421acb2:	ff d2                	callq  *%rdx

}
  800421acb4:	48 83 c4 28          	add    $0x28,%rsp
  800421acb8:	5b                   	pop    %rbx
  800421acb9:	5d                   	pop    %rbp
  800421acba:	c3                   	retq   

000000800421acbb <vmexit>:

void vmexit() {
  800421acbb:	55                   	push   %rbp
  800421acbc:	48 89 e5             	mov    %rsp,%rbp
  800421acbf:	41 54                	push   %r12
  800421acc1:	53                   	push   %rbx
  800421acc2:	48 83 ec 10          	sub    $0x10,%rsp
    int exit_reason = -1;
  800421acc6:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%rbp)
    bool exit_handled = false;
  800421accd:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  800421acd1:	c7 45 e4 02 44 00 00 	movl   $0x4402,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421acd8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421acdb:	89 c7                	mov    %eax,%edi
  800421acdd:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421ace4:	00 00 00 
  800421ace7:	ff d0                	callq  *%rax
    // Get the reason for VMEXIT from the VMCS.
    // Your code here.
	// Bochs writes the exit information into VMwrite32(VMCS_32BIT_VMEXIT_REASON, reason);
	exit_reason = vmcs_read32(VMCS_32BIT_VMEXIT_REASON);
  800421ace9:	89 45 e8             	mov    %eax,-0x18(%rbp)
    //cprintf( "\n Check---VMEXIT Reason: %d---\n", exit_reason );
    //vmcs_dump_cpu();
 
    switch(exit_reason & EXIT_REASON_MASK) {
  800421acec:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421acef:	25 ff ff 00 00       	and    $0xffff,%eax
  800421acf4:	83 e8 0a             	sub    $0xa,%eax
  800421acf7:	83 f8 26             	cmp    $0x26,%eax
  800421acfa:	0f 87 7a 03 00 00    	ja     800421b07a <vmexit+0x3bf>
  800421ad00:	89 c0                	mov    %eax,%eax
  800421ad02:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421ad09:	00 
  800421ad0a:	48 b8 30 f7 21 04 80 	movabs $0x800421f730,%rax
  800421ad11:	00 00 00 
  800421ad14:	48 01 d0             	add    %rdx,%rax
  800421ad17:	48 8b 00             	mov    (%rax),%rax
  800421ad1a:	ff e0                	jmpq   *%rax
        case EXIT_REASON_RDMSR:
     //       cprintf("\nRDMSR, exiting guest.\n");
            exit_handled = handle_rdmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421ad1c:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421ad23:	00 00 00 
  800421ad26:	ff d0                	callq  *%rax
  800421ad28:	48 98                	cltq   
  800421ad2a:	48 c1 e0 03          	shl    $0x3,%rax
  800421ad2e:	48 89 c2             	mov    %rax,%rdx
  800421ad31:	48 c1 e2 04          	shl    $0x4,%rdx
  800421ad35:	48 01 c2             	add    %rax,%rdx
  800421ad38:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421ad3f:	00 00 00 
  800421ad42:	48 01 d0             	add    %rdx,%rax
  800421ad45:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421ad49:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421ad50:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421ad57:	00 00 00 
  800421ad5a:	ff d0                	callq  *%rax
  800421ad5c:	48 98                	cltq   
  800421ad5e:	48 c1 e0 03          	shl    $0x3,%rax
  800421ad62:	48 89 c2             	mov    %rax,%rdx
  800421ad65:	48 c1 e2 04          	shl    $0x4,%rdx
  800421ad69:	48 01 c2             	add    %rax,%rdx
  800421ad6c:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421ad73:	00 00 00 
  800421ad76:	48 01 d0             	add    %rdx,%rax
  800421ad79:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421ad7d:	48 89 de             	mov    %rbx,%rsi
  800421ad80:	48 89 c7             	mov    %rax,%rdi
  800421ad83:	48 b8 49 ba 21 04 80 	movabs $0x800421ba49,%rax
  800421ad8a:	00 00 00 
  800421ad8d:	ff d0                	callq  *%rax
  800421ad8f:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421ad92:	e9 e3 02 00 00       	jmpq   800421b07a <vmexit+0x3bf>
        case EXIT_REASON_WRMSR:
    //        cprintf("\nWRMSR, exiting guest.\n");
            exit_handled = handle_wrmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421ad97:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421ad9e:	00 00 00 
  800421ada1:	ff d0                	callq  *%rax
  800421ada3:	48 98                	cltq   
  800421ada5:	48 c1 e0 03          	shl    $0x3,%rax
  800421ada9:	48 89 c2             	mov    %rax,%rdx
  800421adac:	48 c1 e2 04          	shl    $0x4,%rdx
  800421adb0:	48 01 c2             	add    %rax,%rdx
  800421adb3:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421adba:	00 00 00 
  800421adbd:	48 01 d0             	add    %rdx,%rax
  800421adc0:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421adc4:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421adcb:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421add2:	00 00 00 
  800421add5:	ff d0                	callq  *%rax
  800421add7:	48 98                	cltq   
  800421add9:	48 c1 e0 03          	shl    $0x3,%rax
  800421addd:	48 89 c2             	mov    %rax,%rdx
  800421ade0:	48 c1 e2 04          	shl    $0x4,%rdx
  800421ade4:	48 01 c2             	add    %rax,%rdx
  800421ade7:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421adee:	00 00 00 
  800421adf1:	48 01 d0             	add    %rdx,%rax
  800421adf4:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421adf8:	48 89 de             	mov    %rbx,%rsi
  800421adfb:	48 89 c7             	mov    %rax,%rdi
  800421adfe:	48 b8 55 bb 21 04 80 	movabs $0x800421bb55,%rax
  800421ae05:	00 00 00 
  800421ae08:	ff d0                	callq  *%rax
  800421ae0a:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421ae0d:	e9 68 02 00 00       	jmpq   800421b07a <vmexit+0x3bf>
        case EXIT_REASON_EPT_VIOLATION:
     //       cprintf("\nEPT violation, exiting guest.\n");
            exit_handled = handle_eptviolation(curenv->env_pml4e, &curenv->env_vmxinfo);
  800421ae12:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421ae19:	00 00 00 
  800421ae1c:	ff d0                	callq  *%rax
  800421ae1e:	48 98                	cltq   
  800421ae20:	48 c1 e0 03          	shl    $0x3,%rax
  800421ae24:	48 89 c2             	mov    %rax,%rdx
  800421ae27:	48 c1 e2 04          	shl    $0x4,%rdx
  800421ae2b:	48 01 c2             	add    %rax,%rdx
  800421ae2e:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421ae35:	00 00 00 
  800421ae38:	48 01 d0             	add    %rdx,%rax
  800421ae3b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421ae3f:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421ae46:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421ae4d:	00 00 00 
  800421ae50:	ff d0                	callq  *%rax
  800421ae52:	48 98                	cltq   
  800421ae54:	48 c1 e0 03          	shl    $0x3,%rax
  800421ae58:	48 89 c2             	mov    %rax,%rdx
  800421ae5b:	48 c1 e2 04          	shl    $0x4,%rdx
  800421ae5f:	48 01 c2             	add    %rax,%rdx
  800421ae62:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421ae69:	00 00 00 
  800421ae6c:	48 01 d0             	add    %rdx,%rax
  800421ae6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421ae73:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800421ae7a:	48 89 de             	mov    %rbx,%rsi
  800421ae7d:	48 89 c7             	mov    %rax,%rdi
  800421ae80:	48 b8 c8 bc 21 04 80 	movabs $0x800421bcc8,%rax
  800421ae87:	00 00 00 
  800421ae8a:	ff d0                	callq  *%rax
  800421ae8c:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421ae8f:	e9 e6 01 00 00       	jmpq   800421b07a <vmexit+0x3bf>
        case EXIT_REASON_IO_INSTRUCTION:
      //      cprintf("\nIOINSTR, exiting guest.\n");
            exit_handled = handle_ioinstr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421ae94:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421ae9b:	00 00 00 
  800421ae9e:	ff d0                	callq  *%rax
  800421aea0:	48 98                	cltq   
  800421aea2:	48 c1 e0 03          	shl    $0x3,%rax
  800421aea6:	48 89 c2             	mov    %rax,%rdx
  800421aea9:	48 c1 e2 04          	shl    $0x4,%rdx
  800421aead:	48 01 c2             	add    %rax,%rdx
  800421aeb0:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421aeb7:	00 00 00 
  800421aeba:	48 01 d0             	add    %rdx,%rax
  800421aebd:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421aec1:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421aec8:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421aecf:	00 00 00 
  800421aed2:	ff d0                	callq  *%rax
  800421aed4:	48 98                	cltq   
  800421aed6:	48 c1 e0 03          	shl    $0x3,%rax
  800421aeda:	48 89 c2             	mov    %rax,%rdx
  800421aedd:	48 c1 e2 04          	shl    $0x4,%rdx
  800421aee1:	48 01 c2             	add    %rax,%rdx
  800421aee4:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421aeeb:	00 00 00 
  800421aeee:	48 01 d0             	add    %rdx,%rax
  800421aef1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421aef5:	48 89 de             	mov    %rbx,%rsi
  800421aef8:	48 89 c7             	mov    %rax,%rdi
  800421aefb:	48 b8 7d be 21 04 80 	movabs $0x800421be7d,%rax
  800421af02:	00 00 00 
  800421af05:	ff d0                	callq  *%rax
  800421af07:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421af0a:	e9 6b 01 00 00       	jmpq   800421b07a <vmexit+0x3bf>
        case EXIT_REASON_CPUID:
    //        cprintf("\nCPUID, exiting guest.\n");
            exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
  800421af0f:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421af16:	00 00 00 
  800421af19:	ff d0                	callq  *%rax
  800421af1b:	48 98                	cltq   
  800421af1d:	48 c1 e0 03          	shl    $0x3,%rax
  800421af21:	48 89 c2             	mov    %rax,%rdx
  800421af24:	48 c1 e2 04          	shl    $0x4,%rdx
  800421af28:	48 01 c2             	add    %rax,%rdx
  800421af2b:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421af32:	00 00 00 
  800421af35:	48 01 d0             	add    %rdx,%rax
  800421af38:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421af3c:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421af43:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421af4a:	00 00 00 
  800421af4d:	ff d0                	callq  *%rax
  800421af4f:	48 98                	cltq   
  800421af51:	48 c1 e0 03          	shl    $0x3,%rax
  800421af55:	48 89 c2             	mov    %rax,%rdx
  800421af58:	48 c1 e2 04          	shl    $0x4,%rdx
  800421af5c:	48 01 c2             	add    %rax,%rdx
  800421af5f:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421af66:	00 00 00 
  800421af69:	48 01 d0             	add    %rdx,%rax
  800421af6c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421af70:	48 89 de             	mov    %rbx,%rsi
  800421af73:	48 89 c7             	mov    %rax,%rdi
  800421af76:	48 b8 40 c0 21 04 80 	movabs $0x800421c040,%rax
  800421af7d:	00 00 00 
  800421af80:	ff d0                	callq  *%rax
  800421af82:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421af85:	e9 f0 00 00 00       	jmpq   800421b07a <vmexit+0x3bf>
        case EXIT_REASON_VMCALL:
    //        cprintf("\nVMCALL, exiting guest.\n");
            exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
                    curenv->env_pml4e);
  800421af8a:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421af91:	00 00 00 
  800421af94:	ff d0                	callq  *%rax
  800421af96:	48 98                	cltq   
  800421af98:	48 c1 e0 03          	shl    $0x3,%rax
  800421af9c:	48 89 c2             	mov    %rax,%rdx
  800421af9f:	48 c1 e2 04          	shl    $0x4,%rdx
  800421afa3:	48 01 c2             	add    %rax,%rdx
  800421afa6:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421afad:	00 00 00 
  800421afb0:	48 01 d0             	add    %rdx,%rax
  800421afb3:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421afb7:	48 8b 98 e0 00 00 00 	mov    0xe0(%rax),%rbx
    //        cprintf("\nCPUID, exiting guest.\n");
            exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
            break;
        case EXIT_REASON_VMCALL:
    //        cprintf("\nVMCALL, exiting guest.\n");
            exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
  800421afbe:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421afc5:	00 00 00 
  800421afc8:	ff d0                	callq  *%rax
  800421afca:	48 98                	cltq   
  800421afcc:	48 c1 e0 03          	shl    $0x3,%rax
  800421afd0:	48 89 c2             	mov    %rax,%rdx
  800421afd3:	48 c1 e2 04          	shl    $0x4,%rdx
  800421afd7:	48 01 c2             	add    %rax,%rdx
  800421afda:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421afe1:	00 00 00 
  800421afe4:	48 01 d0             	add    %rdx,%rax
  800421afe7:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421afeb:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421aff2:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421aff9:	00 00 00 
  800421affc:	ff d0                	callq  *%rax
  800421affe:	48 98                	cltq   
  800421b000:	48 c1 e0 03          	shl    $0x3,%rax
  800421b004:	48 89 c2             	mov    %rax,%rdx
  800421b007:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b00b:	48 01 c2             	add    %rax,%rdx
  800421b00e:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b015:	00 00 00 
  800421b018:	48 01 d0             	add    %rdx,%rax
  800421b01b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421b01f:	48 89 da             	mov    %rbx,%rdx
  800421b022:	4c 89 e6             	mov    %r12,%rsi
  800421b025:	48 89 c7             	mov    %rax,%rdi
  800421b028:	48 b8 1e c1 21 04 80 	movabs $0x800421c11e,%rax
  800421b02f:	00 00 00 
  800421b032:	ff d0                	callq  *%rax
  800421b034:	88 45 ef             	mov    %al,-0x11(%rbp)
                    curenv->env_pml4e);
            break;
  800421b037:	eb 41                	jmp    800421b07a <vmexit+0x3bf>
        case EXIT_REASON_HLT:
   //         cprintf("\nHLT in guest, exiting guest.\n");
            env_destroy(curenv);
  800421b039:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b040:	00 00 00 
  800421b043:	ff d0                	callq  *%rax
  800421b045:	48 98                	cltq   
  800421b047:	48 c1 e0 03          	shl    $0x3,%rax
  800421b04b:	48 89 c2             	mov    %rax,%rdx
  800421b04e:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b052:	48 01 c2             	add    %rax,%rdx
  800421b055:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b05c:	00 00 00 
  800421b05f:	48 01 d0             	add    %rdx,%rax
  800421b062:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421b066:	48 89 c7             	mov    %rax,%rdi
  800421b069:	48 b8 59 89 20 04 80 	movabs $0x8004208959,%rax
  800421b070:	00 00 00 
  800421b073:	ff d0                	callq  *%rax
            exit_handled = true;
  800421b075:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
            break;
  800421b079:	90                   	nop
    }

    if(!exit_handled) {
  800421b07a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800421b07e:	83 f0 01             	xor    $0x1,%eax
  800421b081:	84 c0                	test   %al,%al
  800421b083:	74 68                	je     800421b0ed <vmexit+0x432>
        cprintf( "Unhandled VMEXIT, aborting guest.\n" );
  800421b085:	48 bf 08 f7 21 04 80 	movabs $0x800421f708,%rdi
  800421b08c:	00 00 00 
  800421b08f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b094:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421b09b:	00 00 00 
  800421b09e:	ff d2                	callq  *%rdx
        vmcs_dump_cpu();
  800421b0a0:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b0a5:	48 ba 7a ab 21 04 80 	movabs $0x800421ab7a,%rdx
  800421b0ac:	00 00 00 
  800421b0af:	ff d2                	callq  *%rdx
        env_destroy(curenv);
  800421b0b1:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b0b8:	00 00 00 
  800421b0bb:	ff d0                	callq  *%rax
  800421b0bd:	48 98                	cltq   
  800421b0bf:	48 c1 e0 03          	shl    $0x3,%rax
  800421b0c3:	48 89 c2             	mov    %rax,%rdx
  800421b0c6:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b0ca:	48 01 c2             	add    %rax,%rdx
  800421b0cd:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b0d4:	00 00 00 
  800421b0d7:	48 01 d0             	add    %rdx,%rax
  800421b0da:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421b0de:	48 89 c7             	mov    %rax,%rdi
  800421b0e1:	48 b8 59 89 20 04 80 	movabs $0x8004208959,%rax
  800421b0e8:	00 00 00 
  800421b0eb:	ff d0                	callq  *%rax
    }
    
    sched_yield();
  800421b0ed:	48 b8 c4 d2 20 04 80 	movabs $0x800420d2c4,%rax
  800421b0f4:	00 00 00 
  800421b0f7:	ff d0                	callq  *%rax

000000800421b0f9 <asm_vmrun>:
}

void asm_vmrun(struct Trapframe *tf) {
  800421b0f9:	55                   	push   %rbp
  800421b0fa:	48 89 e5             	mov    %rsp,%rbp
  800421b0fd:	41 57                	push   %r15
  800421b0ff:	41 56                	push   %r14
  800421b101:	41 55                	push   %r13
  800421b103:	41 54                	push   %r12
  800421b105:	53                   	push   %rbx
  800421b106:	48 83 ec 28          	sub    $0x28,%rsp
  800421b10a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

    /* cprintf("VMRUN\n"); */
    // NOTE: Since we re-use Trapframe structure, tf.tf_err contains the value
    // of cr2 of the guest.
    tf->tf_ds = curenv->env_runs;
  800421b10e:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b115:	00 00 00 
  800421b118:	ff d0                	callq  *%rax
  800421b11a:	48 98                	cltq   
  800421b11c:	48 c1 e0 03          	shl    $0x3,%rax
  800421b120:	48 89 c2             	mov    %rax,%rdx
  800421b123:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b127:	48 01 c2             	add    %rax,%rdx
  800421b12a:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b131:	00 00 00 
  800421b134:	48 01 d0             	add    %rdx,%rax
  800421b137:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421b13b:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421b141:	89 c2                	mov    %eax,%edx
  800421b143:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b147:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
    tf->tf_es = 0;
  800421b14e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b152:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
    asm(
  800421b158:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421b15c:	ba 14 6c 00 00       	mov    $0x6c14,%edx
  800421b161:	52                   	push   %rdx
  800421b162:	55                   	push   %rbp
  800421b163:	51                   	push   %rcx
  800421b164:	51                   	push   %rcx
  800421b165:	48 89 a1 b0 00 00 00 	mov    %rsp,0xb0(%rcx)
  800421b16c:	0f 79 d4             	vmwrite %rsp,%rdx
  800421b16f:	48 8b 81 90 00 00 00 	mov    0x90(%rcx),%rax
  800421b176:	0f 20 d2             	mov    %cr2,%rdx
  800421b179:	48 39 c2             	cmp    %rax,%rdx
  800421b17c:	74 03                	je     800421b181 <asm_vmrun+0x88>
  800421b17e:	0f 22 d0             	mov    %rax,%cr2
  800421b181:	83 b9 80 00 00 00 01 	cmpl   $0x1,0x80(%rcx)
  800421b188:	48 8b 41 70          	mov    0x70(%rcx),%rax
  800421b18c:	48 8b 59 68          	mov    0x68(%rcx),%rbx
  800421b190:	48 8b 51 58          	mov    0x58(%rcx),%rdx
  800421b194:	48 8b 71 40          	mov    0x40(%rcx),%rsi
  800421b198:	48 8b 79 48          	mov    0x48(%rcx),%rdi
  800421b19c:	48 8b 69 50          	mov    0x50(%rcx),%rbp
  800421b1a0:	4c 8b 41 38          	mov    0x38(%rcx),%r8
  800421b1a4:	4c 8b 49 30          	mov    0x30(%rcx),%r9
  800421b1a8:	4c 8b 51 28          	mov    0x28(%rcx),%r10
  800421b1ac:	4c 8b 59 20          	mov    0x20(%rcx),%r11
  800421b1b0:	4c 8b 61 18          	mov    0x18(%rcx),%r12
  800421b1b4:	4c 8b 69 10          	mov    0x10(%rcx),%r13
  800421b1b8:	4c 8b 71 08          	mov    0x8(%rcx),%r14
  800421b1bc:	4c 8b 39             	mov    (%rcx),%r15
  800421b1bf:	48 8b 49 60          	mov    0x60(%rcx),%rcx
  800421b1c3:	75 05                	jne    800421b1ca <asm_vmrun+0xd1>
  800421b1c5:	0f 01 c2             	vmlaunch 
  800421b1c8:	eb 03                	jmp    800421b1cd <asm_vmrun+0xd4>
  800421b1ca:	0f 01 c3             	vmresume 
  800421b1cd:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421b1d2:	59                   	pop    %rcx
  800421b1d3:	48 89 41 70          	mov    %rax,0x70(%rcx)
  800421b1d7:	48 89 59 68          	mov    %rbx,0x68(%rcx)
  800421b1db:	8f 41 60             	popq   0x60(%rcx)
  800421b1de:	48 89 51 58          	mov    %rdx,0x58(%rcx)
  800421b1e2:	48 89 71 40          	mov    %rsi,0x40(%rcx)
  800421b1e6:	48 89 79 48          	mov    %rdi,0x48(%rcx)
  800421b1ea:	48 89 69 50          	mov    %rbp,0x50(%rcx)
  800421b1ee:	4c 89 41 38          	mov    %r8,0x38(%rcx)
  800421b1f2:	4c 89 49 30          	mov    %r9,0x30(%rcx)
  800421b1f6:	4c 89 51 28          	mov    %r10,0x28(%rcx)
  800421b1fa:	4c 89 59 20          	mov    %r11,0x20(%rcx)
  800421b1fe:	4c 89 61 18          	mov    %r12,0x18(%rcx)
  800421b202:	4c 89 69 10          	mov    %r13,0x10(%rcx)
  800421b206:	4c 89 71 08          	mov    %r14,0x8(%rcx)
  800421b20a:	4c 89 39             	mov    %r15,(%rcx)
  800421b20d:	0f 20 d0             	mov    %cr2,%rax
  800421b210:	48 89 81 90 00 00 00 	mov    %rax,0x90(%rcx)
  800421b217:	5d                   	pop    %rbp
  800421b218:	5a                   	pop    %rdx
  800421b219:	0f 96 41 78          	setbe  0x78(%rcx)
                : "cc", "memory"
                    , "rax", "rbx", "rdi", "rsi"
                        , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
    );

    if(tf->tf_es) {
  800421b21d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b221:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800421b225:	66 85 c0             	test   %ax,%ax
  800421b228:	74 20                	je     800421b24a <asm_vmrun+0x151>
        cprintf("Error during VMLAUNCH/VMRESUME\n");
  800421b22a:	48 bf 68 f8 21 04 80 	movabs $0x800421f868,%rdi
  800421b231:	00 00 00 
  800421b234:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b239:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421b240:	00 00 00 
  800421b243:	ff d2                	callq  *%rdx
  800421b245:	e9 a9 00 00 00       	jmpq   800421b2f3 <asm_vmrun+0x1fa>
    } else {
        curenv->env_tf.tf_rsp = vmcs_read64(VMCS_GUEST_RSP);
  800421b24a:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b251:	00 00 00 
  800421b254:	ff d0                	callq  *%rax
  800421b256:	48 98                	cltq   
  800421b258:	48 c1 e0 03          	shl    $0x3,%rax
  800421b25c:	48 89 c2             	mov    %rax,%rdx
  800421b25f:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b263:	48 01 c2             	add    %rax,%rdx
  800421b266:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b26d:	00 00 00 
  800421b270:	48 01 d0             	add    %rdx,%rax
  800421b273:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421b277:	c7 45 cc 1c 68 00 00 	movl   $0x681c,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421b27e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421b281:	89 c7                	mov    %eax,%edi
  800421b283:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421b28a:	00 00 00 
  800421b28d:	ff d0                	callq  *%rax
  800421b28f:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
        curenv->env_tf.tf_rip = vmcs_read64(VMCS_GUEST_RIP);
  800421b296:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b29d:	00 00 00 
  800421b2a0:	ff d0                	callq  *%rax
  800421b2a2:	48 98                	cltq   
  800421b2a4:	48 c1 e0 03          	shl    $0x3,%rax
  800421b2a8:	48 89 c2             	mov    %rax,%rdx
  800421b2ab:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b2af:	48 01 c2             	add    %rax,%rdx
  800421b2b2:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b2b9:	00 00 00 
  800421b2bc:	48 01 d0             	add    %rdx,%rax
  800421b2bf:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421b2c3:	c7 45 c8 1e 68 00 00 	movl   $0x681e,-0x38(%rbp)
  800421b2ca:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421b2cd:	89 c7                	mov    %eax,%edi
  800421b2cf:	48 b8 18 8f 21 04 80 	movabs $0x8004218f18,%rax
  800421b2d6:	00 00 00 
  800421b2d9:	ff d0                	callq  *%rax
  800421b2db:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
        vmexit();
  800421b2e2:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b2e7:	48 ba bb ac 21 04 80 	movabs $0x800421acbb,%rdx
  800421b2ee:	00 00 00 
  800421b2f1:	ff d2                	callq  *%rdx
    }
}
  800421b2f3:	48 83 c4 28          	add    $0x28,%rsp
  800421b2f7:	5b                   	pop    %rbx
  800421b2f8:	41 5c                	pop    %r12
  800421b2fa:	41 5d                	pop    %r13
  800421b2fc:	41 5e                	pop    %r14
  800421b2fe:	41 5f                	pop    %r15
  800421b300:	5d                   	pop    %rbp
  800421b301:	c3                   	retq   

000000800421b302 <msr_setup>:

void
msr_setup(struct VmxGuestInfo *ginfo) {
  800421b302:	55                   	push   %rbp
  800421b303:	48 89 e5             	mov    %rsp,%rbp
  800421b306:	41 54                	push   %r12
  800421b308:	53                   	push   %rbx
  800421b309:	48 83 ec 40          	sub    $0x40,%rsp
  800421b30d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct vmx_msr_entry *entry;
    uint32_t idx[] = { EFER_MSR };
  800421b311:	c7 45 c0 80 00 00 c0 	movl   $0xc0000080,-0x40(%rbp)
    int i, count = sizeof(idx) / sizeof(idx[0]);
  800421b318:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%rbp)

    assert(count <= MAX_MSR_COUNT);
  800421b31f:	81 7d e8 80 00 00 00 	cmpl   $0x80,-0x18(%rbp)
  800421b326:	7e 35                	jle    800421b35d <msr_setup+0x5b>
  800421b328:	48 b9 88 f8 21 04 80 	movabs $0x800421f888,%rcx
  800421b32f:	00 00 00 
  800421b332:	48 ba d2 f5 21 04 80 	movabs $0x800421f5d2,%rdx
  800421b339:	00 00 00 
  800421b33c:	be 43 02 00 00       	mov    $0x243,%esi
  800421b341:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421b348:	00 00 00 
  800421b34b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b350:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421b357:	00 00 00 
  800421b35a:	41 ff d0             	callq  *%r8
    ginfo->msr_count = count;
  800421b35d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b361:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421b364:	89 50 28             	mov    %edx,0x28(%rax)
    
    for(i=0; i<count; ++i) {
  800421b367:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800421b36e:	e9 a1 00 00 00       	jmpq   800421b414 <msr_setup+0x112>
        entry = ((struct vmx_msr_entry *)ginfo->msr_host_area) + i;
  800421b373:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b377:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421b37b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421b37e:	48 63 d2             	movslq %edx,%rdx
  800421b381:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b385:	48 01 d0             	add    %rdx,%rax
  800421b388:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        entry->msr_index = idx[i];
  800421b38c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b38f:	48 98                	cltq   
  800421b391:	8b 54 85 c0          	mov    -0x40(%rbp,%rax,4),%edx
  800421b395:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421b399:	89 10                	mov    %edx,(%rax)
        entry->msr_value = read_msr(idx[i]);
  800421b39b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b39e:	48 98                	cltq   
  800421b3a0:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  800421b3a4:	89 45 dc             	mov    %eax,-0x24(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  800421b3a7:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  800421b3aa:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
  800421b3ad:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800421b3b0:	0f 32                	rdmsr  
  800421b3b2:	89 c3                	mov    %eax,%ebx
  800421b3b4:	41 89 d4             	mov    %edx,%r12d
  800421b3b7:	44 89 65 d8          	mov    %r12d,-0x28(%rbp)
  800421b3bb:	89 5d d4             	mov    %ebx,-0x2c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  800421b3be:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  800421b3c5:	00 
    ret = edx;
  800421b3c6:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421b3c9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    ret = ret << 32;
  800421b3cd:	48 c1 65 c8 20       	shlq   $0x20,-0x38(%rbp)
    ret |= eax;
  800421b3d2:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421b3d5:	48 09 45 c8          	or     %rax,-0x38(%rbp)

    return ret;
  800421b3d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b3dd:	48 89 c2             	mov    %rax,%rdx
  800421b3e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421b3e4:	48 89 50 08          	mov    %rdx,0x8(%rax)
        
        entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
  800421b3e8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b3ec:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421b3f0:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421b3f3:	48 63 d2             	movslq %edx,%rdx
  800421b3f6:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b3fa:	48 01 d0             	add    %rdx,%rax
  800421b3fd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        entry->msr_index = idx[i];
  800421b401:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b404:	48 98                	cltq   
  800421b406:	8b 54 85 c0          	mov    -0x40(%rbp,%rax,4),%edx
  800421b40a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421b40e:	89 10                	mov    %edx,(%rax)
    int i, count = sizeof(idx) / sizeof(idx[0]);

    assert(count <= MAX_MSR_COUNT);
    ginfo->msr_count = count;
    
    for(i=0; i<count; ++i) {
  800421b410:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421b414:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b417:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421b41a:	0f 8c 53 ff ff ff    	jl     800421b373 <msr_setup+0x71>
        entry->msr_value = read_msr(idx[i]);
        
        entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
        entry->msr_index = idx[i];
    }
}
  800421b420:	48 83 c4 40          	add    $0x40,%rsp
  800421b424:	5b                   	pop    %rbx
  800421b425:	41 5c                	pop    %r12
  800421b427:	5d                   	pop    %rbp
  800421b428:	c3                   	retq   

000000800421b429 <bitmap_setup>:

void
bitmap_setup(struct VmxGuestInfo *ginfo) {
  800421b429:	55                   	push   %rbp
  800421b42a:	48 89 e5             	mov    %rsp,%rbp
  800421b42d:	53                   	push   %rbx
  800421b42e:	48 83 ec 38          	sub    $0x38,%rsp
  800421b432:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };
  800421b436:	c7 45 d0 70 00 00 00 	movl   $0x70,-0x30(%rbp)
  800421b43d:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
    int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
  800421b444:	c7 45 e8 02 00 00 00 	movl   $0x2,-0x18(%rbp)
    
    for(i=0; i<count; ++i) {
  800421b44b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800421b452:	e9 0d 01 00 00       	jmpq   800421b564 <bitmap_setup+0x13b>
        int idx = io_ports[i] / (sizeof(uint64_t) * 8);
  800421b457:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b45a:	48 98                	cltq   
  800421b45c:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421b460:	c1 e8 06             	shr    $0x6,%eax
  800421b463:	89 45 e4             	mov    %eax,-0x1c(%rbp)
        if(io_ports[i] < 0x7FFF) {
  800421b466:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b469:	48 98                	cltq   
  800421b46b:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421b46f:	3d fe 7f 00 00       	cmp    $0x7ffe,%eax
  800421b474:	77 54                	ja     800421b4ca <bitmap_setup+0xa1>
            ginfo->io_bmap_a[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421b476:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b47a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421b47e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421b481:	48 63 d2             	movslq %edx,%rdx
  800421b484:	48 c1 e2 03          	shl    $0x3,%rdx
  800421b488:	48 01 c2             	add    %rax,%rdx
  800421b48b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b48f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421b493:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421b496:	48 63 c9             	movslq %ecx,%rcx
  800421b499:	48 c1 e1 03          	shl    $0x3,%rcx
  800421b49d:	48 01 c8             	add    %rcx,%rax
  800421b4a0:	48 8b 30             	mov    (%rax),%rsi
  800421b4a3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b4a6:	48 98                	cltq   
  800421b4a8:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421b4ac:	83 e0 3f             	and    $0x3f,%eax
  800421b4af:	bf 01 00 00 00       	mov    $0x1,%edi
  800421b4b4:	48 89 fb             	mov    %rdi,%rbx
  800421b4b7:	89 c1                	mov    %eax,%ecx
  800421b4b9:	48 d3 e3             	shl    %cl,%rbx
  800421b4bc:	48 89 d8             	mov    %rbx,%rax
  800421b4bf:	48 09 f0             	or     %rsi,%rax
  800421b4c2:	48 89 02             	mov    %rax,(%rdx)
  800421b4c5:	e9 96 00 00 00       	jmpq   800421b560 <bitmap_setup+0x137>
        } else if (io_ports[i] < 0xFFFF) {
  800421b4ca:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b4cd:	48 98                	cltq   
  800421b4cf:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421b4d3:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  800421b4d8:	77 51                	ja     800421b52b <bitmap_setup+0x102>
            ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421b4da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b4de:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421b4e2:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421b4e5:	48 63 d2             	movslq %edx,%rdx
  800421b4e8:	48 c1 e2 03          	shl    $0x3,%rdx
  800421b4ec:	48 01 c2             	add    %rax,%rdx
  800421b4ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421b4f3:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421b4f7:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421b4fa:	48 63 c9             	movslq %ecx,%rcx
  800421b4fd:	48 c1 e1 03          	shl    $0x3,%rcx
  800421b501:	48 01 c8             	add    %rcx,%rax
  800421b504:	48 8b 30             	mov    (%rax),%rsi
  800421b507:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b50a:	48 98                	cltq   
  800421b50c:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421b510:	83 e0 3f             	and    $0x3f,%eax
  800421b513:	bf 01 00 00 00       	mov    $0x1,%edi
  800421b518:	48 89 fb             	mov    %rdi,%rbx
  800421b51b:	89 c1                	mov    %eax,%ecx
  800421b51d:	48 d3 e3             	shl    %cl,%rbx
  800421b520:	48 89 d8             	mov    %rbx,%rax
  800421b523:	48 09 f0             	or     %rsi,%rax
  800421b526:	48 89 02             	mov    %rax,(%rdx)
  800421b529:	eb 35                	jmp    800421b560 <bitmap_setup+0x137>
        } else {
            assert(false);
  800421b52b:	48 b9 cc f5 21 04 80 	movabs $0x800421f5cc,%rcx
  800421b532:	00 00 00 
  800421b535:	48 ba d2 f5 21 04 80 	movabs $0x800421f5d2,%rdx
  800421b53c:	00 00 00 
  800421b53f:	be 5c 02 00 00       	mov    $0x25c,%esi
  800421b544:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421b54b:	00 00 00 
  800421b54e:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b553:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421b55a:	00 00 00 
  800421b55d:	41 ff d0             	callq  *%r8
void
bitmap_setup(struct VmxGuestInfo *ginfo) {
    unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };
    int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
    
    for(i=0; i<count; ++i) {
  800421b560:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421b564:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421b567:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421b56a:	0f 8c e7 fe ff ff    	jl     800421b457 <bitmap_setup+0x2e>
            ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
        } else {
            assert(false);
        }
    }
}
  800421b570:	48 83 c4 38          	add    $0x38,%rsp
  800421b574:	5b                   	pop    %rbx
  800421b575:	5d                   	pop    %rbp
  800421b576:	c3                   	retq   

000000800421b577 <vmx_vmrun>:

/* 
 * Processor must be in VMX root operation before executing this function.
 */
int vmx_vmrun( struct Env *e ) {
  800421b577:	55                   	push   %rbp
  800421b578:	48 89 e5             	mov    %rsp,%rbp
  800421b57b:	53                   	push   %rbx
  800421b57c:	48 83 ec 78          	sub    $0x78,%rsp
  800421b580:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)

    if ( e->env_type != ENV_TYPE_GUEST ) {
  800421b584:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b588:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421b58e:	83 f8 03             	cmp    $0x3,%eax
  800421b591:	74 0a                	je     800421b59d <vmx_vmrun+0x26>
        return -E_INVAL;
  800421b593:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421b598:	e9 8e 02 00 00       	jmpq   800421b82b <vmx_vmrun+0x2b4>
    }
    uint8_t error;

    if( e->env_runs == 1 ) {
  800421b59d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b5a1:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421b5a7:	83 f8 01             	cmp    $0x1,%eax
  800421b5aa:	0f 85 2c 01 00 00    	jne    800421b6dc <vmx_vmrun+0x165>
        physaddr_t vmcs_phy_addr = PADDR(e->env_vmxinfo.vmcs);
  800421b5b0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b5b4:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421b5bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421b5bf:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b5c6:	00 00 00 
  800421b5c9:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421b5cd:	77 32                	ja     800421b601 <vmx_vmrun+0x8a>
  800421b5cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421b5d3:	48 89 c1             	mov    %rax,%rcx
  800421b5d6:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421b5dd:	00 00 00 
  800421b5e0:	be 6c 02 00 00       	mov    $0x26c,%esi
  800421b5e5:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421b5ec:	00 00 00 
  800421b5ef:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b5f4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421b5fb:	00 00 00 
  800421b5fe:	41 ff d0             	callq  *%r8
  800421b601:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421b608:	ff ff ff 
  800421b60b:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800421b60f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421b613:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421b617:	48 89 45 98          	mov    %rax,-0x68(%rbp)
}

static __inline uint8_t
vmclear( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421b61b:	c6 45 cf 00          	movb   $0x0,-0x31(%rbp)

    __asm __volatile("clc; vmclear %1; setna %0"
  800421b61f:	f8                   	clc    
  800421b620:	66 0f c7 75 98       	vmclear -0x68(%rbp)
  800421b625:	0f 96 c3             	setbe  %bl
  800421b628:	88 5d cf             	mov    %bl,-0x31(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421b62b:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax

        // Call VMCLEAR on the VMCS region.
        error = vmclear(vmcs_phy_addr);
  800421b62f:	88 45 df             	mov    %al,-0x21(%rbp)
        // Check if VMCLEAR succeeded. ( RFLAGS.CF = 0 and RFLAGS.ZF = 0 )
        if ( error )
  800421b632:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800421b636:	74 0a                	je     800421b642 <vmx_vmrun+0xcb>
            return -E_VMCS_INIT; 
  800421b638:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421b63d:	e9 e9 01 00 00       	jmpq   800421b82b <vmx_vmrun+0x2b4>
  800421b642:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421b646:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421b64a:	c6 45 ce 00          	movb   $0x0,-0x32(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421b64e:	f8                   	clc    
  800421b64f:	0f c7 75 a0          	vmptrld -0x60(%rbp)
  800421b653:	0f 96 c3             	setbe  %bl
  800421b656:	88 5d ce             	mov    %bl,-0x32(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421b659:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax

        // Make this VMCS working VMCS.
        error = vmptrld(vmcs_phy_addr);
  800421b65d:	88 45 df             	mov    %al,-0x21(%rbp)
        if ( error )
  800421b660:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800421b664:	74 0a                	je     800421b670 <vmx_vmrun+0xf9>
            return -E_VMCS_INIT; 
  800421b666:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421b66b:	e9 bb 01 00 00       	jmpq   800421b82b <vmx_vmrun+0x2b4>

        vmcs_host_init();
  800421b670:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b675:	48 ba 87 98 21 04 80 	movabs $0x8004219887,%rdx
  800421b67c:	00 00 00 
  800421b67f:	ff d2                	callq  *%rdx
        vmcs_guest_init();
  800421b681:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b686:	48 ba 76 9c 21 04 80 	movabs $0x8004219c76,%rdx
  800421b68d:	00 00 00 
  800421b690:	ff d2                	callq  *%rdx
        // Setup IO and exception bitmaps.
        bitmap_setup(&e->env_vmxinfo);
  800421b692:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b696:	48 05 20 01 00 00    	add    $0x120,%rax
  800421b69c:	48 89 c7             	mov    %rax,%rdi
  800421b69f:	48 b8 29 b4 21 04 80 	movabs $0x800421b429,%rax
  800421b6a6:	00 00 00 
  800421b6a9:	ff d0                	callq  *%rax
        // Setup the msr load/store area
        msr_setup(&e->env_vmxinfo);
  800421b6ab:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b6af:	48 05 20 01 00 00    	add    $0x120,%rax
  800421b6b5:	48 89 c7             	mov    %rax,%rdi
  800421b6b8:	48 b8 02 b3 21 04 80 	movabs $0x800421b302,%rax
  800421b6bf:	00 00 00 
  800421b6c2:	ff d0                	callq  *%rax
        vmcs_ctls_init(e);
  800421b6c4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b6c8:	48 89 c7             	mov    %rax,%rdi
  800421b6cb:	48 b8 3f a5 21 04 80 	movabs $0x800421a53f,%rax
  800421b6d2:	00 00 00 
  800421b6d5:	ff d0                	callq  *%rax
  800421b6d7:	e9 89 00 00 00       	jmpq   800421b765 <vmx_vmrun+0x1ee>

        /* ept_alloc_static(e->env_pml4e, &e->env_vmxinfo); */

    } else {
        // Make this VMCS working VMCS.
        error = vmptrld(PADDR(e->env_vmxinfo.vmcs));
  800421b6dc:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b6e0:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421b6e7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421b6eb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b6f2:	00 00 00 
  800421b6f5:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800421b6f9:	77 32                	ja     800421b72d <vmx_vmrun+0x1b6>
  800421b6fb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421b6ff:	48 89 c1             	mov    %rax,%rcx
  800421b702:	48 ba 30 f6 21 04 80 	movabs $0x800421f630,%rdx
  800421b709:	00 00 00 
  800421b70c:	be 85 02 00 00       	mov    $0x285,%esi
  800421b711:	48 bf e7 f5 21 04 80 	movabs $0x800421f5e7,%rdi
  800421b718:	00 00 00 
  800421b71b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b720:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421b727:	00 00 00 
  800421b72a:	41 ff d0             	callq  *%r8
  800421b72d:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800421b734:	ff ff ff 
  800421b737:	48 03 45 d0          	add    -0x30(%rbp),%rax
  800421b73b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    return error;
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421b73f:	c6 45 cd 00          	movb   $0x0,-0x33(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421b743:	f8                   	clc    
  800421b744:	0f c7 75 a8          	vmptrld -0x58(%rbp)
  800421b748:	0f 96 c3             	setbe  %bl
  800421b74b:	88 5d cd             	mov    %bl,-0x33(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421b74e:	0f b6 45 cd          	movzbl -0x33(%rbp),%eax
  800421b752:	88 45 df             	mov    %al,-0x21(%rbp)
        if ( error ) {
  800421b755:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800421b759:	74 0a                	je     800421b765 <vmx_vmrun+0x1ee>
            return -E_VMCS_INIT; 
  800421b75b:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421b760:	e9 c6 00 00 00       	jmpq   800421b82b <vmx_vmrun+0x2b4>
        }
    }

    vmcs_write64( VMCS_GUEST_RSP, curenv->env_tf.tf_rsp  );
  800421b765:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b76c:	00 00 00 
  800421b76f:	ff d0                	callq  *%rax
  800421b771:	48 98                	cltq   
  800421b773:	48 c1 e0 03          	shl    $0x3,%rax
  800421b777:	48 89 c2             	mov    %rax,%rdx
  800421b77a:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b77e:	48 01 c2             	add    %rax,%rdx
  800421b781:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b788:	00 00 00 
  800421b78b:	48 01 d0             	add    %rdx,%rax
  800421b78e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421b792:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800421b799:	c7 45 c8 1c 68 00 00 	movl   $0x681c,-0x38(%rbp)
  800421b7a0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b7a4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421b7a8:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421b7ab:	48 89 d6             	mov    %rdx,%rsi
  800421b7ae:	89 c7                	mov    %eax,%edi
  800421b7b0:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421b7b7:	00 00 00 
  800421b7ba:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_GUEST_RIP, curenv->env_tf.tf_rip );
  800421b7bc:	48 b8 2d 73 21 04 80 	movabs $0x800421732d,%rax
  800421b7c3:	00 00 00 
  800421b7c6:	ff d0                	callq  *%rax
  800421b7c8:	48 98                	cltq   
  800421b7ca:	48 c1 e0 03          	shl    $0x3,%rax
  800421b7ce:	48 89 c2             	mov    %rax,%rdx
  800421b7d1:	48 c1 e2 04          	shl    $0x4,%rdx
  800421b7d5:	48 01 c2             	add    %rax,%rdx
  800421b7d8:	48 b8 20 50 48 04 80 	movabs $0x8004485020,%rax
  800421b7df:	00 00 00 
  800421b7e2:	48 01 d0             	add    %rdx,%rax
  800421b7e5:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421b7e9:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421b7f0:	c7 45 bc 1e 68 00 00 	movl   $0x681e,-0x44(%rbp)
  800421b7f7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  800421b7fb:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421b7ff:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421b802:	48 89 d6             	mov    %rdx,%rsi
  800421b805:	89 c7                	mov    %eax,%edi
  800421b807:	48 b8 ec 8e 21 04 80 	movabs $0x8004218eec,%rax
  800421b80e:	00 00 00 
  800421b811:	ff d0                	callq  *%rax
    asm_vmrun( &e->env_tf );
  800421b813:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421b817:	48 89 c7             	mov    %rax,%rdi
  800421b81a:	48 b8 f9 b0 21 04 80 	movabs $0x800421b0f9,%rax
  800421b821:	00 00 00 
  800421b824:	ff d0                	callq  *%rax
    return 0;
  800421b826:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421b82b:	48 83 c4 78          	add    $0x78,%rsp
  800421b82f:	5b                   	pop    %rbx
  800421b830:	5d                   	pop    %rbp
  800421b831:	c3                   	retq   
	...

000000800421b834 <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  800421b834:	55                   	push   %rbp
  800421b835:	48 89 e5             	mov    %rsp,%rbp
  800421b838:	53                   	push   %rbx
  800421b839:	48 83 ec 20          	sub    $0x20,%rsp
  800421b83d:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  800421b840:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  800421b844:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421b848:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421b84b:	f8                   	clc    
  800421b84c:	0f 79 d0             	vmwrite %rax,%rdx
  800421b84f:	0f 96 c3             	setbe  %bl
  800421b852:	88 5d f7             	mov    %bl,-0x9(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  800421b855:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  800421b859:	48 83 c4 20          	add    $0x20,%rsp
  800421b85d:	5b                   	pop    %rbx
  800421b85e:	5d                   	pop    %rbp
  800421b85f:	c3                   	retq   

000000800421b860 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  800421b860:	55                   	push   %rbp
  800421b861:	48 89 e5             	mov    %rsp,%rbp
  800421b864:	53                   	push   %rbx
  800421b865:	48 83 ec 18          	sub    $0x18,%rsp
  800421b869:	89 7d e4             	mov    %edi,-0x1c(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  800421b86c:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421b86f:	89 55 e0             	mov    %edx,-0x20(%rbp)
  800421b872:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800421b875:	0f 78 d0             	vmread %rdx,%rax
  800421b878:	48 89 c3             	mov    %rax,%rbx
  800421b87b:	48 89 5d f0          	mov    %rbx,-0x10(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  800421b87f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421b883:	48 83 c4 18          	add    $0x18,%rsp
  800421b887:	5b                   	pop    %rbx
  800421b888:	5d                   	pop    %rbp
  800421b889:	c3                   	retq   

000000800421b88a <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  800421b88a:	55                   	push   %rbp
  800421b88b:	48 89 e5             	mov    %rsp,%rbp
  800421b88e:	41 56                	push   %r14
  800421b890:	41 55                	push   %r13
  800421b892:	41 54                	push   %r12
  800421b894:	53                   	push   %rbx
  800421b895:	48 83 ec 38          	sub    $0x38,%rsp
  800421b899:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800421b89c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421b8a0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421b8a4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421b8a8:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  800421b8ac:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421b8af:	89 45 c8             	mov    %eax,-0x38(%rbp)
  800421b8b2:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421b8b5:	0f a2                	cpuid  
  800421b8b7:	41 89 d4             	mov    %edx,%r12d
  800421b8ba:	41 89 cd             	mov    %ecx,%r13d
  800421b8bd:	41 89 c6             	mov    %eax,%r14d
  800421b8c0:	44 89 75 dc          	mov    %r14d,-0x24(%rbp)
  800421b8c4:	89 5d d8             	mov    %ebx,-0x28(%rbp)
  800421b8c7:	44 89 6d d4          	mov    %r13d,-0x2c(%rbp)
  800421b8cb:	44 89 65 d0          	mov    %r12d,-0x30(%rbp)
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
	if (eaxp)
  800421b8cf:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421b8d4:	74 09                	je     800421b8df <cpuid+0x55>
		*eaxp = eax;
  800421b8d6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421b8da:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421b8dd:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  800421b8df:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800421b8e4:	74 09                	je     800421b8ef <cpuid+0x65>
		*ebxp = ebx;
  800421b8e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421b8ea:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800421b8ed:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  800421b8ef:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  800421b8f4:	74 09                	je     800421b8ff <cpuid+0x75>
		*ecxp = ecx;
  800421b8f6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421b8fa:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800421b8fd:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421b8ff:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800421b904:	74 09                	je     800421b90f <cpuid+0x85>
		*edxp = edx;
  800421b906:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421b90a:	8b 55 d0             	mov    -0x30(%rbp),%edx
  800421b90d:	89 10                	mov    %edx,(%rax)
}
  800421b90f:	48 83 c4 38          	add    $0x38,%rsp
  800421b913:	5b                   	pop    %rbx
  800421b914:	41 5c                	pop    %r12
  800421b916:	41 5d                	pop    %r13
  800421b918:	41 5e                	pop    %r14
  800421b91a:	5d                   	pop    %rbp
  800421b91b:	c3                   	retq   

000000800421b91c <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421b91c:	55                   	push   %rbp
  800421b91d:	48 89 e5             	mov    %rsp,%rbp
  800421b920:	48 83 ec 08          	sub    $0x8,%rsp
  800421b924:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421b928:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421b92c:	48 b8 78 37 48 04 80 	movabs $0x8004483778,%rax
  800421b933:	00 00 00 
  800421b936:	48 8b 00             	mov    (%rax),%rax
  800421b939:	48 89 d1             	mov    %rdx,%rcx
  800421b93c:	48 29 c1             	sub    %rax,%rcx
  800421b93f:	48 89 c8             	mov    %rcx,%rax
  800421b942:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421b946:	c9                   	leaveq 
  800421b947:	c3                   	retq   

000000800421b948 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421b948:	55                   	push   %rbp
  800421b949:	48 89 e5             	mov    %rsp,%rbp
  800421b94c:	48 83 ec 08          	sub    $0x8,%rsp
  800421b950:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421b954:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b958:	48 89 c7             	mov    %rax,%rdi
  800421b95b:	48 b8 1c b9 21 04 80 	movabs $0x800421b91c,%rax
  800421b962:	00 00 00 
  800421b965:	ff d0                	callq  *%rax
  800421b967:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421b96b:	c9                   	leaveq 
  800421b96c:	c3                   	retq   

000000800421b96d <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800421b96d:	55                   	push   %rbp
  800421b96e:	48 89 e5             	mov    %rsp,%rbp
  800421b971:	48 83 ec 20          	sub    $0x20,%rsp
  800421b975:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421b979:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421b97d:	48 89 c7             	mov    %rax,%rdi
  800421b980:	48 b8 48 b9 21 04 80 	movabs $0x800421b948,%rax
  800421b987:	00 00 00 
  800421b98a:	ff d0                	callq  *%rax
  800421b98c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421b990:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b994:	48 c1 e8 0c          	shr    $0xc,%rax
  800421b998:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421b99b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421b99e:	48 b8 70 37 48 04 80 	movabs $0x8004483770,%rax
  800421b9a5:	00 00 00 
  800421b9a8:	48 8b 00             	mov    (%rax),%rax
  800421b9ab:	48 39 c2             	cmp    %rax,%rdx
  800421b9ae:	72 32                	jb     800421b9e2 <page2kva+0x75>
  800421b9b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b9b4:	48 89 c1             	mov    %rax,%rcx
  800421b9b7:	48 ba a0 f8 21 04 80 	movabs $0x800421f8a0,%rdx
  800421b9be:	00 00 00 
  800421b9c1:	be 5b 00 00 00       	mov    $0x5b,%esi
  800421b9c6:	48 bf c3 f8 21 04 80 	movabs $0x800421f8c3,%rdi
  800421b9cd:	00 00 00 
  800421b9d0:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b9d5:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421b9dc:	00 00 00 
  800421b9df:	41 ff d0             	callq  *%r8
  800421b9e2:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800421b9e9:	00 00 00 
  800421b9ec:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  800421b9f0:	c9                   	leaveq 
  800421b9f1:	c3                   	retq   

000000800421b9f2 <find_msr_in_region>:
#include <kern/syscall.h>
#include <kern/env.h>


bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
  800421b9f2:	55                   	push   %rbp
  800421b9f3:	48 89 e5             	mov    %rsp,%rbp
  800421b9f6:	48 83 ec 28          	sub    $0x28,%rsp
  800421b9fa:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421b9fd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421ba01:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421ba04:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
  800421ba08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421ba0c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    int i;
    for(i=0; i<area_sz; ++i) {
  800421ba10:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421ba17:	eb 21                	jmp    800421ba3a <find_msr_in_region+0x48>
        if(entry->msr_index == msr_idx) {
  800421ba19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421ba1d:	8b 00                	mov    (%rax),%eax
  800421ba1f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421ba22:	75 12                	jne    800421ba36 <find_msr_in_region+0x44>
            *msr_entry = entry;
  800421ba24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ba28:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421ba2c:	48 89 10             	mov    %rdx,(%rax)
            return true;
  800421ba2f:	b8 01 00 00 00       	mov    $0x1,%eax
  800421ba34:	eb 11                	jmp    800421ba47 <find_msr_in_region+0x55>

bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
    struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
    int i;
    for(i=0; i<area_sz; ++i) {
  800421ba36:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421ba3a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421ba3d:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421ba40:	7c d7                	jl     800421ba19 <find_msr_in_region+0x27>
        if(entry->msr_index == msr_idx) {
            *msr_entry = entry;
            return true;
        }
    }
    return false;
  800421ba42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421ba47:	c9                   	leaveq 
  800421ba48:	c3                   	retq   

000000800421ba49 <handle_rdmsr>:

bool
handle_rdmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421ba49:	55                   	push   %rbp
  800421ba4a:	48 89 e5             	mov    %rsp,%rbp
  800421ba4d:	53                   	push   %rbx
  800421ba4e:	48 83 ec 48          	sub    $0x48,%rsp
  800421ba52:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421ba56:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    uint64_t msr = tf->tf_regs.reg_rcx;
  800421ba5a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421ba5e:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421ba62:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(msr == EFER_MSR) {
  800421ba66:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421ba6b:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421ba6f:	0f 85 d4 00 00 00    	jne    800421bb49 <handle_rdmsr+0x100>
        // TODO: setup msr_bitmap to ignore EFER_MSR
        uint64_t val;
        struct vmx_msr_entry *entry;
        bool r = find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421ba75:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421ba79:	8b 50 28             	mov    0x28(%rax),%edx
  800421ba7c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421ba80:	48 8b 70 38          	mov    0x38(%rax),%rsi
  800421ba84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421ba88:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  800421ba8c:	89 c7                	mov    %eax,%edi
  800421ba8e:	48 b8 f2 b9 21 04 80 	movabs $0x800421b9f2,%rax
  800421ba95:	00 00 00 
  800421ba98:	ff d0                	callq  *%rax
  800421ba9a:	88 45 e7             	mov    %al,-0x19(%rbp)
        assert(r);
  800421ba9d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421baa1:	83 f0 01             	xor    $0x1,%eax
  800421baa4:	84 c0                	test   %al,%al
  800421baa6:	74 35                	je     800421badd <handle_rdmsr+0x94>
  800421baa8:	48 b9 d1 f8 21 04 80 	movabs $0x800421f8d1,%rcx
  800421baaf:	00 00 00 
  800421bab2:	48 ba d3 f8 21 04 80 	movabs $0x800421f8d3,%rdx
  800421bab9:	00 00 00 
  800421babc:	be 26 00 00 00       	mov    $0x26,%esi
  800421bac1:	48 bf e8 f8 21 04 80 	movabs $0x800421f8e8,%rdi
  800421bac8:	00 00 00 
  800421bacb:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bad0:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421bad7:	00 00 00 
  800421bada:	41 ff d0             	callq  *%r8
        val = entry->msr_value;
  800421badd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bae1:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421bae5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

        tf->tf_regs.reg_rdx = val << 32;
  800421bae9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421baed:	48 89 c2             	mov    %rax,%rdx
  800421baf0:	48 c1 e2 20          	shl    $0x20,%rdx
  800421baf4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421baf8:	48 89 50 58          	mov    %rdx,0x58(%rax)
        tf->tf_regs.reg_rax = val & 0xFFFFFFFF;
  800421bafc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bb00:	48 89 c2             	mov    %rax,%rdx
  800421bb03:	83 e2 ff             	and    $0xffffffff,%edx
  800421bb06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bb0a:	48 89 50 70          	mov    %rdx,0x70(%rax)

        tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421bb0e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bb12:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421bb19:	c7 45 d4 0c 44 00 00 	movl   $0x440c,-0x2c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421bb20:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421bb23:	89 c7                	mov    %eax,%edi
  800421bb25:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421bb2c:	00 00 00 
  800421bb2f:	ff d0                	callq  *%rax
  800421bb31:	89 c0                	mov    %eax,%eax
  800421bb33:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421bb37:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bb3b:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
        return true;
  800421bb42:	b8 01 00 00 00       	mov    $0x1,%eax
  800421bb47:	eb 05                	jmp    800421bb4e <handle_rdmsr+0x105>
    }

    return false;
  800421bb49:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421bb4e:	48 83 c4 48          	add    $0x48,%rsp
  800421bb52:	5b                   	pop    %rbx
  800421bb53:	5d                   	pop    %rbp
  800421bb54:	c3                   	retq   

000000800421bb55 <handle_wrmsr>:

bool 
handle_wrmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421bb55:	55                   	push   %rbp
  800421bb56:	48 89 e5             	mov    %rsp,%rbp
  800421bb59:	53                   	push   %rbx
  800421bb5a:	48 83 ec 58          	sub    $0x58,%rsp
  800421bb5e:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800421bb62:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    uint64_t msr = tf->tf_regs.reg_rcx;
  800421bb66:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421bb6a:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421bb6e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(msr == EFER_MSR) {
  800421bb72:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421bb77:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421bb7b:	0f 85 3b 01 00 00    	jne    800421bcbc <handle_wrmsr+0x167>

        uint64_t cur_val, new_val;
        struct vmx_msr_entry *entry;
        bool r = 
            find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421bb81:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421bb85:	8b 50 28             	mov    0x28(%rax),%edx
  800421bb88:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421bb8c:	48 8b 70 38          	mov    0x38(%rax),%rsi
  800421bb90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421bb94:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
    uint64_t msr = tf->tf_regs.reg_rcx;
    if(msr == EFER_MSR) {

        uint64_t cur_val, new_val;
        struct vmx_msr_entry *entry;
        bool r = 
  800421bb98:	89 c7                	mov    %eax,%edi
  800421bb9a:	48 b8 f2 b9 21 04 80 	movabs $0x800421b9f2,%rax
  800421bba1:	00 00 00 
  800421bba4:	ff d0                	callq  *%rax
  800421bba6:	88 45 e7             	mov    %al,-0x19(%rbp)
            find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
        assert(r);
  800421bba9:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421bbad:	83 f0 01             	xor    $0x1,%eax
  800421bbb0:	84 c0                	test   %al,%al
  800421bbb2:	74 35                	je     800421bbe9 <handle_wrmsr+0x94>
  800421bbb4:	48 b9 d1 f8 21 04 80 	movabs $0x800421f8d1,%rcx
  800421bbbb:	00 00 00 
  800421bbbe:	48 ba d3 f8 21 04 80 	movabs $0x800421f8d3,%rdx
  800421bbc5:	00 00 00 
  800421bbc8:	be 3c 00 00 00       	mov    $0x3c,%esi
  800421bbcd:	48 bf e8 f8 21 04 80 	movabs $0x800421f8e8,%rdi
  800421bbd4:	00 00 00 
  800421bbd7:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bbdc:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421bbe3:	00 00 00 
  800421bbe6:	41 ff d0             	callq  *%r8
        cur_val = entry->msr_value;
  800421bbe9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421bbed:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421bbf1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

        new_val = (tf->tf_regs.reg_rdx << 32)|tf->tf_regs.reg_rax;
  800421bbf5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421bbf9:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421bbfd:	48 89 c2             	mov    %rax,%rdx
  800421bc00:	48 c1 e2 20          	shl    $0x20,%rdx
  800421bc04:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421bc08:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421bc0c:	48 09 d0             	or     %rdx,%rax
  800421bc0f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        if(BIT(cur_val, EFER_LME) == 0 && BIT(new_val, EFER_LME) == 1) {
  800421bc13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bc17:	25 00 01 00 00       	and    $0x100,%eax
  800421bc1c:	48 85 c0             	test   %rax,%rax
  800421bc1f:	75 54                	jne    800421bc75 <handle_wrmsr+0x120>
  800421bc21:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421bc25:	25 00 01 00 00       	and    $0x100,%eax
  800421bc2a:	48 85 c0             	test   %rax,%rax
  800421bc2d:	74 46                	je     800421bc75 <handle_wrmsr+0x120>
  800421bc2f:	c7 45 c8 12 40 00 00 	movl   $0x4012,-0x38(%rbp)
  800421bc36:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421bc39:	89 c7                	mov    %eax,%edi
  800421bc3b:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421bc42:	00 00 00 
  800421bc45:	ff d0                	callq  *%rax
            // Long mode enable.
            uint32_t entry_ctls = vmcs_read32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS );
  800421bc47:	89 45 cc             	mov    %eax,-0x34(%rbp)
            entry_ctls |= VMCS_VMENTRY_x64_GUEST;
  800421bc4a:	81 4d cc 00 02 00 00 	orl    $0x200,-0x34(%rbp)
  800421bc51:	c7 45 c4 12 40 00 00 	movl   $0x4012,-0x3c(%rbp)
  800421bc58:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421bc5b:	89 45 c0             	mov    %eax,-0x40(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421bc5e:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421bc61:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421bc64:	48 89 d6             	mov    %rdx,%rsi
  800421bc67:	89 c7                	mov    %eax,%edi
  800421bc69:	48 b8 34 b8 21 04 80 	movabs $0x800421b834,%rax
  800421bc70:	00 00 00 
  800421bc73:	ff d0                	callq  *%rax
            vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
                    entry_ctls );

        }

        entry->msr_value = new_val;
  800421bc75:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421bc79:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421bc7d:	48 89 50 08          	mov    %rdx,0x8(%rax)
        tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421bc81:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421bc85:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421bc8c:	c7 45 bc 0c 44 00 00 	movl   $0x440c,-0x44(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421bc93:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421bc96:	89 c7                	mov    %eax,%edi
  800421bc98:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421bc9f:	00 00 00 
  800421bca2:	ff d0                	callq  *%rax
  800421bca4:	89 c0                	mov    %eax,%eax
  800421bca6:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421bcaa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421bcae:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
        return true;
  800421bcb5:	b8 01 00 00 00       	mov    $0x1,%eax
  800421bcba:	eb 05                	jmp    800421bcc1 <handle_wrmsr+0x16c>
    }

    return false;
  800421bcbc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421bcc1:	48 83 c4 58          	add    $0x58,%rsp
  800421bcc5:	5b                   	pop    %rbx
  800421bcc6:	5d                   	pop    %rbp
  800421bcc7:	c3                   	retq   

000000800421bcc8 <handle_eptviolation>:

bool
handle_eptviolation(uint64_t *eptrt, struct VmxGuestInfo *ginfo) {
  800421bcc8:	55                   	push   %rbp
  800421bcc9:	48 89 e5             	mov    %rsp,%rbp
  800421bccc:	53                   	push   %rbx
  800421bccd:	48 83 ec 48          	sub    $0x48,%rsp
  800421bcd1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421bcd5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800421bcd9:	c7 45 cc 00 24 00 00 	movl   $0x2400,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421bce0:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421bce3:	89 c7                	mov    %eax,%edi
  800421bce5:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421bcec:	00 00 00 
  800421bcef:	ff d0                	callq  *%rax
    uint64_t gpa = vmcs_read64(VMCS_64BIT_GUEST_PHYSICAL_ADDR);
  800421bcf1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;
    if(gpa < 0xA0000 || (gpa >= 0x100000 && gpa < ginfo->phys_sz)) {
  800421bcf5:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  800421bcfc:	00 
  800421bcfd:	76 1f                	jbe    800421bd1e <handle_eptviolation+0x56>
  800421bcff:	48 81 7d e8 ff ff 0f 	cmpq   $0xfffff,-0x18(%rbp)
  800421bd06:	00 
  800421bd07:	0f 86 de 00 00 00    	jbe    800421bdeb <handle_eptviolation+0x123>
  800421bd0d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421bd11:	48 8b 00             	mov    (%rax),%rax
  800421bd14:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421bd18:	0f 86 cd 00 00 00    	jbe    800421bdeb <handle_eptviolation+0x123>
        // Allocate a new page to the guest.
        struct PageInfo *p = page_alloc(0);
  800421bd1e:	bf 00 00 00 00       	mov    $0x0,%edi
  800421bd23:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800421bd2a:	00 00 00 
  800421bd2d:	ff d0                	callq  *%rax
  800421bd2f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        if(!p)
  800421bd33:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421bd38:	75 0a                	jne    800421bd44 <handle_eptviolation+0x7c>
            return false;
  800421bd3a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bd3f:	e9 32 01 00 00       	jmpq   800421be76 <handle_eptviolation+0x1ae>
        p->pp_ref += 1;
  800421bd44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bd48:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421bd4c:	8d 50 01             	lea    0x1(%rax),%edx
  800421bd4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bd53:	66 89 50 08          	mov    %dx,0x8(%rax)
        r = ept_map_hva2gpa(eptrt, 
                page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
  800421bd57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421bd5b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421bd5f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421bd63:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
        // Allocate a new page to the guest.
        struct PageInfo *p = page_alloc(0);
        if(!p)
            return false;
        p->pp_ref += 1;
        r = ept_map_hva2gpa(eptrt, 
  800421bd69:	48 89 c3             	mov    %rax,%rbx
  800421bd6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bd70:	48 89 c7             	mov    %rax,%rdi
  800421bd73:	48 b8 6d b9 21 04 80 	movabs $0x800421b96d,%rax
  800421bd7a:	00 00 00 
  800421bd7d:	ff d0                	callq  *%rax
  800421bd7f:	48 89 c6             	mov    %rax,%rsi
  800421bd82:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bd86:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421bd8c:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421bd91:	48 89 da             	mov    %rbx,%rdx
  800421bd94:	48 89 c7             	mov    %rax,%rdi
  800421bd97:	48 b8 59 8c 21 04 80 	movabs $0x8004218c59,%rax
  800421bd9e:	00 00 00 
  800421bda1:	ff d0                	callq  *%rax
  800421bda3:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
        assert(r >= 0);
  800421bda6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421bdaa:	79 35                	jns    800421bde1 <handle_eptviolation+0x119>
  800421bdac:	48 b9 f6 f8 21 04 80 	movabs $0x800421f8f6,%rcx
  800421bdb3:	00 00 00 
  800421bdb6:	48 ba d3 f8 21 04 80 	movabs $0x800421f8d3,%rdx
  800421bdbd:	00 00 00 
  800421bdc0:	be 5d 00 00 00       	mov    $0x5d,%esi
  800421bdc5:	48 bf e8 f8 21 04 80 	movabs $0x800421f8e8,%rdi
  800421bdcc:	00 00 00 
  800421bdcf:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bdd4:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421bddb:	00 00 00 
  800421bdde:	41 ff d0             	callq  *%r8
        //cprintf("EPT violation for gpa:%x mapped KVA:%x\n", gpa, page2kva(p));
        return true;
  800421bde1:	b8 01 00 00 00       	mov    $0x1,%eax
  800421bde6:	e9 8b 00 00 00       	jmpq   800421be76 <handle_eptviolation+0x1ae>
    } else if (gpa >= CGA_BUF && gpa < CGA_BUF + PGSIZE) {
  800421bdeb:	48 81 7d e8 ff 7f 0b 	cmpq   $0xb7fff,-0x18(%rbp)
  800421bdf2:	00 
  800421bdf3:	76 7c                	jbe    800421be71 <handle_eptviolation+0x1a9>
  800421bdf5:	48 81 7d e8 ff 8f 0b 	cmpq   $0xb8fff,-0x18(%rbp)
  800421bdfc:	00 
  800421bdfd:	77 72                	ja     800421be71 <handle_eptviolation+0x1a9>
        // FIXME: This give direct access to VGA MMIO region.
        r = ept_map_hva2gpa(eptrt, 
  800421bdff:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421be03:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421be09:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421be0e:	ba 00 80 0b 00       	mov    $0xb8000,%edx
  800421be13:	48 be 00 80 0b 04 80 	movabs $0x80040b8000,%rsi
  800421be1a:	00 00 00 
  800421be1d:	48 89 c7             	mov    %rax,%rdi
  800421be20:	48 b8 59 8c 21 04 80 	movabs $0x8004218c59,%rax
  800421be27:	00 00 00 
  800421be2a:	ff d0                	callq  *%rax
  800421be2c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                (void *)(KERNBASE + CGA_BUF), (void *)CGA_BUF, __EPTE_FULL, 0);
        assert(r >= 0);
  800421be2f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421be33:	79 35                	jns    800421be6a <handle_eptviolation+0x1a2>
  800421be35:	48 b9 f6 f8 21 04 80 	movabs $0x800421f8f6,%rcx
  800421be3c:	00 00 00 
  800421be3f:	48 ba d3 f8 21 04 80 	movabs $0x800421f8d3,%rdx
  800421be46:	00 00 00 
  800421be49:	be 64 00 00 00       	mov    $0x64,%esi
  800421be4e:	48 bf e8 f8 21 04 80 	movabs $0x800421f8e8,%rdi
  800421be55:	00 00 00 
  800421be58:	b8 00 00 00 00       	mov    $0x0,%eax
  800421be5d:	49 b8 c2 04 20 04 80 	movabs $0x80042004c2,%r8
  800421be64:	00 00 00 
  800421be67:	41 ff d0             	callq  *%r8
        return true;
  800421be6a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421be6f:	eb 05                	jmp    800421be76 <handle_eptviolation+0x1ae>
    } 
    return false;
  800421be71:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421be76:	48 83 c4 48          	add    $0x48,%rsp
  800421be7a:	5b                   	pop    %rbx
  800421be7b:	5d                   	pop    %rbp
  800421be7c:	c3                   	retq   

000000800421be7d <handle_ioinstr>:

bool
handle_ioinstr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421be7d:	55                   	push   %rbp
  800421be7e:	48 89 e5             	mov    %rsp,%rbp
  800421be81:	53                   	push   %rbx
  800421be82:	48 83 ec 38          	sub    $0x38,%rsp
  800421be86:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421be8a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421be8e:	c7 45 d4 00 64 00 00 	movl   $0x6400,-0x2c(%rbp)
  800421be95:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421be98:	89 c7                	mov    %eax,%edi
  800421be9a:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421bea1:	00 00 00 
  800421bea4:	ff d0                	callq  *%rax
    static int port_iortc;

    uint64_t qualification = vmcs_read64(VMCS_VMEXIT_QUALIFICATION);
  800421bea6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    int port_number = (qualification >> 16) & 0xFFFF;
  800421beaa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421beae:	48 c1 e8 10          	shr    $0x10,%rax
  800421beb2:	25 ff ff 00 00       	and    $0xffff,%eax
  800421beb7:	89 45 dc             	mov    %eax,-0x24(%rbp)
    bool is_in = BIT(qualification, 3);
  800421beba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421bebe:	48 c1 e8 03          	shr    $0x3,%rax
  800421bec2:	83 e0 01             	and    $0x1,%eax
  800421bec5:	48 85 c0             	test   %rax,%rax
  800421bec8:	0f 95 c0             	setne  %al
  800421becb:	88 45 db             	mov    %al,-0x25(%rbp)
    bool handled = false;
  800421bece:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    // handle reading physical memory from the CMOS.
    if(port_number == IO_RTC) {
  800421bed2:	83 7d dc 70          	cmpl   $0x70,-0x24(%rbp)
  800421bed6:	75 2e                	jne    800421bf06 <handle_ioinstr+0x89>
        if(!is_in) {
  800421bed8:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800421bedc:	83 f0 01             	xor    $0x1,%eax
  800421bedf:	84 c0                	test   %al,%al
  800421bee1:	0f 84 de 00 00 00    	je     800421bfc5 <handle_ioinstr+0x148>
            port_iortc = tf->tf_regs.reg_rax;
  800421bee7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421beeb:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421beef:	89 c2                	mov    %eax,%edx
  800421bef1:	48 b8 44 37 48 04 80 	movabs $0x8004483744,%rax
  800421bef8:	00 00 00 
  800421befb:	89 10                	mov    %edx,(%rax)
            handled = true;
  800421befd:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421bf01:	e9 bf 00 00 00       	jmpq   800421bfc5 <handle_ioinstr+0x148>
        }
    } else if (port_number == IO_RTC + 1) {
  800421bf06:	83 7d dc 71          	cmpl   $0x71,-0x24(%rbp)
  800421bf0a:	0f 85 b5 00 00 00    	jne    800421bfc5 <handle_ioinstr+0x148>
        if(is_in) {
  800421bf10:	80 7d db 00          	cmpb   $0x0,-0x25(%rbp)
  800421bf14:	0f 84 ab 00 00 00    	je     800421bfc5 <handle_ioinstr+0x148>
            if(port_iortc == NVRAM_BASELO) {
  800421bf1a:	48 b8 44 37 48 04 80 	movabs $0x8004483744,%rax
  800421bf21:	00 00 00 
  800421bf24:	8b 00                	mov    (%rax),%eax
  800421bf26:	83 f8 15             	cmp    $0x15,%eax
  800421bf29:	75 15                	jne    800421bf40 <handle_ioinstr+0xc3>
                tf->tf_regs.reg_rax = 640 & 0xFF;
  800421bf2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bf2f:	48 c7 40 70 80 00 00 	movq   $0x80,0x70(%rax)
  800421bf36:	00 
                handled = true;
  800421bf37:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421bf3b:	e9 85 00 00 00       	jmpq   800421bfc5 <handle_ioinstr+0x148>
            } else if (port_iortc == NVRAM_BASEHI) {
  800421bf40:	48 b8 44 37 48 04 80 	movabs $0x8004483744,%rax
  800421bf47:	00 00 00 
  800421bf4a:	8b 00                	mov    (%rax),%eax
  800421bf4c:	83 f8 16             	cmp    $0x16,%eax
  800421bf4f:	75 12                	jne    800421bf63 <handle_ioinstr+0xe6>
                tf->tf_regs.reg_rax = (640 >> 8) & 0xFF;
  800421bf51:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bf55:	48 c7 40 70 02 00 00 	movq   $0x2,0x70(%rax)
  800421bf5c:	00 
                handled = true;
  800421bf5d:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421bf61:	eb 62                	jmp    800421bfc5 <handle_ioinstr+0x148>
            } else if (port_iortc == NVRAM_EXTLO) {
  800421bf63:	48 b8 44 37 48 04 80 	movabs $0x8004483744,%rax
  800421bf6a:	00 00 00 
  800421bf6d:	8b 00                	mov    (%rax),%eax
  800421bf6f:	83 f8 17             	cmp    $0x17,%eax
  800421bf72:	75 1c                	jne    800421bf90 <handle_ioinstr+0x113>
                tf->tf_regs.reg_rax = ((ginfo->phys_sz / 1024) - 1024) & 0xFF;
  800421bf74:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421bf78:	48 8b 00             	mov    (%rax),%rax
  800421bf7b:	48 c1 e8 0a          	shr    $0xa,%rax
  800421bf7f:	0f b6 d0             	movzbl %al,%edx
  800421bf82:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bf86:	48 89 50 70          	mov    %rdx,0x70(%rax)
                handled = true;
  800421bf8a:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421bf8e:	eb 35                	jmp    800421bfc5 <handle_ioinstr+0x148>
            } else if (port_iortc == NVRAM_EXTHI) {
  800421bf90:	48 b8 44 37 48 04 80 	movabs $0x8004483744,%rax
  800421bf97:	00 00 00 
  800421bf9a:	8b 00                	mov    (%rax),%eax
  800421bf9c:	83 f8 18             	cmp    $0x18,%eax
  800421bf9f:	75 24                	jne    800421bfc5 <handle_ioinstr+0x148>
                tf->tf_regs.reg_rax = (((ginfo->phys_sz / 1024) - 1024) >> 8) & 0xFF;
  800421bfa1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421bfa5:	48 8b 00             	mov    (%rax),%rax
  800421bfa8:	48 c1 e8 0a          	shr    $0xa,%rax
  800421bfac:	48 2d 00 04 00 00    	sub    $0x400,%rax
  800421bfb2:	48 c1 e8 08          	shr    $0x8,%rax
  800421bfb6:	0f b6 d0             	movzbl %al,%edx
  800421bfb9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bfbd:	48 89 50 70          	mov    %rdx,0x70(%rax)
                handled = true;
  800421bfc1:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
            }
        }

    }

    if(handled) {
  800421bfc5:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421bfc9:	74 3b                	je     800421c006 <handle_ioinstr+0x189>
        tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421bfcb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bfcf:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421bfd6:	c7 45 d0 0c 44 00 00 	movl   $0x440c,-0x30(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421bfdd:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421bfe0:	89 c7                	mov    %eax,%edi
  800421bfe2:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421bfe9:	00 00 00 
  800421bfec:	ff d0                	callq  *%rax
  800421bfee:	89 c0                	mov    %eax,%eax
  800421bff0:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421bff4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421bff8:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
        return true;
  800421bfff:	b8 01 00 00 00       	mov    $0x1,%eax
  800421c004:	eb 33                	jmp    800421c039 <handle_ioinstr+0x1bc>
    } else {
        cprintf("%x %x\n", qualification, port_iortc);
  800421c006:	48 b8 44 37 48 04 80 	movabs $0x8004483744,%rax
  800421c00d:	00 00 00 
  800421c010:	8b 10                	mov    (%rax),%edx
  800421c012:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421c016:	48 89 c6             	mov    %rax,%rsi
  800421c019:	48 bf fd f8 21 04 80 	movabs $0x800421f8fd,%rdi
  800421c020:	00 00 00 
  800421c023:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c028:	48 b9 7a 90 20 04 80 	movabs $0x800420907a,%rcx
  800421c02f:	00 00 00 
  800421c032:	ff d1                	callq  *%rcx
        return false;    
  800421c034:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
  800421c039:	48 83 c4 38          	add    $0x38,%rsp
  800421c03d:	5b                   	pop    %rbx
  800421c03e:	5d                   	pop    %rbp
  800421c03f:	c3                   	retq   

000000800421c040 <handle_cpuid>:
// Finally, you need to increment the program counter in the trap frame.
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.
bool
handle_cpuid(struct Trapframe *tf, struct VmxGuestInfo *ginfo)
{
  800421c040:	55                   	push   %rbp
  800421c041:	48 89 e5             	mov    %rsp,%rbp
  800421c044:	53                   	push   %rbx
  800421c045:	48 83 ec 38          	sub    $0x38,%rsp
  800421c049:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421c04d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    /* Your code here */
    uint32_t in = (uint32_t) tf->tf_regs.reg_rax;
  800421c051:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c055:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421c059:	89 45 ec             	mov    %eax,-0x14(%rbp)
    uint32_t eax, ebx, ecx, edx;
    cpuid (in, &eax, &ebx, &ecx, &edx);
  800421c05c:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800421c060:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
  800421c064:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800421c068:	48 8d 75 e4          	lea    -0x1c(%rbp),%rsi
  800421c06c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421c06f:	49 89 f8             	mov    %rdi,%r8
  800421c072:	89 c7                	mov    %eax,%edi
  800421c074:	48 b8 8a b8 21 04 80 	movabs $0x800421b88a,%rax
  800421c07b:	00 00 00 
  800421c07e:	ff d0                	callq  *%rax
    if (in == 1) // This is what we did in vmx support case.
  800421c080:	83 7d ec 01          	cmpl   $0x1,-0x14(%rbp)
  800421c084:	75 09                	jne    800421c08f <handle_cpuid+0x4f>
    {
		ecx = ecx & ~32; // remove the 5th bit. This is like saying the OS doesn't support virtual machine extension.
  800421c086:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421c089:	83 e0 df             	and    $0xffffffdf,%eax
  800421c08c:	89 45 dc             	mov    %eax,-0x24(%rbp)
    }
    tf->tf_regs.reg_rax = (uint64_t)eax;
  800421c08f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421c092:	89 c2                	mov    %eax,%edx
  800421c094:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c098:	48 89 50 70          	mov    %rdx,0x70(%rax)
    tf->tf_regs.reg_rbx = (uint64_t)ebx;
  800421c09c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421c09f:	89 c2                	mov    %eax,%edx
  800421c0a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c0a5:	48 89 50 68          	mov    %rdx,0x68(%rax)
    tf->tf_regs.reg_rcx = (uint64_t)ecx;
  800421c0a9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421c0ac:	89 c2                	mov    %eax,%edx
  800421c0ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c0b2:	48 89 50 60          	mov    %rdx,0x60(%rax)
    tf->tf_regs.reg_rdx = (uint64_t)edx;
  800421c0b6:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421c0b9:	89 c2                	mov    %eax,%edx
  800421c0bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c0bf:	48 89 50 58          	mov    %rdx,0x58(%rax)
    tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421c0c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c0c7:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421c0ce:	c7 45 e8 0c 44 00 00 	movl   $0x440c,-0x18(%rbp)
  800421c0d5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421c0d8:	89 c7                	mov    %eax,%edi
  800421c0da:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421c0e1:	00 00 00 
  800421c0e4:	ff d0                	callq  *%rax
  800421c0e6:	89 c0                	mov    %eax,%eax
  800421c0e8:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421c0ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c0f0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
    cprintf("Handle cpuid implemented\n");
  800421c0f7:	48 bf 04 f9 21 04 80 	movabs $0x800421f904,%rdi
  800421c0fe:	00 00 00 
  800421c101:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c106:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421c10d:	00 00 00 
  800421c110:	ff d2                	callq  *%rdx
   	return true;	
  800421c112:	b8 01 00 00 00       	mov    $0x1,%eax

}
  800421c117:	48 83 c4 38          	add    $0x38,%rsp
  800421c11b:	5b                   	pop    %rbx
  800421c11c:	5d                   	pop    %rbp
  800421c11d:	c3                   	retq   

000000800421c11e <handle_vmcall>:
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.//

bool
handle_vmcall(struct Trapframe *tf, struct VmxGuestInfo *gInfo, uint64_t *eptrt)
{
  800421c11e:	55                   	push   %rbp
  800421c11f:	48 89 e5             	mov    %rsp,%rbp
  800421c122:	53                   	push   %rbx
  800421c123:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  800421c12a:	48 89 bd 38 ff ff ff 	mov    %rdi,-0xc8(%rbp)
  800421c131:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
  800421c138:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
    bool handled = false;
  800421c13f:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
    void *gpa_pg, *hva_pg;
    envid_t to_env;
    uint32_t val;
	memory_map_t boot_map[3];
    // phys address of the multiboot map in the guest.
    uint64_t multiboot_map_addr = 0x6000;
  800421c143:	48 c7 45 e0 00 60 00 	movq   $0x6000,-0x20(%rbp)
  800421c14a:	00 

    switch(tf->tf_regs.reg_rax) {
  800421c14b:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421c152:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421c156:	48 83 f8 02          	cmp    $0x2,%rax
  800421c15a:	0f 84 fd 01 00 00    	je     800421c35d <handle_vmcall+0x23f>
  800421c160:	48 83 f8 03          	cmp    $0x3,%rax
  800421c164:	0f 84 14 02 00 00    	je     800421c37e <handle_vmcall+0x260>
  800421c16a:	48 83 f8 01          	cmp    $0x1,%rax
  800421c16e:	0f 85 2a 02 00 00    	jne    800421c39e <handle_vmcall+0x280>
		    // Once the map is ready, find the kernel virtual address of the guest page (if present),
		    //   or allocate one and map it at the multiboot_map_addr (0x6000).
		    // Copy the mbinfo and memory_map_t (segment descriptions) into the guest page, and return
		    //   a pointer to this region in rbx (as a guest physical address).
		    /* Your code here */
			boot_map[0].size = 20; //See kern/multiboot.h
  800421c174:	c7 85 40 ff ff ff 14 	movl   $0x14,-0xc0(%rbp)
  800421c17b:	00 00 00 
			boot_map[0].base_addr_low = 0x0; // base low 32 bit
  800421c17e:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%rbp)
  800421c185:	00 00 00 
			boot_map[0].base_addr_high = 0x0; // base high 32 bit
  800421c188:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%rbp)
  800421c18f:	00 00 00 
			boot_map[0].length_low = IOPHYSMEM; //this will be A0000  lower 32 bit
  800421c192:	c7 85 4c ff ff ff 00 	movl   $0xa0000,-0xb4(%rbp)
  800421c199:	00 0a 00 
			boot_map[0].length_high = 0x0; // 0s in the higher 32 bit
  800421c19c:	c7 85 50 ff ff ff 00 	movl   $0x0,-0xb0(%rbp)
  800421c1a3:	00 00 00 
			boot_map[0].type = MB_TYPE_USABLE;
  800421c1a6:	c7 85 54 ff ff ff 01 	movl   $0x1,-0xac(%rbp)
  800421c1ad:	00 00 00 

			boot_map[1].size = 20;
  800421c1b0:	c7 85 58 ff ff ff 14 	movl   $0x14,-0xa8(%rbp)
  800421c1b7:	00 00 00 
			boot_map[1].base_addr_low = IOPHYSMEM; // base low 32 bit
  800421c1ba:	c7 85 5c ff ff ff 00 	movl   $0xa0000,-0xa4(%rbp)
  800421c1c1:	00 0a 00 
			boot_map[1].base_addr_high = 0x0; // base high 32 bit
  800421c1c4:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%rbp)
  800421c1cb:	00 00 00 
			boot_map[1].length_low = 0x60000; //this will be 1000000 - A0000  lower 32 bit
  800421c1ce:	c7 85 64 ff ff ff 00 	movl   $0x60000,-0x9c(%rbp)
  800421c1d5:	00 06 00 
			boot_map[1].length_high = 0x0; // 0s in the higher 32 bit
  800421c1d8:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%rbp)
  800421c1df:	00 00 00 
			boot_map[1].type = MB_TYPE_RESERVED;
  800421c1e2:	c7 85 6c ff ff ff 02 	movl   $0x2,-0x94(%rbp)
  800421c1e9:	00 00 00 

			boot_map[2].size = 20;
  800421c1ec:	c7 85 70 ff ff ff 14 	movl   $0x14,-0x90(%rbp)
  800421c1f3:	00 00 00 
	    	boot_map[2].base_addr_low = EXTPHYSMEM;
  800421c1f6:	c7 85 74 ff ff ff 00 	movl   $0x100000,-0x8c(%rbp)
  800421c1fd:	00 10 00 
	    	boot_map[2].base_addr_high = 0x0;
  800421c200:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%rbp)
  800421c207:	00 00 00 
	    	boot_map[2].length_low = (gInfo->phys_sz - EXTPHYSMEM) & (0xffffffff); // Get the last 32 bit alone
  800421c20a:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  800421c211:	48 8b 00             	mov    (%rax),%rax
  800421c214:	2d 00 00 10 00       	sub    $0x100000,%eax
  800421c219:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
	    	boot_map[2].length_high = ((gInfo->phys_sz - EXTPHYSMEM) >> 32) & (0xffffffff); // Shift left so that the top 32 bit comes into the last 32 bit...
  800421c21f:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  800421c226:	48 8b 00             	mov    (%rax),%rax
  800421c229:	48 2d 00 00 10 00    	sub    $0x100000,%rax
  800421c22f:	48 c1 e8 20          	shr    $0x20,%rax
  800421c233:	89 45 80             	mov    %eax,-0x80(%rbp)
	    	boot_map[2].type = MB_TYPE_USABLE;
  800421c236:	c7 45 84 01 00 00 00 	movl   $0x1,-0x7c(%rbp)
			// This important... this has everything that the VM needs
	    	mbinfo.mmap_length = sizeof(boot_map);
  800421c23d:	c7 45 bc 48 00 00 00 	movl   $0x48,-0x44(%rbp)
	    	mbinfo.mmap_addr =  multiboot_map_addr + sizeof(multiboot_info_t);
  800421c244:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421c248:	83 c0 34             	add    $0x34,%eax
  800421c24b:	89 45 c0             	mov    %eax,-0x40(%rbp)
			mbinfo.flags = MB_FLAG_MMAP; //forgot this baby
  800421c24e:	c7 45 90 40 00 00 00 	movl   $0x40,-0x70(%rbp)
			
			struct PageInfo* pp = page_alloc(0);
  800421c255:	bf 00 00 00 00       	mov    $0x0,%edi
  800421c25a:	48 b8 6b 2b 20 04 80 	movabs $0x8004202b6b,%rax
  800421c261:	00 00 00 
  800421c264:	ff d0                	callq  *%rax
  800421c266:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			if(!pp) {
  800421c26a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421c26f:	75 24                	jne    800421c295 <handle_vmcall+0x177>
				handled = false;
  800421c271:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
		    	cprintf("e820 map hypercall not implemented\n");
  800421c275:	48 bf 20 f9 21 04 80 	movabs $0x800421f920,%rdi
  800421c27c:	00 00 00 
  800421c27f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c284:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421c28b:	00 00 00 
  800421c28e:	ff d2                	callq  *%rdx
				break;
  800421c290:	e9 09 01 00 00       	jmpq   800421c39e <handle_vmcall+0x280>
			}
			// map... be careful... no more sys_page_map or page_insert ept_map_hva2gpa
			// implies --- increment ppref
			pp->pp_ref++;
  800421c295:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c299:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421c29d:	8d 50 01             	lea    0x1(%rax),%edx
  800421c2a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c2a4:	66 89 50 08          	mov    %dx,0x8(%rax)
			uintptr_t host_va = (uintptr_t)page2kva(pp);
  800421c2a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c2ac:	48 89 c7             	mov    %rax,%rdi
  800421c2af:	48 b8 6d b9 21 04 80 	movabs $0x800421b96d,%rax
  800421c2b6:	00 00 00 
  800421c2b9:	ff d0                	callq  *%rax
  800421c2bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		    memmove((void *)host_va,(void *)& mbinfo, (size_t)sizeof(multiboot_info_t)); 
  800421c2bf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421c2c3:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800421c2c7:	ba 34 00 00 00       	mov    $0x34,%edx
  800421c2cc:	48 89 ce             	mov    %rcx,%rsi
  800421c2cf:	48 89 c7             	mov    %rax,%rdi
  800421c2d2:	48 b8 d2 03 21 04 80 	movabs $0x80042103d2,%rax
  800421c2d9:	00 00 00 
  800421c2dc:	ff d0                	callq  *%rax
		    memmove(((void *)host_va + sizeof(multiboot_info_t)), (void *)boot_map, sizeof(boot_map));	
  800421c2de:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421c2e2:	48 83 c0 34          	add    $0x34,%rax
  800421c2e6:	48 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%rcx
  800421c2ed:	ba 48 00 00 00       	mov    $0x48,%edx
  800421c2f2:	48 89 ce             	mov    %rcx,%rsi
  800421c2f5:	48 89 c7             	mov    %rax,%rdi
  800421c2f8:	48 b8 d2 03 21 04 80 	movabs $0x80042103d2,%rax
  800421c2ff:	00 00 00 
  800421c302:	ff d0                	callq  *%rax
			ept_map_hva2gpa(eptrt, (void *) host_va, (void *)multiboot_map_addr, __EPTE_FULL, 1);		
  800421c304:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421c308:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421c30c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421c313:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  800421c319:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421c31e:	48 89 c7             	mov    %rax,%rdi
  800421c321:	48 b8 59 8c 21 04 80 	movabs $0x8004218c59,%rax
  800421c328:	00 00 00 
  800421c32b:	ff d0                	callq  *%rax
		 	// finally...
			tf->tf_regs.reg_rbx = (uint64_t) multiboot_map_addr;
  800421c32d:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421c334:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421c338:	48 89 50 68          	mov    %rdx,0x68(%rax)
		    cprintf("e820 map hypercall implemented\n");
  800421c33c:	48 bf 48 f9 21 04 80 	movabs $0x800421f948,%rdi
  800421c343:	00 00 00 
  800421c346:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c34b:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421c352:	00 00 00 
  800421c355:	ff d2                	callq  *%rdx
			handled = true;
  800421c357:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
		    break;
  800421c35b:	eb 41                	jmp    800421c39e <handle_vmcall+0x280>
	    // Issue the sys_ipc_send call to the host.
	    // 
	    // If the requested environment is the HOST FS, this call should
	    //  do this translation.
	    /* Your code here */
	    cprintf("IPC send hypercall not implemented\n");	    
  800421c35d:	48 bf 68 f9 21 04 80 	movabs $0x800421f968,%rdi
  800421c364:	00 00 00 
  800421c367:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c36c:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421c373:	00 00 00 
  800421c376:	ff d2                	callq  *%rdx
	    handled = false;
  800421c378:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
            break;
  800421c37c:	eb 20                	jmp    800421c39e <handle_vmcall+0x280>
        case VMX_VMCALL_IPCRECV:
	    // Issue the sys_ipc_recv call for the guest.
	    // NB: because recv can call schedule, clobbering the VMCS, 
	    // you should go ahead and increment rip before this call.
	    /* Your code here */
	    cprintf("IPC recv hypercall not implemented\n");	    
  800421c37e:	48 bf 90 f9 21 04 80 	movabs $0x800421f990,%rdi
  800421c385:	00 00 00 
  800421c388:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c38d:	48 ba 7a 90 20 04 80 	movabs $0x800420907a,%rdx
  800421c394:	00 00 00 
  800421c397:	ff d2                	callq  *%rdx
            handled = false;
  800421c399:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
            break;
  800421c39d:	90                   	nop
    }
    if(handled) {
  800421c39e:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421c3a2:	74 3a                	je     800421c3de <handle_vmcall+0x2c0>
	    /* Advance the program counter by the length of the vmcall instruction. 
	     * 
	     * Hint: The TA solution does not hard-code the length of the vmcall instruction.
	     */
	    /* Your code here */
		tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421c3a4:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421c3ab:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421c3b2:	c7 45 cc 0c 44 00 00 	movl   $0x440c,-0x34(%rbp)
  800421c3b9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c3bc:	89 c7                	mov    %eax,%edi
  800421c3be:	48 b8 60 b8 21 04 80 	movabs $0x800421b860,%rax
  800421c3c5:	00 00 00 
  800421c3c8:	ff d0                	callq  *%rax
  800421c3ca:	89 c0                	mov    %eax,%eax
  800421c3cc:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421c3d0:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421c3d7:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
    }
    return handled;
  800421c3de:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  800421c3e2:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  800421c3e9:	5b                   	pop    %rbx
  800421c3ea:	5d                   	pop    %rbp
  800421c3eb:	c3                   	retq   
