
obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 13 0e 00 00       	callq  800e54 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>
	...

0000000000800044 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800044:	55                   	push   %rbp
  800045:	48 89 e5             	mov    %rsp,%rbp
  800048:	48 83 ec 08          	sub    $0x8,%rsp
  80004c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800052:	8d 48 01             	lea    0x1(%rax),%ecx
  800055:	ba 67 66 66 66       	mov    $0x66666667,%edx
  80005a:	89 c8                	mov    %ecx,%eax
  80005c:	f7 ea                	imul   %edx
  80005e:	c1 fa 03             	sar    $0x3,%edx
  800061:	89 c8                	mov    %ecx,%eax
  800063:	c1 f8 1f             	sar    $0x1f,%eax
  800066:	29 c2                	sub    %eax,%edx
  800068:	89 d0                	mov    %edx,%eax
  80006a:	c1 e0 02             	shl    $0x2,%eax
  80006d:	01 d0                	add    %edx,%eax
  80006f:	c1 e0 02             	shl    $0x2,%eax
  800072:	89 ca                	mov    %ecx,%edx
  800074:	29 c2                	sub    %eax,%edx
  800076:	89 d0                	mov    %edx,%eax
  800078:	c9                   	leaveq 
  800079:	c3                   	retq   

000000000080007a <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  80007a:	55                   	push   %rbp
  80007b:	48 89 e5             	mov    %rsp,%rbp
  80007e:	48 83 ec 08          	sub    $0x8,%rsp
  800082:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800085:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800089:	74 08                	je     800093 <prev_i+0x19>
  80008b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008e:	83 e8 01             	sub    $0x1,%eax
  800091:	eb 05                	jmp    800098 <prev_i+0x1e>
  800093:	b8 13 00 00 00       	mov    $0x13,%eax
  800098:	c9                   	leaveq 
  800099:	c3                   	retq   

000000000080009a <get_buffer>:

static void *
get_buffer(void) {
  80009a:	55                   	push   %rbp
  80009b:	48 89 e5             	mov    %rsp,%rbp
  80009e:	48 83 ec 10          	sub    $0x10,%rsp
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000a2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a9:	00 
  8000aa:	eb 20                	jmp    8000cc <get_buffer+0x32>
        if (!buse[i]) break;
  8000ac:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  8000b3:	00 00 00 
  8000b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000ba:	48 01 d0             	add    %rdx,%rax
  8000bd:	0f b6 00             	movzbl (%rax),%eax
  8000c0:	83 f0 01             	xor    $0x1,%eax
  8000c3:	84 c0                	test   %al,%al
  8000c5:	75 0e                	jne    8000d5 <get_buffer+0x3b>
static void *
get_buffer(void) {
    void *va;

    int64_t i;
    for (i = 0; i < QUEUE_SIZE; i++)
  8000c7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cc:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d1:	7e d9                	jle    8000ac <get_buffer+0x12>
  8000d3:	eb 01                	jmp    8000d6 <get_buffer+0x3c>
        if (!buse[i]) break;
  8000d5:	90                   	nop

    if (i == QUEUE_SIZE) {
  8000d6:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000db:	75 2a                	jne    800107 <get_buffer+0x6d>
        panic("NS: buffer overflow");
  8000dd:	48 ba 20 05 82 00 00 	movabs $0x820520,%rdx
  8000e4:	00 00 00 
  8000e7:	be 3f 00 00 00       	mov    $0x3f,%esi
  8000ec:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  8000f3:	00 00 00 
  8000f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8000fb:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  800102:	00 00 00 
  800105:	ff d1                	callq  *%rcx
        return 0;
    }

    va = (void *)(REQVA + i * PGSIZE);
  800107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80010b:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  800111:	48 c1 e0 0c          	shl    $0xc,%rax
  800115:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    buse[i] = 1;
  800119:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800120:	00 00 00 
  800123:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800127:	48 01 d0             	add    %rdx,%rax
  80012a:	c6 00 01             	movb   $0x1,(%rax)

    return va;
  80012d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800131:	c9                   	leaveq 
  800132:	c3                   	retq   

0000000000800133 <put_buffer>:

static void
put_buffer(void *va) {
  800133:	55                   	push   %rbp
  800134:	48 89 e5             	mov    %rsp,%rbp
  800137:	48 83 ec 18          	sub    $0x18,%rsp
  80013b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800143:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800149:	48 c1 e8 0c          	shr    $0xc,%rax
  80014d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    buse[i] = 0;
  800151:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800158:	00 00 00 
  80015b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015f:	48 01 d0             	add    %rdx,%rax
  800162:	c6 00 00             	movb   $0x0,(%rax)
}
  800165:	c9                   	leaveq 
  800166:	c3                   	retq   

0000000000800167 <lwip_init>:

    static void
lwip_init(struct netif *nif, void *if_state,
        uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800167:	55                   	push   %rbp
  800168:	48 89 e5             	mov    %rsp,%rbp
  80016b:	53                   	push   %rbx
  80016c:	48 83 ec 68          	sub    $0x68,%rsp
  800170:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800174:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800178:	89 55 ac             	mov    %edx,-0x54(%rbp)
  80017b:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  80017e:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
    struct ip_addr ipaddr, netmask, gateway;
    ipaddr.addr  = init_addr;
  800182:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800185:	89 45 e0             	mov    %eax,-0x20(%rbp)
    netmask.addr = init_mask;
  800188:	8b 45 a8             	mov    -0x58(%rbp),%eax
  80018b:	89 45 d0             	mov    %eax,-0x30(%rbp)
    gateway.addr = init_gw;
  80018e:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800191:	89 45 c0             	mov    %eax,-0x40(%rbp)

    if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800194:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  800198:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80019c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8001a0:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8001a4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8001a8:	48 bb f2 08 81 00 00 	movabs $0x8108f2,%rbx
  8001af:	00 00 00 
  8001b2:	48 89 1c 24          	mov    %rbx,(%rsp)
  8001b6:	49 b9 50 93 81 00 00 	movabs $0x819350,%r9
  8001bd:	00 00 00 
  8001c0:	49 89 f8             	mov    %rdi,%r8
  8001c3:	48 89 c7             	mov    %rax,%rdi
  8001c6:	48 b8 94 c9 80 00 00 	movabs $0x80c994,%rax
  8001cd:	00 00 00 
  8001d0:	ff d0                	callq  *%rax
  8001d2:	48 85 c0             	test   %rax,%rax
  8001d5:	75 2a                	jne    800201 <lwip_init+0x9a>
                if_state,
                jif_init,
                ip_input))
        panic("lwip_init: error in netif_add\n");
  8001d7:	48 ba 40 05 82 00 00 	movabs $0x820540,%rdx
  8001de:	00 00 00 
  8001e1:	be 5c 00 00 00       	mov    $0x5c,%esi
  8001e6:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  8001ed:	00 00 00 
  8001f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8001f5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8001fc:	00 00 00 
  8001ff:	ff d1                	callq  *%rcx

    netif_set_default(nif);
  800201:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800205:	48 89 c7             	mov    %rax,%rdi
  800208:	48 b8 97 cd 80 00 00 	movabs $0x80cd97,%rax
  80020f:	00 00 00 
  800212:	ff d0                	callq  *%rax
    netif_set_up(nif);
  800214:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800218:	48 89 c7             	mov    %rax,%rdi
  80021b:	48 b8 b6 cd 80 00 00 	movabs $0x80cdb6,%rax
  800222:	00 00 00 
  800225:	ff d0                	callq  *%rax
}
  800227:	48 83 c4 68          	add    $0x68,%rsp
  80022b:	5b                   	pop    %rbx
  80022c:	5d                   	pop    %rbp
  80022d:	c3                   	retq   

000000000080022e <net_timer>:

    static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022e:	55                   	push   %rbp
  80022f:	48 89 e5             	mov    %rsp,%rbp
  800232:	48 83 ec 20          	sub    $0x20,%rsp
  800236:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct timer_thread *t = (struct timer_thread *) arg;
  80023a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    for (;;) {
        uint32_t cur = sys_time_msec();
  800242:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  800249:	00 00 00 
  80024c:	ff d0                	callq  *%rax
  80024e:	89 45 f4             	mov    %eax,-0xc(%rbp)

        lwip_core_lock();
  800251:	48 b8 c4 84 81 00 00 	movabs $0x8184c4,%rax
  800258:	00 00 00 
  80025b:	ff d0                	callq  *%rax
        t->func();
  80025d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800261:	48 8b 40 08          	mov    0x8(%rax),%rax
  800265:	ff d0                	callq  *%rax
        lwip_core_unlock();
  800267:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  80026e:	00 00 00 
  800271:	ff d0                	callq  *%rax

        thread_wait(0, 0, cur + t->msec);
  800273:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800277:	8b 00                	mov    (%rax),%eax
  800279:	03 45 f4             	add    -0xc(%rbp),%eax
  80027c:	89 c2                	mov    %eax,%edx
  80027e:	be 00 00 00 00       	mov    $0x0,%esi
  800283:	bf 00 00 00 00       	mov    $0x0,%edi
  800288:	48 b8 3f 86 81 00 00 	movabs $0x81863f,%rax
  80028f:	00 00 00 
  800292:	ff d0                	callq  *%rax
    }
  800294:	eb ac                	jmp    800242 <net_timer+0x14>

0000000000800296 <start_timer>:
}

    static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800296:	55                   	push   %rbp
  800297:	48 89 e5             	mov    %rsp,%rbp
  80029a:	48 83 ec 30          	sub    $0x30,%rsp
  80029e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002aa:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    t->msec = msec;
  8002ad:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b4:	89 10                	mov    %edx,(%rax)
    t->func = func;
  8002b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002be:	48 89 50 08          	mov    %rdx,0x8(%rax)
    t->name = name;
  8002c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
    int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d6:	48 89 d1             	mov    %rdx,%rcx
  8002d9:	48 ba 2e 02 80 00 00 	movabs $0x80022e,%rdx
  8002e0:	00 00 00 
  8002e3:	48 89 c6             	mov    %rax,%rsi
  8002e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8002eb:	48 b8 b7 88 81 00 00 	movabs $0x8188b7,%rax
  8002f2:	00 00 00 
  8002f5:	ff d0                	callq  *%rax
  8002f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (r < 0)
  8002fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8002fe:	79 3f                	jns    80033f <start_timer+0xa9>
        panic("cannot create timer thread: %s", e2s(r));
  800300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800303:	89 c7                	mov    %eax,%edi
  800305:	48 b8 47 8f 81 00 00 	movabs $0x818f47,%rax
  80030c:	00 00 00 
  80030f:	ff d0                	callq  *%rax
  800311:	48 89 c1             	mov    %rax,%rcx
  800314:	48 ba 60 05 82 00 00 	movabs $0x820560,%rdx
  80031b:	00 00 00 
  80031e:	be 7a 00 00 00       	mov    $0x7a,%esi
  800323:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  80032a:	00 00 00 
  80032d:	b8 00 00 00 00       	mov    $0x0,%eax
  800332:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  800339:	00 00 00 
  80033c:	41 ff d0             	callq  *%r8
}
  80033f:	c9                   	leaveq 
  800340:	c3                   	retq   

0000000000800341 <tcpip_init_done>:

    static void
tcpip_init_done(void *arg)
{
  800341:	55                   	push   %rbp
  800342:	48 89 e5             	mov    %rsp,%rbp
  800345:	48 83 ec 20          	sub    $0x20,%rsp
  800349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    uint32_t *done = arg;
  80034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800351:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *done = 1;
  800355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800359:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    thread_wakeup(done);
  80035f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800363:	48 89 c7             	mov    %rax,%rdi
  800366:	48 b8 ec 85 81 00 00 	movabs $0x8185ec,%rax
  80036d:	00 00 00 
  800370:	ff d0                	callq  *%rax
}
  800372:	c9                   	leaveq 
  800373:	c3                   	retq   

0000000000800374 <serve_init>:

    void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800374:	55                   	push   %rbp
  800375:	48 89 e5             	mov    %rsp,%rbp
  800378:	48 83 ec 30          	sub    $0x30,%rsp
  80037c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80037f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800382:	89 55 e4             	mov    %edx,-0x1c(%rbp)
    int r;
    lwip_core_lock();
  800385:	48 b8 c4 84 81 00 00 	movabs $0x8184c4,%rax
  80038c:	00 00 00 
  80038f:	ff d0                	callq  *%rax

    uint32_t done = 0;
  800391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    tcpip_init(&tcpip_init_done, &done);
  800398:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80039c:	48 89 c6             	mov    %rax,%rsi
  80039f:	48 bf 41 03 80 00 00 	movabs $0x800341,%rdi
  8003a6:	00 00 00 
  8003a9:	48 b8 50 87 80 00 00 	movabs $0x808750,%rax
  8003b0:	00 00 00 
  8003b3:	ff d0                	callq  *%rax
    lwip_core_unlock();
  8003b5:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  8003bc:	00 00 00 
  8003bf:	ff d0                	callq  *%rax
    thread_wait(&done, 0, (uint32_t)~0);
  8003c1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003c5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003ca:	be 00 00 00 00       	mov    $0x0,%esi
  8003cf:	48 89 c7             	mov    %rax,%rdi
  8003d2:	48 b8 3f 86 81 00 00 	movabs $0x81863f,%rax
  8003d9:	00 00 00 
  8003dc:	ff d0                	callq  *%rax
    lwip_core_lock();
  8003de:	48 b8 c4 84 81 00 00 	movabs $0x8184c4,%rax
  8003e5:	00 00 00 
  8003e8:	ff d0                	callq  *%rax

    lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f3:	41 89 c8             	mov    %ecx,%r8d
  8003f6:	89 d1                	mov    %edx,%ecx
  8003f8:	89 c2                	mov    %eax,%edx
  8003fa:	48 be 60 90 82 00 00 	movabs $0x829060,%rsi
  800401:	00 00 00 
  800404:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  80040b:	00 00 00 
  80040e:	48 b8 67 01 80 00 00 	movabs $0x800167,%rax
  800415:	00 00 00 
  800418:	ff d0                	callq  *%rax

    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041a:	b9 88 13 00 00       	mov    $0x1388,%ecx
  80041f:	48 ba 7f 05 82 00 00 	movabs $0x82057f,%rdx
  800426:	00 00 00 
  800429:	48 be 52 55 81 00 00 	movabs $0x815552,%rsi
  800430:	00 00 00 
  800433:	48 bf 00 90 82 00 00 	movabs $0x829000,%rdi
  80043a:	00 00 00 
  80043d:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800444:	00 00 00 
  800447:	ff d0                	callq  *%rax
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800449:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  80044e:	48 ba 89 05 82 00 00 	movabs $0x820589,%rdx
  800455:	00 00 00 
  800458:	48 be 6e fd 80 00 00 	movabs $0x80fd6e,%rsi
  80045f:	00 00 00 
  800462:	48 bf 20 90 82 00 00 	movabs $0x829020,%rdi
  800469:	00 00 00 
  80046c:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800473:	00 00 00 
  800476:	ff d0                	callq  *%rax
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800478:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  80047d:	48 ba 95 05 82 00 00 	movabs $0x820595,%rdx
  800484:	00 00 00 
  800487:	48 be 0e f5 80 00 00 	movabs $0x80f50e,%rsi
  80048e:	00 00 00 
  800491:	48 bf 40 90 82 00 00 	movabs $0x829040,%rdi
  800498:	00 00 00 
  80049b:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  8004a2:	00 00 00 
  8004a5:	ff d0                	callq  *%rax

    struct in_addr ia = {ipaddr};
  8004a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004aa:	89 45 f0             	mov    %eax,-0x10(%rbp)
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ad:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b0:	89 c7                	mov    %eax,%edi
  8004b2:	48 b8 81 29 81 00 00 	movabs $0x812981,%rax
  8004b9:	00 00 00 
  8004bc:	ff d0                	callq  *%rax
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004be:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004c5:	00 00 00 
  8004c8:	0f b6 52 46          	movzbl 0x46(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004cc:	0f b6 fa             	movzbl %dl,%edi
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004cf:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004d6:	00 00 00 
  8004d9:	0f b6 52 45          	movzbl 0x45(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004dd:	44 0f b6 ca          	movzbl %dl,%r9d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e1:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004e8:	00 00 00 
  8004eb:	0f b6 52 44          	movzbl 0x44(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ef:	44 0f b6 c2          	movzbl %dl,%r8d
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004f3:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  8004fa:	00 00 00 
  8004fd:	0f b6 52 43          	movzbl 0x43(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800501:	0f b6 ca             	movzbl %dl,%ecx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800504:	48 ba 20 75 b5 00 00 	movabs $0xb57520,%rdx
  80050b:	00 00 00 
  80050e:	0f b6 52 42          	movzbl 0x42(%rdx),%edx
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800512:	0f b6 d2             	movzbl %dl,%edx
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800515:	48 be 20 75 b5 00 00 	movabs $0xb57520,%rsi
  80051c:	00 00 00 
  80051f:	0f b6 76 41          	movzbl 0x41(%rsi),%esi
    start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
    start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
    start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

    struct in_addr ia = {ipaddr};
    cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800523:	40 0f b6 f6          	movzbl %sil,%esi
  800527:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  80052c:	89 3c 24             	mov    %edi,(%rsp)
  80052f:	48 bf a8 05 82 00 00 	movabs $0x8205a8,%rdi
  800536:	00 00 00 
  800539:	b8 00 00 00 00       	mov    $0x0,%eax
  80053e:	49 ba 5b 11 80 00 00 	movabs $0x80115b,%r10
  800545:	00 00 00 
  800548:	41 ff d2             	callq  *%r10
            " bound to static IP %s\n",
            nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
            nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
            inet_ntoa(ia));

    lwip_core_unlock();
  80054b:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  800552:	00 00 00 
  800555:	ff d0                	callq  *%rax

    cprintf("NS: TCP/IP initialized.\n");
  800557:	48 bf e1 05 82 00 00 	movabs $0x8205e1,%rdi
  80055e:	00 00 00 
  800561:	b8 00 00 00 00       	mov    $0x0,%eax
  800566:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  80056d:	00 00 00 
  800570:	ff d2                	callq  *%rdx
}
  800572:	c9                   	leaveq 
  800573:	c3                   	retq   

0000000000800574 <process_timer>:

static void
process_timer(envid_t envid) {
  800574:	55                   	push   %rbp
  800575:	48 89 e5             	mov    %rsp,%rbp
  800578:	48 83 ec 20          	sub    $0x20,%rsp
  80057c:	89 7d ec             	mov    %edi,-0x14(%rbp)
    uint32_t start, now, to;

    if (envid != timer_envid) {
  80057f:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800586:	00 00 00 
  800589:	8b 00                	mov    (%rax),%eax
  80058b:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80058e:	74 22                	je     8005b2 <process_timer+0x3e>
        cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800590:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800593:	89 c6                	mov    %eax,%esi
  800595:	48 bf 00 06 82 00 00 	movabs $0x820600,%rdi
  80059c:	00 00 00 
  80059f:	b8 00 00 00 00       	mov    $0x0,%eax
  8005a4:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  8005ab:	00 00 00 
  8005ae:	ff d2                	callq  *%rdx
        return;
  8005b0:	eb 5c                	jmp    80060e <process_timer+0x9a>
    }

    start = sys_time_msec();
  8005b2:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  8005b9:	00 00 00 
  8005bc:	ff d0                	callq  *%rax
  8005be:	89 45 fc             	mov    %eax,-0x4(%rbp)
    thread_yield();
  8005c1:	48 b8 38 8b 81 00 00 	movabs $0x818b38,%rax
  8005c8:	00 00 00 
  8005cb:	ff d0                	callq  *%rax
    now = sys_time_msec();
  8005cd:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  8005d4:	00 00 00 
  8005d7:	ff d0                	callq  *%rax
  8005d9:	89 45 f8             	mov    %eax,-0x8(%rbp)

    to = TIMER_INTERVAL - (now - start);
  8005dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8005df:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8005e2:	89 d1                	mov    %edx,%ecx
  8005e4:	29 c1                	sub    %eax,%ecx
  8005e6:	89 c8                	mov    %ecx,%eax
  8005e8:	05 fa 00 00 00       	add    $0xfa,%eax
  8005ed:	89 45 f4             	mov    %eax,-0xc(%rbp)
    ipc_send(envid, to, 0, 0);
  8005f0:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005f6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8005fb:	ba 00 00 00 00       	mov    $0x0,%edx
  800600:	89 c7                	mov    %eax,%edi
  800602:	48 b8 ff 31 80 00 00 	movabs $0x8031ff,%rax
  800609:	00 00 00 
  80060c:	ff d0                	callq  *%rax
}
  80060e:	c9                   	leaveq 
  80060f:	c3                   	retq   

0000000000800610 <serve_thread>:
    uint32_t whom;
    union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  800610:	55                   	push   %rbp
  800611:	48 89 e5             	mov    %rsp,%rbp
  800614:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80061b:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    struct st_args *args = (struct st_args *)a;
  800622:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800629:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    union Nsipc *req = args->req;
  80062d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800631:	48 8b 40 08          	mov    0x8(%rax),%rax
  800635:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;

    switch (args->reqno) {
  800639:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80063d:	8b 00                	mov    (%rax),%eax
  80063f:	83 f8 0a             	cmp    $0xa,%eax
  800642:	0f 87 d7 01 00 00    	ja     80081f <serve_thread+0x20f>
  800648:	89 c0                	mov    %eax,%eax
  80064a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800651:	00 
  800652:	48 b8 78 06 82 00 00 	movabs $0x820678,%rax
  800659:	00 00 00 
  80065c:	48 01 d0             	add    %rdx,%rax
  80065f:	48 8b 00             	mov    (%rax),%rax
  800662:	ff e0                	jmpq   *%rax
        case NSREQ_ACCEPT:
            {
                struct Nsret_accept ret;
                r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800664:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800668:	8b 00                	mov    (%rax),%eax
  80066a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80066e:	48 83 c2 10          	add    $0x10,%rdx
  800672:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800676:	48 89 ce             	mov    %rcx,%rsi
  800679:	89 c7                	mov    %eax,%edi
  80067b:	48 b8 59 59 80 00 00 	movabs $0x805959,%rax
  800682:	00 00 00 
  800685:	ff d0                	callq  *%rax
  800687:	89 45 fc             	mov    %eax,-0x4(%rbp)
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
  80068a:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80068e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800692:	ba 14 00 00 00       	mov    $0x14,%edx
  800697:	48 89 ce             	mov    %rcx,%rsi
  80069a:	48 89 c7             	mov    %rax,%rdi
  80069d:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  8006a4:	00 00 00 
  8006a7:	ff d0                	callq  *%rax
                break;
  8006a9:	e9 a5 01 00 00       	jmpq   800853 <serve_thread+0x243>
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
                    req->bind.req_namelen);
  8006ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                        &ret.ret_addrlen);
                memmove(req, &ret, sizeof ret);
                break;
            }
        case NSREQ_BIND:
            r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006b2:	8b 50 14             	mov    0x14(%rax),%edx
  8006b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b9:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c1:	8b 00                	mov    (%rax),%eax
  8006c3:	48 89 ce             	mov    %rcx,%rsi
  8006c6:	89 c7                	mov    %eax,%edi
  8006c8:	48 b8 83 5c 80 00 00 	movabs $0x805c83,%rax
  8006cf:	00 00 00 
  8006d2:	ff d0                	callq  *%rax
  8006d4:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->bind.req_namelen);
            break;
  8006d7:	e9 77 01 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_SHUTDOWN:
            r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e0:	8b 50 04             	mov    0x4(%rax),%edx
  8006e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e7:	8b 00                	mov    (%rax),%eax
  8006e9:	89 d6                	mov    %edx,%esi
  8006eb:	89 c7                	mov    %eax,%edi
  8006ed:	48 b8 06 74 80 00 00 	movabs $0x807406,%rax
  8006f4:	00 00 00 
  8006f7:	ff d0                	callq  *%rax
  8006f9:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  8006fc:	e9 52 01 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
  800701:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800705:	8b 00                	mov    (%rax),%eax
  800707:	89 c7                	mov    %eax,%edi
  800709:	48 b8 b8 5d 80 00 00 	movabs $0x805db8,%rax
  800710:	00 00 00 
  800713:	ff d0                	callq  *%rax
  800715:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800718:	e9 36 01 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
                    req->connect.req_namelen);
  80071d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            break;
        case NSREQ_CLOSE:
            r = lwip_close(req->close.req_s);
            break;
        case NSREQ_CONNECT:
            r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800721:	8b 50 14             	mov    0x14(%rax),%edx
  800724:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800728:	48 8d 48 04          	lea    0x4(%rax),%rcx
  80072c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800730:	8b 00                	mov    (%rax),%eax
  800732:	48 89 ce             	mov    %rcx,%rsi
  800735:	89 c7                	mov    %eax,%edi
  800737:	48 b8 9d 5e 80 00 00 	movabs $0x805e9d,%rax
  80073e:	00 00 00 
  800741:	ff d0                	callq  *%rax
  800743:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->connect.req_namelen);
            break;
  800746:	e9 08 01 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_LISTEN:
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80074b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80074f:	8b 50 04             	mov    0x4(%rax),%edx
  800752:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800756:	8b 00                	mov    (%rax),%eax
  800758:	89 d6                	mov    %edx,%esi
  80075a:	89 c7                	mov    %eax,%edi
  80075c:	48 b8 f9 5f 80 00 00 	movabs $0x805ff9,%rax
  800763:	00 00 00 
  800766:	ff d0                	callq  *%rax
  800768:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  80076b:	e9 e3 00 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
                    req->recv.req_len, req->recv.req_flags);
  800770:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
            break;
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800774:	8b 48 08             	mov    0x8(%rax),%ecx
                    req->recv.req_len, req->recv.req_flags);
  800777:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
            break;
        case NSREQ_RECV:
            // Note that we read the request fields before we
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80077b:	8b 50 04             	mov    0x4(%rax),%edx
  80077e:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800782:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800786:	8b 00                	mov    (%rax),%eax
  800788:	89 c7                	mov    %eax,%edi
  80078a:	48 b8 fa 64 80 00 00 	movabs $0x8064fa,%rax
  800791:	00 00 00 
  800794:	ff d0                	callq  *%rax
  800796:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->recv.req_len, req->recv.req_flags);
            break;
  800799:	e9 b5 00 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
                    req->send.req_size, req->send.req_flags);
  80079e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
                    req->recv.req_len, req->recv.req_flags);
            break;
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a2:	8b 48 08             	mov    0x8(%rax),%ecx
                    req->send.req_size, req->send.req_flags);
  8007a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            // overwrite it with the response data.
            r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
                    req->recv.req_len, req->recv.req_flags);
            break;
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a9:	8b 50 04             	mov    0x4(%rax),%edx
  8007ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b0:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b8:	8b 00                	mov    (%rax),%eax
  8007ba:	89 c7                	mov    %eax,%edi
  8007bc:	48 b8 38 65 80 00 00 	movabs $0x806538,%rax
  8007c3:	00 00 00 
  8007c6:	ff d0                	callq  *%rax
  8007c8:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->send.req_size, req->send.req_flags);
            break;
  8007cb:	e9 83 00 00 00       	jmpq   800853 <serve_thread+0x243>
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
                    req->socket.req_protocol);
  8007d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
        case NSREQ_SEND:
            r = lwip_send(req->send.req_s, &req->send.req_buf,
                    req->send.req_size, req->send.req_flags);
            break;
        case NSREQ_SOCKET:
            r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007d4:	8b 50 08             	mov    0x8(%rax),%edx
  8007d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007db:	8b 48 04             	mov    0x4(%rax),%ecx
  8007de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e2:	8b 00                	mov    (%rax),%eax
  8007e4:	89 ce                	mov    %ecx,%esi
  8007e6:	89 c7                	mov    %eax,%edi
  8007e8:	48 b8 55 68 80 00 00 	movabs $0x806855,%rax
  8007ef:	00 00 00 
  8007f2:	ff d0                	callq  *%rax
  8007f4:	89 45 fc             	mov    %eax,-0x4(%rbp)
                    req->socket.req_protocol);
            break;
  8007f7:	eb 5a                	jmp    800853 <serve_thread+0x243>
        case NSREQ_INPUT:
            jif_input(&nif, (void *)&req->pkt);
  8007f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007fd:	48 89 c6             	mov    %rax,%rsi
  800800:	48 bf 20 75 b5 00 00 	movabs $0xb57520,%rdi
  800807:	00 00 00 
  80080a:	48 b8 53 92 81 00 00 	movabs $0x819253,%rax
  800811:	00 00 00 
  800814:	ff d0                	callq  *%rax
            r = 0;
  800816:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
            break;
  80081d:	eb 34                	jmp    800853 <serve_thread+0x243>
        default:
            cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80081f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800823:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800827:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082b:	8b 40 04             	mov    0x4(%rax),%eax
  80082e:	89 c6                	mov    %eax,%esi
  800830:	48 bf 40 06 82 00 00 	movabs $0x820640,%rdi
  800837:	00 00 00 
  80083a:	b8 00 00 00 00       	mov    $0x0,%eax
  80083f:	48 b9 5b 11 80 00 00 	movabs $0x80115b,%rcx
  800846:	00 00 00 
  800849:	ff d1                	callq  *%rcx
            r = -E_INVAL;
  80084b:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
            break;
  800852:	90                   	nop
    }

    if (r == -1) {
  800853:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800857:	75 49                	jne    8008a2 <serve_thread+0x292>
        char buf[100];
        snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800859:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80085d:	8b 10                	mov    (%rax),%edx
  80085f:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800866:	89 d1                	mov    %edx,%ecx
  800868:	48 ba 63 06 82 00 00 	movabs $0x820663,%rdx
  80086f:	00 00 00 
  800872:	be 64 00 00 00       	mov    $0x64,%esi
  800877:	48 89 c7             	mov    %rax,%rdi
  80087a:	b8 00 00 00 00       	mov    $0x0,%eax
  80087f:	49 b8 dd 1b 80 00 00 	movabs $0x801bdd,%r8
  800886:	00 00 00 
  800889:	41 ff d0             	callq  *%r8
        perror(buf);
  80088c:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800893:	48 89 c7             	mov    %rax,%rdi
  800896:	48 b8 f4 8e 81 00 00 	movabs $0x818ef4,%rax
  80089d:	00 00 00 
  8008a0:	ff d0                	callq  *%rax
    }

    if (args->reqno != NSREQ_INPUT)
  8008a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008a6:	8b 00                	mov    (%rax),%eax
  8008a8:	83 f8 0a             	cmp    $0xa,%eax
  8008ab:	74 22                	je     8008cf <serve_thread+0x2bf>
        ipc_send(args->whom, r, 0, 0);
  8008ad:	8b 75 fc             	mov    -0x4(%rbp),%esi
  8008b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008b4:	8b 40 04             	mov    0x4(%rax),%eax
  8008b7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008bc:	ba 00 00 00 00       	mov    $0x0,%edx
  8008c1:	89 c7                	mov    %eax,%edi
  8008c3:	48 b8 ff 31 80 00 00 	movabs $0x8031ff,%rax
  8008ca:	00 00 00 
  8008cd:	ff d0                	callq  *%rax

    put_buffer(args->req);
  8008cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008d7:	48 89 c7             	mov    %rax,%rdi
  8008da:	48 b8 33 01 80 00 00 	movabs $0x800133,%rax
  8008e1:	00 00 00 
  8008e4:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void*) args->req);
  8008e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008ea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008ee:	48 89 c6             	mov    %rax,%rsi
  8008f1:	bf 00 00 00 00       	mov    $0x0,%edi
  8008f6:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  8008fd:	00 00 00 
  800900:	ff d0                	callq  *%rax
    free(args);
  800902:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800906:	48 89 c7             	mov    %rax,%rdi
  800909:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  800910:	00 00 00 
  800913:	ff d0                	callq  *%rax
}
  800915:	c9                   	leaveq 
  800916:	c3                   	retq   

0000000000800917 <serve>:

void
serve(void) {
  800917:	55                   	push   %rbp
  800918:	48 89 e5             	mov    %rsp,%rbp
  80091b:	48 83 ec 30          	sub    $0x30,%rsp

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80091f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800926:	eb 10                	jmp    800938 <serve+0x21>
            thread_yield();
  800928:	48 b8 38 8b 81 00 00 	movabs $0x818b38,%rax
  80092f:	00 00 00 
  800932:	ff d0                	callq  *%rax

    while (1) {
        // ipc_recv will block the entire process, so we flush
        // all pending work from other threads.  We limit the
        // number of yields in case there's a rogue thread.
        for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800934:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800938:	48 b8 20 87 81 00 00 	movabs $0x818720,%rax
  80093f:	00 00 00 
  800942:	ff d0                	callq  *%rax
  800944:	85 c0                	test   %eax,%eax
  800946:	74 06                	je     80094e <serve+0x37>
  800948:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80094c:	7e da                	jle    800928 <serve+0x11>
            thread_yield();

        perm = 0;
  80094e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        va = get_buffer();
  800955:	48 b8 9a 00 80 00 00 	movabs $0x80009a,%rax
  80095c:	00 00 00 
  80095f:	ff d0                	callq  *%rax
  800961:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800965:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800969:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80096d:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  800971:	48 89 ce             	mov    %rcx,%rsi
  800974:	48 89 c7             	mov    %rax,%rdi
  800977:	48 b8 18 31 80 00 00 	movabs $0x803118,%rax
  80097e:	00 00 00 
  800981:	ff d0                	callq  *%rax
  800983:	89 45 ec             	mov    %eax,-0x14(%rbp)
        if (debug) {
            cprintf("ns req %d from %08x\n", reqno, whom);
        }

        // first take care of requests that do not contain an argument page
        if (reqno == NSREQ_TIMER) {
  800986:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  80098a:	75 29                	jne    8009b5 <serve+0x9e>
            process_timer(whom);
  80098c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80098f:	89 c7                	mov    %eax,%edi
  800991:	48 b8 74 05 80 00 00 	movabs $0x800574,%rax
  800998:	00 00 00 
  80099b:	ff d0                	callq  *%rax
            put_buffer(va);
  80099d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009a1:	48 89 c7             	mov    %rax,%rdi
  8009a4:	48 b8 33 01 80 00 00 	movabs $0x800133,%rax
  8009ab:	00 00 00 
  8009ae:	ff d0                	callq  *%rax
            continue;
  8009b0:	e9 d1 00 00 00       	jmpq   800a86 <serve+0x16f>
        }

        // All remaining requests must contain an argument page
        if (!(perm & PTE_P)) {
  8009b5:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009b8:	83 e0 01             	and    $0x1,%eax
  8009bb:	85 c0                	test   %eax,%eax
  8009bd:	75 25                	jne    8009e4 <serve+0xcd>
            cprintf("Invalid request from %08x: no argument page\n", whom);
  8009bf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009c2:	89 c6                	mov    %eax,%esi
  8009c4:	48 bf d0 06 82 00 00 	movabs $0x8206d0,%rdi
  8009cb:	00 00 00 
  8009ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8009d3:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  8009da:	00 00 00 
  8009dd:	ff d2                	callq  *%rdx
            continue; // just leave it hanging...
  8009df:	e9 a2 00 00 00       	jmpq   800a86 <serve+0x16f>
        }

        // Since some lwIP socket calls will block, create a thread and
        // process the rest of the request in the thread.
        struct st_args *args = malloc(sizeof(struct st_args));
  8009e4:	bf 10 00 00 00       	mov    $0x10,%edi
  8009e9:	48 b8 09 48 80 00 00 	movabs $0x804809,%rax
  8009f0:	00 00 00 
  8009f3:	ff d0                	callq  *%rax
  8009f5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (!args)
  8009f9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8009fe:	75 2a                	jne    800a2a <serve+0x113>
            panic("could not allocate thread args structure");
  800a00:	48 ba 00 07 82 00 00 	movabs $0x820700,%rdx
  800a07:	00 00 00 
  800a0a:	be 26 01 00 00       	mov    $0x126,%esi
  800a0f:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  800a16:	00 00 00 
  800a19:	b8 00 00 00 00       	mov    $0x0,%eax
  800a1e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  800a25:	00 00 00 
  800a28:	ff d1                	callq  *%rcx

        args->reqno = reqno;
  800a2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a2e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a31:	89 10                	mov    %edx,(%rax)
        args->whom = whom;
  800a33:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a3a:	89 50 04             	mov    %edx,0x4(%rax)
        args->req = va;
  800a3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a41:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a45:	48 89 50 08          	mov    %rdx,0x8(%rax)

        thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4d:	48 89 c1             	mov    %rax,%rcx
  800a50:	48 ba 10 06 80 00 00 	movabs $0x800610,%rdx
  800a57:	00 00 00 
  800a5a:	48 be 29 07 82 00 00 	movabs $0x820729,%rsi
  800a61:	00 00 00 
  800a64:	bf 00 00 00 00       	mov    $0x0,%edi
  800a69:	48 b8 b7 88 81 00 00 	movabs $0x8188b7,%rax
  800a70:	00 00 00 
  800a73:	ff d0                	callq  *%rax
        thread_yield(); // let the thread created run
  800a75:	48 b8 38 8b 81 00 00 	movabs $0x818b38,%rax
  800a7c:	00 00 00 
  800a7f:	ff d0                	callq  *%rax
    }
  800a81:	e9 99 fe ff ff       	jmpq   80091f <serve+0x8>
  800a86:	e9 94 fe ff ff       	jmpq   80091f <serve+0x8>

0000000000800a8b <tmain>:
}

static void
tmain(uint64_t arg) {
  800a8b:	55                   	push   %rbp
  800a8c:	48 89 e5             	mov    %rsp,%rbp
  800a8f:	41 54                	push   %r12
  800a91:	53                   	push   %rbx
  800a92:	48 83 ec 10          	sub    $0x10,%rsp
  800a96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    serve_init(inet_addr(IP),
  800a9a:	48 bf 36 07 82 00 00 	movabs $0x820736,%rdi
  800aa1:	00 00 00 
  800aa4:	48 b8 9c 26 81 00 00 	movabs $0x81269c,%rax
  800aab:	00 00 00 
  800aae:	ff d0                	callq  *%rax
  800ab0:	41 89 c4             	mov    %eax,%r12d
  800ab3:	48 bf 3f 07 82 00 00 	movabs $0x82073f,%rdi
  800aba:	00 00 00 
  800abd:	48 b8 9c 26 81 00 00 	movabs $0x81269c,%rax
  800ac4:	00 00 00 
  800ac7:	ff d0                	callq  *%rax
  800ac9:	89 c3                	mov    %eax,%ebx
  800acb:	48 bf 4d 07 82 00 00 	movabs $0x82074d,%rdi
  800ad2:	00 00 00 
  800ad5:	48 b8 9c 26 81 00 00 	movabs $0x81269c,%rax
  800adc:	00 00 00 
  800adf:	ff d0                	callq  *%rax
  800ae1:	44 89 e2             	mov    %r12d,%edx
  800ae4:	89 de                	mov    %ebx,%esi
  800ae6:	89 c7                	mov    %eax,%edi
  800ae8:	48 b8 74 03 80 00 00 	movabs $0x800374,%rax
  800aef:	00 00 00 
  800af2:	ff d0                	callq  *%rax
            inet_addr(MASK),
            inet_addr(DEFAULT));
    serve();
  800af4:	48 b8 17 09 80 00 00 	movabs $0x800917,%rax
  800afb:	00 00 00 
  800afe:	ff d0                	callq  *%rax
}
  800b00:	48 83 c4 10          	add    $0x10,%rsp
  800b04:	5b                   	pop    %rbx
  800b05:	41 5c                	pop    %r12
  800b07:	5d                   	pop    %rbp
  800b08:	c3                   	retq   

0000000000800b09 <umain>:

    void
umain(int argc, char **argv)
{
  800b09:	55                   	push   %rbp
  800b0a:	48 89 e5             	mov    %rsp,%rbp
  800b0d:	48 83 ec 20          	sub    $0x20,%rsp
  800b11:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800b14:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    envid_t ns_envid = sys_getenvid();
  800b18:	48 b8 e8 25 80 00 00 	movabs $0x8025e8,%rax
  800b1f:	00 00 00 
  800b22:	ff d0                	callq  *%rax
  800b24:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns";
  800b27:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800b2e:	00 00 00 
  800b31:	48 ba 57 07 82 00 00 	movabs $0x820757,%rdx
  800b38:	00 00 00 
  800b3b:	48 89 10             	mov    %rdx,(%rax)

    // fork off the timer thread which will send us periodic messages
    timer_envid = fork();
  800b3e:	48 b8 7a 2d 80 00 00 	movabs $0x802d7a,%rax
  800b45:	00 00 00 
  800b48:	ff d0                	callq  *%rax
  800b4a:	48 ba 58 90 82 00 00 	movabs $0x829058,%rdx
  800b51:	00 00 00 
  800b54:	89 02                	mov    %eax,(%rdx)
    if (timer_envid < 0)
  800b56:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b5d:	00 00 00 
  800b60:	8b 00                	mov    (%rax),%eax
  800b62:	85 c0                	test   %eax,%eax
  800b64:	79 2a                	jns    800b90 <umain+0x87>
        panic("error forking");
  800b66:	48 ba 5a 07 82 00 00 	movabs $0x82075a,%rdx
  800b6d:	00 00 00 
  800b70:	be 43 01 00 00       	mov    $0x143,%esi
  800b75:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  800b7c:	00 00 00 
  800b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800b84:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  800b8b:	00 00 00 
  800b8e:	ff d1                	callq  *%rcx
    else if (timer_envid == 0) {
  800b90:	48 b8 58 90 82 00 00 	movabs $0x829058,%rax
  800b97:	00 00 00 
  800b9a:	8b 00                	mov    (%rax),%eax
  800b9c:	85 c0                	test   %eax,%eax
  800b9e:	75 1b                	jne    800bbb <umain+0xb2>
        timer(ns_envid, TIMER_INTERVAL);
  800ba0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ba3:	be fa 00 00 00       	mov    $0xfa,%esi
  800ba8:	89 c7                	mov    %eax,%edi
  800baa:	48 b8 ec 0c 80 00 00 	movabs $0x800cec,%rax
  800bb1:	00 00 00 
  800bb4:	ff d0                	callq  *%rax
        return;
  800bb6:	e9 2f 01 00 00       	jmpq   800cea <umain+0x1e1>
    }

    // fork off the input thread which will poll the NIC driver for input
    // packets
    input_envid = fork();
  800bbb:	48 b8 7a 2d 80 00 00 	movabs $0x802d7a,%rax
  800bc2:	00 00 00 
  800bc5:	ff d0                	callq  *%rax
  800bc7:	48 ba 5c 90 82 00 00 	movabs $0x82905c,%rdx
  800bce:	00 00 00 
  800bd1:	89 02                	mov    %eax,(%rdx)
    if (input_envid < 0)
  800bd3:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800bda:	00 00 00 
  800bdd:	8b 00                	mov    (%rax),%eax
  800bdf:	85 c0                	test   %eax,%eax
  800be1:	79 2a                	jns    800c0d <umain+0x104>
        panic("error forking");
  800be3:	48 ba 5a 07 82 00 00 	movabs $0x82075a,%rdx
  800bea:	00 00 00 
  800bed:	be 4d 01 00 00       	mov    $0x14d,%esi
  800bf2:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  800bf9:	00 00 00 
  800bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  800c01:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  800c08:	00 00 00 
  800c0b:	ff d1                	callq  *%rcx
    else if (input_envid == 0) {
  800c0d:	48 b8 5c 90 82 00 00 	movabs $0x82905c,%rax
  800c14:	00 00 00 
  800c17:	8b 00                	mov    (%rax),%eax
  800c19:	85 c0                	test   %eax,%eax
  800c1b:	75 16                	jne    800c33 <umain+0x12a>
        input(ns_envid);
  800c1d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c20:	89 c7                	mov    %eax,%edi
  800c22:	48 b8 0c 0e 80 00 00 	movabs $0x800e0c,%rax
  800c29:	00 00 00 
  800c2c:	ff d0                	callq  *%rax
        return;
  800c2e:	e9 b7 00 00 00       	jmpq   800cea <umain+0x1e1>
    }

    // fork off the output thread that will send the packets to the NIC
    // driver
    output_envid = fork();
  800c33:	48 b8 7a 2d 80 00 00 	movabs $0x802d7a,%rax
  800c3a:	00 00 00 
  800c3d:	ff d0                	callq  *%rax
  800c3f:	48 ba 60 90 82 00 00 	movabs $0x829060,%rdx
  800c46:	00 00 00 
  800c49:	89 02                	mov    %eax,(%rdx)
    if (output_envid < 0)
  800c4b:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c52:	00 00 00 
  800c55:	8b 00                	mov    (%rax),%eax
  800c57:	85 c0                	test   %eax,%eax
  800c59:	79 2a                	jns    800c85 <umain+0x17c>
        panic("error forking");
  800c5b:	48 ba 5a 07 82 00 00 	movabs $0x82075a,%rdx
  800c62:	00 00 00 
  800c65:	be 57 01 00 00       	mov    $0x157,%esi
  800c6a:	48 bf 34 05 82 00 00 	movabs $0x820534,%rdi
  800c71:	00 00 00 
  800c74:	b8 00 00 00 00       	mov    $0x0,%eax
  800c79:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  800c80:	00 00 00 
  800c83:	ff d1                	callq  *%rcx
    else if (output_envid == 0) {
  800c85:	48 b8 60 90 82 00 00 	movabs $0x829060,%rax
  800c8c:	00 00 00 
  800c8f:	8b 00                	mov    (%rax),%eax
  800c91:	85 c0                	test   %eax,%eax
  800c93:	75 13                	jne    800ca8 <umain+0x19f>
        output(ns_envid);
  800c95:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c98:	89 c7                	mov    %eax,%edi
  800c9a:	48 b8 30 0e 80 00 00 	movabs $0x800e30,%rax
  800ca1:	00 00 00 
  800ca4:	ff d0                	callq  *%rax
        return;
  800ca6:	eb 42                	jmp    800cea <umain+0x1e1>
    }

    // lwIP requires a user threading library; start the library and jump
    // into a thread to continue initialization.
    thread_init();
  800ca8:	48 b8 ab 85 81 00 00 	movabs $0x8185ab,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
    thread_create(0, "main", tmain, 0);
  800cb4:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cb9:	48 ba 8b 0a 80 00 00 	movabs $0x800a8b,%rdx
  800cc0:	00 00 00 
  800cc3:	48 be 68 07 82 00 00 	movabs $0x820768,%rsi
  800cca:	00 00 00 
  800ccd:	bf 00 00 00 00       	mov    $0x0,%edi
  800cd2:	48 b8 b7 88 81 00 00 	movabs $0x8188b7,%rax
  800cd9:	00 00 00 
  800cdc:	ff d0                	callq  *%rax
    thread_yield();
  800cde:	48 b8 38 8b 81 00 00 	movabs $0x818b38,%rax
  800ce5:	00 00 00 
  800ce8:	ff d0                	callq  *%rax
    // never coming here!
}
  800cea:	c9                   	leaveq 
  800ceb:	c3                   	retq   

0000000000800cec <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cec:	55                   	push   %rbp
  800ced:	48 89 e5             	mov    %rsp,%rbp
  800cf0:	48 83 ec 20          	sub    $0x20,%rsp
  800cf4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800cf7:	89 75 e8             	mov    %esi,-0x18(%rbp)
    int r;
    uint32_t stop = sys_time_msec() + initial_to;
  800cfa:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  800d01:	00 00 00 
  800d04:	ff d0                	callq  *%rax
  800d06:	03 45 e8             	add    -0x18(%rbp),%eax
  800d09:	89 45 fc             	mov    %eax,-0x4(%rbp)

    binaryname = "ns_timer";
  800d0c:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800d13:	00 00 00 
  800d16:	48 ba 70 07 82 00 00 	movabs $0x820770,%rdx
  800d1d:	00 00 00 
  800d20:	48 89 10             	mov    %rdx,(%rax)

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d23:	eb 0c                	jmp    800d31 <timer+0x45>
            sys_yield();
  800d25:	48 b8 26 26 80 00 00 	movabs $0x802626,%rax
  800d2c:	00 00 00 
  800d2f:	ff d0                	callq  *%rax
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800d31:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  800d38:	00 00 00 
  800d3b:	ff d0                	callq  *%rax
  800d3d:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800d40:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d43:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800d46:	73 06                	jae    800d4e <timer+0x62>
  800d48:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d4c:	79 d7                	jns    800d25 <timer+0x39>
            sys_yield();
        }
        if (r < 0)
  800d4e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d52:	79 30                	jns    800d84 <timer+0x98>
            panic("sys_time_msec: %e", r);
  800d54:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d57:	89 c1                	mov    %eax,%ecx
  800d59:	48 ba 79 07 82 00 00 	movabs $0x820779,%rdx
  800d60:	00 00 00 
  800d63:	be 0f 00 00 00       	mov    $0xf,%esi
  800d68:	48 bf 8b 07 82 00 00 	movabs $0x82078b,%rdi
  800d6f:	00 00 00 
  800d72:	b8 00 00 00 00       	mov    $0x0,%eax
  800d77:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  800d7e:	00 00 00 
  800d81:	41 ff d0             	callq  *%r8

        ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800d87:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d8c:	ba 00 00 00 00       	mov    $0x0,%edx
  800d91:	be 0c 00 00 00       	mov    $0xc,%esi
  800d96:	89 c7                	mov    %eax,%edi
  800d98:	48 b8 ff 31 80 00 00 	movabs $0x8031ff,%rax
  800d9f:	00 00 00 
  800da2:	ff d0                	callq  *%rax

        while (1) {
            uint32_t to, whom;
            to = ipc_recv((int32_t *) &whom, 0, 0);
  800da4:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800da8:	ba 00 00 00 00       	mov    $0x0,%edx
  800dad:	be 00 00 00 00       	mov    $0x0,%esi
  800db2:	48 89 c7             	mov    %rax,%rdi
  800db5:	48 b8 18 31 80 00 00 	movabs $0x803118,%rax
  800dbc:	00 00 00 
  800dbf:	ff d0                	callq  *%rax
  800dc1:	89 45 f4             	mov    %eax,-0xc(%rbp)

            if (whom != ns_envid) {
  800dc4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800dc7:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800dca:	39 c2                	cmp    %eax,%edx
  800dcc:	74 22                	je     800df0 <timer+0x104>
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800dce:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800dd1:	89 c6                	mov    %eax,%esi
  800dd3:	48 bf 98 07 82 00 00 	movabs $0x820798,%rdi
  800dda:	00 00 00 
  800ddd:	b8 00 00 00 00       	mov    $0x0,%eax
  800de2:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  800de9:	00 00 00 
  800dec:	ff d2                	callq  *%rdx
                continue;
            }

            stop = sys_time_msec() + to;
            break;
        }
  800dee:	eb b4                	jmp    800da4 <timer+0xb8>
            if (whom != ns_envid) {
                cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
                continue;
            }

            stop = sys_time_msec() + to;
  800df0:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  800df7:	00 00 00 
  800dfa:	ff d0                	callq  *%rax
  800dfc:	03 45 f4             	add    -0xc(%rbp),%eax
  800dff:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
  800e02:	90                   	nop
        }
    }
  800e03:	90                   	nop
    uint32_t stop = sys_time_msec() + initial_to;

    binaryname = "ns_timer";

    while (1) {
        while((r = sys_time_msec()) < stop && r >= 0) {
  800e04:	e9 28 ff ff ff       	jmpq   800d31 <timer+0x45>
  800e09:	00 00                	add    %al,(%rax)
	...

0000000000800e0c <input>:

extern union Nsipc nsipcbuf;

    void
input(envid_t ns_envid)
{
  800e0c:	55                   	push   %rbp
  800e0d:	48 89 e5             	mov    %rsp,%rbp
  800e10:	48 83 ec 08          	sub    $0x8,%rsp
  800e14:	89 7d fc             	mov    %edi,-0x4(%rbp)
    binaryname = "ns_input";
  800e17:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e1e:	00 00 00 
  800e21:	48 ba d3 07 82 00 00 	movabs $0x8207d3,%rdx
  800e28:	00 00 00 
  800e2b:	48 89 10             	mov    %rdx,(%rax)
    // 	- read a packet from the device driver
    //	- send it to the network server
    // Hint: When you IPC a page to the network server, it will be
    // reading from it for a while, so don't immediately receive
    // another packet in to the same physical page.
}
  800e2e:	c9                   	leaveq 
  800e2f:	c3                   	retq   

0000000000800e30 <output>:

extern union Nsipc nsipcbuf;

    void
output(envid_t ns_envid)
{
  800e30:	55                   	push   %rbp
  800e31:	48 89 e5             	mov    %rsp,%rbp
  800e34:	48 83 ec 08          	sub    $0x8,%rsp
  800e38:	89 7d fc             	mov    %edi,-0x4(%rbp)
    binaryname = "ns_output";
  800e3b:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e42:	00 00 00 
  800e45:	48 ba dc 07 82 00 00 	movabs $0x8207dc,%rdx
  800e4c:	00 00 00 
  800e4f:	48 89 10             	mov    %rdx,(%rax)

    // LAB 6: Your code here:
    // 	- read a packet from the network server
    //	- send the packet to the device driver
}
  800e52:	c9                   	leaveq 
  800e53:	c3                   	retq   

0000000000800e54 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  800e54:	55                   	push   %rbp
  800e55:	48 89 e5             	mov    %rsp,%rbp
  800e58:	48 83 ec 10          	sub    $0x10,%rsp
  800e5c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800e5f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = 0;
  800e63:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  800e6a:	00 00 00 
  800e6d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	thisenv = &envs[ENVX(sys_getenvid())];
  800e74:	48 b8 e8 25 80 00 00 	movabs $0x8025e8,%rax
  800e7b:	00 00 00 
  800e7e:	ff d0                	callq  *%rax
  800e80:	48 98                	cltq   
  800e82:	48 89 c2             	mov    %rax,%rdx
  800e85:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800e8b:	48 89 d0             	mov    %rdx,%rax
  800e8e:	48 c1 e0 02          	shl    $0x2,%rax
  800e92:	48 01 d0             	add    %rdx,%rax
  800e95:	48 01 c0             	add    %rax,%rax
  800e98:	48 01 d0             	add    %rdx,%rax
  800e9b:	48 c1 e0 05          	shl    $0x5,%rax
  800e9f:	48 89 c2             	mov    %rax,%rdx
  800ea2:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800ea9:	00 00 00 
  800eac:	48 01 c2             	add    %rax,%rdx
  800eaf:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  800eb6:	00 00 00 
  800eb9:	48 89 10             	mov    %rdx,(%rax)

	// save the name of the program so that panic() can use it
	if (argc > 0)
  800ebc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800ec0:	7e 14                	jle    800ed6 <libmain+0x82>
		binaryname = argv[0];
  800ec2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800ec6:	48 8b 10             	mov    (%rax),%rdx
  800ec9:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800ed0:	00 00 00 
  800ed3:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  800ed6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800eda:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800edd:	48 89 d6             	mov    %rdx,%rsi
  800ee0:	89 c7                	mov    %eax,%edi
  800ee2:	48 b8 09 0b 80 00 00 	movabs $0x800b09,%rax
  800ee9:	00 00 00 
  800eec:	ff d0                	callq  *%rax

	// exit gracefully
	exit();
  800eee:	48 b8 fc 0e 80 00 00 	movabs $0x800efc,%rax
  800ef5:	00 00 00 
  800ef8:	ff d0                	callq  *%rax
}
  800efa:	c9                   	leaveq 
  800efb:	c3                   	retq   

0000000000800efc <exit>:

#include <inc/lib.h>

void
exit(void)
{
  800efc:	55                   	push   %rbp
  800efd:	48 89 e5             	mov    %rsp,%rbp
	close_all();
  800f00:	48 b8 7d 36 80 00 00 	movabs $0x80367d,%rax
  800f07:	00 00 00 
  800f0a:	ff d0                	callq  *%rax
	sys_env_destroy(0);
  800f0c:	bf 00 00 00 00       	mov    $0x0,%edi
  800f11:	48 b8 a4 25 80 00 00 	movabs $0x8025a4,%rax
  800f18:	00 00 00 
  800f1b:	ff d0                	callq  *%rax
}
  800f1d:	5d                   	pop    %rbp
  800f1e:	c3                   	retq   
	...

0000000000800f20 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  800f20:	55                   	push   %rbp
  800f21:	48 89 e5             	mov    %rsp,%rbp
  800f24:	53                   	push   %rbx
  800f25:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  800f2c:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  800f33:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  800f39:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  800f40:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  800f47:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  800f4e:	84 c0                	test   %al,%al
  800f50:	74 23                	je     800f75 <_panic+0x55>
  800f52:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  800f59:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  800f5d:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  800f61:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  800f65:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  800f69:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  800f6d:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  800f71:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
  800f75:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800f7c:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  800f83:	00 00 00 
  800f86:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  800f8d:	00 00 00 
  800f90:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800f94:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800f9b:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  800fa2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  800fa9:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800fb0:	00 00 00 
  800fb3:	48 8b 18             	mov    (%rax),%rbx
  800fb6:	48 b8 e8 25 80 00 00 	movabs $0x8025e8,%rax
  800fbd:	00 00 00 
  800fc0:	ff d0                	callq  *%rax
  800fc2:	8b 8d 14 ff ff ff    	mov    -0xec(%rbp),%ecx
  800fc8:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800fcf:	41 89 c8             	mov    %ecx,%r8d
  800fd2:	48 89 d1             	mov    %rdx,%rcx
  800fd5:	48 89 da             	mov    %rbx,%rdx
  800fd8:	89 c6                	mov    %eax,%esi
  800fda:	48 bf f0 07 82 00 00 	movabs $0x8207f0,%rdi
  800fe1:	00 00 00 
  800fe4:	b8 00 00 00 00       	mov    $0x0,%eax
  800fe9:	49 b9 5b 11 80 00 00 	movabs $0x80115b,%r9
  800ff0:	00 00 00 
  800ff3:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  800ff6:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  800ffd:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801004:	48 89 d6             	mov    %rdx,%rsi
  801007:	48 89 c7             	mov    %rax,%rdi
  80100a:	48 b8 af 10 80 00 00 	movabs $0x8010af,%rax
  801011:	00 00 00 
  801014:	ff d0                	callq  *%rax
	cprintf("\n");
  801016:	48 bf 13 08 82 00 00 	movabs $0x820813,%rdi
  80101d:	00 00 00 
  801020:	b8 00 00 00 00       	mov    $0x0,%eax
  801025:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  80102c:	00 00 00 
  80102f:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  801031:	cc                   	int3   
  801032:	eb fd                	jmp    801031 <_panic+0x111>

0000000000801034 <putch>:
};


    static void
putch(int ch, struct printbuf *b)
{
  801034:	55                   	push   %rbp
  801035:	48 89 e5             	mov    %rsp,%rbp
  801038:	48 83 ec 10          	sub    $0x10,%rsp
  80103c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80103f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    b->buf[b->idx++] = ch;
  801043:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801047:	8b 00                	mov    (%rax),%eax
  801049:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80104c:	89 d6                	mov    %edx,%esi
  80104e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  801052:	48 63 d0             	movslq %eax,%rdx
  801055:	40 88 74 11 08       	mov    %sil,0x8(%rcx,%rdx,1)
  80105a:	8d 50 01             	lea    0x1(%rax),%edx
  80105d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801061:	89 10                	mov    %edx,(%rax)
    if (b->idx == 256-1) {
  801063:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801067:	8b 00                	mov    (%rax),%eax
  801069:	3d ff 00 00 00       	cmp    $0xff,%eax
  80106e:	75 2c                	jne    80109c <putch+0x68>
        sys_cputs(b->buf, b->idx);
  801070:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801074:	8b 00                	mov    (%rax),%eax
  801076:	48 98                	cltq   
  801078:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80107c:	48 83 c2 08          	add    $0x8,%rdx
  801080:	48 89 c6             	mov    %rax,%rsi
  801083:	48 89 d7             	mov    %rdx,%rdi
  801086:	48 b8 1c 25 80 00 00 	movabs $0x80251c,%rax
  80108d:	00 00 00 
  801090:	ff d0                	callq  *%rax
        b->idx = 0;
  801092:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801096:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    }
    b->cnt++;
  80109c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8010a0:	8b 40 04             	mov    0x4(%rax),%eax
  8010a3:	8d 50 01             	lea    0x1(%rax),%edx
  8010a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8010aa:	89 50 04             	mov    %edx,0x4(%rax)
}
  8010ad:	c9                   	leaveq 
  8010ae:	c3                   	retq   

00000000008010af <vcprintf>:

    int
vcprintf(const char *fmt, va_list ap)
{
  8010af:	55                   	push   %rbp
  8010b0:	48 89 e5             	mov    %rsp,%rbp
  8010b3:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  8010ba:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  8010c1:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
    struct printbuf b;
    va_list aq;
    va_copy(aq,ap);
  8010c8:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  8010cf:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  8010d6:	48 8b 0a             	mov    (%rdx),%rcx
  8010d9:	48 89 08             	mov    %rcx,(%rax)
  8010dc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8010e0:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8010e4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8010e8:	48 89 50 10          	mov    %rdx,0x10(%rax)
    b.idx = 0;
  8010ec:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  8010f3:	00 00 00 
    b.cnt = 0;
  8010f6:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  8010fd:	00 00 00 
    vprintfmt((void*)putch, &b, fmt, aq);
  801100:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  801107:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  80110e:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  801115:	48 89 c6             	mov    %rax,%rsi
  801118:	48 bf 34 10 80 00 00 	movabs $0x801034,%rdi
  80111f:	00 00 00 
  801122:	48 b8 0c 15 80 00 00 	movabs $0x80150c,%rax
  801129:	00 00 00 
  80112c:	ff d0                	callq  *%rax
    sys_cputs(b.buf, b.idx);
  80112e:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  801134:	48 98                	cltq   
  801136:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  80113d:	48 83 c2 08          	add    $0x8,%rdx
  801141:	48 89 c6             	mov    %rax,%rsi
  801144:	48 89 d7             	mov    %rdx,%rdi
  801147:	48 b8 1c 25 80 00 00 	movabs $0x80251c,%rax
  80114e:	00 00 00 
  801151:	ff d0                	callq  *%rax
    va_end(aq);

    return b.cnt;
  801153:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801159:	c9                   	leaveq 
  80115a:	c3                   	retq   

000000000080115b <cprintf>:

    int
cprintf(const char *fmt, ...)
{
  80115b:	55                   	push   %rbp
  80115c:	48 89 e5             	mov    %rsp,%rbp
  80115f:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  801166:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  80116d:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  801174:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80117b:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801182:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801189:	84 c0                	test   %al,%al
  80118b:	74 20                	je     8011ad <cprintf+0x52>
  80118d:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801191:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801195:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801199:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80119d:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8011a1:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8011a5:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8011a9:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8011ad:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
    va_list ap;
    int cnt;
    va_list aq;
    va_start(ap, fmt);
  8011b4:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8011bb:	00 00 00 
  8011be:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8011c5:	00 00 00 
  8011c8:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8011cc:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8011d3:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8011da:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_copy(aq,ap);
  8011e1:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8011e8:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8011ef:	48 8b 0a             	mov    (%rdx),%rcx
  8011f2:	48 89 08             	mov    %rcx,(%rax)
  8011f5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8011f9:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8011fd:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801201:	48 89 50 10          	mov    %rdx,0x10(%rax)
    cnt = vcprintf(fmt, aq);
  801205:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  80120c:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801213:	48 89 d6             	mov    %rdx,%rsi
  801216:	48 89 c7             	mov    %rax,%rdi
  801219:	48 b8 af 10 80 00 00 	movabs $0x8010af,%rax
  801220:	00 00 00 
  801223:	ff d0                	callq  *%rax
  801225:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    va_end(aq);

    return cnt;
  80122b:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801231:	c9                   	leaveq 
  801232:	c3                   	retq   
	...

0000000000801234 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  801234:	55                   	push   %rbp
  801235:	48 89 e5             	mov    %rsp,%rbp
  801238:	48 83 ec 30          	sub    $0x30,%rsp
  80123c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801240:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  801244:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  801248:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  80124b:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  80124f:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  801253:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  801256:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80125a:	77 52                	ja     8012ae <printnum+0x7a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80125c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80125f:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  801263:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  801266:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80126a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80126e:	ba 00 00 00 00       	mov    $0x0,%edx
  801273:	48 f7 75 d0          	divq   -0x30(%rbp)
  801277:	48 89 c2             	mov    %rax,%rdx
  80127a:	8b 7d dc             	mov    -0x24(%rbp),%edi
  80127d:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801280:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  801284:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801288:	41 89 f9             	mov    %edi,%r9d
  80128b:	48 89 c7             	mov    %rax,%rdi
  80128e:	48 b8 34 12 80 00 00 	movabs $0x801234,%rax
  801295:	00 00 00 
  801298:	ff d0                	callq  *%rax
  80129a:	eb 1c                	jmp    8012b8 <printnum+0x84>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80129c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8012a0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8012a3:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8012a7:	48 89 d6             	mov    %rdx,%rsi
  8012aa:	89 c7                	mov    %eax,%edi
  8012ac:	ff d1                	callq  *%rcx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  8012ae:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  8012b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  8012b6:	7f e4                	jg     80129c <printnum+0x68>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  8012b8:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8012bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8012bf:	ba 00 00 00 00       	mov    $0x0,%edx
  8012c4:	48 f7 f1             	div    %rcx
  8012c7:	48 89 d0             	mov    %rdx,%rax
  8012ca:	48 ba 10 0a 82 00 00 	movabs $0x820a10,%rdx
  8012d1:	00 00 00 
  8012d4:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8012d8:	0f be c0             	movsbl %al,%eax
  8012db:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8012df:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8012e3:	48 89 d6             	mov    %rdx,%rsi
  8012e6:	89 c7                	mov    %eax,%edi
  8012e8:	ff d1                	callq  *%rcx
}
  8012ea:	c9                   	leaveq 
  8012eb:	c3                   	retq   

00000000008012ec <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  8012ec:	55                   	push   %rbp
  8012ed:	48 89 e5             	mov    %rsp,%rbp
  8012f0:	48 83 ec 20          	sub    $0x20,%rsp
  8012f4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8012f8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  8012fb:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8012ff:	7e 52                	jle    801353 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  801301:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801305:	8b 00                	mov    (%rax),%eax
  801307:	83 f8 30             	cmp    $0x30,%eax
  80130a:	73 24                	jae    801330 <getuint+0x44>
  80130c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801310:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801314:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801318:	8b 00                	mov    (%rax),%eax
  80131a:	89 c0                	mov    %eax,%eax
  80131c:	48 01 d0             	add    %rdx,%rax
  80131f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801323:	8b 12                	mov    (%rdx),%edx
  801325:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801328:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80132c:	89 0a                	mov    %ecx,(%rdx)
  80132e:	eb 17                	jmp    801347 <getuint+0x5b>
  801330:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801334:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801338:	48 89 d0             	mov    %rdx,%rax
  80133b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  80133f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801343:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801347:	48 8b 00             	mov    (%rax),%rax
  80134a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80134e:	e9 a3 00 00 00       	jmpq   8013f6 <getuint+0x10a>
	else if (lflag)
  801353:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801357:	74 4f                	je     8013a8 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  801359:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80135d:	8b 00                	mov    (%rax),%eax
  80135f:	83 f8 30             	cmp    $0x30,%eax
  801362:	73 24                	jae    801388 <getuint+0x9c>
  801364:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801368:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80136c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801370:	8b 00                	mov    (%rax),%eax
  801372:	89 c0                	mov    %eax,%eax
  801374:	48 01 d0             	add    %rdx,%rax
  801377:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80137b:	8b 12                	mov    (%rdx),%edx
  80137d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801380:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801384:	89 0a                	mov    %ecx,(%rdx)
  801386:	eb 17                	jmp    80139f <getuint+0xb3>
  801388:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80138c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801390:	48 89 d0             	mov    %rdx,%rax
  801393:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801397:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80139b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80139f:	48 8b 00             	mov    (%rax),%rax
  8013a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8013a6:	eb 4e                	jmp    8013f6 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  8013a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013ac:	8b 00                	mov    (%rax),%eax
  8013ae:	83 f8 30             	cmp    $0x30,%eax
  8013b1:	73 24                	jae    8013d7 <getuint+0xeb>
  8013b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013b7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8013bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013bf:	8b 00                	mov    (%rax),%eax
  8013c1:	89 c0                	mov    %eax,%eax
  8013c3:	48 01 d0             	add    %rdx,%rax
  8013c6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013ca:	8b 12                	mov    (%rdx),%edx
  8013cc:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8013cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013d3:	89 0a                	mov    %ecx,(%rdx)
  8013d5:	eb 17                	jmp    8013ee <getuint+0x102>
  8013d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8013db:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8013df:	48 89 d0             	mov    %rdx,%rax
  8013e2:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8013e6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8013ea:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8013ee:	8b 00                	mov    (%rax),%eax
  8013f0:	89 c0                	mov    %eax,%eax
  8013f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8013f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8013fa:	c9                   	leaveq 
  8013fb:	c3                   	retq   

00000000008013fc <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  8013fc:	55                   	push   %rbp
  8013fd:	48 89 e5             	mov    %rsp,%rbp
  801400:	48 83 ec 20          	sub    $0x20,%rsp
  801404:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801408:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  80140b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80140f:	7e 52                	jle    801463 <getint+0x67>
		x=va_arg(*ap, long long);
  801411:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801415:	8b 00                	mov    (%rax),%eax
  801417:	83 f8 30             	cmp    $0x30,%eax
  80141a:	73 24                	jae    801440 <getint+0x44>
  80141c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801420:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801424:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801428:	8b 00                	mov    (%rax),%eax
  80142a:	89 c0                	mov    %eax,%eax
  80142c:	48 01 d0             	add    %rdx,%rax
  80142f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801433:	8b 12                	mov    (%rdx),%edx
  801435:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801438:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80143c:	89 0a                	mov    %ecx,(%rdx)
  80143e:	eb 17                	jmp    801457 <getint+0x5b>
  801440:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801444:	48 8b 50 08          	mov    0x8(%rax),%rdx
  801448:	48 89 d0             	mov    %rdx,%rax
  80144b:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  80144f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801453:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801457:	48 8b 00             	mov    (%rax),%rax
  80145a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80145e:	e9 a3 00 00 00       	jmpq   801506 <getint+0x10a>
	else if (lflag)
  801463:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801467:	74 4f                	je     8014b8 <getint+0xbc>
		x=va_arg(*ap, long);
  801469:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80146d:	8b 00                	mov    (%rax),%eax
  80146f:	83 f8 30             	cmp    $0x30,%eax
  801472:	73 24                	jae    801498 <getint+0x9c>
  801474:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801478:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80147c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801480:	8b 00                	mov    (%rax),%eax
  801482:	89 c0                	mov    %eax,%eax
  801484:	48 01 d0             	add    %rdx,%rax
  801487:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80148b:	8b 12                	mov    (%rdx),%edx
  80148d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  801490:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801494:	89 0a                	mov    %ecx,(%rdx)
  801496:	eb 17                	jmp    8014af <getint+0xb3>
  801498:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80149c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8014a0:	48 89 d0             	mov    %rdx,%rax
  8014a3:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8014a7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014ab:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8014af:	48 8b 00             	mov    (%rax),%rax
  8014b2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8014b6:	eb 4e                	jmp    801506 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  8014b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014bc:	8b 00                	mov    (%rax),%eax
  8014be:	83 f8 30             	cmp    $0x30,%eax
  8014c1:	73 24                	jae    8014e7 <getint+0xeb>
  8014c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014c7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8014cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014cf:	8b 00                	mov    (%rax),%eax
  8014d1:	89 c0                	mov    %eax,%eax
  8014d3:	48 01 d0             	add    %rdx,%rax
  8014d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014da:	8b 12                	mov    (%rdx),%edx
  8014dc:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014df:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014e3:	89 0a                	mov    %ecx,(%rdx)
  8014e5:	eb 17                	jmp    8014fe <getint+0x102>
  8014e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014eb:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8014ef:	48 89 d0             	mov    %rdx,%rax
  8014f2:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8014f6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014fa:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8014fe:	8b 00                	mov    (%rax),%eax
  801500:	48 98                	cltq   
  801502:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  801506:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80150a:	c9                   	leaveq 
  80150b:	c3                   	retq   

000000000080150c <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80150c:	55                   	push   %rbp
  80150d:	48 89 e5             	mov    %rsp,%rbp
  801510:	41 54                	push   %r12
  801512:	53                   	push   %rbx
  801513:	48 83 ec 60          	sub    $0x60,%rsp
  801517:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80151b:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80151f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  801523:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  801527:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  80152b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80152f:	48 8b 0a             	mov    (%rdx),%rcx
  801532:	48 89 08             	mov    %rcx,(%rax)
  801535:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801539:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80153d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801541:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801545:	eb 17                	jmp    80155e <vprintfmt+0x52>
			if (ch == '\0')
  801547:	85 db                	test   %ebx,%ebx
  801549:	0f 84 ea 04 00 00    	je     801a39 <vprintfmt+0x52d>
				return;
			putch(ch, putdat);
  80154f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801553:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801557:	48 89 c6             	mov    %rax,%rsi
  80155a:	89 df                	mov    %ebx,%edi
  80155c:	ff d2                	callq  *%rdx
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80155e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801562:	0f b6 00             	movzbl (%rax),%eax
  801565:	0f b6 d8             	movzbl %al,%ebx
  801568:	83 fb 25             	cmp    $0x25,%ebx
  80156b:	0f 95 c0             	setne  %al
  80156e:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  801573:	84 c0                	test   %al,%al
  801575:	75 d0                	jne    801547 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  801577:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  80157b:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  801582:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  801589:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  801590:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  801597:	eb 04                	jmp    80159d <vprintfmt+0x91>
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
			goto reswitch;
  801599:	90                   	nop
  80159a:	eb 01                	jmp    80159d <vprintfmt+0x91>
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
			goto reswitch;
  80159c:	90                   	nop
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80159d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8015a1:	0f b6 00             	movzbl (%rax),%eax
  8015a4:	0f b6 d8             	movzbl %al,%ebx
  8015a7:	89 d8                	mov    %ebx,%eax
  8015a9:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  8015ae:	83 e8 23             	sub    $0x23,%eax
  8015b1:	83 f8 55             	cmp    $0x55,%eax
  8015b4:	0f 87 4b 04 00 00    	ja     801a05 <vprintfmt+0x4f9>
  8015ba:	89 c0                	mov    %eax,%eax
  8015bc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8015c3:	00 
  8015c4:	48 b8 38 0a 82 00 00 	movabs $0x820a38,%rax
  8015cb:	00 00 00 
  8015ce:	48 01 d0             	add    %rdx,%rax
  8015d1:	48 8b 00             	mov    (%rax),%rax
  8015d4:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  8015d6:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  8015da:	eb c1                	jmp    80159d <vprintfmt+0x91>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  8015dc:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  8015e0:	eb bb                	jmp    80159d <vprintfmt+0x91>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8015e2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  8015e9:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8015ec:	89 d0                	mov    %edx,%eax
  8015ee:	c1 e0 02             	shl    $0x2,%eax
  8015f1:	01 d0                	add    %edx,%eax
  8015f3:	01 c0                	add    %eax,%eax
  8015f5:	01 d8                	add    %ebx,%eax
  8015f7:	83 e8 30             	sub    $0x30,%eax
  8015fa:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8015fd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801601:	0f b6 00             	movzbl (%rax),%eax
  801604:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  801607:	83 fb 2f             	cmp    $0x2f,%ebx
  80160a:	7e 63                	jle    80166f <vprintfmt+0x163>
  80160c:	83 fb 39             	cmp    $0x39,%ebx
  80160f:	7f 5e                	jg     80166f <vprintfmt+0x163>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  801611:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  801616:	eb d1                	jmp    8015e9 <vprintfmt+0xdd>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  801618:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80161b:	83 f8 30             	cmp    $0x30,%eax
  80161e:	73 17                	jae    801637 <vprintfmt+0x12b>
  801620:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801624:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801627:	89 c0                	mov    %eax,%eax
  801629:	48 01 d0             	add    %rdx,%rax
  80162c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80162f:	83 c2 08             	add    $0x8,%edx
  801632:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801635:	eb 0f                	jmp    801646 <vprintfmt+0x13a>
  801637:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80163b:	48 89 d0             	mov    %rdx,%rax
  80163e:	48 83 c2 08          	add    $0x8,%rdx
  801642:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801646:	8b 00                	mov    (%rax),%eax
  801648:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  80164b:	eb 23                	jmp    801670 <vprintfmt+0x164>

		case '.':
			if (width < 0)
  80164d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801651:	0f 89 42 ff ff ff    	jns    801599 <vprintfmt+0x8d>
				width = 0;
  801657:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  80165e:	e9 36 ff ff ff       	jmpq   801599 <vprintfmt+0x8d>

		case '#':
			altflag = 1;
  801663:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  80166a:	e9 2e ff ff ff       	jmpq   80159d <vprintfmt+0x91>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  80166f:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  801670:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801674:	0f 89 22 ff ff ff    	jns    80159c <vprintfmt+0x90>
				width = precision, precision = -1;
  80167a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  80167d:	89 45 dc             	mov    %eax,-0x24(%rbp)
  801680:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  801687:	e9 10 ff ff ff       	jmpq   80159c <vprintfmt+0x90>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  80168c:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  801690:	e9 08 ff ff ff       	jmpq   80159d <vprintfmt+0x91>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  801695:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801698:	83 f8 30             	cmp    $0x30,%eax
  80169b:	73 17                	jae    8016b4 <vprintfmt+0x1a8>
  80169d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8016a1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8016a4:	89 c0                	mov    %eax,%eax
  8016a6:	48 01 d0             	add    %rdx,%rax
  8016a9:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8016ac:	83 c2 08             	add    $0x8,%edx
  8016af:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8016b2:	eb 0f                	jmp    8016c3 <vprintfmt+0x1b7>
  8016b4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8016b8:	48 89 d0             	mov    %rdx,%rax
  8016bb:	48 83 c2 08          	add    $0x8,%rdx
  8016bf:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8016c3:	8b 00                	mov    (%rax),%eax
  8016c5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8016c9:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8016cd:	48 89 d6             	mov    %rdx,%rsi
  8016d0:	89 c7                	mov    %eax,%edi
  8016d2:	ff d1                	callq  *%rcx
			break;
  8016d4:	e9 5a 03 00 00       	jmpq   801a33 <vprintfmt+0x527>

			// error message
		case 'e':
			err = va_arg(aq, int);
  8016d9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8016dc:	83 f8 30             	cmp    $0x30,%eax
  8016df:	73 17                	jae    8016f8 <vprintfmt+0x1ec>
  8016e1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8016e5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8016e8:	89 c0                	mov    %eax,%eax
  8016ea:	48 01 d0             	add    %rdx,%rax
  8016ed:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8016f0:	83 c2 08             	add    $0x8,%edx
  8016f3:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8016f6:	eb 0f                	jmp    801707 <vprintfmt+0x1fb>
  8016f8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8016fc:	48 89 d0             	mov    %rdx,%rax
  8016ff:	48 83 c2 08          	add    $0x8,%rdx
  801703:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801707:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  801709:	85 db                	test   %ebx,%ebx
  80170b:	79 02                	jns    80170f <vprintfmt+0x203>
				err = -err;
  80170d:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80170f:	83 fb 15             	cmp    $0x15,%ebx
  801712:	7f 16                	jg     80172a <vprintfmt+0x21e>
  801714:	48 b8 60 09 82 00 00 	movabs $0x820960,%rax
  80171b:	00 00 00 
  80171e:	48 63 d3             	movslq %ebx,%rdx
  801721:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  801725:	4d 85 e4             	test   %r12,%r12
  801728:	75 2e                	jne    801758 <vprintfmt+0x24c>
				printfmt(putch, putdat, "error %d", err);
  80172a:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80172e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801732:	89 d9                	mov    %ebx,%ecx
  801734:	48 ba 21 0a 82 00 00 	movabs $0x820a21,%rdx
  80173b:	00 00 00 
  80173e:	48 89 c7             	mov    %rax,%rdi
  801741:	b8 00 00 00 00       	mov    $0x0,%eax
  801746:	49 b8 43 1a 80 00 00 	movabs $0x801a43,%r8
  80174d:	00 00 00 
  801750:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  801753:	e9 db 02 00 00       	jmpq   801a33 <vprintfmt+0x527>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  801758:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80175c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801760:	4c 89 e1             	mov    %r12,%rcx
  801763:	48 ba 2a 0a 82 00 00 	movabs $0x820a2a,%rdx
  80176a:	00 00 00 
  80176d:	48 89 c7             	mov    %rax,%rdi
  801770:	b8 00 00 00 00       	mov    $0x0,%eax
  801775:	49 b8 43 1a 80 00 00 	movabs $0x801a43,%r8
  80177c:	00 00 00 
  80177f:	41 ff d0             	callq  *%r8
			break;
  801782:	e9 ac 02 00 00       	jmpq   801a33 <vprintfmt+0x527>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  801787:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80178a:	83 f8 30             	cmp    $0x30,%eax
  80178d:	73 17                	jae    8017a6 <vprintfmt+0x29a>
  80178f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801793:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801796:	89 c0                	mov    %eax,%eax
  801798:	48 01 d0             	add    %rdx,%rax
  80179b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80179e:	83 c2 08             	add    $0x8,%edx
  8017a1:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8017a4:	eb 0f                	jmp    8017b5 <vprintfmt+0x2a9>
  8017a6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8017aa:	48 89 d0             	mov    %rdx,%rax
  8017ad:	48 83 c2 08          	add    $0x8,%rdx
  8017b1:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8017b5:	4c 8b 20             	mov    (%rax),%r12
  8017b8:	4d 85 e4             	test   %r12,%r12
  8017bb:	75 0a                	jne    8017c7 <vprintfmt+0x2bb>
				p = "(null)";
  8017bd:	49 bc 2d 0a 82 00 00 	movabs $0x820a2d,%r12
  8017c4:	00 00 00 
			if (width > 0 && padc != '-')
  8017c7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8017cb:	7e 7a                	jle    801847 <vprintfmt+0x33b>
  8017cd:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  8017d1:	74 74                	je     801847 <vprintfmt+0x33b>
				for (width -= strnlen(p, precision); width > 0; width--)
  8017d3:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8017d6:	48 98                	cltq   
  8017d8:	48 89 c6             	mov    %rax,%rsi
  8017db:	4c 89 e7             	mov    %r12,%rdi
  8017de:	48 b8 ee 1c 80 00 00 	movabs $0x801cee,%rax
  8017e5:	00 00 00 
  8017e8:	ff d0                	callq  *%rax
  8017ea:	29 45 dc             	sub    %eax,-0x24(%rbp)
  8017ed:	eb 17                	jmp    801806 <vprintfmt+0x2fa>
					putch(padc, putdat);
  8017ef:	0f be 45 d3          	movsbl -0x2d(%rbp),%eax
  8017f3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8017f7:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8017fb:	48 89 d6             	mov    %rdx,%rsi
  8017fe:	89 c7                	mov    %eax,%edi
  801800:	ff d1                	callq  *%rcx
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  801802:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801806:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80180a:	7f e3                	jg     8017ef <vprintfmt+0x2e3>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80180c:	eb 39                	jmp    801847 <vprintfmt+0x33b>
				if (altflag && (ch < ' ' || ch > '~'))
  80180e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  801812:	74 1e                	je     801832 <vprintfmt+0x326>
  801814:	83 fb 1f             	cmp    $0x1f,%ebx
  801817:	7e 05                	jle    80181e <vprintfmt+0x312>
  801819:	83 fb 7e             	cmp    $0x7e,%ebx
  80181c:	7e 14                	jle    801832 <vprintfmt+0x326>
					putch('?', putdat);
  80181e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801822:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801826:	48 89 c6             	mov    %rax,%rsi
  801829:	bf 3f 00 00 00       	mov    $0x3f,%edi
  80182e:	ff d2                	callq  *%rdx
  801830:	eb 0f                	jmp    801841 <vprintfmt+0x335>
				else
					putch(ch, putdat);
  801832:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801836:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80183a:	48 89 c6             	mov    %rax,%rsi
  80183d:	89 df                	mov    %ebx,%edi
  80183f:	ff d2                	callq  *%rdx
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  801841:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801845:	eb 01                	jmp    801848 <vprintfmt+0x33c>
  801847:	90                   	nop
  801848:	41 0f b6 04 24       	movzbl (%r12),%eax
  80184d:	0f be d8             	movsbl %al,%ebx
  801850:	85 db                	test   %ebx,%ebx
  801852:	0f 95 c0             	setne  %al
  801855:	49 83 c4 01          	add    $0x1,%r12
  801859:	84 c0                	test   %al,%al
  80185b:	74 28                	je     801885 <vprintfmt+0x379>
  80185d:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801861:	78 ab                	js     80180e <vprintfmt+0x302>
  801863:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  801867:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80186b:	79 a1                	jns    80180e <vprintfmt+0x302>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80186d:	eb 16                	jmp    801885 <vprintfmt+0x379>
				putch(' ', putdat);
  80186f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801873:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801877:	48 89 c6             	mov    %rax,%rsi
  80187a:	bf 20 00 00 00       	mov    $0x20,%edi
  80187f:	ff d2                	callq  *%rdx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801881:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801885:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801889:	7f e4                	jg     80186f <vprintfmt+0x363>
				putch(' ', putdat);
			break;
  80188b:	e9 a3 01 00 00       	jmpq   801a33 <vprintfmt+0x527>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  801890:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801894:	be 03 00 00 00       	mov    $0x3,%esi
  801899:	48 89 c7             	mov    %rax,%rdi
  80189c:	48 b8 fc 13 80 00 00 	movabs $0x8013fc,%rax
  8018a3:	00 00 00 
  8018a6:	ff d0                	callq  *%rax
  8018a8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  8018ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8018b0:	48 85 c0             	test   %rax,%rax
  8018b3:	79 1d                	jns    8018d2 <vprintfmt+0x3c6>
				putch('-', putdat);
  8018b5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8018b9:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8018bd:	48 89 c6             	mov    %rax,%rsi
  8018c0:	bf 2d 00 00 00       	mov    $0x2d,%edi
  8018c5:	ff d2                	callq  *%rdx
				num = -(long long) num;
  8018c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8018cb:	48 f7 d8             	neg    %rax
  8018ce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  8018d2:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  8018d9:	e9 e8 00 00 00       	jmpq   8019c6 <vprintfmt+0x4ba>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  8018de:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8018e2:	be 03 00 00 00       	mov    $0x3,%esi
  8018e7:	48 89 c7             	mov    %rax,%rdi
  8018ea:	48 b8 ec 12 80 00 00 	movabs $0x8012ec,%rax
  8018f1:	00 00 00 
  8018f4:	ff d0                	callq  *%rax
  8018f6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  8018fa:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801901:	e9 c0 00 00 00       	jmpq   8019c6 <vprintfmt+0x4ba>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
  801906:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80190a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80190e:	48 89 c6             	mov    %rax,%rsi
  801911:	bf 58 00 00 00       	mov    $0x58,%edi
  801916:	ff d2                	callq  *%rdx
			putch('X', putdat);
  801918:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80191c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801920:	48 89 c6             	mov    %rax,%rsi
  801923:	bf 58 00 00 00       	mov    $0x58,%edi
  801928:	ff d2                	callq  *%rdx
			putch('X', putdat);
  80192a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80192e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801932:	48 89 c6             	mov    %rax,%rsi
  801935:	bf 58 00 00 00       	mov    $0x58,%edi
  80193a:	ff d2                	callq  *%rdx
			break;
  80193c:	e9 f2 00 00 00       	jmpq   801a33 <vprintfmt+0x527>

			// pointer
		case 'p':
			putch('0', putdat);
  801941:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801945:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801949:	48 89 c6             	mov    %rax,%rsi
  80194c:	bf 30 00 00 00       	mov    $0x30,%edi
  801951:	ff d2                	callq  *%rdx
			putch('x', putdat);
  801953:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801957:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80195b:	48 89 c6             	mov    %rax,%rsi
  80195e:	bf 78 00 00 00       	mov    $0x78,%edi
  801963:	ff d2                	callq  *%rdx
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801965:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801968:	83 f8 30             	cmp    $0x30,%eax
  80196b:	73 17                	jae    801984 <vprintfmt+0x478>
  80196d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801971:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801974:	89 c0                	mov    %eax,%eax
  801976:	48 01 d0             	add    %rdx,%rax
  801979:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80197c:	83 c2 08             	add    $0x8,%edx
  80197f:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801982:	eb 0f                	jmp    801993 <vprintfmt+0x487>
				(uintptr_t) va_arg(aq, void *);
  801984:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801988:	48 89 d0             	mov    %rdx,%rax
  80198b:	48 83 c2 08          	add    $0x8,%rdx
  80198f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801993:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801996:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  80199a:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  8019a1:	eb 23                	jmp    8019c6 <vprintfmt+0x4ba>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  8019a3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8019a7:	be 03 00 00 00       	mov    $0x3,%esi
  8019ac:	48 89 c7             	mov    %rax,%rdi
  8019af:	48 b8 ec 12 80 00 00 	movabs $0x8012ec,%rax
  8019b6:	00 00 00 
  8019b9:	ff d0                	callq  *%rax
  8019bb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  8019bf:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  8019c6:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  8019cb:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8019ce:	8b 7d dc             	mov    -0x24(%rbp),%edi
  8019d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8019d5:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8019d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8019dd:	45 89 c1             	mov    %r8d,%r9d
  8019e0:	41 89 f8             	mov    %edi,%r8d
  8019e3:	48 89 c7             	mov    %rax,%rdi
  8019e6:	48 b8 34 12 80 00 00 	movabs $0x801234,%rax
  8019ed:	00 00 00 
  8019f0:	ff d0                	callq  *%rax
			break;
  8019f2:	eb 3f                	jmp    801a33 <vprintfmt+0x527>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  8019f4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8019f8:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8019fc:	48 89 c6             	mov    %rax,%rsi
  8019ff:	89 df                	mov    %ebx,%edi
  801a01:	ff d2                	callq  *%rdx
			break;
  801a03:	eb 2e                	jmp    801a33 <vprintfmt+0x527>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801a05:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801a09:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801a0d:	48 89 c6             	mov    %rax,%rsi
  801a10:	bf 25 00 00 00       	mov    $0x25,%edi
  801a15:	ff d2                	callq  *%rdx
			for (fmt--; fmt[-1] != '%'; fmt--)
  801a17:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801a1c:	eb 05                	jmp    801a23 <vprintfmt+0x517>
  801a1e:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801a23:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801a27:	48 83 e8 01          	sub    $0x1,%rax
  801a2b:	0f b6 00             	movzbl (%rax),%eax
  801a2e:	3c 25                	cmp    $0x25,%al
  801a30:	75 ec                	jne    801a1e <vprintfmt+0x512>
				/* do nothing */;
			break;
  801a32:	90                   	nop
		}
	}
  801a33:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801a34:	e9 25 fb ff ff       	jmpq   80155e <vprintfmt+0x52>
			if (ch == '\0')
				return;
  801a39:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  801a3a:	48 83 c4 60          	add    $0x60,%rsp
  801a3e:	5b                   	pop    %rbx
  801a3f:	41 5c                	pop    %r12
  801a41:	5d                   	pop    %rbp
  801a42:	c3                   	retq   

0000000000801a43 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801a43:	55                   	push   %rbp
  801a44:	48 89 e5             	mov    %rsp,%rbp
  801a47:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801a4e:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801a55:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801a5c:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801a63:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801a6a:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801a71:	84 c0                	test   %al,%al
  801a73:	74 20                	je     801a95 <printfmt+0x52>
  801a75:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801a79:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801a7d:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801a81:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801a85:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801a89:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801a8d:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801a91:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801a95:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801a9c:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801aa3:	00 00 00 
  801aa6:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801aad:	00 00 00 
  801ab0:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801ab4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801abb:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801ac2:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801ac9:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801ad0:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801ad7:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801ade:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801ae5:	48 89 c7             	mov    %rax,%rdi
  801ae8:	48 b8 0c 15 80 00 00 	movabs $0x80150c,%rax
  801aef:	00 00 00 
  801af2:	ff d0                	callq  *%rax
	va_end(ap);
}
  801af4:	c9                   	leaveq 
  801af5:	c3                   	retq   

0000000000801af6 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801af6:	55                   	push   %rbp
  801af7:	48 89 e5             	mov    %rsp,%rbp
  801afa:	48 83 ec 10          	sub    $0x10,%rsp
  801afe:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801b01:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801b05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b09:	8b 40 10             	mov    0x10(%rax),%eax
  801b0c:	8d 50 01             	lea    0x1(%rax),%edx
  801b0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b13:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801b16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b1a:	48 8b 10             	mov    (%rax),%rdx
  801b1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b21:	48 8b 40 08          	mov    0x8(%rax),%rax
  801b25:	48 39 c2             	cmp    %rax,%rdx
  801b28:	73 17                	jae    801b41 <sprintputch+0x4b>
		*b->buf++ = ch;
  801b2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b2e:	48 8b 00             	mov    (%rax),%rax
  801b31:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801b34:	88 10                	mov    %dl,(%rax)
  801b36:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801b3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801b3e:	48 89 10             	mov    %rdx,(%rax)
}
  801b41:	c9                   	leaveq 
  801b42:	c3                   	retq   

0000000000801b43 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801b43:	55                   	push   %rbp
  801b44:	48 89 e5             	mov    %rsp,%rbp
  801b47:	48 83 ec 50          	sub    $0x50,%rsp
  801b4b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801b4f:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801b52:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801b56:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801b5a:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801b5e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801b62:	48 8b 0a             	mov    (%rdx),%rcx
  801b65:	48 89 08             	mov    %rcx,(%rax)
  801b68:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801b6c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801b70:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801b74:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801b78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801b7c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801b80:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801b83:	48 98                	cltq   
  801b85:	48 83 e8 01          	sub    $0x1,%rax
  801b89:	48 03 45 c8          	add    -0x38(%rbp),%rax
  801b8d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801b91:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801b98:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801b9d:	74 06                	je     801ba5 <vsnprintf+0x62>
  801b9f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801ba3:	7f 07                	jg     801bac <vsnprintf+0x69>
		return -E_INVAL;
  801ba5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801baa:	eb 2f                	jmp    801bdb <vsnprintf+0x98>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801bac:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801bb0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801bb4:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801bb8:	48 89 c6             	mov    %rax,%rsi
  801bbb:	48 bf f6 1a 80 00 00 	movabs $0x801af6,%rdi
  801bc2:	00 00 00 
  801bc5:	48 b8 0c 15 80 00 00 	movabs $0x80150c,%rax
  801bcc:	00 00 00 
  801bcf:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801bd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801bd5:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801bd8:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801bdb:	c9                   	leaveq 
  801bdc:	c3                   	retq   

0000000000801bdd <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801bdd:	55                   	push   %rbp
  801bde:	48 89 e5             	mov    %rsp,%rbp
  801be1:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801be8:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801bef:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801bf5:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801bfc:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c03:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c0a:	84 c0                	test   %al,%al
  801c0c:	74 20                	je     801c2e <snprintf+0x51>
  801c0e:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c12:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c16:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c1a:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c1e:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c22:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c26:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801c2a:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801c2e:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801c35:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801c3c:	00 00 00 
  801c3f:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801c46:	00 00 00 
  801c49:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801c4d:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801c54:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801c5b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801c62:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801c69:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801c70:	48 8b 0a             	mov    (%rdx),%rcx
  801c73:	48 89 08             	mov    %rcx,(%rax)
  801c76:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801c7a:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801c7e:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801c82:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801c86:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801c8d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801c94:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801c9a:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801ca1:	48 89 c7             	mov    %rax,%rdi
  801ca4:	48 b8 43 1b 80 00 00 	movabs $0x801b43,%rax
  801cab:	00 00 00 
  801cae:	ff d0                	callq  *%rax
  801cb0:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801cb6:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801cbc:	c9                   	leaveq 
  801cbd:	c3                   	retq   
	...

0000000000801cc0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801cc0:	55                   	push   %rbp
  801cc1:	48 89 e5             	mov    %rsp,%rbp
  801cc4:	48 83 ec 18          	sub    $0x18,%rsp
  801cc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801ccc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801cd3:	eb 09                	jmp    801cde <strlen+0x1e>
		n++;
  801cd5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801cd9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801cde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ce2:	0f b6 00             	movzbl (%rax),%eax
  801ce5:	84 c0                	test   %al,%al
  801ce7:	75 ec                	jne    801cd5 <strlen+0x15>
		n++;
	return n;
  801ce9:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801cec:	c9                   	leaveq 
  801ced:	c3                   	retq   

0000000000801cee <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801cee:	55                   	push   %rbp
  801cef:	48 89 e5             	mov    %rsp,%rbp
  801cf2:	48 83 ec 20          	sub    $0x20,%rsp
  801cf6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801cfa:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801cfe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801d05:	eb 0e                	jmp    801d15 <strnlen+0x27>
		n++;
  801d07:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801d0b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801d10:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801d15:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801d1a:	74 0b                	je     801d27 <strnlen+0x39>
  801d1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d20:	0f b6 00             	movzbl (%rax),%eax
  801d23:	84 c0                	test   %al,%al
  801d25:	75 e0                	jne    801d07 <strnlen+0x19>
		n++;
	return n;
  801d27:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801d2a:	c9                   	leaveq 
  801d2b:	c3                   	retq   

0000000000801d2c <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801d2c:	55                   	push   %rbp
  801d2d:	48 89 e5             	mov    %rsp,%rbp
  801d30:	48 83 ec 20          	sub    $0x20,%rsp
  801d34:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801d38:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801d3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d40:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801d44:	90                   	nop
  801d45:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801d49:	0f b6 10             	movzbl (%rax),%edx
  801d4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d50:	88 10                	mov    %dl,(%rax)
  801d52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d56:	0f b6 00             	movzbl (%rax),%eax
  801d59:	84 c0                	test   %al,%al
  801d5b:	0f 95 c0             	setne  %al
  801d5e:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801d63:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  801d68:	84 c0                	test   %al,%al
  801d6a:	75 d9                	jne    801d45 <strcpy+0x19>
		/* do nothing */;
	return ret;
  801d6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801d70:	c9                   	leaveq 
  801d71:	c3                   	retq   

0000000000801d72 <strcat>:

char *
strcat(char *dst, const char *src)
{
  801d72:	55                   	push   %rbp
  801d73:	48 89 e5             	mov    %rsp,%rbp
  801d76:	48 83 ec 20          	sub    $0x20,%rsp
  801d7a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801d7e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801d82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801d86:	48 89 c7             	mov    %rax,%rdi
  801d89:	48 b8 c0 1c 80 00 00 	movabs $0x801cc0,%rax
  801d90:	00 00 00 
  801d93:	ff d0                	callq  *%rax
  801d95:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801d98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801d9b:	48 98                	cltq   
  801d9d:	48 03 45 e8          	add    -0x18(%rbp),%rax
  801da1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801da5:	48 89 d6             	mov    %rdx,%rsi
  801da8:	48 89 c7             	mov    %rax,%rdi
  801dab:	48 b8 2c 1d 80 00 00 	movabs $0x801d2c,%rax
  801db2:	00 00 00 
  801db5:	ff d0                	callq  *%rax
	return dst;
  801db7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801dbb:	c9                   	leaveq 
  801dbc:	c3                   	retq   

0000000000801dbd <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801dbd:	55                   	push   %rbp
  801dbe:	48 89 e5             	mov    %rsp,%rbp
  801dc1:	48 83 ec 28          	sub    $0x28,%rsp
  801dc5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801dc9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801dcd:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801dd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801dd5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801dd9:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801de0:	00 
  801de1:	eb 27                	jmp    801e0a <strncpy+0x4d>
		*dst++ = *src;
  801de3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801de7:	0f b6 10             	movzbl (%rax),%edx
  801dea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801dee:	88 10                	mov    %dl,(%rax)
  801df0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801df5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801df9:	0f b6 00             	movzbl (%rax),%eax
  801dfc:	84 c0                	test   %al,%al
  801dfe:	74 05                	je     801e05 <strncpy+0x48>
			src++;
  801e00:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801e05:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801e0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e0e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801e12:	72 cf                	jb     801de3 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  801e14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801e18:	c9                   	leaveq 
  801e19:	c3                   	retq   

0000000000801e1a <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801e1a:	55                   	push   %rbp
  801e1b:	48 89 e5             	mov    %rsp,%rbp
  801e1e:	48 83 ec 28          	sub    $0x28,%rsp
  801e22:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801e26:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801e2a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801e2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801e36:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801e3b:	74 37                	je     801e74 <strlcpy+0x5a>
		while (--size > 0 && *src != '\0')
  801e3d:	eb 17                	jmp    801e56 <strlcpy+0x3c>
			*dst++ = *src++;
  801e3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801e43:	0f b6 10             	movzbl (%rax),%edx
  801e46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e4a:	88 10                	mov    %dl,(%rax)
  801e4c:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801e51:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801e56:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  801e5b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801e60:	74 0b                	je     801e6d <strlcpy+0x53>
  801e62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801e66:	0f b6 00             	movzbl (%rax),%eax
  801e69:	84 c0                	test   %al,%al
  801e6b:	75 d2                	jne    801e3f <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  801e6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e71:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  801e74:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801e78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801e7c:	48 89 d1             	mov    %rdx,%rcx
  801e7f:	48 29 c1             	sub    %rax,%rcx
  801e82:	48 89 c8             	mov    %rcx,%rax
}
  801e85:	c9                   	leaveq 
  801e86:	c3                   	retq   

0000000000801e87 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  801e87:	55                   	push   %rbp
  801e88:	48 89 e5             	mov    %rsp,%rbp
  801e8b:	48 83 ec 10          	sub    $0x10,%rsp
  801e8f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801e93:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  801e97:	eb 0a                	jmp    801ea3 <strcmp+0x1c>
		p++, q++;
  801e99:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801e9e:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  801ea3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ea7:	0f b6 00             	movzbl (%rax),%eax
  801eaa:	84 c0                	test   %al,%al
  801eac:	74 12                	je     801ec0 <strcmp+0x39>
  801eae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801eb2:	0f b6 10             	movzbl (%rax),%edx
  801eb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801eb9:	0f b6 00             	movzbl (%rax),%eax
  801ebc:	38 c2                	cmp    %al,%dl
  801ebe:	74 d9                	je     801e99 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  801ec0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801ec4:	0f b6 00             	movzbl (%rax),%eax
  801ec7:	0f b6 d0             	movzbl %al,%edx
  801eca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ece:	0f b6 00             	movzbl (%rax),%eax
  801ed1:	0f b6 c0             	movzbl %al,%eax
  801ed4:	89 d1                	mov    %edx,%ecx
  801ed6:	29 c1                	sub    %eax,%ecx
  801ed8:	89 c8                	mov    %ecx,%eax
}
  801eda:	c9                   	leaveq 
  801edb:	c3                   	retq   

0000000000801edc <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  801edc:	55                   	push   %rbp
  801edd:	48 89 e5             	mov    %rsp,%rbp
  801ee0:	48 83 ec 18          	sub    $0x18,%rsp
  801ee4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801ee8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  801eec:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  801ef0:	eb 0f                	jmp    801f01 <strncmp+0x25>
		n--, p++, q++;
  801ef2:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  801ef7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801efc:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  801f01:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801f06:	74 1d                	je     801f25 <strncmp+0x49>
  801f08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f0c:	0f b6 00             	movzbl (%rax),%eax
  801f0f:	84 c0                	test   %al,%al
  801f11:	74 12                	je     801f25 <strncmp+0x49>
  801f13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f17:	0f b6 10             	movzbl (%rax),%edx
  801f1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801f1e:	0f b6 00             	movzbl (%rax),%eax
  801f21:	38 c2                	cmp    %al,%dl
  801f23:	74 cd                	je     801ef2 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  801f25:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801f2a:	75 07                	jne    801f33 <strncmp+0x57>
		return 0;
  801f2c:	b8 00 00 00 00       	mov    $0x0,%eax
  801f31:	eb 1a                	jmp    801f4d <strncmp+0x71>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801f33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f37:	0f b6 00             	movzbl (%rax),%eax
  801f3a:	0f b6 d0             	movzbl %al,%edx
  801f3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801f41:	0f b6 00             	movzbl (%rax),%eax
  801f44:	0f b6 c0             	movzbl %al,%eax
  801f47:	89 d1                	mov    %edx,%ecx
  801f49:	29 c1                	sub    %eax,%ecx
  801f4b:	89 c8                	mov    %ecx,%eax
}
  801f4d:	c9                   	leaveq 
  801f4e:	c3                   	retq   

0000000000801f4f <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  801f4f:	55                   	push   %rbp
  801f50:	48 89 e5             	mov    %rsp,%rbp
  801f53:	48 83 ec 10          	sub    $0x10,%rsp
  801f57:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801f5b:	89 f0                	mov    %esi,%eax
  801f5d:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  801f60:	eb 17                	jmp    801f79 <strchr+0x2a>
		if (*s == c)
  801f62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f66:	0f b6 00             	movzbl (%rax),%eax
  801f69:	3a 45 f4             	cmp    -0xc(%rbp),%al
  801f6c:	75 06                	jne    801f74 <strchr+0x25>
			return (char *) s;
  801f6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f72:	eb 15                	jmp    801f89 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  801f74:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801f79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801f7d:	0f b6 00             	movzbl (%rax),%eax
  801f80:	84 c0                	test   %al,%al
  801f82:	75 de                	jne    801f62 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  801f84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801f89:	c9                   	leaveq 
  801f8a:	c3                   	retq   

0000000000801f8b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  801f8b:	55                   	push   %rbp
  801f8c:	48 89 e5             	mov    %rsp,%rbp
  801f8f:	48 83 ec 10          	sub    $0x10,%rsp
  801f93:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801f97:	89 f0                	mov    %esi,%eax
  801f99:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  801f9c:	eb 11                	jmp    801faf <strfind+0x24>
		if (*s == c)
  801f9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fa2:	0f b6 00             	movzbl (%rax),%eax
  801fa5:	3a 45 f4             	cmp    -0xc(%rbp),%al
  801fa8:	74 12                	je     801fbc <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  801faa:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801faf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fb3:	0f b6 00             	movzbl (%rax),%eax
  801fb6:	84 c0                	test   %al,%al
  801fb8:	75 e4                	jne    801f9e <strfind+0x13>
  801fba:	eb 01                	jmp    801fbd <strfind+0x32>
		if (*s == c)
			break;
  801fbc:	90                   	nop
	return (char *) s;
  801fbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801fc1:	c9                   	leaveq 
  801fc2:	c3                   	retq   

0000000000801fc3 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801fc3:	55                   	push   %rbp
  801fc4:	48 89 e5             	mov    %rsp,%rbp
  801fc7:	48 83 ec 18          	sub    $0x18,%rsp
  801fcb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  801fcf:	89 75 f4             	mov    %esi,-0xc(%rbp)
  801fd2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  801fd6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  801fdb:	75 06                	jne    801fe3 <memset+0x20>
		return v;
  801fdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fe1:	eb 69                	jmp    80204c <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  801fe3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fe7:	83 e0 03             	and    $0x3,%eax
  801fea:	48 85 c0             	test   %rax,%rax
  801fed:	75 48                	jne    802037 <memset+0x74>
  801fef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ff3:	83 e0 03             	and    $0x3,%eax
  801ff6:	48 85 c0             	test   %rax,%rax
  801ff9:	75 3c                	jne    802037 <memset+0x74>
		c &= 0xFF;
  801ffb:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  802002:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802005:	89 c2                	mov    %eax,%edx
  802007:	c1 e2 18             	shl    $0x18,%edx
  80200a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80200d:	c1 e0 10             	shl    $0x10,%eax
  802010:	09 c2                	or     %eax,%edx
  802012:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802015:	c1 e0 08             	shl    $0x8,%eax
  802018:	09 d0                	or     %edx,%eax
  80201a:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  80201d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802021:	48 89 c1             	mov    %rax,%rcx
  802024:	48 c1 e9 02          	shr    $0x2,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  802028:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80202c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80202f:	48 89 d7             	mov    %rdx,%rdi
  802032:	fc                   	cld    
  802033:	f3 ab                	rep stos %eax,%es:(%rdi)
  802035:	eb 11                	jmp    802048 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  802037:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80203b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80203e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802042:	48 89 d7             	mov    %rdx,%rdi
  802045:	fc                   	cld    
  802046:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  802048:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80204c:	c9                   	leaveq 
  80204d:	c3                   	retq   

000000000080204e <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80204e:	55                   	push   %rbp
  80204f:	48 89 e5             	mov    %rsp,%rbp
  802052:	48 83 ec 28          	sub    $0x28,%rsp
  802056:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80205a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80205e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  802062:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802066:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  80206a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80206e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  802072:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802076:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80207a:	0f 83 88 00 00 00    	jae    802108 <memmove+0xba>
  802080:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802084:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802088:	48 01 d0             	add    %rdx,%rax
  80208b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80208f:	76 77                	jbe    802108 <memmove+0xba>
		s += n;
  802091:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802095:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  802099:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80209d:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8020a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020a5:	83 e0 03             	and    $0x3,%eax
  8020a8:	48 85 c0             	test   %rax,%rax
  8020ab:	75 3b                	jne    8020e8 <memmove+0x9a>
  8020ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020b1:	83 e0 03             	and    $0x3,%eax
  8020b4:	48 85 c0             	test   %rax,%rax
  8020b7:	75 2f                	jne    8020e8 <memmove+0x9a>
  8020b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8020bd:	83 e0 03             	and    $0x3,%eax
  8020c0:	48 85 c0             	test   %rax,%rax
  8020c3:	75 23                	jne    8020e8 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  8020c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020c9:	48 83 e8 04          	sub    $0x4,%rax
  8020cd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8020d1:	48 83 ea 04          	sub    $0x4,%rdx
  8020d5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8020d9:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  8020dd:	48 89 c7             	mov    %rax,%rdi
  8020e0:	48 89 d6             	mov    %rdx,%rsi
  8020e3:	fd                   	std    
  8020e4:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8020e6:	eb 1d                	jmp    802105 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  8020e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020ec:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8020f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020f4:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  8020f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8020fc:	48 89 d7             	mov    %rdx,%rdi
  8020ff:	48 89 c1             	mov    %rax,%rcx
  802102:	fd                   	std    
  802103:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  802105:	fc                   	cld    
  802106:	eb 57                	jmp    80215f <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  802108:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80210c:	83 e0 03             	and    $0x3,%eax
  80210f:	48 85 c0             	test   %rax,%rax
  802112:	75 36                	jne    80214a <memmove+0xfc>
  802114:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802118:	83 e0 03             	and    $0x3,%eax
  80211b:	48 85 c0             	test   %rax,%rax
  80211e:	75 2a                	jne    80214a <memmove+0xfc>
  802120:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802124:	83 e0 03             	and    $0x3,%eax
  802127:	48 85 c0             	test   %rax,%rax
  80212a:	75 1e                	jne    80214a <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80212c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802130:	48 89 c1             	mov    %rax,%rcx
  802133:	48 c1 e9 02          	shr    $0x2,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  802137:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80213b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80213f:	48 89 c7             	mov    %rax,%rdi
  802142:	48 89 d6             	mov    %rdx,%rsi
  802145:	fc                   	cld    
  802146:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  802148:	eb 15                	jmp    80215f <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80214a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80214e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802152:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802156:	48 89 c7             	mov    %rax,%rdi
  802159:	48 89 d6             	mov    %rdx,%rsi
  80215c:	fc                   	cld    
  80215d:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  80215f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802163:	c9                   	leaveq 
  802164:	c3                   	retq   

0000000000802165 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  802165:	55                   	push   %rbp
  802166:	48 89 e5             	mov    %rsp,%rbp
  802169:	48 83 ec 18          	sub    $0x18,%rsp
  80216d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802171:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802175:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  802179:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80217d:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802181:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802185:	48 89 ce             	mov    %rcx,%rsi
  802188:	48 89 c7             	mov    %rax,%rdi
  80218b:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  802192:	00 00 00 
  802195:	ff d0                	callq  *%rax
}
  802197:	c9                   	leaveq 
  802198:	c3                   	retq   

0000000000802199 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  802199:	55                   	push   %rbp
  80219a:	48 89 e5             	mov    %rsp,%rbp
  80219d:	48 83 ec 28          	sub    $0x28,%rsp
  8021a1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8021a5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8021a9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  8021ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  8021b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8021b9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  8021bd:	eb 38                	jmp    8021f7 <memcmp+0x5e>
		if (*s1 != *s2)
  8021bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021c3:	0f b6 10             	movzbl (%rax),%edx
  8021c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8021ca:	0f b6 00             	movzbl (%rax),%eax
  8021cd:	38 c2                	cmp    %al,%dl
  8021cf:	74 1c                	je     8021ed <memcmp+0x54>
			return (int) *s1 - (int) *s2;
  8021d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8021d5:	0f b6 00             	movzbl (%rax),%eax
  8021d8:	0f b6 d0             	movzbl %al,%edx
  8021db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8021df:	0f b6 00             	movzbl (%rax),%eax
  8021e2:	0f b6 c0             	movzbl %al,%eax
  8021e5:	89 d1                	mov    %edx,%ecx
  8021e7:	29 c1                	sub    %eax,%ecx
  8021e9:	89 c8                	mov    %ecx,%eax
  8021eb:	eb 20                	jmp    80220d <memcmp+0x74>
		s1++, s2++;
  8021ed:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8021f2:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8021f7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8021fc:	0f 95 c0             	setne  %al
  8021ff:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  802204:	84 c0                	test   %al,%al
  802206:	75 b7                	jne    8021bf <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  802208:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80220d:	c9                   	leaveq 
  80220e:	c3                   	retq   

000000000080220f <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80220f:	55                   	push   %rbp
  802210:	48 89 e5             	mov    %rsp,%rbp
  802213:	48 83 ec 28          	sub    $0x28,%rsp
  802217:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80221b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80221e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  802222:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802226:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80222a:	48 01 d0             	add    %rdx,%rax
  80222d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  802231:	eb 13                	jmp    802246 <memfind+0x37>
		if (*(const unsigned char *) s == (unsigned char) c)
  802233:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802237:	0f b6 10             	movzbl (%rax),%edx
  80223a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80223d:	38 c2                	cmp    %al,%dl
  80223f:	74 11                	je     802252 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  802241:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  802246:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80224a:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80224e:	72 e3                	jb     802233 <memfind+0x24>
  802250:	eb 01                	jmp    802253 <memfind+0x44>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  802252:	90                   	nop
	return (void *) s;
  802253:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802257:	c9                   	leaveq 
  802258:	c3                   	retq   

0000000000802259 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  802259:	55                   	push   %rbp
  80225a:	48 89 e5             	mov    %rsp,%rbp
  80225d:	48 83 ec 38          	sub    $0x38,%rsp
  802261:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  802265:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  802269:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  80226c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  802273:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80227a:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80227b:	eb 05                	jmp    802282 <strtol+0x29>
		s++;
  80227d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802282:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802286:	0f b6 00             	movzbl (%rax),%eax
  802289:	3c 20                	cmp    $0x20,%al
  80228b:	74 f0                	je     80227d <strtol+0x24>
  80228d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802291:	0f b6 00             	movzbl (%rax),%eax
  802294:	3c 09                	cmp    $0x9,%al
  802296:	74 e5                	je     80227d <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  802298:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80229c:	0f b6 00             	movzbl (%rax),%eax
  80229f:	3c 2b                	cmp    $0x2b,%al
  8022a1:	75 07                	jne    8022aa <strtol+0x51>
		s++;
  8022a3:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8022a8:	eb 17                	jmp    8022c1 <strtol+0x68>
	else if (*s == '-')
  8022aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022ae:	0f b6 00             	movzbl (%rax),%eax
  8022b1:	3c 2d                	cmp    $0x2d,%al
  8022b3:	75 0c                	jne    8022c1 <strtol+0x68>
		s++, neg = 1;
  8022b5:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8022ba:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  8022c1:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8022c5:	74 06                	je     8022cd <strtol+0x74>
  8022c7:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  8022cb:	75 28                	jne    8022f5 <strtol+0x9c>
  8022cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022d1:	0f b6 00             	movzbl (%rax),%eax
  8022d4:	3c 30                	cmp    $0x30,%al
  8022d6:	75 1d                	jne    8022f5 <strtol+0x9c>
  8022d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022dc:	48 83 c0 01          	add    $0x1,%rax
  8022e0:	0f b6 00             	movzbl (%rax),%eax
  8022e3:	3c 78                	cmp    $0x78,%al
  8022e5:	75 0e                	jne    8022f5 <strtol+0x9c>
		s += 2, base = 16;
  8022e7:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  8022ec:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  8022f3:	eb 2c                	jmp    802321 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  8022f5:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8022f9:	75 19                	jne    802314 <strtol+0xbb>
  8022fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022ff:	0f b6 00             	movzbl (%rax),%eax
  802302:	3c 30                	cmp    $0x30,%al
  802304:	75 0e                	jne    802314 <strtol+0xbb>
		s++, base = 8;
  802306:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80230b:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  802312:	eb 0d                	jmp    802321 <strtol+0xc8>
	else if (base == 0)
  802314:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802318:	75 07                	jne    802321 <strtol+0xc8>
		base = 10;
  80231a:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  802321:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802325:	0f b6 00             	movzbl (%rax),%eax
  802328:	3c 2f                	cmp    $0x2f,%al
  80232a:	7e 1d                	jle    802349 <strtol+0xf0>
  80232c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802330:	0f b6 00             	movzbl (%rax),%eax
  802333:	3c 39                	cmp    $0x39,%al
  802335:	7f 12                	jg     802349 <strtol+0xf0>
			dig = *s - '0';
  802337:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80233b:	0f b6 00             	movzbl (%rax),%eax
  80233e:	0f be c0             	movsbl %al,%eax
  802341:	83 e8 30             	sub    $0x30,%eax
  802344:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802347:	eb 4e                	jmp    802397 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  802349:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80234d:	0f b6 00             	movzbl (%rax),%eax
  802350:	3c 60                	cmp    $0x60,%al
  802352:	7e 1d                	jle    802371 <strtol+0x118>
  802354:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802358:	0f b6 00             	movzbl (%rax),%eax
  80235b:	3c 7a                	cmp    $0x7a,%al
  80235d:	7f 12                	jg     802371 <strtol+0x118>
			dig = *s - 'a' + 10;
  80235f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802363:	0f b6 00             	movzbl (%rax),%eax
  802366:	0f be c0             	movsbl %al,%eax
  802369:	83 e8 57             	sub    $0x57,%eax
  80236c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80236f:	eb 26                	jmp    802397 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  802371:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802375:	0f b6 00             	movzbl (%rax),%eax
  802378:	3c 40                	cmp    $0x40,%al
  80237a:	7e 47                	jle    8023c3 <strtol+0x16a>
  80237c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802380:	0f b6 00             	movzbl (%rax),%eax
  802383:	3c 5a                	cmp    $0x5a,%al
  802385:	7f 3c                	jg     8023c3 <strtol+0x16a>
			dig = *s - 'A' + 10;
  802387:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80238b:	0f b6 00             	movzbl (%rax),%eax
  80238e:	0f be c0             	movsbl %al,%eax
  802391:	83 e8 37             	sub    $0x37,%eax
  802394:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  802397:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80239a:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80239d:	7d 23                	jge    8023c2 <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  80239f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8023a4:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8023a7:	48 98                	cltq   
  8023a9:	48 89 c2             	mov    %rax,%rdx
  8023ac:	48 0f af 55 f0       	imul   -0x10(%rbp),%rdx
  8023b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8023b4:	48 98                	cltq   
  8023b6:	48 01 d0             	add    %rdx,%rax
  8023b9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  8023bd:	e9 5f ff ff ff       	jmpq   802321 <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  8023c2:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  8023c3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8023c8:	74 0b                	je     8023d5 <strtol+0x17c>
		*endptr = (char *) s;
  8023ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8023ce:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8023d2:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  8023d5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8023d9:	74 09                	je     8023e4 <strtol+0x18b>
  8023db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8023df:	48 f7 d8             	neg    %rax
  8023e2:	eb 04                	jmp    8023e8 <strtol+0x18f>
  8023e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8023e8:	c9                   	leaveq 
  8023e9:	c3                   	retq   

00000000008023ea <strstr>:

char * strstr(const char *in, const char *str)
{
  8023ea:	55                   	push   %rbp
  8023eb:	48 89 e5             	mov    %rsp,%rbp
  8023ee:	48 83 ec 30          	sub    $0x30,%rsp
  8023f2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8023f6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  8023fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8023fe:	0f b6 00             	movzbl (%rax),%eax
  802401:	88 45 ff             	mov    %al,-0x1(%rbp)
  802404:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
	if (!c)
  802409:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80240d:	75 06                	jne    802415 <strstr+0x2b>
		return (char *) in;	// Trivial empty string case
  80240f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802413:	eb 68                	jmp    80247d <strstr+0x93>

	len = strlen(str);
  802415:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802419:	48 89 c7             	mov    %rax,%rdi
  80241c:	48 b8 c0 1c 80 00 00 	movabs $0x801cc0,%rax
  802423:	00 00 00 
  802426:	ff d0                	callq  *%rax
  802428:	48 98                	cltq   
  80242a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  80242e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802432:	0f b6 00             	movzbl (%rax),%eax
  802435:	88 45 ef             	mov    %al,-0x11(%rbp)
  802438:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
			if (!sc)
  80243d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  802441:	75 07                	jne    80244a <strstr+0x60>
				return (char *) 0;
  802443:	b8 00 00 00 00       	mov    $0x0,%eax
  802448:	eb 33                	jmp    80247d <strstr+0x93>
		} while (sc != c);
  80244a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80244e:	3a 45 ff             	cmp    -0x1(%rbp),%al
  802451:	75 db                	jne    80242e <strstr+0x44>
	} while (strncmp(in, str, len) != 0);
  802453:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802457:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80245b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80245f:	48 89 ce             	mov    %rcx,%rsi
  802462:	48 89 c7             	mov    %rax,%rdi
  802465:	48 b8 dc 1e 80 00 00 	movabs $0x801edc,%rax
  80246c:	00 00 00 
  80246f:	ff d0                	callq  *%rax
  802471:	85 c0                	test   %eax,%eax
  802473:	75 b9                	jne    80242e <strstr+0x44>

	return (char *) (in - 1);
  802475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802479:	48 83 e8 01          	sub    $0x1,%rax
}
  80247d:	c9                   	leaveq 
  80247e:	c3                   	retq   
	...

0000000000802480 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802480:	55                   	push   %rbp
  802481:	48 89 e5             	mov    %rsp,%rbp
  802484:	53                   	push   %rbx
  802485:	48 83 ec 58          	sub    $0x58,%rsp
  802489:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80248c:	89 75 d8             	mov    %esi,-0x28(%rbp)
  80248f:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  802493:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  802497:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  80249b:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80249f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8024a2:	89 45 ac             	mov    %eax,-0x54(%rbp)
  8024a5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8024a9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8024ad:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8024b1:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8024b5:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8024b9:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8024bc:	4c 89 c3             	mov    %r8,%rbx
  8024bf:	cd 30                	int    $0x30
  8024c1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8024c5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8024c9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  8024cd:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8024d1:	74 3e                	je     802511 <syscall+0x91>
  8024d3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8024d8:	7e 37                	jle    802511 <syscall+0x91>
		panic("syscall %d returned %d (> 0)", num, ret);
  8024da:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8024de:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8024e1:	49 89 d0             	mov    %rdx,%r8
  8024e4:	89 c1                	mov    %eax,%ecx
  8024e6:	48 ba e8 0c 82 00 00 	movabs $0x820ce8,%rdx
  8024ed:	00 00 00 
  8024f0:	be 23 00 00 00       	mov    $0x23,%esi
  8024f5:	48 bf 05 0d 82 00 00 	movabs $0x820d05,%rdi
  8024fc:	00 00 00 
  8024ff:	b8 00 00 00 00       	mov    $0x0,%eax
  802504:	49 b9 20 0f 80 00 00 	movabs $0x800f20,%r9
  80250b:	00 00 00 
  80250e:	41 ff d1             	callq  *%r9

	return ret;
  802511:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  802515:	48 83 c4 58          	add    $0x58,%rsp
  802519:	5b                   	pop    %rbx
  80251a:	5d                   	pop    %rbp
  80251b:	c3                   	retq   

000000000080251c <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  80251c:	55                   	push   %rbp
  80251d:	48 89 e5             	mov    %rsp,%rbp
  802520:	48 83 ec 20          	sub    $0x20,%rsp
  802524:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802528:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  80252c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802530:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802534:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80253b:	00 
  80253c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802542:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802548:	48 89 d1             	mov    %rdx,%rcx
  80254b:	48 89 c2             	mov    %rax,%rdx
  80254e:	be 00 00 00 00       	mov    $0x0,%esi
  802553:	bf 00 00 00 00       	mov    $0x0,%edi
  802558:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  80255f:	00 00 00 
  802562:	ff d0                	callq  *%rax
}
  802564:	c9                   	leaveq 
  802565:	c3                   	retq   

0000000000802566 <sys_cgetc>:

int
sys_cgetc(void)
{
  802566:	55                   	push   %rbp
  802567:	48 89 e5             	mov    %rsp,%rbp
  80256a:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  80256e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802575:	00 
  802576:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80257c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802582:	b9 00 00 00 00       	mov    $0x0,%ecx
  802587:	ba 00 00 00 00       	mov    $0x0,%edx
  80258c:	be 00 00 00 00       	mov    $0x0,%esi
  802591:	bf 01 00 00 00       	mov    $0x1,%edi
  802596:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  80259d:	00 00 00 
  8025a0:	ff d0                	callq  *%rax
}
  8025a2:	c9                   	leaveq 
  8025a3:	c3                   	retq   

00000000008025a4 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  8025a4:	55                   	push   %rbp
  8025a5:	48 89 e5             	mov    %rsp,%rbp
  8025a8:	48 83 ec 20          	sub    $0x20,%rsp
  8025ac:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  8025af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8025b2:	48 98                	cltq   
  8025b4:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8025bb:	00 
  8025bc:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8025c2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8025c8:	b9 00 00 00 00       	mov    $0x0,%ecx
  8025cd:	48 89 c2             	mov    %rax,%rdx
  8025d0:	be 01 00 00 00       	mov    $0x1,%esi
  8025d5:	bf 03 00 00 00       	mov    $0x3,%edi
  8025da:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  8025e1:	00 00 00 
  8025e4:	ff d0                	callq  *%rax
}
  8025e6:	c9                   	leaveq 
  8025e7:	c3                   	retq   

00000000008025e8 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  8025e8:	55                   	push   %rbp
  8025e9:	48 89 e5             	mov    %rsp,%rbp
  8025ec:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  8025f0:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8025f7:	00 
  8025f8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8025fe:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802604:	b9 00 00 00 00       	mov    $0x0,%ecx
  802609:	ba 00 00 00 00       	mov    $0x0,%edx
  80260e:	be 00 00 00 00       	mov    $0x0,%esi
  802613:	bf 02 00 00 00       	mov    $0x2,%edi
  802618:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  80261f:	00 00 00 
  802622:	ff d0                	callq  *%rax
}
  802624:	c9                   	leaveq 
  802625:	c3                   	retq   

0000000000802626 <sys_yield>:

void
sys_yield(void)
{
  802626:	55                   	push   %rbp
  802627:	48 89 e5             	mov    %rsp,%rbp
  80262a:	48 83 ec 10          	sub    $0x10,%rsp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  80262e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802635:	00 
  802636:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80263c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802642:	b9 00 00 00 00       	mov    $0x0,%ecx
  802647:	ba 00 00 00 00       	mov    $0x0,%edx
  80264c:	be 00 00 00 00       	mov    $0x0,%esi
  802651:	bf 0b 00 00 00       	mov    $0xb,%edi
  802656:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  80265d:	00 00 00 
  802660:	ff d0                	callq  *%rax
}
  802662:	c9                   	leaveq 
  802663:	c3                   	retq   

0000000000802664 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  802664:	55                   	push   %rbp
  802665:	48 89 e5             	mov    %rsp,%rbp
  802668:	48 83 ec 20          	sub    $0x20,%rsp
  80266c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80266f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802673:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  802676:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802679:	48 63 c8             	movslq %eax,%rcx
  80267c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802680:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802683:	48 98                	cltq   
  802685:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80268c:	00 
  80268d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802693:	49 89 c8             	mov    %rcx,%r8
  802696:	48 89 d1             	mov    %rdx,%rcx
  802699:	48 89 c2             	mov    %rax,%rdx
  80269c:	be 01 00 00 00       	mov    $0x1,%esi
  8026a1:	bf 04 00 00 00       	mov    $0x4,%edi
  8026a6:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  8026ad:	00 00 00 
  8026b0:	ff d0                	callq  *%rax
}
  8026b2:	c9                   	leaveq 
  8026b3:	c3                   	retq   

00000000008026b4 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  8026b4:	55                   	push   %rbp
  8026b5:	48 89 e5             	mov    %rsp,%rbp
  8026b8:	48 83 ec 30          	sub    $0x30,%rsp
  8026bc:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8026bf:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8026c3:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8026c6:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  8026ca:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  8026ce:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8026d1:	48 63 c8             	movslq %eax,%rcx
  8026d4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8026d8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8026db:	48 63 f0             	movslq %eax,%rsi
  8026de:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8026e5:	48 98                	cltq   
  8026e7:	48 89 0c 24          	mov    %rcx,(%rsp)
  8026eb:	49 89 f9             	mov    %rdi,%r9
  8026ee:	49 89 f0             	mov    %rsi,%r8
  8026f1:	48 89 d1             	mov    %rdx,%rcx
  8026f4:	48 89 c2             	mov    %rax,%rdx
  8026f7:	be 01 00 00 00       	mov    $0x1,%esi
  8026fc:	bf 05 00 00 00       	mov    $0x5,%edi
  802701:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  802708:	00 00 00 
  80270b:	ff d0                	callq  *%rax
}
  80270d:	c9                   	leaveq 
  80270e:	c3                   	retq   

000000000080270f <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80270f:	55                   	push   %rbp
  802710:	48 89 e5             	mov    %rsp,%rbp
  802713:	48 83 ec 20          	sub    $0x20,%rsp
  802717:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80271a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  80271e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802722:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802725:	48 98                	cltq   
  802727:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80272e:	00 
  80272f:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802735:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80273b:	48 89 d1             	mov    %rdx,%rcx
  80273e:	48 89 c2             	mov    %rax,%rdx
  802741:	be 01 00 00 00       	mov    $0x1,%esi
  802746:	bf 06 00 00 00       	mov    $0x6,%edi
  80274b:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  802752:	00 00 00 
  802755:	ff d0                	callq  *%rax
}
  802757:	c9                   	leaveq 
  802758:	c3                   	retq   

0000000000802759 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  802759:	55                   	push   %rbp
  80275a:	48 89 e5             	mov    %rsp,%rbp
  80275d:	48 83 ec 20          	sub    $0x20,%rsp
  802761:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802764:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  802767:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80276a:	48 63 d0             	movslq %eax,%rdx
  80276d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802770:	48 98                	cltq   
  802772:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802779:	00 
  80277a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802780:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802786:	48 89 d1             	mov    %rdx,%rcx
  802789:	48 89 c2             	mov    %rax,%rdx
  80278c:	be 01 00 00 00       	mov    $0x1,%esi
  802791:	bf 08 00 00 00       	mov    $0x8,%edi
  802796:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  80279d:	00 00 00 
  8027a0:	ff d0                	callq  *%rax
}
  8027a2:	c9                   	leaveq 
  8027a3:	c3                   	retq   

00000000008027a4 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  8027a4:	55                   	push   %rbp
  8027a5:	48 89 e5             	mov    %rsp,%rbp
  8027a8:	48 83 ec 20          	sub    $0x20,%rsp
  8027ac:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8027af:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  8027b3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8027b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8027ba:	48 98                	cltq   
  8027bc:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8027c3:	00 
  8027c4:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027ca:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027d0:	48 89 d1             	mov    %rdx,%rcx
  8027d3:	48 89 c2             	mov    %rax,%rdx
  8027d6:	be 01 00 00 00       	mov    $0x1,%esi
  8027db:	bf 09 00 00 00       	mov    $0x9,%edi
  8027e0:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  8027e7:	00 00 00 
  8027ea:	ff d0                	callq  *%rax
}
  8027ec:	c9                   	leaveq 
  8027ed:	c3                   	retq   

00000000008027ee <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  8027ee:	55                   	push   %rbp
  8027ef:	48 89 e5             	mov    %rsp,%rbp
  8027f2:	48 83 ec 20          	sub    $0x20,%rsp
  8027f6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8027f9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  8027fd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802801:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802804:	48 98                	cltq   
  802806:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80280d:	00 
  80280e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802814:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80281a:	48 89 d1             	mov    %rdx,%rcx
  80281d:	48 89 c2             	mov    %rax,%rdx
  802820:	be 01 00 00 00       	mov    $0x1,%esi
  802825:	bf 0a 00 00 00       	mov    $0xa,%edi
  80282a:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  802831:	00 00 00 
  802834:	ff d0                	callq  *%rax
}
  802836:	c9                   	leaveq 
  802837:	c3                   	retq   

0000000000802838 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  802838:	55                   	push   %rbp
  802839:	48 89 e5             	mov    %rsp,%rbp
  80283c:	48 83 ec 30          	sub    $0x30,%rsp
  802840:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802843:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802847:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80284b:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  80284e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802851:	48 63 f0             	movslq %eax,%rsi
  802854:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802858:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80285b:	48 98                	cltq   
  80285d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802861:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802868:	00 
  802869:	49 89 f1             	mov    %rsi,%r9
  80286c:	49 89 c8             	mov    %rcx,%r8
  80286f:	48 89 d1             	mov    %rdx,%rcx
  802872:	48 89 c2             	mov    %rax,%rdx
  802875:	be 00 00 00 00       	mov    $0x0,%esi
  80287a:	bf 0c 00 00 00       	mov    $0xc,%edi
  80287f:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  802886:	00 00 00 
  802889:	ff d0                	callq  *%rax
}
  80288b:	c9                   	leaveq 
  80288c:	c3                   	retq   

000000000080288d <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80288d:	55                   	push   %rbp
  80288e:	48 89 e5             	mov    %rsp,%rbp
  802891:	48 83 ec 20          	sub    $0x20,%rsp
  802895:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802899:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80289d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8028a4:	00 
  8028a5:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028ab:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028b1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8028b6:	48 89 c2             	mov    %rax,%rdx
  8028b9:	be 01 00 00 00       	mov    $0x1,%esi
  8028be:	bf 0d 00 00 00       	mov    $0xd,%edi
  8028c3:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  8028ca:	00 00 00 
  8028cd:	ff d0                	callq  *%rax
}
  8028cf:	c9                   	leaveq 
  8028d0:	c3                   	retq   

00000000008028d1 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  8028d1:	55                   	push   %rbp
  8028d2:	48 89 e5             	mov    %rsp,%rbp
  8028d5:	48 83 ec 10          	sub    $0x10,%rsp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  8028d9:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8028e0:	00 
  8028e1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028e7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028ed:	b9 00 00 00 00       	mov    $0x0,%ecx
  8028f2:	ba 00 00 00 00       	mov    $0x0,%edx
  8028f7:	be 00 00 00 00       	mov    $0x0,%esi
  8028fc:	bf 0e 00 00 00       	mov    $0xe,%edi
  802901:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  802908:	00 00 00 
  80290b:	ff d0                	callq  *%rax
}
  80290d:	c9                   	leaveq 
  80290e:	c3                   	retq   

000000000080290f <sys_ept_map>:


int
sys_ept_map(envid_t srcenvid, void *srcva, envid_t guest, void* guest_pa, int perm) 
{
  80290f:	55                   	push   %rbp
  802910:	48 89 e5             	mov    %rsp,%rbp
  802913:	48 83 ec 30          	sub    $0x30,%rsp
  802917:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80291a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80291e:	89 55 f8             	mov    %edx,-0x8(%rbp)
  802921:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802925:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_ept_map, 0, srcenvid, 
  802929:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80292c:	48 63 c8             	movslq %eax,%rcx
  80292f:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  802933:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802936:	48 63 f0             	movslq %eax,%rsi
  802939:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80293d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802940:	48 98                	cltq   
  802942:	48 89 0c 24          	mov    %rcx,(%rsp)
  802946:	49 89 f9             	mov    %rdi,%r9
  802949:	49 89 f0             	mov    %rsi,%r8
  80294c:	48 89 d1             	mov    %rdx,%rcx
  80294f:	48 89 c2             	mov    %rax,%rdx
  802952:	be 00 00 00 00       	mov    $0x0,%esi
  802957:	bf 0f 00 00 00       	mov    $0xf,%edi
  80295c:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  802963:	00 00 00 
  802966:	ff d0                	callq  *%rax
		       (uint64_t)srcva, guest, (uint64_t)guest_pa, perm);
}
  802968:	c9                   	leaveq 
  802969:	c3                   	retq   

000000000080296a <sys_env_mkguest>:

envid_t
sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  80296a:	55                   	push   %rbp
  80296b:	48 89 e5             	mov    %rsp,%rbp
  80296e:	48 83 ec 20          	sub    $0x20,%rsp
  802972:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802976:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return (envid_t) syscall(SYS_env_mkguest, 0, gphysz, gRIP, 0, 0, 0);
  80297a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80297e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802982:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802989:	00 
  80298a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802990:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802996:	48 89 d1             	mov    %rdx,%rcx
  802999:	48 89 c2             	mov    %rax,%rdx
  80299c:	be 00 00 00 00       	mov    $0x0,%esi
  8029a1:	bf 10 00 00 00       	mov    $0x10,%edi
  8029a6:	48 b8 80 24 80 00 00 	movabs $0x802480,%rax
  8029ad:	00 00 00 
  8029b0:	ff d0                	callq  *%rax
}
  8029b2:	c9                   	leaveq 
  8029b3:	c3                   	retq   

00000000008029b4 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  8029b4:	55                   	push   %rbp
  8029b5:	48 89 e5             	mov    %rsp,%rbp
  8029b8:	48 83 ec 40          	sub    $0x40,%rsp
  8029bc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  8029c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8029c4:	48 8b 00             	mov    (%rax),%rax
  8029c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t err = utf->utf_err;
  8029cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8029cf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8029d3:	89 45 f4             	mov    %eax,-0xc(%rbp)
	// copy-on-write page.  If not, panic.
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).
	// LAB 4: Your code here.
	pte_t entry = uvpt[VPN(addr)];
  8029d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8029da:	48 89 c2             	mov    %rax,%rdx
  8029dd:	48 c1 ea 0c          	shr    $0xc,%rdx
  8029e1:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8029e8:	01 00 00 
  8029eb:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8029ef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// copy the data from the old page to the new page, then move the new
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.
	if((err & FEC_WR) && (uvpt[VPN(addr)] & PTE_COW)) {
  8029f3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8029f6:	83 e0 02             	and    $0x2,%eax
  8029f9:	85 c0                	test   %eax,%eax
  8029fb:	0f 84 4f 01 00 00    	je     802b50 <pgfault+0x19c>
  802a01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a05:	48 89 c2             	mov    %rax,%rdx
  802a08:	48 c1 ea 0c          	shr    $0xc,%rdx
  802a0c:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802a13:	01 00 00 
  802a16:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802a1a:	25 00 08 00 00       	and    $0x800,%eax
  802a1f:	48 85 c0             	test   %rax,%rax
  802a22:	0f 84 28 01 00 00    	je     802b50 <pgfault+0x19c>
		if(sys_page_alloc(0, (void*)PFTEMP, PTE_U|PTE_P|PTE_W) == 0) {
  802a28:	ba 07 00 00 00       	mov    $0x7,%edx
  802a2d:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802a32:	bf 00 00 00 00       	mov    $0x0,%edi
  802a37:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  802a3e:	00 00 00 
  802a41:	ff d0                	callq  *%rax
  802a43:	85 c0                	test   %eax,%eax
  802a45:	0f 85 db 00 00 00    	jne    802b26 <pgfault+0x172>
			void *pg_addr = ROUNDDOWN(addr, PGSIZE);
  802a4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a4f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  802a53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802a57:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802a5d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
			memmove(PFTEMP, pg_addr, PGSIZE);
  802a61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802a65:	ba 00 10 00 00       	mov    $0x1000,%edx
  802a6a:	48 89 c6             	mov    %rax,%rsi
  802a6d:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802a72:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  802a79:	00 00 00 
  802a7c:	ff d0                	callq  *%rax
			r = sys_page_map(0, (void*)PFTEMP, 0, pg_addr, PTE_U|PTE_W|PTE_P);
  802a7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802a82:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802a88:	48 89 c1             	mov    %rax,%rcx
  802a8b:	ba 00 00 00 00       	mov    $0x0,%edx
  802a90:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802a95:	bf 00 00 00 00       	mov    $0x0,%edi
  802a9a:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  802aa1:	00 00 00 
  802aa4:	ff d0                	callq  *%rax
  802aa6:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			if (r < 0) {
  802aa9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  802aad:	79 2a                	jns    802ad9 <pgfault+0x125>
				panic("pgfault...something wrong with page_map");
  802aaf:	48 ba 18 0d 82 00 00 	movabs $0x820d18,%rdx
  802ab6:	00 00 00 
  802ab9:	be 28 00 00 00       	mov    $0x28,%esi
  802abe:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802ac5:	00 00 00 
  802ac8:	b8 00 00 00 00       	mov    $0x0,%eax
  802acd:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  802ad4:	00 00 00 
  802ad7:	ff d1                	callq  *%rcx
			}
			r = sys_page_unmap(0, PFTEMP);
  802ad9:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802ade:	bf 00 00 00 00       	mov    $0x0,%edi
  802ae3:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  802aea:	00 00 00 
  802aed:	ff d0                	callq  *%rax
  802aef:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			if (r < 0) {
  802af2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  802af6:	0f 89 84 00 00 00    	jns    802b80 <pgfault+0x1cc>
				panic("pgfault...something wrong with page_unmap");
  802afc:	48 ba 50 0d 82 00 00 	movabs $0x820d50,%rdx
  802b03:	00 00 00 
  802b06:	be 2c 00 00 00       	mov    $0x2c,%esi
  802b0b:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802b12:	00 00 00 
  802b15:	b8 00 00 00 00       	mov    $0x0,%eax
  802b1a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  802b21:	00 00 00 
  802b24:	ff d1                	callq  *%rcx
			}
			return;
		}
		else {
			panic("pgfault...something wrong with page_alloc");
  802b26:	48 ba 80 0d 82 00 00 	movabs $0x820d80,%rdx
  802b2d:	00 00 00 
  802b30:	be 31 00 00 00       	mov    $0x31,%esi
  802b35:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802b3c:	00 00 00 
  802b3f:	b8 00 00 00 00       	mov    $0x0,%eax
  802b44:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  802b4b:	00 00 00 
  802b4e:	ff d1                	callq  *%rcx
		}
	}
	else {
			panic("pgfault...wrong error %e", err);	
  802b50:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802b53:	89 c1                	mov    %eax,%ecx
  802b55:	48 ba aa 0d 82 00 00 	movabs $0x820daa,%rdx
  802b5c:	00 00 00 
  802b5f:	be 35 00 00 00       	mov    $0x35,%esi
  802b64:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802b6b:	00 00 00 
  802b6e:	b8 00 00 00 00       	mov    $0x0,%eax
  802b73:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802b7a:	00 00 00 
  802b7d:	41 ff d0             	callq  *%r8
			}
			r = sys_page_unmap(0, PFTEMP);
			if (r < 0) {
				panic("pgfault...something wrong with page_unmap");
			}
			return;
  802b80:	90                   	nop
	}
	else {
			panic("pgfault...wrong error %e", err);	
	}
	// LAB 4: Your code here.
}
  802b81:	c9                   	leaveq 
  802b82:	c3                   	retq   

0000000000802b83 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802b83:	55                   	push   %rbp
  802b84:	48 89 e5             	mov    %rsp,%rbp
  802b87:	48 83 ec 30          	sub    $0x30,%rsp
  802b8b:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802b8e:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	pte_t entry = uvpt[pn];
  802b91:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802b98:	01 00 00 
  802b9b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  802b9e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802ba2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	void* addr = (void*) ((uintptr_t)pn * PGSIZE);
  802ba6:	8b 45 d8             	mov    -0x28(%rbp),%eax
  802ba9:	48 c1 e0 0c          	shl    $0xc,%rax
  802bad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	int perm = entry & PTE_SYSCALL;
  802bb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802bb5:	25 07 0e 00 00       	and    $0xe07,%eax
  802bba:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(perm& PTE_SHARE) {
  802bbd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802bc0:	25 00 04 00 00       	and    $0x400,%eax
  802bc5:	85 c0                	test   %eax,%eax
  802bc7:	74 62                	je     802c2b <duppage+0xa8>
		r = sys_page_map(0, addr, envid, addr, perm);
  802bc9:	8b 75 ec             	mov    -0x14(%rbp),%esi
  802bcc:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802bd0:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802bd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802bd7:	41 89 f0             	mov    %esi,%r8d
  802bda:	48 89 c6             	mov    %rax,%rsi
  802bdd:	bf 00 00 00 00       	mov    $0x0,%edi
  802be2:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  802be9:	00 00 00 
  802bec:	ff d0                	callq  *%rax
  802bee:	89 45 e8             	mov    %eax,-0x18(%rbp)
		if(r < 0) {
  802bf1:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  802bf5:	0f 89 78 01 00 00    	jns    802d73 <duppage+0x1f0>
			panic("Something went wrong on duppage %e",r);
  802bfb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802bfe:	89 c1                	mov    %eax,%ecx
  802c00:	48 ba c8 0d 82 00 00 	movabs $0x820dc8,%rdx
  802c07:	00 00 00 
  802c0a:	be 4f 00 00 00       	mov    $0x4f,%esi
  802c0f:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802c16:	00 00 00 
  802c19:	b8 00 00 00 00       	mov    $0x0,%eax
  802c1e:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802c25:	00 00 00 
  802c28:	41 ff d0             	callq  *%r8
		}
	}
	else if((perm & PTE_COW) || (perm & PTE_W)) {
  802c2b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802c2e:	25 00 08 00 00       	and    $0x800,%eax
  802c33:	85 c0                	test   %eax,%eax
  802c35:	75 0e                	jne    802c45 <duppage+0xc2>
  802c37:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802c3a:	83 e0 02             	and    $0x2,%eax
  802c3d:	85 c0                	test   %eax,%eax
  802c3f:	0f 84 d0 00 00 00    	je     802d15 <duppage+0x192>
		perm &= ~PTE_W;
  802c45:	83 65 ec fd          	andl   $0xfffffffd,-0x14(%rbp)
		perm |= PTE_COW;
  802c49:	81 4d ec 00 08 00 00 	orl    $0x800,-0x14(%rbp)
		r = sys_page_map(0, addr, envid, addr, perm);
  802c50:	8b 75 ec             	mov    -0x14(%rbp),%esi
  802c53:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802c57:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802c5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802c5e:	41 89 f0             	mov    %esi,%r8d
  802c61:	48 89 c6             	mov    %rax,%rsi
  802c64:	bf 00 00 00 00       	mov    $0x0,%edi
  802c69:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  802c70:	00 00 00 
  802c73:	ff d0                	callq  *%rax
  802c75:	89 45 e8             	mov    %eax,-0x18(%rbp)
		if(r < 0) {
  802c78:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  802c7c:	79 30                	jns    802cae <duppage+0x12b>
			panic("Something went wrong on duppage %e",r);
  802c7e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802c81:	89 c1                	mov    %eax,%ecx
  802c83:	48 ba c8 0d 82 00 00 	movabs $0x820dc8,%rdx
  802c8a:	00 00 00 
  802c8d:	be 57 00 00 00       	mov    $0x57,%esi
  802c92:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802c99:	00 00 00 
  802c9c:	b8 00 00 00 00       	mov    $0x0,%eax
  802ca1:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802ca8:	00 00 00 
  802cab:	41 ff d0             	callq  *%r8
		}
		r = sys_page_map(0, addr, 0, addr, perm);
  802cae:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  802cb1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802cb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802cb9:	41 89 c8             	mov    %ecx,%r8d
  802cbc:	48 89 d1             	mov    %rdx,%rcx
  802cbf:	ba 00 00 00 00       	mov    $0x0,%edx
  802cc4:	48 89 c6             	mov    %rax,%rsi
  802cc7:	bf 00 00 00 00       	mov    $0x0,%edi
  802ccc:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  802cd3:	00 00 00 
  802cd6:	ff d0                	callq  *%rax
  802cd8:	89 45 e8             	mov    %eax,-0x18(%rbp)
		if(r < 0) {
  802cdb:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  802cdf:	0f 89 8e 00 00 00    	jns    802d73 <duppage+0x1f0>
			panic("Something went wrong on duppage %e",r);
  802ce5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802ce8:	89 c1                	mov    %eax,%ecx
  802cea:	48 ba c8 0d 82 00 00 	movabs $0x820dc8,%rdx
  802cf1:	00 00 00 
  802cf4:	be 5b 00 00 00       	mov    $0x5b,%esi
  802cf9:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802d00:	00 00 00 
  802d03:	b8 00 00 00 00       	mov    $0x0,%eax
  802d08:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802d0f:	00 00 00 
  802d12:	41 ff d0             	callq  *%r8
		}
	}
	else {
		r = sys_page_map(0, addr, envid, addr, perm);
  802d15:	8b 75 ec             	mov    -0x14(%rbp),%esi
  802d18:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802d1c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802d1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802d23:	41 89 f0             	mov    %esi,%r8d
  802d26:	48 89 c6             	mov    %rax,%rsi
  802d29:	bf 00 00 00 00       	mov    $0x0,%edi
  802d2e:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  802d35:	00 00 00 
  802d38:	ff d0                	callq  *%rax
  802d3a:	89 45 e8             	mov    %eax,-0x18(%rbp)
		if(r < 0) {
  802d3d:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  802d41:	79 30                	jns    802d73 <duppage+0x1f0>
			panic("Something went wrong on duppage %e",r);
  802d43:	8b 45 e8             	mov    -0x18(%rbp),%eax
  802d46:	89 c1                	mov    %eax,%ecx
  802d48:	48 ba c8 0d 82 00 00 	movabs $0x820dc8,%rdx
  802d4f:	00 00 00 
  802d52:	be 61 00 00 00       	mov    $0x61,%esi
  802d57:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802d5e:	00 00 00 
  802d61:	b8 00 00 00 00       	mov    $0x0,%eax
  802d66:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802d6d:	00 00 00 
  802d70:	41 ff d0             	callq  *%r8
		}
	}
	// LAB 4: Your code here.
	//panic("duppage not implemented");
	return 0;
  802d73:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802d78:	c9                   	leaveq 
  802d79:	c3                   	retq   

0000000000802d7a <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  802d7a:	55                   	push   %rbp
  802d7b:	48 89 e5             	mov    %rsp,%rbp
  802d7e:	53                   	push   %rbx
  802d7f:	48 83 ec 68          	sub    $0x68,%rsp
	int r=0;
  802d83:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
	set_pgfault_handler(pgfault);
  802d8a:	48 bf b4 29 80 00 00 	movabs $0x8029b4,%rdi
  802d91:	00 00 00 
  802d94:	48 b8 78 55 80 00 00 	movabs $0x805578,%rax
  802d9b:	00 00 00 
  802d9e:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  802da0:	c7 45 9c 07 00 00 00 	movl   $0x7,-0x64(%rbp)
  802da7:	8b 45 9c             	mov    -0x64(%rbp),%eax
  802daa:	cd 30                	int    $0x30
  802dac:	89 c3                	mov    %eax,%ebx
  802dae:	89 5d ac             	mov    %ebx,-0x54(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  802db1:	8b 45 ac             	mov    -0x54(%rbp),%eax
	envid_t childid = sys_exofork();
  802db4:	89 45 b0             	mov    %eax,-0x50(%rbp)
	if(childid < 0) {
  802db7:	83 7d b0 00          	cmpl   $0x0,-0x50(%rbp)
  802dbb:	79 30                	jns    802ded <fork+0x73>
		panic("\n couldn't call fork %e\n",childid);
  802dbd:	8b 45 b0             	mov    -0x50(%rbp),%eax
  802dc0:	89 c1                	mov    %eax,%ecx
  802dc2:	48 ba eb 0d 82 00 00 	movabs $0x820deb,%rdx
  802dc9:	00 00 00 
  802dcc:	be 80 00 00 00       	mov    $0x80,%esi
  802dd1:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802dd8:	00 00 00 
  802ddb:	b8 00 00 00 00       	mov    $0x0,%eax
  802de0:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802de7:	00 00 00 
  802dea:	41 ff d0             	callq  *%r8
	}
	if(childid == 0) {
  802ded:	83 7d b0 00          	cmpl   $0x0,-0x50(%rbp)
  802df1:	75 52                	jne    802e45 <fork+0xcb>
		thisenv = &envs[ENVX(sys_getenvid())];	// some how figured how to get this thing...
  802df3:	48 b8 e8 25 80 00 00 	movabs $0x8025e8,%rax
  802dfa:	00 00 00 
  802dfd:	ff d0                	callq  *%rax
  802dff:	48 98                	cltq   
  802e01:	48 89 c2             	mov    %rax,%rdx
  802e04:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  802e0a:	48 89 d0             	mov    %rdx,%rax
  802e0d:	48 c1 e0 02          	shl    $0x2,%rax
  802e11:	48 01 d0             	add    %rdx,%rax
  802e14:	48 01 c0             	add    %rax,%rax
  802e17:	48 01 d0             	add    %rdx,%rax
  802e1a:	48 c1 e0 05          	shl    $0x5,%rax
  802e1e:	48 89 c2             	mov    %rax,%rdx
  802e21:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  802e28:	00 00 00 
  802e2b:	48 01 c2             	add    %rax,%rdx
  802e2e:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  802e35:	00 00 00 
  802e38:	48 89 10             	mov    %rdx,(%rax)
		return 0; //this is for the child
  802e3b:	b8 00 00 00 00       	mov    $0x0,%eax
  802e40:	e9 9d 02 00 00       	jmpq   8030e2 <fork+0x368>
	}
	r = sys_page_alloc(childid, (void*)(UXSTACKTOP-PGSIZE), PTE_P|PTE_W|PTE_U);
  802e45:	8b 45 b0             	mov    -0x50(%rbp),%eax
  802e48:	ba 07 00 00 00       	mov    $0x7,%edx
  802e4d:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  802e52:	89 c7                	mov    %eax,%edi
  802e54:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  802e5b:	00 00 00 
  802e5e:	ff d0                	callq  *%rax
  802e60:	89 45 b4             	mov    %eax,-0x4c(%rbp)
	if (r < 0)
  802e63:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  802e67:	79 30                	jns    802e99 <fork+0x11f>
		panic("\n couldn't call fork %e\n", r);
  802e69:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  802e6c:	89 c1                	mov    %eax,%ecx
  802e6e:	48 ba eb 0d 82 00 00 	movabs $0x820deb,%rdx
  802e75:	00 00 00 
  802e78:	be 88 00 00 00       	mov    $0x88,%esi
  802e7d:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802e84:	00 00 00 
  802e87:	b8 00 00 00 00       	mov    $0x0,%eax
  802e8c:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802e93:	00 00 00 
  802e96:	41 ff d0             	callq  *%r8
    
	uint64_t pml;
	uint64_t pdpe;
	uint64_t pde;
	uint64_t pte;
	uint64_t each_pde = 0;
  802e99:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  802ea0:	00 
	uint64_t each_pte = 0;
  802ea1:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  802ea8:	00 
	uint64_t each_pdpe = 0;
  802ea9:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  802eb0:	00 
	for(pml = 0; pml < VPML4E(UTOP); pml++) {
  802eb1:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  802eb8:	00 
  802eb9:	e9 73 01 00 00       	jmpq   803031 <fork+0x2b7>
		if(uvpml4e[pml] & PTE_P) {
  802ebe:	48 b8 00 20 40 80 00 	movabs $0x10080402000,%rax
  802ec5:	01 00 00 
  802ec8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802ecc:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802ed0:	83 e0 01             	and    $0x1,%eax
  802ed3:	84 c0                	test   %al,%al
  802ed5:	0f 84 41 01 00 00    	je     80301c <fork+0x2a2>
			
			for(pdpe = 0; pdpe < NPDPENTRIES; pdpe++, each_pdpe++) {
  802edb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  802ee2:	00 
  802ee3:	e9 24 01 00 00       	jmpq   80300c <fork+0x292>
				if(uvpde[each_pdpe] & PTE_P) {
  802ee8:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  802eef:	01 00 00 
  802ef2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  802ef6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802efa:	83 e0 01             	and    $0x1,%eax
  802efd:	84 c0                	test   %al,%al
  802eff:	0f 84 ed 00 00 00    	je     802ff2 <fork+0x278>
					
					for(pde= 0; pde < NPDENTRIES; pde++, each_pde++) {
  802f05:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  802f0c:	00 
  802f0d:	e9 d0 00 00 00       	jmpq   802fe2 <fork+0x268>
						if(uvpd[each_pde] & PTE_P) {
  802f12:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  802f19:	01 00 00 
  802f1c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  802f20:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f24:	83 e0 01             	and    $0x1,%eax
  802f27:	84 c0                	test   %al,%al
  802f29:	0f 84 99 00 00 00    	je     802fc8 <fork+0x24e>
							
							for(pte = 0; pte < NPTENTRIES; pte++, each_pte++) {
  802f2f:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  802f36:	00 
  802f37:	eb 7f                	jmp    802fb8 <fork+0x23e>
								if(uvpt[each_pte] & PTE_P) {
  802f39:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802f40:	01 00 00 
  802f43:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  802f47:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802f4b:	83 e0 01             	and    $0x1,%eax
  802f4e:	84 c0                	test   %al,%al
  802f50:	74 5c                	je     802fae <fork+0x234>
									
									if(each_pte != VPN(UXSTACKTOP-PGSIZE)) {
  802f52:	48 81 7d c0 ff f7 0e 	cmpq   $0xef7ff,-0x40(%rbp)
  802f59:	00 
  802f5a:	74 52                	je     802fae <fork+0x234>
										r = duppage(childid, (unsigned)each_pte);
  802f5c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  802f60:	89 c2                	mov    %eax,%edx
  802f62:	8b 45 b0             	mov    -0x50(%rbp),%eax
  802f65:	89 d6                	mov    %edx,%esi
  802f67:	89 c7                	mov    %eax,%edi
  802f69:	48 b8 83 2b 80 00 00 	movabs $0x802b83,%rax
  802f70:	00 00 00 
  802f73:	ff d0                	callq  *%rax
  802f75:	89 45 b4             	mov    %eax,-0x4c(%rbp)
										if (r < 0)
  802f78:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  802f7c:	79 30                	jns    802fae <fork+0x234>
											panic("\n couldn't call fork %e\n", r);
  802f7e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  802f81:	89 c1                	mov    %eax,%ecx
  802f83:	48 ba eb 0d 82 00 00 	movabs $0x820deb,%rdx
  802f8a:	00 00 00 
  802f8d:	be a0 00 00 00       	mov    $0xa0,%esi
  802f92:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  802f99:	00 00 00 
  802f9c:	b8 00 00 00 00       	mov    $0x0,%eax
  802fa1:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  802fa8:	00 00 00 
  802fab:	41 ff d0             	callq  *%r8
				if(uvpde[each_pdpe] & PTE_P) {
					
					for(pde= 0; pde < NPDENTRIES; pde++, each_pde++) {
						if(uvpd[each_pde] & PTE_P) {
							
							for(pte = 0; pte < NPTENTRIES; pte++, each_pte++) {
  802fae:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
  802fb3:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
  802fb8:	48 81 7d d0 ff 01 00 	cmpq   $0x1ff,-0x30(%rbp)
  802fbf:	00 
  802fc0:	0f 86 73 ff ff ff    	jbe    802f39 <fork+0x1bf>
  802fc6:	eb 10                	jmp    802fd8 <fork+0x25e>
								}
							}

						}
						else {
							each_pte = (each_pde+1)*NPTENTRIES;		
  802fc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  802fcc:	48 83 c0 01          	add    $0x1,%rax
  802fd0:	48 c1 e0 09          	shl    $0x9,%rax
  802fd4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if(uvpml4e[pml] & PTE_P) {
			
			for(pdpe = 0; pdpe < NPDPENTRIES; pdpe++, each_pdpe++) {
				if(uvpde[each_pdpe] & PTE_P) {
					
					for(pde= 0; pde < NPDENTRIES; pde++, each_pde++) {
  802fd8:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802fdd:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
  802fe2:	48 81 7d d8 ff 01 00 	cmpq   $0x1ff,-0x28(%rbp)
  802fe9:	00 
  802fea:	0f 86 22 ff ff ff    	jbe    802f12 <fork+0x198>
  802ff0:	eb 10                	jmp    803002 <fork+0x288>

					}

				}
				else {
					each_pde = (each_pdpe+1)* NPDENTRIES;
  802ff2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  802ff6:	48 83 c0 01          	add    $0x1,%rax
  802ffa:	48 c1 e0 09          	shl    $0x9,%rax
  802ffe:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	uint64_t each_pte = 0;
	uint64_t each_pdpe = 0;
	for(pml = 0; pml < VPML4E(UTOP); pml++) {
		if(uvpml4e[pml] & PTE_P) {
			
			for(pdpe = 0; pdpe < NPDPENTRIES; pdpe++, each_pdpe++) {
  803002:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  803007:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  80300c:	48 81 7d e0 ff 01 00 	cmpq   $0x1ff,-0x20(%rbp)
  803013:	00 
  803014:	0f 86 ce fe ff ff    	jbe    802ee8 <fork+0x16e>
  80301a:	eb 10                	jmp    80302c <fork+0x2b2>

			}

		}
		else {
			each_pdpe = (pml+1) *NPDPENTRIES;
  80301c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803020:	48 83 c0 01          	add    $0x1,%rax
  803024:	48 c1 e0 09          	shl    $0x9,%rax
  803028:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	uint64_t pde;
	uint64_t pte;
	uint64_t each_pde = 0;
	uint64_t each_pte = 0;
	uint64_t each_pdpe = 0;
	for(pml = 0; pml < VPML4E(UTOP); pml++) {
  80302c:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  803031:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803036:	0f 84 82 fe ff ff    	je     802ebe <fork+0x144>
			each_pdpe = (pml+1) *NPDPENTRIES;
		}
	}

	extern void _pgfault_upcall(void);	
	r = sys_env_set_pgfault_upcall(childid, _pgfault_upcall);
  80303c:	8b 45 b0             	mov    -0x50(%rbp),%eax
  80303f:	48 be 10 56 80 00 00 	movabs $0x805610,%rsi
  803046:	00 00 00 
  803049:	89 c7                	mov    %eax,%edi
  80304b:	48 b8 ee 27 80 00 00 	movabs $0x8027ee,%rax
  803052:	00 00 00 
  803055:	ff d0                	callq  *%rax
  803057:	89 45 b4             	mov    %eax,-0x4c(%rbp)
	if (r < 0)
  80305a:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  80305e:	79 30                	jns    803090 <fork+0x316>
		panic("\n couldn't call fork %e\n", r);
  803060:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  803063:	89 c1                	mov    %eax,%ecx
  803065:	48 ba eb 0d 82 00 00 	movabs $0x820deb,%rdx
  80306c:	00 00 00 
  80306f:	be bd 00 00 00       	mov    $0xbd,%esi
  803074:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  80307b:	00 00 00 
  80307e:	b8 00 00 00 00       	mov    $0x0,%eax
  803083:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  80308a:	00 00 00 
  80308d:	41 ff d0             	callq  *%r8

	r = sys_env_set_status(childid, ENV_RUNNABLE);
  803090:	8b 45 b0             	mov    -0x50(%rbp),%eax
  803093:	be 02 00 00 00       	mov    $0x2,%esi
  803098:	89 c7                	mov    %eax,%edi
  80309a:	48 b8 59 27 80 00 00 	movabs $0x802759,%rax
  8030a1:	00 00 00 
  8030a4:	ff d0                	callq  *%rax
  8030a6:	89 45 b4             	mov    %eax,-0x4c(%rbp)
	if (r < 0)
  8030a9:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8030ad:	79 30                	jns    8030df <fork+0x365>
		panic("\n couldn't call fork %e\n", r);
  8030af:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8030b2:	89 c1                	mov    %eax,%ecx
  8030b4:	48 ba eb 0d 82 00 00 	movabs $0x820deb,%rdx
  8030bb:	00 00 00 
  8030be:	be c1 00 00 00       	mov    $0xc1,%esi
  8030c3:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  8030ca:	00 00 00 
  8030cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8030d2:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  8030d9:	00 00 00 
  8030dc:	41 ff d0             	callq  *%r8
	
	// LAB 4: Your code here.
	//panic("fork not implemented");
	return childid;
  8030df:	8b 45 b0             	mov    -0x50(%rbp),%eax
}
  8030e2:	48 83 c4 68          	add    $0x68,%rsp
  8030e6:	5b                   	pop    %rbx
  8030e7:	5d                   	pop    %rbp
  8030e8:	c3                   	retq   

00000000008030e9 <sfork>:

// Challenge!
int
sfork(void)
{
  8030e9:	55                   	push   %rbp
  8030ea:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  8030ed:	48 ba 04 0e 82 00 00 	movabs $0x820e04,%rdx
  8030f4:	00 00 00 
  8030f7:	be cc 00 00 00       	mov    $0xcc,%esi
  8030fc:	48 bf 40 0d 82 00 00 	movabs $0x820d40,%rdi
  803103:	00 00 00 
  803106:	b8 00 00 00 00       	mov    $0x0,%eax
  80310b:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  803112:	00 00 00 
  803115:	ff d1                	callq  *%rcx
	...

0000000000803118 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  803118:	55                   	push   %rbp
  803119:	48 89 e5             	mov    %rsp,%rbp
  80311c:	48 83 ec 30          	sub    $0x30,%rsp
  803120:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803124:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803128:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r = 0;
  80312c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	if(pg) {
  803133:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803138:	74 18                	je     803152 <ipc_recv+0x3a>
		r = sys_ipc_recv(pg);
  80313a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80313e:	48 89 c7             	mov    %rax,%rdi
  803141:	48 b8 8d 28 80 00 00 	movabs $0x80288d,%rax
  803148:	00 00 00 
  80314b:	ff d0                	callq  *%rax
  80314d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803150:	eb 19                	jmp    80316b <ipc_recv+0x53>
	}
	else {
		r = sys_ipc_recv((void*)KERNBASE);
  803152:	48 bf 00 00 00 04 80 	movabs $0x8004000000,%rdi
  803159:	00 00 00 
  80315c:	48 b8 8d 28 80 00 00 	movabs $0x80288d,%rax
  803163:	00 00 00 
  803166:	ff d0                	callq  *%rax
  803168:	89 45 fc             	mov    %eax,-0x4(%rbp)
	}
	if (r < 0) {
  80316b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80316f:	79 39                	jns    8031aa <ipc_recv+0x92>
		*from_env_store =  (from_env_store != NULL) ? (envid_t)0 : *from_env_store;
  803171:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803176:	75 08                	jne    803180 <ipc_recv+0x68>
  803178:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80317c:	8b 00                	mov    (%rax),%eax
  80317e:	eb 05                	jmp    803185 <ipc_recv+0x6d>
  803180:	b8 00 00 00 00       	mov    $0x0,%eax
  803185:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  803189:	89 02                	mov    %eax,(%rdx)
		*perm_store = (perm_store != NULL) ? (int)0 : *perm_store;
  80318b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803190:	75 08                	jne    80319a <ipc_recv+0x82>
  803192:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803196:	8b 00                	mov    (%rax),%eax
  803198:	eb 05                	jmp    80319f <ipc_recv+0x87>
  80319a:	b8 00 00 00 00       	mov    $0x0,%eax
  80319f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8031a3:	89 02                	mov    %eax,(%rdx)
		return r;
  8031a5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8031a8:	eb 53                	jmp    8031fd <ipc_recv+0xe5>
	}
	if(from_env_store) {
  8031aa:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8031af:	74 19                	je     8031ca <ipc_recv+0xb2>
		*from_env_store = thisenv->env_ipc_from;
  8031b1:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8031b8:	00 00 00 
  8031bb:	48 8b 00             	mov    (%rax),%rax
  8031be:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  8031c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8031c8:	89 10                	mov    %edx,(%rax)
	}
	if(perm_store) {
  8031ca:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8031cf:	74 19                	je     8031ea <ipc_recv+0xd2>
		*perm_store = thisenv->env_ipc_perm;
  8031d1:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8031d8:	00 00 00 
  8031db:	48 8b 00             	mov    (%rax),%rax
  8031de:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  8031e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8031e8:	89 10                	mov    %edx,(%rax)
	}
	return thisenv->env_ipc_value;
  8031ea:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8031f1:	00 00 00 
  8031f4:	48 8b 00             	mov    (%rax),%rax
  8031f7:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax
	// LAB 4: Your code here.
	//panic("ipc_recv not implemented");
}
  8031fd:	c9                   	leaveq 
  8031fe:	c3                   	retq   

00000000008031ff <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8031ff:	55                   	push   %rbp
  803200:	48 89 e5             	mov    %rsp,%rbp
  803203:	48 83 ec 30          	sub    $0x30,%rsp
  803207:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80320a:	89 75 e8             	mov    %esi,-0x18(%rbp)
  80320d:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  803211:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r = -E_IPC_NOT_RECV;
  803214:	c7 45 fc f8 ff ff ff 	movl   $0xfffffff8,-0x4(%rbp)
	while(r == -E_IPC_NOT_RECV) {
  80321b:	eb 59                	jmp    803276 <ipc_send+0x77>
		if(pg) {
  80321d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803222:	74 20                	je     803244 <ipc_send+0x45>
			r = sys_ipc_try_send(to_env,val,pg,perm);
  803224:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803227:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  80322a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80322e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803231:	89 c7                	mov    %eax,%edi
  803233:	48 b8 38 28 80 00 00 	movabs $0x802838,%rax
  80323a:	00 00 00 
  80323d:	ff d0                	callq  *%rax
  80323f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803242:	eb 26                	jmp    80326a <ipc_send+0x6b>
		}
		else {
			r = sys_ipc_try_send(to_env, val, (void*)KERNBASE, perm);
  803244:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803247:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80324a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80324d:	89 d1                	mov    %edx,%ecx
  80324f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  803256:	00 00 00 
  803259:	89 c7                	mov    %eax,%edi
  80325b:	48 b8 38 28 80 00 00 	movabs $0x802838,%rax
  803262:	00 00 00 
  803265:	ff d0                	callq  *%rax
  803267:	89 45 fc             	mov    %eax,-0x4(%rbp)
		}
		sys_yield();
  80326a:	48 b8 26 26 80 00 00 	movabs $0x802626,%rax
  803271:	00 00 00 
  803274:	ff d0                	callq  *%rax
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
	int r = -E_IPC_NOT_RECV;
	while(r == -E_IPC_NOT_RECV) {
  803276:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  80327a:	74 a1                	je     80321d <ipc_send+0x1e>
		else {
			r = sys_ipc_try_send(to_env, val, (void*)KERNBASE, perm);
		}
		sys_yield();
	}
	if (r != 0) {
  80327c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803280:	74 2a                	je     8032ac <ipc_send+0xad>
		panic("something went wrong with sending the page");
  803282:	48 ba 20 0e 82 00 00 	movabs $0x820e20,%rdx
  803289:	00 00 00 
  80328c:	be 49 00 00 00       	mov    $0x49,%esi
  803291:	48 bf 4b 0e 82 00 00 	movabs $0x820e4b,%rdi
  803298:	00 00 00 
  80329b:	b8 00 00 00 00       	mov    $0x0,%eax
  8032a0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8032a7:	00 00 00 
  8032aa:	ff d1                	callq  *%rcx
	}
	// LAB 4: Your code here.
	//panic("ipc_send not implemented");
}
  8032ac:	c9                   	leaveq 
  8032ad:	c3                   	retq   

00000000008032ae <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  8032ae:	55                   	push   %rbp
  8032af:	48 89 e5             	mov    %rsp,%rbp
  8032b2:	48 83 ec 18          	sub    $0x18,%rsp
  8032b6:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8032b9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8032c0:	eb 6a                	jmp    80332c <ipc_find_env+0x7e>
		if (envs[i].env_type == type)
  8032c2:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8032c9:	00 00 00 
  8032cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8032cf:	48 63 d0             	movslq %eax,%rdx
  8032d2:	48 89 d0             	mov    %rdx,%rax
  8032d5:	48 c1 e0 02          	shl    $0x2,%rax
  8032d9:	48 01 d0             	add    %rdx,%rax
  8032dc:	48 01 c0             	add    %rax,%rax
  8032df:	48 01 d0             	add    %rdx,%rax
  8032e2:	48 c1 e0 05          	shl    $0x5,%rax
  8032e6:	48 01 c8             	add    %rcx,%rax
  8032e9:	48 05 d0 00 00 00    	add    $0xd0,%rax
  8032ef:	8b 00                	mov    (%rax),%eax
  8032f1:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8032f4:	75 32                	jne    803328 <ipc_find_env+0x7a>
			return envs[i].env_id;
  8032f6:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8032fd:	00 00 00 
  803300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803303:	48 63 d0             	movslq %eax,%rdx
  803306:	48 89 d0             	mov    %rdx,%rax
  803309:	48 c1 e0 02          	shl    $0x2,%rax
  80330d:	48 01 d0             	add    %rdx,%rax
  803310:	48 01 c0             	add    %rax,%rax
  803313:	48 01 d0             	add    %rdx,%rax
  803316:	48 c1 e0 05          	shl    $0x5,%rax
  80331a:	48 01 c8             	add    %rcx,%rax
  80331d:	48 05 c0 00 00 00    	add    $0xc0,%rax
  803323:	8b 40 08             	mov    0x8(%rax),%eax
  803326:	eb 12                	jmp    80333a <ipc_find_env+0x8c>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  803328:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80332c:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  803333:	7e 8d                	jle    8032c2 <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  803335:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80333a:	c9                   	leaveq 
  80333b:	c3                   	retq   

000000000080333c <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  80333c:	55                   	push   %rbp
  80333d:	48 89 e5             	mov    %rsp,%rbp
  803340:	48 83 ec 08          	sub    $0x8,%rsp
  803344:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  803348:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80334c:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  803353:	ff ff ff 
  803356:	48 01 d0             	add    %rdx,%rax
  803359:	48 c1 e8 0c          	shr    $0xc,%rax
}
  80335d:	c9                   	leaveq 
  80335e:	c3                   	retq   

000000000080335f <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80335f:	55                   	push   %rbp
  803360:	48 89 e5             	mov    %rsp,%rbp
  803363:	48 83 ec 08          	sub    $0x8,%rsp
  803367:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  80336b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80336f:	48 89 c7             	mov    %rax,%rdi
  803372:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  803379:	00 00 00 
  80337c:	ff d0                	callq  *%rax
  80337e:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803384:	48 c1 e0 0c          	shl    $0xc,%rax
}
  803388:	c9                   	leaveq 
  803389:	c3                   	retq   

000000000080338a <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80338a:	55                   	push   %rbp
  80338b:	48 89 e5             	mov    %rsp,%rbp
  80338e:	48 83 ec 18          	sub    $0x18,%rsp
  803392:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803396:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80339d:	eb 6b                	jmp    80340a <fd_alloc+0x80>
		fd = INDEX2FD(i);
  80339f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033a2:	48 98                	cltq   
  8033a4:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8033aa:	48 c1 e0 0c          	shl    $0xc,%rax
  8033ae:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  8033b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8033b6:	48 89 c2             	mov    %rax,%rdx
  8033b9:	48 c1 ea 15          	shr    $0x15,%rdx
  8033bd:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8033c4:	01 00 00 
  8033c7:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8033cb:	83 e0 01             	and    $0x1,%eax
  8033ce:	48 85 c0             	test   %rax,%rax
  8033d1:	74 21                	je     8033f4 <fd_alloc+0x6a>
  8033d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8033d7:	48 89 c2             	mov    %rax,%rdx
  8033da:	48 c1 ea 0c          	shr    $0xc,%rdx
  8033de:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8033e5:	01 00 00 
  8033e8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8033ec:	83 e0 01             	and    $0x1,%eax
  8033ef:	48 85 c0             	test   %rax,%rax
  8033f2:	75 12                	jne    803406 <fd_alloc+0x7c>
			*fd_store = fd;
  8033f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8033f8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8033fc:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8033ff:	b8 00 00 00 00       	mov    $0x0,%eax
  803404:	eb 1a                	jmp    803420 <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803406:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80340a:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80340e:	7e 8f                	jle    80339f <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  803410:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803414:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  80341b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  803420:	c9                   	leaveq 
  803421:	c3                   	retq   

0000000000803422 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  803422:	55                   	push   %rbp
  803423:	48 89 e5             	mov    %rsp,%rbp
  803426:	48 83 ec 20          	sub    $0x20,%rsp
  80342a:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80342d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  803431:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  803435:	78 06                	js     80343d <fd_lookup+0x1b>
  803437:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  80343b:	7e 07                	jle    803444 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  80343d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803442:	eb 6c                	jmp    8034b0 <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  803444:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803447:	48 98                	cltq   
  803449:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80344f:	48 c1 e0 0c          	shl    $0xc,%rax
  803453:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  803457:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80345b:	48 89 c2             	mov    %rax,%rdx
  80345e:	48 c1 ea 15          	shr    $0x15,%rdx
  803462:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803469:	01 00 00 
  80346c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803470:	83 e0 01             	and    $0x1,%eax
  803473:	48 85 c0             	test   %rax,%rax
  803476:	74 21                	je     803499 <fd_lookup+0x77>
  803478:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80347c:	48 89 c2             	mov    %rax,%rdx
  80347f:	48 c1 ea 0c          	shr    $0xc,%rdx
  803483:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80348a:	01 00 00 
  80348d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803491:	83 e0 01             	and    $0x1,%eax
  803494:	48 85 c0             	test   %rax,%rax
  803497:	75 07                	jne    8034a0 <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803499:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80349e:	eb 10                	jmp    8034b0 <fd_lookup+0x8e>
	}
	*fd_store = fd;
  8034a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8034a4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8034a8:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8034ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8034b0:	c9                   	leaveq 
  8034b1:	c3                   	retq   

00000000008034b2 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8034b2:	55                   	push   %rbp
  8034b3:	48 89 e5             	mov    %rsp,%rbp
  8034b6:	48 83 ec 30          	sub    $0x30,%rsp
  8034ba:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8034be:	89 f0                	mov    %esi,%eax
  8034c0:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  8034c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8034c7:	48 89 c7             	mov    %rax,%rdi
  8034ca:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  8034d1:	00 00 00 
  8034d4:	ff d0                	callq  *%rax
  8034d6:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8034da:	48 89 d6             	mov    %rdx,%rsi
  8034dd:	89 c7                	mov    %eax,%edi
  8034df:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  8034e6:	00 00 00 
  8034e9:	ff d0                	callq  *%rax
  8034eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8034ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8034f2:	78 0a                	js     8034fe <fd_close+0x4c>
	    || fd != fd2)
  8034f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8034f8:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8034fc:	74 12                	je     803510 <fd_close+0x5e>
		return (must_exist ? r : 0);
  8034fe:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  803502:	74 05                	je     803509 <fd_close+0x57>
  803504:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803507:	eb 05                	jmp    80350e <fd_close+0x5c>
  803509:	b8 00 00 00 00       	mov    $0x0,%eax
  80350e:	eb 69                	jmp    803579 <fd_close+0xc7>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  803510:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803514:	8b 00                	mov    (%rax),%eax
  803516:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80351a:	48 89 d6             	mov    %rdx,%rsi
  80351d:	89 c7                	mov    %eax,%edi
  80351f:	48 b8 7b 35 80 00 00 	movabs $0x80357b,%rax
  803526:	00 00 00 
  803529:	ff d0                	callq  *%rax
  80352b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80352e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803532:	78 2a                	js     80355e <fd_close+0xac>
		if (dev->dev_close)
  803534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803538:	48 8b 40 20          	mov    0x20(%rax),%rax
  80353c:	48 85 c0             	test   %rax,%rax
  80353f:	74 16                	je     803557 <fd_close+0xa5>
			r = (*dev->dev_close)(fd);
  803541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803545:	48 8b 50 20          	mov    0x20(%rax),%rdx
  803549:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80354d:	48 89 c7             	mov    %rax,%rdi
  803550:	ff d2                	callq  *%rdx
  803552:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803555:	eb 07                	jmp    80355e <fd_close+0xac>
		else
			r = 0;
  803557:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80355e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803562:	48 89 c6             	mov    %rax,%rsi
  803565:	bf 00 00 00 00       	mov    $0x0,%edi
  80356a:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  803571:	00 00 00 
  803574:	ff d0                	callq  *%rax
	return r;
  803576:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803579:	c9                   	leaveq 
  80357a:	c3                   	retq   

000000000080357b <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80357b:	55                   	push   %rbp
  80357c:	48 89 e5             	mov    %rsp,%rbp
  80357f:	48 83 ec 20          	sub    $0x20,%rsp
  803583:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803586:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  80358a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803591:	eb 41                	jmp    8035d4 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  803593:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  80359a:	00 00 00 
  80359d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8035a0:	48 63 d2             	movslq %edx,%rdx
  8035a3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8035a7:	8b 00                	mov    (%rax),%eax
  8035a9:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8035ac:	75 22                	jne    8035d0 <dev_lookup+0x55>
			*dev = devtab[i];
  8035ae:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8035b5:	00 00 00 
  8035b8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8035bb:	48 63 d2             	movslq %edx,%rdx
  8035be:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8035c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8035c6:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8035c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8035ce:	eb 60                	jmp    803630 <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8035d0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8035d4:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8035db:	00 00 00 
  8035de:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8035e1:	48 63 d2             	movslq %edx,%rdx
  8035e4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8035e8:	48 85 c0             	test   %rax,%rax
  8035eb:	75 a6                	jne    803593 <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8035ed:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8035f4:	00 00 00 
  8035f7:	48 8b 00             	mov    (%rax),%rax
  8035fa:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803600:	8b 55 ec             	mov    -0x14(%rbp),%edx
  803603:	89 c6                	mov    %eax,%esi
  803605:	48 bf 58 0e 82 00 00 	movabs $0x820e58,%rdi
  80360c:	00 00 00 
  80360f:	b8 00 00 00 00       	mov    $0x0,%eax
  803614:	48 b9 5b 11 80 00 00 	movabs $0x80115b,%rcx
  80361b:	00 00 00 
  80361e:	ff d1                	callq  *%rcx
	*dev = 0;
  803620:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803624:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  80362b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  803630:	c9                   	leaveq 
  803631:	c3                   	retq   

0000000000803632 <close>:

int
close(int fdnum)
{
  803632:	55                   	push   %rbp
  803633:	48 89 e5             	mov    %rsp,%rbp
  803636:	48 83 ec 20          	sub    $0x20,%rsp
  80363a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80363d:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803641:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803644:	48 89 d6             	mov    %rdx,%rsi
  803647:	89 c7                	mov    %eax,%edi
  803649:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  803650:	00 00 00 
  803653:	ff d0                	callq  *%rax
  803655:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803658:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80365c:	79 05                	jns    803663 <close+0x31>
		return r;
  80365e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803661:	eb 18                	jmp    80367b <close+0x49>
	else
		return fd_close(fd, 1);
  803663:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803667:	be 01 00 00 00       	mov    $0x1,%esi
  80366c:	48 89 c7             	mov    %rax,%rdi
  80366f:	48 b8 b2 34 80 00 00 	movabs $0x8034b2,%rax
  803676:	00 00 00 
  803679:	ff d0                	callq  *%rax
}
  80367b:	c9                   	leaveq 
  80367c:	c3                   	retq   

000000000080367d <close_all>:

void
close_all(void)
{
  80367d:	55                   	push   %rbp
  80367e:	48 89 e5             	mov    %rsp,%rbp
  803681:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  803685:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80368c:	eb 15                	jmp    8036a3 <close_all+0x26>
		close(i);
  80368e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803691:	89 c7                	mov    %eax,%edi
  803693:	48 b8 32 36 80 00 00 	movabs $0x803632,%rax
  80369a:	00 00 00 
  80369d:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80369f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8036a3:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8036a7:	7e e5                	jle    80368e <close_all+0x11>
		close(i);
}
  8036a9:	c9                   	leaveq 
  8036aa:	c3                   	retq   

00000000008036ab <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8036ab:	55                   	push   %rbp
  8036ac:	48 89 e5             	mov    %rsp,%rbp
  8036af:	48 83 ec 40          	sub    $0x40,%rsp
  8036b3:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8036b6:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8036b9:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  8036bd:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8036c0:	48 89 d6             	mov    %rdx,%rsi
  8036c3:	89 c7                	mov    %eax,%edi
  8036c5:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  8036cc:	00 00 00 
  8036cf:	ff d0                	callq  *%rax
  8036d1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8036d4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8036d8:	79 08                	jns    8036e2 <dup+0x37>
		return r;
  8036da:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8036dd:	e9 70 01 00 00       	jmpq   803852 <dup+0x1a7>
	close(newfdnum);
  8036e2:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8036e5:	89 c7                	mov    %eax,%edi
  8036e7:	48 b8 32 36 80 00 00 	movabs $0x803632,%rax
  8036ee:	00 00 00 
  8036f1:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  8036f3:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8036f6:	48 98                	cltq   
  8036f8:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8036fe:	48 c1 e0 0c          	shl    $0xc,%rax
  803702:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  803706:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80370a:	48 89 c7             	mov    %rax,%rdi
  80370d:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  803714:	00 00 00 
  803717:	ff d0                	callq  *%rax
  803719:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  80371d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803721:	48 89 c7             	mov    %rax,%rdi
  803724:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  80372b:	00 00 00 
  80372e:	ff d0                	callq  *%rax
  803730:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  803734:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803738:	48 89 c2             	mov    %rax,%rdx
  80373b:	48 c1 ea 15          	shr    $0x15,%rdx
  80373f:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803746:	01 00 00 
  803749:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80374d:	83 e0 01             	and    $0x1,%eax
  803750:	84 c0                	test   %al,%al
  803752:	74 71                	je     8037c5 <dup+0x11a>
  803754:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803758:	48 89 c2             	mov    %rax,%rdx
  80375b:	48 c1 ea 0c          	shr    $0xc,%rdx
  80375f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803766:	01 00 00 
  803769:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80376d:	83 e0 01             	and    $0x1,%eax
  803770:	84 c0                	test   %al,%al
  803772:	74 51                	je     8037c5 <dup+0x11a>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  803774:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803778:	48 89 c2             	mov    %rax,%rdx
  80377b:	48 c1 ea 0c          	shr    $0xc,%rdx
  80377f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803786:	01 00 00 
  803789:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80378d:	89 c1                	mov    %eax,%ecx
  80378f:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  803795:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803799:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80379d:	41 89 c8             	mov    %ecx,%r8d
  8037a0:	48 89 d1             	mov    %rdx,%rcx
  8037a3:	ba 00 00 00 00       	mov    $0x0,%edx
  8037a8:	48 89 c6             	mov    %rax,%rsi
  8037ab:	bf 00 00 00 00       	mov    $0x0,%edi
  8037b0:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  8037b7:	00 00 00 
  8037ba:	ff d0                	callq  *%rax
  8037bc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8037bf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8037c3:	78 56                	js     80381b <dup+0x170>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8037c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8037c9:	48 89 c2             	mov    %rax,%rdx
  8037cc:	48 c1 ea 0c          	shr    $0xc,%rdx
  8037d0:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8037d7:	01 00 00 
  8037da:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8037de:	89 c1                	mov    %eax,%ecx
  8037e0:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  8037e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8037ea:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8037ee:	41 89 c8             	mov    %ecx,%r8d
  8037f1:	48 89 d1             	mov    %rdx,%rcx
  8037f4:	ba 00 00 00 00       	mov    $0x0,%edx
  8037f9:	48 89 c6             	mov    %rax,%rsi
  8037fc:	bf 00 00 00 00       	mov    $0x0,%edi
  803801:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  803808:	00 00 00 
  80380b:	ff d0                	callq  *%rax
  80380d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803810:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803814:	78 08                	js     80381e <dup+0x173>
		goto err;

	return newfdnum;
  803816:	8b 45 c8             	mov    -0x38(%rbp),%eax
  803819:	eb 37                	jmp    803852 <dup+0x1a7>
	ova = fd2data(oldfd);
	nva = fd2data(newfd);

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
  80381b:	90                   	nop
  80381c:	eb 01                	jmp    80381f <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
		goto err;
  80381e:	90                   	nop

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  80381f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803823:	48 89 c6             	mov    %rax,%rsi
  803826:	bf 00 00 00 00       	mov    $0x0,%edi
  80382b:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  803832:	00 00 00 
  803835:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803837:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80383b:	48 89 c6             	mov    %rax,%rsi
  80383e:	bf 00 00 00 00       	mov    $0x0,%edi
  803843:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  80384a:	00 00 00 
  80384d:	ff d0                	callq  *%rax
	return r;
  80384f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803852:	c9                   	leaveq 
  803853:	c3                   	retq   

0000000000803854 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  803854:	55                   	push   %rbp
  803855:	48 89 e5             	mov    %rsp,%rbp
  803858:	48 83 ec 40          	sub    $0x40,%rsp
  80385c:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80385f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803863:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803867:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80386b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80386e:	48 89 d6             	mov    %rdx,%rsi
  803871:	89 c7                	mov    %eax,%edi
  803873:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  80387a:	00 00 00 
  80387d:	ff d0                	callq  *%rax
  80387f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803882:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803886:	78 24                	js     8038ac <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803888:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80388c:	8b 00                	mov    (%rax),%eax
  80388e:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803892:	48 89 d6             	mov    %rdx,%rsi
  803895:	89 c7                	mov    %eax,%edi
  803897:	48 b8 7b 35 80 00 00 	movabs $0x80357b,%rax
  80389e:	00 00 00 
  8038a1:	ff d0                	callq  *%rax
  8038a3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038a6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038aa:	79 05                	jns    8038b1 <read+0x5d>
		return r;
  8038ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8038af:	eb 7a                	jmp    80392b <read+0xd7>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  8038b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8038b5:	8b 40 08             	mov    0x8(%rax),%eax
  8038b8:	83 e0 03             	and    $0x3,%eax
  8038bb:	83 f8 01             	cmp    $0x1,%eax
  8038be:	75 3a                	jne    8038fa <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  8038c0:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  8038c7:	00 00 00 
  8038ca:	48 8b 00             	mov    (%rax),%rax
  8038cd:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8038d3:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8038d6:	89 c6                	mov    %eax,%esi
  8038d8:	48 bf 77 0e 82 00 00 	movabs $0x820e77,%rdi
  8038df:	00 00 00 
  8038e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8038e7:	48 b9 5b 11 80 00 00 	movabs $0x80115b,%rcx
  8038ee:	00 00 00 
  8038f1:	ff d1                	callq  *%rcx
		return -E_INVAL;
  8038f3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8038f8:	eb 31                	jmp    80392b <read+0xd7>
	}
	if (!dev->dev_read)
  8038fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8038fe:	48 8b 40 10          	mov    0x10(%rax),%rax
  803902:	48 85 c0             	test   %rax,%rax
  803905:	75 07                	jne    80390e <read+0xba>
		return -E_NOT_SUPP;
  803907:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  80390c:	eb 1d                	jmp    80392b <read+0xd7>
	return (*dev->dev_read)(fd, buf, n);
  80390e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803912:	4c 8b 40 10          	mov    0x10(%rax),%r8
  803916:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80391a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80391e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803922:	48 89 ce             	mov    %rcx,%rsi
  803925:	48 89 c7             	mov    %rax,%rdi
  803928:	41 ff d0             	callq  *%r8
}
  80392b:	c9                   	leaveq 
  80392c:	c3                   	retq   

000000000080392d <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80392d:	55                   	push   %rbp
  80392e:	48 89 e5             	mov    %rsp,%rbp
  803931:	48 83 ec 30          	sub    $0x30,%rsp
  803935:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803938:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80393c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803940:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803947:	eb 46                	jmp    80398f <readn+0x62>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803949:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80394c:	48 98                	cltq   
  80394e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803952:	48 29 c2             	sub    %rax,%rdx
  803955:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803958:	48 98                	cltq   
  80395a:	48 89 c1             	mov    %rax,%rcx
  80395d:	48 03 4d e0          	add    -0x20(%rbp),%rcx
  803961:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803964:	48 89 ce             	mov    %rcx,%rsi
  803967:	89 c7                	mov    %eax,%edi
  803969:	48 b8 54 38 80 00 00 	movabs $0x803854,%rax
  803970:	00 00 00 
  803973:	ff d0                	callq  *%rax
  803975:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803978:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80397c:	79 05                	jns    803983 <readn+0x56>
			return m;
  80397e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803981:	eb 1d                	jmp    8039a0 <readn+0x73>
		if (m == 0)
  803983:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803987:	74 13                	je     80399c <readn+0x6f>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803989:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80398c:	01 45 fc             	add    %eax,-0x4(%rbp)
  80398f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803992:	48 98                	cltq   
  803994:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803998:	72 af                	jb     803949 <readn+0x1c>
  80399a:	eb 01                	jmp    80399d <readn+0x70>
		m = read(fdnum, (char*)buf + tot, n - tot);
		if (m < 0)
			return m;
		if (m == 0)
			break;
  80399c:	90                   	nop
	}
	return tot;
  80399d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8039a0:	c9                   	leaveq 
  8039a1:	c3                   	retq   

00000000008039a2 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8039a2:	55                   	push   %rbp
  8039a3:	48 89 e5             	mov    %rsp,%rbp
  8039a6:	48 83 ec 40          	sub    $0x40,%rsp
  8039aa:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8039ad:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8039b1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8039b5:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8039b9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8039bc:	48 89 d6             	mov    %rdx,%rsi
  8039bf:	89 c7                	mov    %eax,%edi
  8039c1:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  8039c8:	00 00 00 
  8039cb:	ff d0                	callq  *%rax
  8039cd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039d0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039d4:	78 24                	js     8039fa <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8039d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8039da:	8b 00                	mov    (%rax),%eax
  8039dc:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8039e0:	48 89 d6             	mov    %rdx,%rsi
  8039e3:	89 c7                	mov    %eax,%edi
  8039e5:	48 b8 7b 35 80 00 00 	movabs $0x80357b,%rax
  8039ec:	00 00 00 
  8039ef:	ff d0                	callq  *%rax
  8039f1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8039f4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8039f8:	79 05                	jns    8039ff <write+0x5d>
		return r;
  8039fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8039fd:	eb 79                	jmp    803a78 <write+0xd6>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8039ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a03:	8b 40 08             	mov    0x8(%rax),%eax
  803a06:	83 e0 03             	and    $0x3,%eax
  803a09:	85 c0                	test   %eax,%eax
  803a0b:	75 3a                	jne    803a47 <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803a0d:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803a14:	00 00 00 
  803a17:	48 8b 00             	mov    (%rax),%rax
  803a1a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803a20:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803a23:	89 c6                	mov    %eax,%esi
  803a25:	48 bf 93 0e 82 00 00 	movabs $0x820e93,%rdi
  803a2c:	00 00 00 
  803a2f:	b8 00 00 00 00       	mov    $0x0,%eax
  803a34:	48 b9 5b 11 80 00 00 	movabs $0x80115b,%rcx
  803a3b:	00 00 00 
  803a3e:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803a40:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803a45:	eb 31                	jmp    803a78 <write+0xd6>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  803a47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a4b:	48 8b 40 18          	mov    0x18(%rax),%rax
  803a4f:	48 85 c0             	test   %rax,%rax
  803a52:	75 07                	jne    803a5b <write+0xb9>
		return -E_NOT_SUPP;
  803a54:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803a59:	eb 1d                	jmp    803a78 <write+0xd6>
	return (*dev->dev_write)(fd, buf, n);
  803a5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803a5f:	4c 8b 40 18          	mov    0x18(%rax),%r8
  803a63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803a67:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803a6b:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803a6f:	48 89 ce             	mov    %rcx,%rsi
  803a72:	48 89 c7             	mov    %rax,%rdi
  803a75:	41 ff d0             	callq  *%r8
}
  803a78:	c9                   	leaveq 
  803a79:	c3                   	retq   

0000000000803a7a <seek>:

int
seek(int fdnum, off_t offset)
{
  803a7a:	55                   	push   %rbp
  803a7b:	48 89 e5             	mov    %rsp,%rbp
  803a7e:	48 83 ec 18          	sub    $0x18,%rsp
  803a82:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803a85:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803a88:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803a8c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803a8f:	48 89 d6             	mov    %rdx,%rsi
  803a92:	89 c7                	mov    %eax,%edi
  803a94:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  803a9b:	00 00 00 
  803a9e:	ff d0                	callq  *%rax
  803aa0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803aa3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803aa7:	79 05                	jns    803aae <seek+0x34>
		return r;
  803aa9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803aac:	eb 0f                	jmp    803abd <seek+0x43>
	fd->fd_offset = offset;
  803aae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ab2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803ab5:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  803ab8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803abd:	c9                   	leaveq 
  803abe:	c3                   	retq   

0000000000803abf <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803abf:	55                   	push   %rbp
  803ac0:	48 89 e5             	mov    %rsp,%rbp
  803ac3:	48 83 ec 30          	sub    $0x30,%rsp
  803ac7:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803aca:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803acd:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803ad1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803ad4:	48 89 d6             	mov    %rdx,%rsi
  803ad7:	89 c7                	mov    %eax,%edi
  803ad9:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  803ae0:	00 00 00 
  803ae3:	ff d0                	callq  *%rax
  803ae5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ae8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803aec:	78 24                	js     803b12 <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803aee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803af2:	8b 00                	mov    (%rax),%eax
  803af4:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803af8:	48 89 d6             	mov    %rdx,%rsi
  803afb:	89 c7                	mov    %eax,%edi
  803afd:	48 b8 7b 35 80 00 00 	movabs $0x80357b,%rax
  803b04:	00 00 00 
  803b07:	ff d0                	callq  *%rax
  803b09:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b0c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b10:	79 05                	jns    803b17 <ftruncate+0x58>
		return r;
  803b12:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b15:	eb 72                	jmp    803b89 <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803b17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803b1b:	8b 40 08             	mov    0x8(%rax),%eax
  803b1e:	83 e0 03             	and    $0x3,%eax
  803b21:	85 c0                	test   %eax,%eax
  803b23:	75 3a                	jne    803b5f <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803b25:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  803b2c:	00 00 00 
  803b2f:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803b32:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803b38:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803b3b:	89 c6                	mov    %eax,%esi
  803b3d:	48 bf b0 0e 82 00 00 	movabs $0x820eb0,%rdi
  803b44:	00 00 00 
  803b47:	b8 00 00 00 00       	mov    $0x0,%eax
  803b4c:	48 b9 5b 11 80 00 00 	movabs $0x80115b,%rcx
  803b53:	00 00 00 
  803b56:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803b58:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803b5d:	eb 2a                	jmp    803b89 <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803b5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b63:	48 8b 40 30          	mov    0x30(%rax),%rax
  803b67:	48 85 c0             	test   %rax,%rax
  803b6a:	75 07                	jne    803b73 <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803b6c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803b71:	eb 16                	jmp    803b89 <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803b73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b77:	48 8b 48 30          	mov    0x30(%rax),%rcx
  803b7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803b7f:	8b 55 d8             	mov    -0x28(%rbp),%edx
  803b82:	89 d6                	mov    %edx,%esi
  803b84:	48 89 c7             	mov    %rax,%rdi
  803b87:	ff d1                	callq  *%rcx
}
  803b89:	c9                   	leaveq 
  803b8a:	c3                   	retq   

0000000000803b8b <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803b8b:	55                   	push   %rbp
  803b8c:	48 89 e5             	mov    %rsp,%rbp
  803b8f:	48 83 ec 30          	sub    $0x30,%rsp
  803b93:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803b96:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803b9a:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803b9e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803ba1:	48 89 d6             	mov    %rdx,%rsi
  803ba4:	89 c7                	mov    %eax,%edi
  803ba6:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  803bad:	00 00 00 
  803bb0:	ff d0                	callq  *%rax
  803bb2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bb5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bb9:	78 24                	js     803bdf <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803bbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803bbf:	8b 00                	mov    (%rax),%eax
  803bc1:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803bc5:	48 89 d6             	mov    %rdx,%rsi
  803bc8:	89 c7                	mov    %eax,%edi
  803bca:	48 b8 7b 35 80 00 00 	movabs $0x80357b,%rax
  803bd1:	00 00 00 
  803bd4:	ff d0                	callq  *%rax
  803bd6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bd9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bdd:	79 05                	jns    803be4 <fstat+0x59>
		return r;
  803bdf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803be2:	eb 5e                	jmp    803c42 <fstat+0xb7>
	if (!dev->dev_stat)
  803be4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803be8:	48 8b 40 28          	mov    0x28(%rax),%rax
  803bec:	48 85 c0             	test   %rax,%rax
  803bef:	75 07                	jne    803bf8 <fstat+0x6d>
		return -E_NOT_SUPP;
  803bf1:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803bf6:	eb 4a                	jmp    803c42 <fstat+0xb7>
	stat->st_name[0] = 0;
  803bf8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803bfc:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803bff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803c03:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803c0a:	00 00 00 
	stat->st_isdir = 0;
  803c0d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803c11:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803c18:	00 00 00 
	stat->st_dev = dev;
  803c1b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803c1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803c23:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803c2a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c2e:	48 8b 48 28          	mov    0x28(%rax),%rcx
  803c32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c36:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  803c3a:	48 89 d6             	mov    %rdx,%rsi
  803c3d:	48 89 c7             	mov    %rax,%rdi
  803c40:	ff d1                	callq  *%rcx
}
  803c42:	c9                   	leaveq 
  803c43:	c3                   	retq   

0000000000803c44 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803c44:	55                   	push   %rbp
  803c45:	48 89 e5             	mov    %rsp,%rbp
  803c48:	48 83 ec 20          	sub    $0x20,%rsp
  803c4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803c50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803c54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c58:	be 00 00 00 00       	mov    $0x0,%esi
  803c5d:	48 89 c7             	mov    %rax,%rdi
  803c60:	48 b8 33 3d 80 00 00 	movabs $0x803d33,%rax
  803c67:	00 00 00 
  803c6a:	ff d0                	callq  *%rax
  803c6c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c6f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c73:	79 05                	jns    803c7a <stat+0x36>
		return fd;
  803c75:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c78:	eb 2f                	jmp    803ca9 <stat+0x65>
	r = fstat(fd, stat);
  803c7a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803c7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c81:	48 89 d6             	mov    %rdx,%rsi
  803c84:	89 c7                	mov    %eax,%edi
  803c86:	48 b8 8b 3b 80 00 00 	movabs $0x803b8b,%rax
  803c8d:	00 00 00 
  803c90:	ff d0                	callq  *%rax
  803c92:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803c95:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803c98:	89 c7                	mov    %eax,%edi
  803c9a:	48 b8 32 36 80 00 00 	movabs $0x803632,%rax
  803ca1:	00 00 00 
  803ca4:	ff d0                	callq  *%rax
	return r;
  803ca6:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803ca9:	c9                   	leaveq 
  803caa:	c3                   	retq   
	...

0000000000803cac <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803cac:	55                   	push   %rbp
  803cad:	48 89 e5             	mov    %rsp,%rbp
  803cb0:	48 83 ec 10          	sub    $0x10,%rsp
  803cb4:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803cb7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803cbb:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803cc2:	00 00 00 
  803cc5:	8b 00                	mov    (%rax),%eax
  803cc7:	85 c0                	test   %eax,%eax
  803cc9:	75 1d                	jne    803ce8 <fsipc+0x3c>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803ccb:	bf 01 00 00 00       	mov    $0x1,%edi
  803cd0:	48 b8 ae 32 80 00 00 	movabs $0x8032ae,%rax
  803cd7:	00 00 00 
  803cda:	ff d0                	callq  *%rax
  803cdc:	48 ba 84 90 82 00 00 	movabs $0x829084,%rdx
  803ce3:	00 00 00 
  803ce6:	89 02                	mov    %eax,(%rdx)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803ce8:	48 b8 84 90 82 00 00 	movabs $0x829084,%rax
  803cef:	00 00 00 
  803cf2:	8b 00                	mov    (%rax),%eax
  803cf4:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803cf7:	b9 07 00 00 00       	mov    $0x7,%ecx
  803cfc:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803d03:	00 00 00 
  803d06:	89 c7                	mov    %eax,%edi
  803d08:	48 b8 ff 31 80 00 00 	movabs $0x8031ff,%rax
  803d0f:	00 00 00 
  803d12:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803d14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803d18:	ba 00 00 00 00       	mov    $0x0,%edx
  803d1d:	48 89 c6             	mov    %rax,%rsi
  803d20:	bf 00 00 00 00       	mov    $0x0,%edi
  803d25:	48 b8 18 31 80 00 00 	movabs $0x803118,%rax
  803d2c:	00 00 00 
  803d2f:	ff d0                	callq  *%rax
}
  803d31:	c9                   	leaveq 
  803d32:	c3                   	retq   

0000000000803d33 <open>:
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.

int
open(const char *path, int mode)
{
  803d33:	55                   	push   %rbp
  803d34:	48 89 e5             	mov    %rsp,%rbp
  803d37:	48 83 ec 20          	sub    $0x20,%rsp
  803d3b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803d3f:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	if(strlen(path) >= MAXPATHLEN) {
  803d42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d46:	48 89 c7             	mov    %rax,%rdi
  803d49:	48 b8 c0 1c 80 00 00 	movabs $0x801cc0,%rax
  803d50:	00 00 00 
  803d53:	ff d0                	callq  *%rax
  803d55:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803d5a:	7e 0a                	jle    803d66 <open+0x33>
		return -E_BAD_PATH;
  803d5c:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803d61:	e9 a5 00 00 00       	jmpq   803e0b <open+0xd8>
	// Return the file descriptor index.
	// If any step after fd_alloc fails, use fd_close to free the
	// file descriptor.
	// LAB 5: Your code here
	struct Fd *new_fd;
	int r = fd_alloc(&new_fd);
  803d66:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803d6a:	48 89 c7             	mov    %rax,%rdi
  803d6d:	48 b8 8a 33 80 00 00 	movabs $0x80338a,%rax
  803d74:	00 00 00 
  803d77:	ff d0                	callq  *%rax
  803d79:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r<0) {
  803d7c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d80:	79 08                	jns    803d8a <open+0x57>
		return r;
  803d82:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d85:	e9 81 00 00 00       	jmpq   803e0b <open+0xd8>
	}
	fsipcbuf.open.req_omode = mode;
  803d8a:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803d91:	00 00 00 
  803d94:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  803d97:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)
	strcpy(fsipcbuf.open.req_path, path);
  803d9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803da1:	48 89 c6             	mov    %rax,%rsi
  803da4:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803dab:	00 00 00 
  803dae:	48 b8 2c 1d 80 00 00 	movabs $0x801d2c,%rax
  803db5:	00 00 00 
  803db8:	ff d0                	callq  *%rax
	r = fsipc(FSREQ_OPEN, new_fd);
  803dba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803dbe:	48 89 c6             	mov    %rax,%rsi
  803dc1:	bf 01 00 00 00       	mov    $0x1,%edi
  803dc6:	48 b8 ac 3c 80 00 00 	movabs $0x803cac,%rax
  803dcd:	00 00 00 
  803dd0:	ff d0                	callq  *%rax
  803dd2:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r<0) {
  803dd5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803dd9:	79 1d                	jns    803df8 <open+0xc5>
		fd_close(new_fd, 0);
  803ddb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ddf:	be 00 00 00 00       	mov    $0x0,%esi
  803de4:	48 89 c7             	mov    %rax,%rdi
  803de7:	48 b8 b2 34 80 00 00 	movabs $0x8034b2,%rax
  803dee:	00 00 00 
  803df1:	ff d0                	callq  *%rax
		return r;	
  803df3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803df6:	eb 13                	jmp    803e0b <open+0xd8>
	}
	return fd2num(new_fd);
  803df8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803dfc:	48 89 c7             	mov    %rax,%rdi
  803dff:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  803e06:	00 00 00 
  803e09:	ff d0                	callq  *%rax
}
  803e0b:	c9                   	leaveq 
  803e0c:	c3                   	retq   

0000000000803e0d <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  803e0d:	55                   	push   %rbp
  803e0e:	48 89 e5             	mov    %rsp,%rbp
  803e11:	48 83 ec 10          	sub    $0x10,%rsp
  803e15:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  803e19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803e1d:	8b 50 0c             	mov    0xc(%rax),%edx
  803e20:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803e27:	00 00 00 
  803e2a:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  803e2c:	be 00 00 00 00       	mov    $0x0,%esi
  803e31:	bf 06 00 00 00       	mov    $0x6,%edi
  803e36:	48 b8 ac 3c 80 00 00 	movabs $0x803cac,%rax
  803e3d:	00 00 00 
  803e40:	ff d0                	callq  *%rax
}
  803e42:	c9                   	leaveq 
  803e43:	c3                   	retq   

0000000000803e44 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  803e44:	55                   	push   %rbp
  803e45:	48 89 e5             	mov    %rsp,%rbp
  803e48:	48 83 ec 30          	sub    $0x30,%rsp
  803e4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803e50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803e54:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
	// panic("devfile_read not implemented");
	fsipcbuf.read.req_fileid =  fd->fd_file.id;
  803e58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e5c:	8b 50 0c             	mov    0xc(%rax),%edx
  803e5f:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803e66:	00 00 00 
  803e69:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  803e6b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803e72:	00 00 00 
  803e75:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803e79:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ssize_t nbytes = fsipc(FSREQ_READ, NULL);
  803e7d:	be 00 00 00 00       	mov    $0x0,%esi
  803e82:	bf 03 00 00 00       	mov    $0x3,%edi
  803e87:	48 b8 ac 3c 80 00 00 	movabs $0x803cac,%rax
  803e8e:	00 00 00 
  803e91:	ff d0                	callq  *%rax
  803e93:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(nbytes > 0) {
  803e96:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e9a:	7e 23                	jle    803ebf <devfile_read+0x7b>
		memmove(buf, fsipcbuf.readRet.ret_buf, nbytes);
  803e9c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e9f:	48 63 d0             	movslq %eax,%rdx
  803ea2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803ea6:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  803ead:	00 00 00 
  803eb0:	48 89 c7             	mov    %rax,%rdi
  803eb3:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  803eba:	00 00 00 
  803ebd:	ff d0                	callq  *%rax
	}
	return nbytes;
  803ebf:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803ec2:	c9                   	leaveq 
  803ec3:	c3                   	retq   

0000000000803ec4 <devfile_stat>:

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  803ec4:	55                   	push   %rbp
  803ec5:	48 89 e5             	mov    %rsp,%rbp
  803ec8:	48 83 ec 20          	sub    $0x20,%rsp
  803ecc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803ed0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  803ed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803ed8:	8b 50 0c             	mov    0xc(%rax),%edx
  803edb:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803ee2:	00 00 00 
  803ee5:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  803ee7:	be 00 00 00 00       	mov    $0x0,%esi
  803eec:	bf 05 00 00 00       	mov    $0x5,%edi
  803ef1:	48 b8 ac 3c 80 00 00 	movabs $0x803cac,%rax
  803ef8:	00 00 00 
  803efb:	ff d0                	callq  *%rax
  803efd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f00:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f04:	79 05                	jns    803f0b <devfile_stat+0x47>
		return r;
  803f06:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f09:	eb 56                	jmp    803f61 <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  803f0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f0f:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  803f16:	00 00 00 
  803f19:	48 89 c7             	mov    %rax,%rdi
  803f1c:	48 b8 2c 1d 80 00 00 	movabs $0x801d2c,%rax
  803f23:	00 00 00 
  803f26:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  803f28:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f2f:	00 00 00 
  803f32:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  803f38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f3c:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  803f42:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f49:	00 00 00 
  803f4c:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  803f52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f56:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  803f5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803f61:	c9                   	leaveq 
  803f62:	c3                   	retq   
	...

0000000000803f64 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  803f64:	55                   	push   %rbp
  803f65:	48 89 e5             	mov    %rsp,%rbp
  803f68:	48 83 ec 20          	sub    $0x20,%rsp
  803f6c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  803f6f:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803f73:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803f76:	48 89 d6             	mov    %rdx,%rsi
  803f79:	89 c7                	mov    %eax,%edi
  803f7b:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  803f82:	00 00 00 
  803f85:	ff d0                	callq  *%rax
  803f87:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f8a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f8e:	79 05                	jns    803f95 <fd2sockid+0x31>
		return r;
  803f90:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f93:	eb 24                	jmp    803fb9 <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  803f95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803f99:	8b 10                	mov    (%rax),%edx
  803f9b:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  803fa2:	00 00 00 
  803fa5:	8b 00                	mov    (%rax),%eax
  803fa7:	39 c2                	cmp    %eax,%edx
  803fa9:	74 07                	je     803fb2 <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  803fab:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803fb0:	eb 07                	jmp    803fb9 <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  803fb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803fb6:	8b 40 0c             	mov    0xc(%rax),%eax
}
  803fb9:	c9                   	leaveq 
  803fba:	c3                   	retq   

0000000000803fbb <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  803fbb:	55                   	push   %rbp
  803fbc:	48 89 e5             	mov    %rsp,%rbp
  803fbf:	48 83 ec 20          	sub    $0x20,%rsp
  803fc3:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  803fc6:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803fca:	48 89 c7             	mov    %rax,%rdi
  803fcd:	48 b8 8a 33 80 00 00 	movabs $0x80338a,%rax
  803fd4:	00 00 00 
  803fd7:	ff d0                	callq  *%rax
  803fd9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803fdc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803fe0:	78 26                	js     804008 <alloc_sockfd+0x4d>
            || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  803fe2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803fe6:	ba 07 04 00 00       	mov    $0x407,%edx
  803feb:	48 89 c6             	mov    %rax,%rsi
  803fee:	bf 00 00 00 00       	mov    $0x0,%edi
  803ff3:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  803ffa:	00 00 00 
  803ffd:	ff d0                	callq  *%rax
  803fff:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804002:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804006:	79 16                	jns    80401e <alloc_sockfd+0x63>
		nsipc_close(sockid);
  804008:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80400b:	89 c7                	mov    %eax,%edi
  80400d:	48 b8 c8 44 80 00 00 	movabs $0x8044c8,%rax
  804014:	00 00 00 
  804017:	ff d0                	callq  *%rax
		return r;
  804019:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80401c:	eb 3a                	jmp    804058 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80401e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804022:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  804029:	00 00 00 
  80402c:	8b 12                	mov    (%rdx),%edx
  80402e:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  804030:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804034:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  80403b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80403f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804042:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  804045:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804049:	48 89 c7             	mov    %rax,%rdi
  80404c:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  804053:	00 00 00 
  804056:	ff d0                	callq  *%rax
}
  804058:	c9                   	leaveq 
  804059:	c3                   	retq   

000000000080405a <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80405a:	55                   	push   %rbp
  80405b:	48 89 e5             	mov    %rsp,%rbp
  80405e:	48 83 ec 30          	sub    $0x30,%rsp
  804062:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804065:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804069:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  80406d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804070:	89 c7                	mov    %eax,%edi
  804072:	48 b8 64 3f 80 00 00 	movabs $0x803f64,%rax
  804079:	00 00 00 
  80407c:	ff d0                	callq  *%rax
  80407e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804081:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804085:	79 05                	jns    80408c <accept+0x32>
		return r;
  804087:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80408a:	eb 3b                	jmp    8040c7 <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80408c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804090:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804094:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804097:	48 89 ce             	mov    %rcx,%rsi
  80409a:	89 c7                	mov    %eax,%edi
  80409c:	48 b8 a5 43 80 00 00 	movabs $0x8043a5,%rax
  8040a3:	00 00 00 
  8040a6:	ff d0                	callq  *%rax
  8040a8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8040ab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8040af:	79 05                	jns    8040b6 <accept+0x5c>
		return r;
  8040b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040b4:	eb 11                	jmp    8040c7 <accept+0x6d>
	return alloc_sockfd(r);
  8040b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040b9:	89 c7                	mov    %eax,%edi
  8040bb:	48 b8 bb 3f 80 00 00 	movabs $0x803fbb,%rax
  8040c2:	00 00 00 
  8040c5:	ff d0                	callq  *%rax
}
  8040c7:	c9                   	leaveq 
  8040c8:	c3                   	retq   

00000000008040c9 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8040c9:	55                   	push   %rbp
  8040ca:	48 89 e5             	mov    %rsp,%rbp
  8040cd:	48 83 ec 20          	sub    $0x20,%rsp
  8040d1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8040d4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8040d8:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8040db:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8040de:	89 c7                	mov    %eax,%edi
  8040e0:	48 b8 64 3f 80 00 00 	movabs $0x803f64,%rax
  8040e7:	00 00 00 
  8040ea:	ff d0                	callq  *%rax
  8040ec:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8040ef:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8040f3:	79 05                	jns    8040fa <bind+0x31>
		return r;
  8040f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040f8:	eb 1b                	jmp    804115 <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  8040fa:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8040fd:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804101:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804104:	48 89 ce             	mov    %rcx,%rsi
  804107:	89 c7                	mov    %eax,%edi
  804109:	48 b8 24 44 80 00 00 	movabs $0x804424,%rax
  804110:	00 00 00 
  804113:	ff d0                	callq  *%rax
}
  804115:	c9                   	leaveq 
  804116:	c3                   	retq   

0000000000804117 <shutdown>:

int
shutdown(int s, int how)
{
  804117:	55                   	push   %rbp
  804118:	48 89 e5             	mov    %rsp,%rbp
  80411b:	48 83 ec 20          	sub    $0x20,%rsp
  80411f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804122:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804125:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804128:	89 c7                	mov    %eax,%edi
  80412a:	48 b8 64 3f 80 00 00 	movabs $0x803f64,%rax
  804131:	00 00 00 
  804134:	ff d0                	callq  *%rax
  804136:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804139:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80413d:	79 05                	jns    804144 <shutdown+0x2d>
		return r;
  80413f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804142:	eb 16                	jmp    80415a <shutdown+0x43>
	return nsipc_shutdown(r, how);
  804144:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804147:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80414a:	89 d6                	mov    %edx,%esi
  80414c:	89 c7                	mov    %eax,%edi
  80414e:	48 b8 88 44 80 00 00 	movabs $0x804488,%rax
  804155:	00 00 00 
  804158:	ff d0                	callq  *%rax
}
  80415a:	c9                   	leaveq 
  80415b:	c3                   	retq   

000000000080415c <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  80415c:	55                   	push   %rbp
  80415d:	48 89 e5             	mov    %rsp,%rbp
  804160:	48 83 ec 10          	sub    $0x10,%rsp
  804164:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804168:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80416c:	48 89 c7             	mov    %rax,%rdi
  80416f:	48 b8 94 56 80 00 00 	movabs $0x805694,%rax
  804176:	00 00 00 
  804179:	ff d0                	callq  *%rax
  80417b:	83 f8 01             	cmp    $0x1,%eax
  80417e:	75 17                	jne    804197 <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  804180:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804184:	8b 40 0c             	mov    0xc(%rax),%eax
  804187:	89 c7                	mov    %eax,%edi
  804189:	48 b8 c8 44 80 00 00 	movabs $0x8044c8,%rax
  804190:	00 00 00 
  804193:	ff d0                	callq  *%rax
  804195:	eb 05                	jmp    80419c <devsock_close+0x40>
	else
		return 0;
  804197:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80419c:	c9                   	leaveq 
  80419d:	c3                   	retq   

000000000080419e <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80419e:	55                   	push   %rbp
  80419f:	48 89 e5             	mov    %rsp,%rbp
  8041a2:	48 83 ec 20          	sub    $0x20,%rsp
  8041a6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8041a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8041ad:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8041b0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041b3:	89 c7                	mov    %eax,%edi
  8041b5:	48 b8 64 3f 80 00 00 	movabs $0x803f64,%rax
  8041bc:	00 00 00 
  8041bf:	ff d0                	callq  *%rax
  8041c1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8041c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8041c8:	79 05                	jns    8041cf <connect+0x31>
		return r;
  8041ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8041cd:	eb 1b                	jmp    8041ea <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  8041cf:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8041d2:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8041d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8041d9:	48 89 ce             	mov    %rcx,%rsi
  8041dc:	89 c7                	mov    %eax,%edi
  8041de:	48 b8 f5 44 80 00 00 	movabs $0x8044f5,%rax
  8041e5:	00 00 00 
  8041e8:	ff d0                	callq  *%rax
}
  8041ea:	c9                   	leaveq 
  8041eb:	c3                   	retq   

00000000008041ec <listen>:

int
listen(int s, int backlog)
{
  8041ec:	55                   	push   %rbp
  8041ed:	48 89 e5             	mov    %rsp,%rbp
  8041f0:	48 83 ec 20          	sub    $0x20,%rsp
  8041f4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8041f7:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8041fa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041fd:	89 c7                	mov    %eax,%edi
  8041ff:	48 b8 64 3f 80 00 00 	movabs $0x803f64,%rax
  804206:	00 00 00 
  804209:	ff d0                	callq  *%rax
  80420b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80420e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804212:	79 05                	jns    804219 <listen+0x2d>
		return r;
  804214:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804217:	eb 16                	jmp    80422f <listen+0x43>
	return nsipc_listen(r, backlog);
  804219:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80421c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80421f:	89 d6                	mov    %edx,%esi
  804221:	89 c7                	mov    %eax,%edi
  804223:	48 b8 59 45 80 00 00 	movabs $0x804559,%rax
  80422a:	00 00 00 
  80422d:	ff d0                	callq  *%rax
}
  80422f:	c9                   	leaveq 
  804230:	c3                   	retq   

0000000000804231 <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  804231:	55                   	push   %rbp
  804232:	48 89 e5             	mov    %rsp,%rbp
  804235:	48 83 ec 20          	sub    $0x20,%rsp
  804239:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80423d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804241:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  804245:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804249:	89 c2                	mov    %eax,%edx
  80424b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80424f:	8b 40 0c             	mov    0xc(%rax),%eax
  804252:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804256:	b9 00 00 00 00       	mov    $0x0,%ecx
  80425b:	89 c7                	mov    %eax,%edi
  80425d:	48 b8 99 45 80 00 00 	movabs $0x804599,%rax
  804264:	00 00 00 
  804267:	ff d0                	callq  *%rax
}
  804269:	c9                   	leaveq 
  80426a:	c3                   	retq   

000000000080426b <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80426b:	55                   	push   %rbp
  80426c:	48 89 e5             	mov    %rsp,%rbp
  80426f:	48 83 ec 20          	sub    $0x20,%rsp
  804273:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804277:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80427b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80427f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804283:	89 c2                	mov    %eax,%edx
  804285:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804289:	8b 40 0c             	mov    0xc(%rax),%eax
  80428c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804290:	b9 00 00 00 00       	mov    $0x0,%ecx
  804295:	89 c7                	mov    %eax,%edi
  804297:	48 b8 65 46 80 00 00 	movabs $0x804665,%rax
  80429e:	00 00 00 
  8042a1:	ff d0                	callq  *%rax
}
  8042a3:	c9                   	leaveq 
  8042a4:	c3                   	retq   

00000000008042a5 <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8042a5:	55                   	push   %rbp
  8042a6:	48 89 e5             	mov    %rsp,%rbp
  8042a9:	48 83 ec 10          	sub    $0x10,%rsp
  8042ad:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8042b1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  8042b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8042b9:	48 be db 0e 82 00 00 	movabs $0x820edb,%rsi
  8042c0:	00 00 00 
  8042c3:	48 89 c7             	mov    %rax,%rdi
  8042c6:	48 b8 2c 1d 80 00 00 	movabs $0x801d2c,%rax
  8042cd:	00 00 00 
  8042d0:	ff d0                	callq  *%rax
	return 0;
  8042d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8042d7:	c9                   	leaveq 
  8042d8:	c3                   	retq   

00000000008042d9 <socket>:

int
socket(int domain, int type, int protocol)
{
  8042d9:	55                   	push   %rbp
  8042da:	48 89 e5             	mov    %rsp,%rbp
  8042dd:	48 83 ec 20          	sub    $0x20,%rsp
  8042e1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8042e4:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8042e7:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8042ea:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8042ed:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  8042f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8042f3:	89 ce                	mov    %ecx,%esi
  8042f5:	89 c7                	mov    %eax,%edi
  8042f7:	48 b8 1d 47 80 00 00 	movabs $0x80471d,%rax
  8042fe:	00 00 00 
  804301:	ff d0                	callq  *%rax
  804303:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804306:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80430a:	79 05                	jns    804311 <socket+0x38>
		return r;
  80430c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80430f:	eb 11                	jmp    804322 <socket+0x49>
	return alloc_sockfd(r);
  804311:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804314:	89 c7                	mov    %eax,%edi
  804316:	48 b8 bb 3f 80 00 00 	movabs $0x803fbb,%rax
  80431d:	00 00 00 
  804320:	ff d0                	callq  *%rax
}
  804322:	c9                   	leaveq 
  804323:	c3                   	retq   

0000000000804324 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  804324:	55                   	push   %rbp
  804325:	48 89 e5             	mov    %rsp,%rbp
  804328:	48 83 ec 10          	sub    $0x10,%rsp
  80432c:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  80432f:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  804336:	00 00 00 
  804339:	8b 00                	mov    (%rax),%eax
  80433b:	85 c0                	test   %eax,%eax
  80433d:	75 1d                	jne    80435c <nsipc+0x38>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  80433f:	bf 02 00 00 00       	mov    $0x2,%edi
  804344:	48 b8 ae 32 80 00 00 	movabs $0x8032ae,%rax
  80434b:	00 00 00 
  80434e:	ff d0                	callq  *%rax
  804350:	48 ba 88 90 82 00 00 	movabs $0x829088,%rdx
  804357:	00 00 00 
  80435a:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80435c:	48 b8 88 90 82 00 00 	movabs $0x829088,%rax
  804363:	00 00 00 
  804366:	8b 00                	mov    (%rax),%eax
  804368:	8b 75 fc             	mov    -0x4(%rbp),%esi
  80436b:	b9 07 00 00 00       	mov    $0x7,%ecx
  804370:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  804377:	00 00 00 
  80437a:	89 c7                	mov    %eax,%edi
  80437c:	48 b8 ff 31 80 00 00 	movabs $0x8031ff,%rax
  804383:	00 00 00 
  804386:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  804388:	ba 00 00 00 00       	mov    $0x0,%edx
  80438d:	be 00 00 00 00       	mov    $0x0,%esi
  804392:	bf 00 00 00 00       	mov    $0x0,%edi
  804397:	48 b8 18 31 80 00 00 	movabs $0x803118,%rax
  80439e:	00 00 00 
  8043a1:	ff d0                	callq  *%rax
}
  8043a3:	c9                   	leaveq 
  8043a4:	c3                   	retq   

00000000008043a5 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8043a5:	55                   	push   %rbp
  8043a6:	48 89 e5             	mov    %rsp,%rbp
  8043a9:	48 83 ec 30          	sub    $0x30,%rsp
  8043ad:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8043b0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8043b4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  8043b8:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8043bf:	00 00 00 
  8043c2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8043c5:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8043c7:	bf 01 00 00 00       	mov    $0x1,%edi
  8043cc:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  8043d3:	00 00 00 
  8043d6:	ff d0                	callq  *%rax
  8043d8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8043db:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8043df:	78 3e                	js     80441f <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  8043e1:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8043e8:	00 00 00 
  8043eb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8043ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8043f3:	8b 40 10             	mov    0x10(%rax),%eax
  8043f6:	89 c2                	mov    %eax,%edx
  8043f8:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8043fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804400:	48 89 ce             	mov    %rcx,%rsi
  804403:	48 89 c7             	mov    %rax,%rdi
  804406:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  80440d:	00 00 00 
  804410:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  804412:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804416:	8b 50 10             	mov    0x10(%rax),%edx
  804419:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80441d:	89 10                	mov    %edx,(%rax)
	}
	return r;
  80441f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804422:	c9                   	leaveq 
  804423:	c3                   	retq   

0000000000804424 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804424:	55                   	push   %rbp
  804425:	48 89 e5             	mov    %rsp,%rbp
  804428:	48 83 ec 10          	sub    $0x10,%rsp
  80442c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80442f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804433:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  804436:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80443d:	00 00 00 
  804440:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804443:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  804445:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804448:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80444c:	48 89 c6             	mov    %rax,%rsi
  80444f:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804456:	00 00 00 
  804459:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  804460:	00 00 00 
  804463:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  804465:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80446c:	00 00 00 
  80446f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804472:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  804475:	bf 02 00 00 00       	mov    $0x2,%edi
  80447a:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  804481:	00 00 00 
  804484:	ff d0                	callq  *%rax
}
  804486:	c9                   	leaveq 
  804487:	c3                   	retq   

0000000000804488 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804488:	55                   	push   %rbp
  804489:	48 89 e5             	mov    %rsp,%rbp
  80448c:	48 83 ec 10          	sub    $0x10,%rsp
  804490:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804493:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  804496:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80449d:	00 00 00 
  8044a0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8044a3:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  8044a5:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8044ac:	00 00 00 
  8044af:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8044b2:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  8044b5:	bf 03 00 00 00       	mov    $0x3,%edi
  8044ba:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  8044c1:	00 00 00 
  8044c4:	ff d0                	callq  *%rax
}
  8044c6:	c9                   	leaveq 
  8044c7:	c3                   	retq   

00000000008044c8 <nsipc_close>:

int
nsipc_close(int s)
{
  8044c8:	55                   	push   %rbp
  8044c9:	48 89 e5             	mov    %rsp,%rbp
  8044cc:	48 83 ec 10          	sub    $0x10,%rsp
  8044d0:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  8044d3:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8044da:	00 00 00 
  8044dd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8044e0:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  8044e2:	bf 04 00 00 00       	mov    $0x4,%edi
  8044e7:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  8044ee:	00 00 00 
  8044f1:	ff d0                	callq  *%rax
}
  8044f3:	c9                   	leaveq 
  8044f4:	c3                   	retq   

00000000008044f5 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8044f5:	55                   	push   %rbp
  8044f6:	48 89 e5             	mov    %rsp,%rbp
  8044f9:	48 83 ec 10          	sub    $0x10,%rsp
  8044fd:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804500:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804504:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  804507:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80450e:	00 00 00 
  804511:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804514:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  804516:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804519:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80451d:	48 89 c6             	mov    %rax,%rsi
  804520:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804527:	00 00 00 
  80452a:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  804531:	00 00 00 
  804534:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  804536:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80453d:	00 00 00 
  804540:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804543:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  804546:	bf 05 00 00 00       	mov    $0x5,%edi
  80454b:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  804552:	00 00 00 
  804555:	ff d0                	callq  *%rax
}
  804557:	c9                   	leaveq 
  804558:	c3                   	retq   

0000000000804559 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804559:	55                   	push   %rbp
  80455a:	48 89 e5             	mov    %rsp,%rbp
  80455d:	48 83 ec 10          	sub    $0x10,%rsp
  804561:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804564:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  804567:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80456e:	00 00 00 
  804571:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804574:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804576:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80457d:	00 00 00 
  804580:	8b 55 f8             	mov    -0x8(%rbp),%edx
  804583:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  804586:	bf 06 00 00 00       	mov    $0x6,%edi
  80458b:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  804592:	00 00 00 
  804595:	ff d0                	callq  *%rax
}
  804597:	c9                   	leaveq 
  804598:	c3                   	retq   

0000000000804599 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804599:	55                   	push   %rbp
  80459a:	48 89 e5             	mov    %rsp,%rbp
  80459d:	48 83 ec 30          	sub    $0x30,%rsp
  8045a1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8045a4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8045a8:	89 55 e8             	mov    %edx,-0x18(%rbp)
  8045ab:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  8045ae:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8045b5:	00 00 00 
  8045b8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8045bb:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  8045bd:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8045c4:	00 00 00 
  8045c7:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8045ca:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  8045cd:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8045d4:	00 00 00 
  8045d7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8045da:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8045dd:	bf 07 00 00 00       	mov    $0x7,%edi
  8045e2:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  8045e9:	00 00 00 
  8045ec:	ff d0                	callq  *%rax
  8045ee:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8045f1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8045f5:	78 69                	js     804660 <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  8045f7:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  8045fe:	7f 08                	jg     804608 <nsipc_recv+0x6f>
  804600:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804603:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  804606:	7e 35                	jle    80463d <nsipc_recv+0xa4>
  804608:	48 b9 e2 0e 82 00 00 	movabs $0x820ee2,%rcx
  80460f:	00 00 00 
  804612:	48 ba f7 0e 82 00 00 	movabs $0x820ef7,%rdx
  804619:	00 00 00 
  80461c:	be 61 00 00 00       	mov    $0x61,%esi
  804621:	48 bf 0c 0f 82 00 00 	movabs $0x820f0c,%rdi
  804628:	00 00 00 
  80462b:	b8 00 00 00 00       	mov    $0x0,%eax
  804630:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  804637:	00 00 00 
  80463a:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  80463d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804640:	48 63 d0             	movslq %eax,%rdx
  804643:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804647:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  80464e:	00 00 00 
  804651:	48 89 c7             	mov    %rax,%rdi
  804654:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  80465b:	00 00 00 
  80465e:	ff d0                	callq  *%rax
	}

	return r;
  804660:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804663:	c9                   	leaveq 
  804664:	c3                   	retq   

0000000000804665 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804665:	55                   	push   %rbp
  804666:	48 89 e5             	mov    %rsp,%rbp
  804669:	48 83 ec 20          	sub    $0x20,%rsp
  80466d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804670:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804674:	89 55 f8             	mov    %edx,-0x8(%rbp)
  804677:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  80467a:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804681:	00 00 00 
  804684:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804687:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804689:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  804690:	7e 35                	jle    8046c7 <nsipc_send+0x62>
  804692:	48 b9 18 0f 82 00 00 	movabs $0x820f18,%rcx
  804699:	00 00 00 
  80469c:	48 ba f7 0e 82 00 00 	movabs $0x820ef7,%rdx
  8046a3:	00 00 00 
  8046a6:	be 6c 00 00 00       	mov    $0x6c,%esi
  8046ab:	48 bf 0c 0f 82 00 00 	movabs $0x820f0c,%rdi
  8046b2:	00 00 00 
  8046b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8046ba:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  8046c1:	00 00 00 
  8046c4:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8046c7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8046ca:	48 63 d0             	movslq %eax,%rdx
  8046cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8046d1:	48 89 c6             	mov    %rax,%rsi
  8046d4:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  8046db:	00 00 00 
  8046de:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  8046e5:	00 00 00 
  8046e8:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  8046ea:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8046f1:	00 00 00 
  8046f4:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8046f7:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  8046fa:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804701:	00 00 00 
  804704:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804707:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  80470a:	bf 08 00 00 00       	mov    $0x8,%edi
  80470f:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  804716:	00 00 00 
  804719:	ff d0                	callq  *%rax
}
  80471b:	c9                   	leaveq 
  80471c:	c3                   	retq   

000000000080471d <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  80471d:	55                   	push   %rbp
  80471e:	48 89 e5             	mov    %rsp,%rbp
  804721:	48 83 ec 10          	sub    $0x10,%rsp
  804725:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804728:	89 75 f8             	mov    %esi,-0x8(%rbp)
  80472b:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  80472e:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804735:	00 00 00 
  804738:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80473b:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  80473d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804744:	00 00 00 
  804747:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80474a:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  80474d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804754:	00 00 00 
  804757:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80475a:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  80475d:	bf 09 00 00 00       	mov    $0x9,%edi
  804762:	48 b8 24 43 80 00 00 	movabs $0x804324,%rax
  804769:	00 00 00 
  80476c:	ff d0                	callq  *%rax
}
  80476e:	c9                   	leaveq 
  80476f:	c3                   	retq   

0000000000804770 <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  804770:	55                   	push   %rbp
  804771:	48 89 e5             	mov    %rsp,%rbp
  804774:	48 83 ec 20          	sub    $0x20,%rsp
  804778:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80477c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  804780:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804784:	48 03 45 e0          	add    -0x20(%rbp),%rax
  804788:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  80478c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804790:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804794:	eb 62                	jmp    8047f8 <isfree+0x88>
		if (va >= (uintptr_t) mend
  804796:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  80479d:	00 00 00 
  8047a0:	48 8b 00             	mov    (%rax),%rax
  8047a3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8047a7:	76 40                	jbe    8047e9 <isfree+0x79>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8047a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047ad:	48 89 c2             	mov    %rax,%rdx
  8047b0:	48 c1 ea 15          	shr    $0x15,%rdx
  8047b4:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8047bb:	01 00 00 
  8047be:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8047c2:	83 e0 01             	and    $0x1,%eax
  8047c5:	84 c0                	test   %al,%al
  8047c7:	74 27                	je     8047f0 <isfree+0x80>
  8047c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047cd:	48 89 c2             	mov    %rax,%rdx
  8047d0:	48 c1 ea 0c          	shr    $0xc,%rdx
  8047d4:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8047db:	01 00 00 
  8047de:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8047e2:	83 e0 01             	and    $0x1,%eax
  8047e5:	84 c0                	test   %al,%al
  8047e7:	74 07                	je     8047f0 <isfree+0x80>
			return 0;
  8047e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8047ee:	eb 17                	jmp    804807 <isfree+0x97>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8047f0:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8047f7:	00 
  8047f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8047fc:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  804800:	72 94                	jb     804796 <isfree+0x26>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  804802:	b8 01 00 00 00       	mov    $0x1,%eax
}
  804807:	c9                   	leaveq 
  804808:	c3                   	retq   

0000000000804809 <malloc>:

void*
malloc(size_t n)
{
  804809:	55                   	push   %rbp
  80480a:	48 89 e5             	mov    %rsp,%rbp
  80480d:	48 83 ec 60          	sub    $0x60,%rsp
  804811:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  804815:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80481c:	00 00 00 
  80481f:	48 8b 00             	mov    (%rax),%rax
  804822:	48 85 c0             	test   %rax,%rax
  804825:	75 1a                	jne    804841 <malloc+0x38>
		mptr = mbegin;
  804827:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  80482e:	00 00 00 
  804831:	48 8b 10             	mov    (%rax),%rdx
  804834:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80483b:	00 00 00 
  80483e:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  804841:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  804848:	00 
  804849:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80484d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804851:	48 01 d0             	add    %rdx,%rax
  804854:	48 83 e8 01          	sub    $0x1,%rax
  804858:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80485c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804860:	ba 00 00 00 00       	mov    $0x0,%edx
  804865:	48 f7 75 f0          	divq   -0x10(%rbp)
  804869:	48 89 d0             	mov    %rdx,%rax
  80486c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804870:	48 89 d1             	mov    %rdx,%rcx
  804873:	48 29 c1             	sub    %rax,%rcx
  804876:	48 89 c8             	mov    %rcx,%rax
  804879:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	if (n >= MAXMALLOC)
  80487d:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804884:	00 
  804885:	76 0a                	jbe    804891 <malloc+0x88>
		return 0;
  804887:	b8 00 00 00 00       	mov    $0x0,%eax
  80488c:	e9 f6 02 00 00       	jmpq   804b87 <malloc+0x37e>

	if ((uintptr_t) mptr % PGSIZE){
  804891:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804898:	00 00 00 
  80489b:	48 8b 00             	mov    (%rax),%rax
  80489e:	25 ff 0f 00 00       	and    $0xfff,%eax
  8048a3:	48 85 c0             	test   %rax,%rax
  8048a6:	0f 84 12 01 00 00    	je     8049be <malloc+0x1b5>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8048ac:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8048b3:	00 
  8048b4:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8048bb:	00 00 00 
  8048be:	48 8b 00             	mov    (%rax),%rax
  8048c1:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8048c5:	48 83 e8 01          	sub    $0x1,%rax
  8048c9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8048cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8048d1:	ba 00 00 00 00       	mov    $0x0,%edx
  8048d6:	48 f7 75 e0          	divq   -0x20(%rbp)
  8048da:	48 89 d0             	mov    %rdx,%rax
  8048dd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8048e1:	48 89 d1             	mov    %rdx,%rcx
  8048e4:	48 29 c1             	sub    %rax,%rcx
  8048e7:	48 89 c8             	mov    %rcx,%rax
  8048ea:	48 83 e8 04          	sub    $0x4,%rax
  8048ee:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8048f2:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8048f9:	00 00 00 
  8048fc:	48 8b 00             	mov    (%rax),%rax
  8048ff:	48 89 c1             	mov    %rax,%rcx
  804902:	48 c1 e9 0c          	shr    $0xc,%rcx
  804906:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80490d:	00 00 00 
  804910:	48 8b 00             	mov    (%rax),%rax
  804913:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804917:	48 83 c2 03          	add    $0x3,%rdx
  80491b:	48 01 d0             	add    %rdx,%rax
  80491e:	48 c1 e8 0c          	shr    $0xc,%rax
  804922:	48 39 c1             	cmp    %rax,%rcx
  804925:	75 4a                	jne    804971 <malloc+0x168>
			(*ref)++;
  804927:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80492b:	8b 00                	mov    (%rax),%eax
  80492d:	8d 50 01             	lea    0x1(%rax),%edx
  804930:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804934:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804936:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80493d:	00 00 00 
  804940:	48 8b 00             	mov    (%rax),%rax
  804943:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804947:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  80494e:	00 00 00 
  804951:	48 8b 00             	mov    (%rax),%rax
  804954:	48 89 c2             	mov    %rax,%rdx
  804957:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  80495b:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804962:	00 00 00 
  804965:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804968:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80496c:	e9 16 02 00 00       	jmpq   804b87 <malloc+0x37e>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804971:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804978:	00 00 00 
  80497b:	48 8b 00             	mov    (%rax),%rax
  80497e:	48 89 c7             	mov    %rax,%rdi
  804981:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  804988:	00 00 00 
  80498b:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  80498d:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804994:	00 00 00 
  804997:	48 8b 00             	mov    (%rax),%rax
  80499a:	48 05 00 10 00 00    	add    $0x1000,%rax
  8049a0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8049a4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8049a8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8049ae:	48 89 c2             	mov    %rax,%rdx
  8049b1:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8049b8:	00 00 00 
  8049bb:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  8049be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8049c5:	eb 01                	jmp    8049c8 <malloc+0x1bf>
		if (mptr == mend) {
			mptr = mbegin;
			if (++nwrap == 2)
				return 0;	/* out of address space */
		}
	}
  8049c7:	90                   	nop
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  8049c8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8049cc:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8049d0:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8049d7:	00 00 00 
  8049da:	48 8b 00             	mov    (%rax),%rax
  8049dd:	48 89 d6             	mov    %rdx,%rsi
  8049e0:	48 89 c7             	mov    %rax,%rdi
  8049e3:	48 b8 70 47 80 00 00 	movabs $0x804770,%rax
  8049ea:	00 00 00 
  8049ed:	ff d0                	callq  *%rax
  8049ef:	85 c0                	test   %eax,%eax
  8049f1:	75 72                	jne    804a65 <malloc+0x25c>
			break;
		mptr += PGSIZE;
  8049f3:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  8049fa:	00 00 00 
  8049fd:	48 8b 00             	mov    (%rax),%rax
  804a00:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  804a07:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804a0e:	00 00 00 
  804a11:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  804a14:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804a1b:	00 00 00 
  804a1e:	48 8b 10             	mov    (%rax),%rdx
  804a21:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804a28:	00 00 00 
  804a2b:	48 8b 00             	mov    (%rax),%rax
  804a2e:	48 39 c2             	cmp    %rax,%rdx
  804a31:	75 94                	jne    8049c7 <malloc+0x1be>
			mptr = mbegin;
  804a33:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804a3a:	00 00 00 
  804a3d:	48 8b 10             	mov    (%rax),%rdx
  804a40:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804a47:	00 00 00 
  804a4a:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  804a4d:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  804a51:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  804a55:	0f 85 6c ff ff ff    	jne    8049c7 <malloc+0x1be>
				return 0;	/* out of address space */
  804a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  804a60:	e9 22 01 00 00       	jmpq   804b87 <malloc+0x37e>
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
  804a65:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804a66:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804a6d:	e9 a1 00 00 00       	jmpq   804b13 <malloc+0x30a>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  804a72:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804a75:	05 00 10 00 00       	add    $0x1000,%eax
  804a7a:	48 98                	cltq   
  804a7c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804a80:	48 83 c2 04          	add    $0x4,%rdx
  804a84:	48 39 d0             	cmp    %rdx,%rax
  804a87:	73 07                	jae    804a90 <malloc+0x287>
  804a89:	b8 00 04 00 00       	mov    $0x400,%eax
  804a8e:	eb 05                	jmp    804a95 <malloc+0x28c>
  804a90:	b8 00 00 00 00       	mov    $0x0,%eax
  804a95:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  804a98:	8b 45 bc             	mov    -0x44(%rbp),%eax
  804a9b:	89 c2                	mov    %eax,%edx
  804a9d:	83 ca 07             	or     $0x7,%edx
  804aa0:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804aa7:	00 00 00 
  804aaa:	48 8b 08             	mov    (%rax),%rcx
  804aad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804ab0:	48 98                	cltq   
  804ab2:	48 01 c8             	add    %rcx,%rax
  804ab5:	48 89 c6             	mov    %rax,%rsi
  804ab8:	bf 00 00 00 00       	mov    $0x0,%edi
  804abd:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  804ac4:	00 00 00 
  804ac7:	ff d0                	callq  *%rax
  804ac9:	85 c0                	test   %eax,%eax
  804acb:	79 3f                	jns    804b0c <malloc+0x303>
			for (; i >= 0; i -= PGSIZE)
  804acd:	eb 30                	jmp    804aff <malloc+0x2f6>
				sys_page_unmap(0, mptr + i);
  804acf:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804ad6:	00 00 00 
  804ad9:	48 8b 10             	mov    (%rax),%rdx
  804adc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804adf:	48 98                	cltq   
  804ae1:	48 01 d0             	add    %rdx,%rax
  804ae4:	48 89 c6             	mov    %rax,%rsi
  804ae7:	bf 00 00 00 00       	mov    $0x0,%edi
  804aec:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  804af3:	00 00 00 
  804af6:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  804af8:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  804aff:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804b03:	79 ca                	jns    804acf <malloc+0x2c6>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  804b05:	b8 00 00 00 00       	mov    $0x0,%eax
  804b0a:	eb 7b                	jmp    804b87 <malloc+0x37e>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804b0c:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  804b13:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804b16:	48 98                	cltq   
  804b18:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804b1c:	48 83 c2 04          	add    $0x4,%rdx
  804b20:	48 39 d0             	cmp    %rdx,%rax
  804b23:	0f 82 49 ff ff ff    	jb     804a72 <malloc+0x269>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  804b29:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804b30:	00 00 00 
  804b33:	48 8b 00             	mov    (%rax),%rax
  804b36:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804b39:	48 63 d2             	movslq %edx,%rdx
  804b3c:	48 83 ea 04          	sub    $0x4,%rdx
  804b40:	48 01 d0             	add    %rdx,%rax
  804b43:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  804b47:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804b4b:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  804b51:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804b58:	00 00 00 
  804b5b:	48 8b 00             	mov    (%rax),%rax
  804b5e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  804b62:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804b69:	00 00 00 
  804b6c:	48 8b 00             	mov    (%rax),%rax
  804b6f:	48 89 c2             	mov    %rax,%rdx
  804b72:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  804b76:	48 b8 90 90 82 00 00 	movabs $0x829090,%rax
  804b7d:	00 00 00 
  804b80:	48 89 10             	mov    %rdx,(%rax)
	return v;
  804b83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  804b87:	c9                   	leaveq 
  804b88:	c3                   	retq   

0000000000804b89 <free>:

void
free(void *v)
{
  804b89:	55                   	push   %rbp
  804b8a:	48 89 e5             	mov    %rsp,%rbp
  804b8d:	48 83 ec 30          	sub    $0x30,%rsp
  804b91:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  804b95:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  804b9a:	0f 84 56 01 00 00    	je     804cf6 <free+0x16d>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  804ba0:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804ba7:	00 00 00 
  804baa:	48 8b 00             	mov    (%rax),%rax
  804bad:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  804bb1:	77 13                	ja     804bc6 <free+0x3d>
  804bb3:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804bba:	00 00 00 
  804bbd:	48 8b 00             	mov    (%rax),%rax
  804bc0:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  804bc4:	72 35                	jb     804bfb <free+0x72>
  804bc6:	48 b9 28 0f 82 00 00 	movabs $0x820f28,%rcx
  804bcd:	00 00 00 
  804bd0:	48 ba 56 0f 82 00 00 	movabs $0x820f56,%rdx
  804bd7:	00 00 00 
  804bda:	be 7a 00 00 00       	mov    $0x7a,%esi
  804bdf:	48 bf 6b 0f 82 00 00 	movabs $0x820f6b,%rdi
  804be6:	00 00 00 
  804be9:	b8 00 00 00 00       	mov    $0x0,%eax
  804bee:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  804bf5:	00 00 00 
  804bf8:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  804bfb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804bff:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  804c03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804c07:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804c0d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  804c11:	eb 7b                	jmp    804c8e <free+0x105>
		sys_page_unmap(0, c);
  804c13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804c17:	48 89 c6             	mov    %rax,%rsi
  804c1a:	bf 00 00 00 00       	mov    $0x0,%edi
  804c1f:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  804c26:	00 00 00 
  804c29:	ff d0                	callq  *%rax
		c += PGSIZE;
  804c2b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804c32:	00 
		assert(mbegin <= c && c < mend);
  804c33:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804c3a:	00 00 00 
  804c3d:	48 8b 00             	mov    (%rax),%rax
  804c40:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804c44:	77 13                	ja     804c59 <free+0xd0>
  804c46:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804c4d:	00 00 00 
  804c50:	48 8b 00             	mov    (%rax),%rax
  804c53:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804c57:	72 35                	jb     804c8e <free+0x105>
  804c59:	48 b9 78 0f 82 00 00 	movabs $0x820f78,%rcx
  804c60:	00 00 00 
  804c63:	48 ba 56 0f 82 00 00 	movabs $0x820f56,%rdx
  804c6a:	00 00 00 
  804c6d:	be 81 00 00 00       	mov    $0x81,%esi
  804c72:	48 bf 6b 0f 82 00 00 	movabs $0x820f6b,%rdi
  804c79:	00 00 00 
  804c7c:	b8 00 00 00 00       	mov    $0x0,%eax
  804c81:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  804c88:	00 00 00 
  804c8b:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  804c8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804c92:	48 89 c2             	mov    %rax,%rdx
  804c95:	48 c1 ea 0c          	shr    $0xc,%rdx
  804c99:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804ca0:	01 00 00 
  804ca3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804ca7:	25 00 04 00 00       	and    $0x400,%eax
  804cac:	48 85 c0             	test   %rax,%rax
  804caf:	0f 85 5e ff ff ff    	jne    804c13 <free+0x8a>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  804cb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804cb9:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  804cbf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  804cc3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804cc7:	8b 00                	mov    (%rax),%eax
  804cc9:	8d 50 ff             	lea    -0x1(%rax),%edx
  804ccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804cd0:	89 10                	mov    %edx,(%rax)
  804cd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804cd6:	8b 00                	mov    (%rax),%eax
  804cd8:	85 c0                	test   %eax,%eax
  804cda:	75 1b                	jne    804cf7 <free+0x16e>
		sys_page_unmap(0, c);
  804cdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804ce0:	48 89 c6             	mov    %rax,%rsi
  804ce3:	bf 00 00 00 00       	mov    $0x0,%edi
  804ce8:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  804cef:	00 00 00 
  804cf2:	ff d0                	callq  *%rax
  804cf4:	eb 01                	jmp    804cf7 <free+0x16e>
{
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
		return;
  804cf6:	90                   	nop
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
		sys_page_unmap(0, c);
}
  804cf7:	c9                   	leaveq 
  804cf8:	c3                   	retq   
  804cf9:	00 00                	add    %al,(%rax)
	...

0000000000804cfc <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  804cfc:	55                   	push   %rbp
  804cfd:	48 89 e5             	mov    %rsp,%rbp
  804d00:	53                   	push   %rbx
  804d01:	48 83 ec 38          	sub    $0x38,%rsp
  804d05:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  804d09:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  804d0d:	48 89 c7             	mov    %rax,%rdi
  804d10:	48 b8 8a 33 80 00 00 	movabs $0x80338a,%rax
  804d17:	00 00 00 
  804d1a:	ff d0                	callq  *%rax
  804d1c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804d1f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804d23:	0f 88 bf 01 00 00    	js     804ee8 <pipe+0x1ec>
            || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804d29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804d2d:	ba 07 04 00 00       	mov    $0x407,%edx
  804d32:	48 89 c6             	mov    %rax,%rsi
  804d35:	bf 00 00 00 00       	mov    $0x0,%edi
  804d3a:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  804d41:	00 00 00 
  804d44:	ff d0                	callq  *%rax
  804d46:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804d49:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804d4d:	0f 88 95 01 00 00    	js     804ee8 <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  804d53:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  804d57:	48 89 c7             	mov    %rax,%rdi
  804d5a:	48 b8 8a 33 80 00 00 	movabs $0x80338a,%rax
  804d61:	00 00 00 
  804d64:	ff d0                	callq  *%rax
  804d66:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804d69:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804d6d:	0f 88 5d 01 00 00    	js     804ed0 <pipe+0x1d4>
            || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804d73:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804d77:	ba 07 04 00 00       	mov    $0x407,%edx
  804d7c:	48 89 c6             	mov    %rax,%rsi
  804d7f:	bf 00 00 00 00       	mov    $0x0,%edi
  804d84:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  804d8b:	00 00 00 
  804d8e:	ff d0                	callq  *%rax
  804d90:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804d93:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804d97:	0f 88 33 01 00 00    	js     804ed0 <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  804d9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804da1:	48 89 c7             	mov    %rax,%rdi
  804da4:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  804dab:	00 00 00 
  804dae:	ff d0                	callq  *%rax
  804db0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804db4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804db8:	ba 07 04 00 00       	mov    $0x407,%edx
  804dbd:	48 89 c6             	mov    %rax,%rsi
  804dc0:	bf 00 00 00 00       	mov    $0x0,%edi
  804dc5:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  804dcc:	00 00 00 
  804dcf:	ff d0                	callq  *%rax
  804dd1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804dd4:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804dd8:	0f 88 d9 00 00 00    	js     804eb7 <pipe+0x1bb>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804dde:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804de2:	48 89 c7             	mov    %rax,%rdi
  804de5:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  804dec:	00 00 00 
  804def:	ff d0                	callq  *%rax
  804df1:	48 89 c2             	mov    %rax,%rdx
  804df4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804df8:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  804dfe:	48 89 d1             	mov    %rdx,%rcx
  804e01:	ba 00 00 00 00       	mov    $0x0,%edx
  804e06:	48 89 c6             	mov    %rax,%rsi
  804e09:	bf 00 00 00 00       	mov    $0x0,%edi
  804e0e:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  804e15:	00 00 00 
  804e18:	ff d0                	callq  *%rax
  804e1a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804e1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804e21:	78 79                	js     804e9c <pipe+0x1a0>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  804e23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804e27:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  804e2e:	00 00 00 
  804e31:	8b 12                	mov    (%rdx),%edx
  804e33:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  804e35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804e39:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  804e40:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804e44:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  804e4b:	00 00 00 
  804e4e:	8b 12                	mov    (%rdx),%edx
  804e50:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  804e52:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804e56:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  804e5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804e61:	48 89 c7             	mov    %rax,%rdi
  804e64:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  804e6b:	00 00 00 
  804e6e:	ff d0                	callq  *%rax
  804e70:	89 c2                	mov    %eax,%edx
  804e72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804e76:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  804e78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804e7c:	48 8d 58 04          	lea    0x4(%rax),%rbx
  804e80:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804e84:	48 89 c7             	mov    %rax,%rdi
  804e87:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  804e8e:	00 00 00 
  804e91:	ff d0                	callq  *%rax
  804e93:	89 03                	mov    %eax,(%rbx)
	return 0;
  804e95:	b8 00 00 00 00       	mov    $0x0,%eax
  804e9a:	eb 4f                	jmp    804eeb <pipe+0x1ef>
	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;
  804e9c:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

err3:
	sys_page_unmap(0, va);
  804e9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804ea1:	48 89 c6             	mov    %rax,%rsi
  804ea4:	bf 00 00 00 00       	mov    $0x0,%edi
  804ea9:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  804eb0:	00 00 00 
  804eb3:	ff d0                	callq  *%rax
  804eb5:	eb 01                	jmp    804eb8 <pipe+0x1bc>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
  804eb7:	90                   	nop
	return 0;

err3:
	sys_page_unmap(0, va);
err2:
	sys_page_unmap(0, fd1);
  804eb8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804ebc:	48 89 c6             	mov    %rax,%rsi
  804ebf:	bf 00 00 00 00       	mov    $0x0,%edi
  804ec4:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  804ecb:	00 00 00 
  804ece:	ff d0                	callq  *%rax
err1:
	sys_page_unmap(0, fd0);
  804ed0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804ed4:	48 89 c6             	mov    %rax,%rsi
  804ed7:	bf 00 00 00 00       	mov    $0x0,%edi
  804edc:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  804ee3:	00 00 00 
  804ee6:	ff d0                	callq  *%rax
err:
	return r;
  804ee8:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  804eeb:	48 83 c4 38          	add    $0x38,%rsp
  804eef:	5b                   	pop    %rbx
  804ef0:	5d                   	pop    %rbp
  804ef1:	c3                   	retq   

0000000000804ef2 <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  804ef2:	55                   	push   %rbp
  804ef3:	48 89 e5             	mov    %rsp,%rbp
  804ef6:	53                   	push   %rbx
  804ef7:	48 83 ec 28          	sub    $0x28,%rsp
  804efb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  804eff:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  804f03:	eb 01                	jmp    804f06 <_pipeisclosed+0x14>
		nn = thisenv->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
	}
  804f05:	90                   	nop
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  804f06:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  804f0d:	00 00 00 
  804f10:	48 8b 00             	mov    (%rax),%rax
  804f13:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  804f19:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  804f1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804f20:	48 89 c7             	mov    %rax,%rdi
  804f23:	48 b8 94 56 80 00 00 	movabs $0x805694,%rax
  804f2a:	00 00 00 
  804f2d:	ff d0                	callq  *%rax
  804f2f:	89 c3                	mov    %eax,%ebx
  804f31:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f35:	48 89 c7             	mov    %rax,%rdi
  804f38:	48 b8 94 56 80 00 00 	movabs $0x805694,%rax
  804f3f:	00 00 00 
  804f42:	ff d0                	callq  *%rax
  804f44:	39 c3                	cmp    %eax,%ebx
  804f46:	0f 94 c0             	sete   %al
  804f49:	0f b6 c0             	movzbl %al,%eax
  804f4c:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  804f4f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  804f56:	00 00 00 
  804f59:	48 8b 00             	mov    (%rax),%rax
  804f5c:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  804f62:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  804f65:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804f68:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  804f6b:	75 0a                	jne    804f77 <_pipeisclosed+0x85>
			return ret;
  804f6d:	8b 45 e8             	mov    -0x18(%rbp),%eax
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
	}
}
  804f70:	48 83 c4 28          	add    $0x28,%rsp
  804f74:	5b                   	pop    %rbx
  804f75:	5d                   	pop    %rbp
  804f76:	c3                   	retq   
		n = thisenv->env_runs;
		ret = pageref(fd) == pageref(p);
		nn = thisenv->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
  804f77:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804f7a:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  804f7d:	74 86                	je     804f05 <_pipeisclosed+0x13>
  804f7f:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  804f83:	75 80                	jne    804f05 <_pipeisclosed+0x13>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  804f85:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  804f8c:	00 00 00 
  804f8f:	48 8b 00             	mov    (%rax),%rax
  804f92:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  804f98:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  804f9b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804f9e:	89 c6                	mov    %eax,%esi
  804fa0:	48 bf 95 0f 82 00 00 	movabs $0x820f95,%rdi
  804fa7:	00 00 00 
  804faa:	b8 00 00 00 00       	mov    $0x0,%eax
  804faf:	49 b8 5b 11 80 00 00 	movabs $0x80115b,%r8
  804fb6:	00 00 00 
  804fb9:	41 ff d0             	callq  *%r8
	}
  804fbc:	e9 44 ff ff ff       	jmpq   804f05 <_pipeisclosed+0x13>

0000000000804fc1 <pipeisclosed>:
}

int
pipeisclosed(int fdnum)
{
  804fc1:	55                   	push   %rbp
  804fc2:	48 89 e5             	mov    %rsp,%rbp
  804fc5:	48 83 ec 30          	sub    $0x30,%rsp
  804fc9:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  804fcc:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  804fd0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  804fd3:	48 89 d6             	mov    %rdx,%rsi
  804fd6:	89 c7                	mov    %eax,%edi
  804fd8:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  804fdf:	00 00 00 
  804fe2:	ff d0                	callq  *%rax
  804fe4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804fe7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804feb:	79 05                	jns    804ff2 <pipeisclosed+0x31>
		return r;
  804fed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804ff0:	eb 31                	jmp    805023 <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  804ff2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804ff6:	48 89 c7             	mov    %rax,%rdi
  804ff9:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  805000:	00 00 00 
  805003:	ff d0                	callq  *%rax
  805005:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  805009:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80500d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805011:	48 89 d6             	mov    %rdx,%rsi
  805014:	48 89 c7             	mov    %rax,%rdi
  805017:	48 b8 f2 4e 80 00 00 	movabs $0x804ef2,%rax
  80501e:	00 00 00 
  805021:	ff d0                	callq  *%rax
}
  805023:	c9                   	leaveq 
  805024:	c3                   	retq   

0000000000805025 <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  805025:	55                   	push   %rbp
  805026:	48 89 e5             	mov    %rsp,%rbp
  805029:	48 83 ec 40          	sub    $0x40,%rsp
  80502d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  805031:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  805035:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  805039:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80503d:	48 89 c7             	mov    %rax,%rdi
  805040:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  805047:	00 00 00 
  80504a:	ff d0                	callq  *%rax
  80504c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  805050:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805054:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805058:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80505f:	00 
  805060:	e9 97 00 00 00       	jmpq   8050fc <devpipe_read+0xd7>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  805065:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80506a:	74 09                	je     805075 <devpipe_read+0x50>
				return i;
  80506c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805070:	e9 95 00 00 00       	jmpq   80510a <devpipe_read+0xe5>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  805075:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805079:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80507d:	48 89 d6             	mov    %rdx,%rsi
  805080:	48 89 c7             	mov    %rax,%rdi
  805083:	48 b8 f2 4e 80 00 00 	movabs $0x804ef2,%rax
  80508a:	00 00 00 
  80508d:	ff d0                	callq  *%rax
  80508f:	85 c0                	test   %eax,%eax
  805091:	74 07                	je     80509a <devpipe_read+0x75>
				return 0;
  805093:	b8 00 00 00 00       	mov    $0x0,%eax
  805098:	eb 70                	jmp    80510a <devpipe_read+0xe5>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  80509a:	48 b8 26 26 80 00 00 	movabs $0x802626,%rax
  8050a1:	00 00 00 
  8050a4:	ff d0                	callq  *%rax
  8050a6:	eb 01                	jmp    8050a9 <devpipe_read+0x84>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  8050a8:	90                   	nop
  8050a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8050ad:	8b 10                	mov    (%rax),%edx
  8050af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8050b3:	8b 40 04             	mov    0x4(%rax),%eax
  8050b6:	39 c2                	cmp    %eax,%edx
  8050b8:	74 ab                	je     805065 <devpipe_read+0x40>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8050ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8050be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8050c2:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8050c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8050ca:	8b 00                	mov    (%rax),%eax
  8050cc:	89 c2                	mov    %eax,%edx
  8050ce:	c1 fa 1f             	sar    $0x1f,%edx
  8050d1:	c1 ea 1b             	shr    $0x1b,%edx
  8050d4:	01 d0                	add    %edx,%eax
  8050d6:	83 e0 1f             	and    $0x1f,%eax
  8050d9:	29 d0                	sub    %edx,%eax
  8050db:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8050df:	48 98                	cltq   
  8050e1:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  8050e6:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  8050e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8050ec:	8b 00                	mov    (%rax),%eax
  8050ee:	8d 50 01             	lea    0x1(%rax),%edx
  8050f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8050f5:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8050f7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8050fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805100:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  805104:	72 a2                	jb     8050a8 <devpipe_read+0x83>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  805106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80510a:	c9                   	leaveq 
  80510b:	c3                   	retq   

000000000080510c <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  80510c:	55                   	push   %rbp
  80510d:	48 89 e5             	mov    %rsp,%rbp
  805110:	48 83 ec 40          	sub    $0x40,%rsp
  805114:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  805118:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80511c:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  805120:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805124:	48 89 c7             	mov    %rax,%rdi
  805127:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  80512e:	00 00 00 
  805131:	ff d0                	callq  *%rax
  805133:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  805137:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80513b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  80513f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  805146:	00 
  805147:	e9 93 00 00 00       	jmpq   8051df <devpipe_write+0xd3>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  80514c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805150:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805154:	48 89 d6             	mov    %rdx,%rsi
  805157:	48 89 c7             	mov    %rax,%rdi
  80515a:	48 b8 f2 4e 80 00 00 	movabs $0x804ef2,%rax
  805161:	00 00 00 
  805164:	ff d0                	callq  *%rax
  805166:	85 c0                	test   %eax,%eax
  805168:	74 07                	je     805171 <devpipe_write+0x65>
				return 0;
  80516a:	b8 00 00 00 00       	mov    $0x0,%eax
  80516f:	eb 7c                	jmp    8051ed <devpipe_write+0xe1>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  805171:	48 b8 26 26 80 00 00 	movabs $0x802626,%rax
  805178:	00 00 00 
  80517b:	ff d0                	callq  *%rax
  80517d:	eb 01                	jmp    805180 <devpipe_write+0x74>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  80517f:	90                   	nop
  805180:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805184:	8b 40 04             	mov    0x4(%rax),%eax
  805187:	48 63 d0             	movslq %eax,%rdx
  80518a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80518e:	8b 00                	mov    (%rax),%eax
  805190:	48 98                	cltq   
  805192:	48 83 c0 20          	add    $0x20,%rax
  805196:	48 39 c2             	cmp    %rax,%rdx
  805199:	73 b1                	jae    80514c <devpipe_write+0x40>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  80519b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80519f:	8b 40 04             	mov    0x4(%rax),%eax
  8051a2:	89 c2                	mov    %eax,%edx
  8051a4:	c1 fa 1f             	sar    $0x1f,%edx
  8051a7:	c1 ea 1b             	shr    $0x1b,%edx
  8051aa:	01 d0                	add    %edx,%eax
  8051ac:	83 e0 1f             	and    $0x1f,%eax
  8051af:	29 d0                	sub    %edx,%eax
  8051b1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8051b5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8051b9:	48 01 ca             	add    %rcx,%rdx
  8051bc:	0f b6 0a             	movzbl (%rdx),%ecx
  8051bf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8051c3:	48 98                	cltq   
  8051c5:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  8051c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8051cd:	8b 40 04             	mov    0x4(%rax),%eax
  8051d0:	8d 50 01             	lea    0x1(%rax),%edx
  8051d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8051d7:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8051da:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8051df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8051e3:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8051e7:	72 96                	jb     80517f <devpipe_write+0x73>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  8051e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8051ed:	c9                   	leaveq 
  8051ee:	c3                   	retq   

00000000008051ef <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8051ef:	55                   	push   %rbp
  8051f0:	48 89 e5             	mov    %rsp,%rbp
  8051f3:	48 83 ec 20          	sub    $0x20,%rsp
  8051f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8051fb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8051ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805203:	48 89 c7             	mov    %rax,%rdi
  805206:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  80520d:	00 00 00 
  805210:	ff d0                	callq  *%rax
  805212:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  805216:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80521a:	48 be a8 0f 82 00 00 	movabs $0x820fa8,%rsi
  805221:	00 00 00 
  805224:	48 89 c7             	mov    %rax,%rdi
  805227:	48 b8 2c 1d 80 00 00 	movabs $0x801d2c,%rax
  80522e:	00 00 00 
  805231:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  805233:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805237:	8b 50 04             	mov    0x4(%rax),%edx
  80523a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80523e:	8b 00                	mov    (%rax),%eax
  805240:	29 c2                	sub    %eax,%edx
  805242:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805246:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  80524c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805250:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  805257:	00 00 00 
	stat->st_dev = &devpipe;
  80525a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80525e:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805265:	00 00 00 
  805268:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return 0;
  80526f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805274:	c9                   	leaveq 
  805275:	c3                   	retq   

0000000000805276 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  805276:	55                   	push   %rbp
  805277:	48 89 e5             	mov    %rsp,%rbp
  80527a:	48 83 ec 10          	sub    $0x10,%rsp
  80527e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	(void) sys_page_unmap(0, fd);
  805282:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805286:	48 89 c6             	mov    %rax,%rsi
  805289:	bf 00 00 00 00       	mov    $0x0,%edi
  80528e:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  805295:	00 00 00 
  805298:	ff d0                	callq  *%rax
	return sys_page_unmap(0, fd2data(fd));
  80529a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80529e:	48 89 c7             	mov    %rax,%rdi
  8052a1:	48 b8 5f 33 80 00 00 	movabs $0x80335f,%rax
  8052a8:	00 00 00 
  8052ab:	ff d0                	callq  *%rax
  8052ad:	48 89 c6             	mov    %rax,%rsi
  8052b0:	bf 00 00 00 00       	mov    $0x0,%edi
  8052b5:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  8052bc:	00 00 00 
  8052bf:	ff d0                	callq  *%rax
}
  8052c1:	c9                   	leaveq 
  8052c2:	c3                   	retq   
	...

00000000008052c4 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  8052c4:	55                   	push   %rbp
  8052c5:	48 89 e5             	mov    %rsp,%rbp
  8052c8:	48 83 ec 20          	sub    $0x20,%rsp
  8052cc:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  8052cf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8052d2:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  8052d5:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  8052d9:	be 01 00 00 00       	mov    $0x1,%esi
  8052de:	48 89 c7             	mov    %rax,%rdi
  8052e1:	48 b8 1c 25 80 00 00 	movabs $0x80251c,%rax
  8052e8:	00 00 00 
  8052eb:	ff d0                	callq  *%rax
}
  8052ed:	c9                   	leaveq 
  8052ee:	c3                   	retq   

00000000008052ef <getchar>:

int
getchar(void)
{
  8052ef:	55                   	push   %rbp
  8052f0:	48 89 e5             	mov    %rsp,%rbp
  8052f3:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8052f7:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  8052fb:	ba 01 00 00 00       	mov    $0x1,%edx
  805300:	48 89 c6             	mov    %rax,%rsi
  805303:	bf 00 00 00 00       	mov    $0x0,%edi
  805308:	48 b8 54 38 80 00 00 	movabs $0x803854,%rax
  80530f:	00 00 00 
  805312:	ff d0                	callq  *%rax
  805314:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  805317:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80531b:	79 05                	jns    805322 <getchar+0x33>
		return r;
  80531d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805320:	eb 14                	jmp    805336 <getchar+0x47>
	if (r < 1)
  805322:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805326:	7f 07                	jg     80532f <getchar+0x40>
		return -E_EOF;
  805328:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80532d:	eb 07                	jmp    805336 <getchar+0x47>
	return c;
  80532f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  805333:	0f b6 c0             	movzbl %al,%eax
}
  805336:	c9                   	leaveq 
  805337:	c3                   	retq   

0000000000805338 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  805338:	55                   	push   %rbp
  805339:	48 89 e5             	mov    %rsp,%rbp
  80533c:	48 83 ec 20          	sub    $0x20,%rsp
  805340:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  805343:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  805347:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80534a:	48 89 d6             	mov    %rdx,%rsi
  80534d:	89 c7                	mov    %eax,%edi
  80534f:	48 b8 22 34 80 00 00 	movabs $0x803422,%rax
  805356:	00 00 00 
  805359:	ff d0                	callq  *%rax
  80535b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80535e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805362:	79 05                	jns    805369 <iscons+0x31>
		return r;
  805364:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805367:	eb 1a                	jmp    805383 <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  805369:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80536d:	8b 10                	mov    (%rax),%edx
  80536f:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  805376:	00 00 00 
  805379:	8b 00                	mov    (%rax),%eax
  80537b:	39 c2                	cmp    %eax,%edx
  80537d:	0f 94 c0             	sete   %al
  805380:	0f b6 c0             	movzbl %al,%eax
}
  805383:	c9                   	leaveq 
  805384:	c3                   	retq   

0000000000805385 <opencons>:

int
opencons(void)
{
  805385:	55                   	push   %rbp
  805386:	48 89 e5             	mov    %rsp,%rbp
  805389:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  80538d:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  805391:	48 89 c7             	mov    %rax,%rdi
  805394:	48 b8 8a 33 80 00 00 	movabs $0x80338a,%rax
  80539b:	00 00 00 
  80539e:	ff d0                	callq  *%rax
  8053a0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8053a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8053a7:	79 05                	jns    8053ae <opencons+0x29>
		return r;
  8053a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8053ac:	eb 5b                	jmp    805409 <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8053ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8053b2:	ba 07 04 00 00       	mov    $0x407,%edx
  8053b7:	48 89 c6             	mov    %rax,%rsi
  8053ba:	bf 00 00 00 00       	mov    $0x0,%edi
  8053bf:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  8053c6:	00 00 00 
  8053c9:	ff d0                	callq  *%rax
  8053cb:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8053ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8053d2:	79 05                	jns    8053d9 <opencons+0x54>
		return r;
  8053d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8053d7:	eb 30                	jmp    805409 <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  8053d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8053dd:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  8053e4:	00 00 00 
  8053e7:	8b 12                	mov    (%rdx),%edx
  8053e9:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  8053eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8053ef:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  8053f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8053fa:	48 89 c7             	mov    %rax,%rdi
  8053fd:	48 b8 3c 33 80 00 00 	movabs $0x80333c,%rax
  805404:	00 00 00 
  805407:	ff d0                	callq  *%rax
}
  805409:	c9                   	leaveq 
  80540a:	c3                   	retq   

000000000080540b <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  80540b:	55                   	push   %rbp
  80540c:	48 89 e5             	mov    %rsp,%rbp
  80540f:	48 83 ec 30          	sub    $0x30,%rsp
  805413:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  805417:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80541b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  80541f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  805424:	75 13                	jne    805439 <devcons_read+0x2e>
		return 0;
  805426:	b8 00 00 00 00       	mov    $0x0,%eax
  80542b:	eb 49                	jmp    805476 <devcons_read+0x6b>

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  80542d:	48 b8 26 26 80 00 00 	movabs $0x802626,%rax
  805434:	00 00 00 
  805437:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  805439:	48 b8 66 25 80 00 00 	movabs $0x802566,%rax
  805440:	00 00 00 
  805443:	ff d0                	callq  *%rax
  805445:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805448:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80544c:	74 df                	je     80542d <devcons_read+0x22>
		sys_yield();
	if (c < 0)
  80544e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805452:	79 05                	jns    805459 <devcons_read+0x4e>
		return c;
  805454:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805457:	eb 1d                	jmp    805476 <devcons_read+0x6b>
	if (c == 0x04)	// ctl-d is eof
  805459:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  80545d:	75 07                	jne    805466 <devcons_read+0x5b>
		return 0;
  80545f:	b8 00 00 00 00       	mov    $0x0,%eax
  805464:	eb 10                	jmp    805476 <devcons_read+0x6b>
	*(char*)vbuf = c;
  805466:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805469:	89 c2                	mov    %eax,%edx
  80546b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80546f:	88 10                	mov    %dl,(%rax)
	return 1;
  805471:	b8 01 00 00 00       	mov    $0x1,%eax
}
  805476:	c9                   	leaveq 
  805477:	c3                   	retq   

0000000000805478 <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805478:	55                   	push   %rbp
  805479:	48 89 e5             	mov    %rsp,%rbp
  80547c:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  805483:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80548a:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  805491:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805498:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80549f:	eb 77                	jmp    805518 <devcons_write+0xa0>
		m = n - tot;
  8054a1:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8054a8:	89 c2                	mov    %eax,%edx
  8054aa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8054ad:	89 d1                	mov    %edx,%ecx
  8054af:	29 c1                	sub    %eax,%ecx
  8054b1:	89 c8                	mov    %ecx,%eax
  8054b3:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  8054b6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8054b9:	83 f8 7f             	cmp    $0x7f,%eax
  8054bc:	76 07                	jbe    8054c5 <devcons_write+0x4d>
			m = sizeof(buf) - 1;
  8054be:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  8054c5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8054c8:	48 63 d0             	movslq %eax,%rdx
  8054cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8054ce:	48 98                	cltq   
  8054d0:	48 89 c1             	mov    %rax,%rcx
  8054d3:	48 03 8d 60 ff ff ff 	add    -0xa0(%rbp),%rcx
  8054da:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8054e1:	48 89 ce             	mov    %rcx,%rsi
  8054e4:	48 89 c7             	mov    %rax,%rdi
  8054e7:	48 b8 4e 20 80 00 00 	movabs $0x80204e,%rax
  8054ee:	00 00 00 
  8054f1:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  8054f3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8054f6:	48 63 d0             	movslq %eax,%rdx
  8054f9:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  805500:	48 89 d6             	mov    %rdx,%rsi
  805503:	48 89 c7             	mov    %rax,%rdi
  805506:	48 b8 1c 25 80 00 00 	movabs $0x80251c,%rax
  80550d:	00 00 00 
  805510:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805512:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805515:	01 45 fc             	add    %eax,-0x4(%rbp)
  805518:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80551b:	48 98                	cltq   
  80551d:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  805524:	0f 82 77 ff ff ff    	jb     8054a1 <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  80552a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80552d:	c9                   	leaveq 
  80552e:	c3                   	retq   

000000000080552f <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  80552f:	55                   	push   %rbp
  805530:	48 89 e5             	mov    %rsp,%rbp
  805533:	48 83 ec 08          	sub    $0x8,%rsp
  805537:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  80553b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805540:	c9                   	leaveq 
  805541:	c3                   	retq   

0000000000805542 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  805542:	55                   	push   %rbp
  805543:	48 89 e5             	mov    %rsp,%rbp
  805546:	48 83 ec 10          	sub    $0x10,%rsp
  80554a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80554e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  805552:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805556:	48 be b4 0f 82 00 00 	movabs $0x820fb4,%rsi
  80555d:	00 00 00 
  805560:	48 89 c7             	mov    %rax,%rdi
  805563:	48 b8 2c 1d 80 00 00 	movabs $0x801d2c,%rax
  80556a:	00 00 00 
  80556d:	ff d0                	callq  *%rax
	return 0;
  80556f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805574:	c9                   	leaveq 
  805575:	c3                   	retq   
	...

0000000000805578 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  805578:	55                   	push   %rbp
  805579:	48 89 e5             	mov    %rsp,%rbp
  80557c:	48 83 ec 10          	sub    $0x10,%rsp
  805580:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	int r;

	if (_pgfault_handler == 0) {
  805584:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  80558b:	00 00 00 
  80558e:	48 8b 00             	mov    (%rax),%rax
  805591:	48 85 c0             	test   %rax,%rax
  805594:	75 66                	jne    8055fc <set_pgfault_handler+0x84>
		// First time through!
		// LAB 4: Your code here.
		if(sys_page_alloc(0, (void*)(UXSTACKTOP-PGSIZE), PTE_W|PTE_U|PTE_P) == 0)
  805596:	ba 07 00 00 00       	mov    $0x7,%edx
  80559b:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  8055a0:	bf 00 00 00 00       	mov    $0x0,%edi
  8055a5:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  8055ac:	00 00 00 
  8055af:	ff d0                	callq  *%rax
  8055b1:	85 c0                	test   %eax,%eax
  8055b3:	75 1d                	jne    8055d2 <set_pgfault_handler+0x5a>
			sys_env_set_pgfault_upcall(0, _pgfault_upcall);
  8055b5:	48 be 10 56 80 00 00 	movabs $0x805610,%rsi
  8055bc:	00 00 00 
  8055bf:	bf 00 00 00 00       	mov    $0x0,%edi
  8055c4:	48 b8 ee 27 80 00 00 	movabs $0x8027ee,%rax
  8055cb:	00 00 00 
  8055ce:	ff d0                	callq  *%rax
  8055d0:	eb 2a                	jmp    8055fc <set_pgfault_handler+0x84>
		else
			panic("set_pgfault_handler no memory");
  8055d2:	48 ba bb 0f 82 00 00 	movabs $0x820fbb,%rdx
  8055d9:	00 00 00 
  8055dc:	be 23 00 00 00       	mov    $0x23,%esi
  8055e1:	48 bf d9 0f 82 00 00 	movabs $0x820fd9,%rdi
  8055e8:	00 00 00 
  8055eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8055f0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8055f7:	00 00 00 
  8055fa:	ff d1                	callq  *%rcx
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8055fc:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805603:	00 00 00 
  805606:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80560a:	48 89 10             	mov    %rdx,(%rax)
}
  80560d:	c9                   	leaveq 
  80560e:	c3                   	retq   
	...

0000000000805610 <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
// Call the C page fault handler.
// function argument: pointer to UTF

movq  %rsp,%rdi                // passing the function argument in rdi
  805610:	48 89 e7             	mov    %rsp,%rdi
movabs _pgfault_handler, %rax
  805613:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  80561a:	00 00 00 
call *%rax
  80561d:	ff d0                	callq  *%rax
// may find that you have to rearrange your code in non-obvious
// ways as registers become unavailable as scratch space.
//
// LAB 4: Your code here.

addq $16,%rsp /* to skip fault_va and error code (not needed) */
  80561f:	48 83 c4 10          	add    $0x10,%rsp

/* from rsp which is pointing to fault_va which is the 8 for fault_va, 8 for error_code, 120 positions is occupied by regs, 8 for eflags and 8 for rip */

movq 120(%rsp), %r10 /*RIP*/
  805623:	4c 8b 54 24 78       	mov    0x78(%rsp),%r10
movq 136(%rsp), %r11 /*RSP*/
  805628:	4c 8b 9c 24 88 00 00 	mov    0x88(%rsp),%r11
  80562f:	00 

subq $8, %r11  /*to push the value of the rip to timetrap rsp, subtract and then push*/
  805630:	49 83 eb 08          	sub    $0x8,%r11
movq %r10, (%r11) /*transfer RIP to the trap time RSP% */
  805634:	4d 89 13             	mov    %r10,(%r11)
movq %r11, 136(%rsp)  /*Putting the RSP back in the right place*/
  805637:	4c 89 9c 24 88 00 00 	mov    %r11,0x88(%rsp)
  80563e:	00 

// Restore the trap-time registers.  After you do this, you
// can no longer modify any general-purpose registers.
// LAB 4: Your code here.

POPA_ /* already skipped the fault_va and error_code previously by adding 16, so just pop using the macro*/
  80563f:	4c 8b 3c 24          	mov    (%rsp),%r15
  805643:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805648:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  80564d:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  805652:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805657:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80565c:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  805661:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805666:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  80566b:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  805670:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  805675:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  80567a:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  80567f:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  805684:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805689:	48 83 c4 78          	add    $0x78,%rsp
// Restore eflags from the stack.  After you do this, you can
// no longer use arithmetic operations or anything else that
// modifies eflags.
// LAB 4: Your code here.
	
addq $8, %rsp /* go to eflags skipping rip*/
  80568d:	48 83 c4 08          	add    $0x8,%rsp
popfq /*pop the flags*/ 
  805691:	9d                   	popfq  

// Switch back to the adjusted trap-time stack.
// LAB 4: Your code here.

popq %rsp /* already at the point of rsp. so just pop.*/
  805692:	5c                   	pop    %rsp

// Return to re-execute the instruction that faulted.
// LAB 4: Your code here.

ret
  805693:	c3                   	retq   

0000000000805694 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  805694:	55                   	push   %rbp
  805695:	48 89 e5             	mov    %rsp,%rbp
  805698:	48 83 ec 18          	sub    $0x18,%rsp
  80569c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  8056a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8056a4:	48 89 c2             	mov    %rax,%rdx
  8056a7:	48 c1 ea 15          	shr    $0x15,%rdx
  8056ab:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  8056b2:	01 00 00 
  8056b5:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8056b9:	83 e0 01             	and    $0x1,%eax
  8056bc:	48 85 c0             	test   %rax,%rax
  8056bf:	75 07                	jne    8056c8 <pageref+0x34>
		return 0;
  8056c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8056c6:	eb 53                	jmp    80571b <pageref+0x87>
	pte = uvpt[PGNUM(v)];
  8056c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8056cc:	48 89 c2             	mov    %rax,%rdx
  8056cf:	48 c1 ea 0c          	shr    $0xc,%rdx
  8056d3:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8056da:	01 00 00 
  8056dd:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8056e1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  8056e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056e9:	83 e0 01             	and    $0x1,%eax
  8056ec:	48 85 c0             	test   %rax,%rax
  8056ef:	75 07                	jne    8056f8 <pageref+0x64>
		return 0;
  8056f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8056f6:	eb 23                	jmp    80571b <pageref+0x87>
	return pages[PPN(pte)].pp_ref;
  8056f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8056fc:	48 89 c2             	mov    %rax,%rdx
  8056ff:	48 c1 ea 0c          	shr    $0xc,%rdx
  805703:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  80570a:	00 00 00 
  80570d:	48 c1 e2 04          	shl    $0x4,%rdx
  805711:	48 01 d0             	add    %rdx,%rax
  805714:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  805718:	0f b7 c0             	movzwl %ax,%eax
}
  80571b:	c9                   	leaveq 
  80571c:	c3                   	retq   
  80571d:	00 00                	add    %al,(%rax)
	...

0000000000805720 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805720:	55                   	push   %rbp
  805721:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805724:	bf 01 00 00 00       	mov    $0x1,%edi
  805729:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  805730:	00 00 00 
  805733:	ff d0                	callq  *%rax
  805735:	48 ba a8 94 82 00 00 	movabs $0x8294a8,%rdx
  80573c:	00 00 00 
  80573f:	89 02                	mov    %eax,(%rdx)
  selectsem = sys_sem_new(1);
  805741:	bf 01 00 00 00       	mov    $0x1,%edi
  805746:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  80574d:	00 00 00 
  805750:	ff d0                	callq  *%rax
  805752:	48 ba ac 94 82 00 00 	movabs $0x8294ac,%rdx
  805759:	00 00 00 
  80575c:	89 02                	mov    %eax,(%rdx)
}
  80575e:	5d                   	pop    %rbp
  80575f:	c3                   	retq   

0000000000805760 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805760:	55                   	push   %rbp
  805761:	48 89 e5             	mov    %rsp,%rbp
  805764:	48 83 ec 18          	sub    $0x18,%rsp
  805768:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  80576b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80576f:	78 06                	js     805777 <get_socket+0x17>
  805771:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805775:	7e 17                	jle    80578e <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805777:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80577e:	00 00 00 
  805781:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805787:	b8 00 00 00 00       	mov    $0x0,%eax
  80578c:	eb 44                	jmp    8057d2 <get_socket+0x72>
  }

  sock = &sockets[s];
  80578e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805791:	48 98                	cltq   
  805793:	48 89 c2             	mov    %rax,%rdx
  805796:	48 c1 e2 05          	shl    $0x5,%rdx
  80579a:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8057a1:	00 00 00 
  8057a4:	48 01 d0             	add    %rdx,%rax
  8057a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  8057ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8057af:	48 8b 00             	mov    (%rax),%rax
  8057b2:	48 85 c0             	test   %rax,%rax
  8057b5:	75 17                	jne    8057ce <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  8057b7:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8057be:	00 00 00 
  8057c1:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  8057c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8057cc:	eb 04                	jmp    8057d2 <get_socket+0x72>
  }

  return sock;
  8057ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8057d2:	c9                   	leaveq 
  8057d3:	c3                   	retq   

00000000008057d4 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  8057d4:	55                   	push   %rbp
  8057d5:	48 89 e5             	mov    %rsp,%rbp
  8057d8:	48 83 ec 20          	sub    $0x20,%rsp
  8057dc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  8057e0:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8057e7:	00 00 00 
  8057ea:	8b 00                	mov    (%rax),%eax
  8057ec:	89 c7                	mov    %eax,%edi
  8057ee:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  8057f5:	00 00 00 
  8057f8:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  8057fa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  805801:	e9 28 01 00 00       	jmpq   80592e <alloc_socket+0x15a>
    if (!sockets[i].conn) {
  805806:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  80580d:	00 00 00 
  805810:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805813:	48 63 d2             	movslq %edx,%rdx
  805816:	48 c1 e2 05          	shl    $0x5,%rdx
  80581a:	48 01 d0             	add    %rdx,%rax
  80581d:	48 8b 00             	mov    (%rax),%rax
  805820:	48 85 c0             	test   %rax,%rax
  805823:	0f 85 01 01 00 00    	jne    80592a <alloc_socket+0x156>
      sockets[i].conn       = newconn;
  805829:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805830:	00 00 00 
  805833:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805836:	48 63 d2             	movslq %edx,%rdx
  805839:	48 c1 e2 05          	shl    $0x5,%rdx
  80583d:	48 01 c2             	add    %rax,%rdx
  805840:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805844:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805847:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  80584e:	00 00 00 
  805851:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805854:	48 63 d2             	movslq %edx,%rdx
  805857:	48 c1 e2 05          	shl    $0x5,%rdx
  80585b:	48 01 d0             	add    %rdx,%rax
  80585e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805865:	00 
      sockets[i].lastoffset = 0;
  805866:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  80586d:	00 00 00 
  805870:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805873:	48 63 d2             	movslq %edx,%rdx
  805876:	48 c1 e2 05          	shl    $0x5,%rdx
  80587a:	48 01 d0             	add    %rdx,%rax
  80587d:	48 83 c0 10          	add    $0x10,%rax
  805881:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805886:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  80588d:	00 00 00 
  805890:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805893:	48 63 d2             	movslq %edx,%rdx
  805896:	48 c1 e2 05          	shl    $0x5,%rdx
  80589a:	48 01 d0             	add    %rdx,%rax
  80589d:	48 83 c0 10          	add    $0x10,%rax
  8058a1:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  8058a7:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8058ae:	00 00 00 
  8058b1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8058b4:	48 63 d2             	movslq %edx,%rdx
  8058b7:	48 c1 e2 05          	shl    $0x5,%rdx
  8058bb:	48 01 d0             	add    %rdx,%rax
  8058be:	48 83 c0 10          	add    $0x10,%rax
  8058c2:	66 c7 40 04 01 00    	movw   $0x1,0x4(%rax)
      sockets[i].flags      = 0;
  8058c8:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8058cf:	00 00 00 
  8058d2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8058d5:	48 63 d2             	movslq %edx,%rdx
  8058d8:	48 c1 e2 05          	shl    $0x5,%rdx
  8058dc:	48 01 d0             	add    %rdx,%rax
  8058df:	48 83 c0 10          	add    $0x10,%rax
  8058e3:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
      sockets[i].err        = 0;
  8058e9:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  8058f0:	00 00 00 
  8058f3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8058f6:	48 63 d2             	movslq %edx,%rdx
  8058f9:	48 c1 e2 05          	shl    $0x5,%rdx
  8058fd:	48 01 d0             	add    %rdx,%rax
  805900:	48 83 c0 10          	add    $0x10,%rax
  805904:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      sys_sem_signal(socksem);
  80590b:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805912:	00 00 00 
  805915:	8b 00                	mov    (%rax),%eax
  805917:	89 c7                	mov    %eax,%edi
  805919:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  805920:	00 00 00 
  805923:	ff d0                	callq  *%rax
      return i;
  805925:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805928:	eb 2d                	jmp    805957 <alloc_socket+0x183>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  80592a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80592e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805932:	0f 8e ce fe ff ff    	jle    805806 <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805938:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  80593f:	00 00 00 
  805942:	8b 00                	mov    (%rax),%eax
  805944:	89 c7                	mov    %eax,%edi
  805946:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80594d:	00 00 00 
  805950:	ff d0                	callq  *%rax
  return -1;
  805952:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805957:	c9                   	leaveq 
  805958:	c3                   	retq   

0000000000805959 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805959:	55                   	push   %rbp
  80595a:	48 89 e5             	mov    %rsp,%rbp
  80595d:	48 83 ec 70          	sub    $0x70,%rsp
  805961:	89 7d ac             	mov    %edi,-0x54(%rbp)
  805964:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  805968:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  80596c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80596f:	89 c7                	mov    %eax,%edi
  805971:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  805978:	00 00 00 
  80597b:	ff d0                	callq  *%rax
  80597d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805981:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805986:	75 0a                	jne    805992 <lwip_accept+0x39>
    return -1;
  805988:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80598d:	e9 ef 02 00 00       	jmpq   805c81 <lwip_accept+0x328>

  newconn = netconn_accept(sock->conn);
  805992:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805996:	48 8b 00             	mov    (%rax),%rax
  805999:	48 89 c7             	mov    %rax,%rdi
  80599c:	48 b8 94 99 81 00 00 	movabs $0x819994,%rax
  8059a3:	00 00 00 
  8059a6:	ff d0                	callq  *%rax
  8059a8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!newconn) {
  8059ac:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8059b1:	75 62                	jne    805a15 <lwip_accept+0xbc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  8059b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8059b7:	48 8b 00             	mov    (%rax),%rax
  8059ba:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8059be:	0f be c0             	movsbl %al,%eax
  8059c1:	f7 d8                	neg    %eax
  8059c3:	83 f8 0e             	cmp    $0xe,%eax
  8059c6:	77 24                	ja     8059ec <lwip_accept+0x93>
  8059c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8059cc:	48 8b 00             	mov    (%rax),%rax
  8059cf:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8059d3:	0f be c0             	movsbl %al,%eax
  8059d6:	89 c2                	mov    %eax,%edx
  8059d8:	f7 da                	neg    %edx
  8059da:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  8059e1:	00 00 00 
  8059e4:	48 63 d2             	movslq %edx,%rdx
  8059e7:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8059ea:	eb 05                	jmp    8059f1 <lwip_accept+0x98>
  8059ec:	b8 05 00 00 00       	mov    $0x5,%eax
  8059f1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8059f5:	89 42 18             	mov    %eax,0x18(%rdx)
  8059f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8059fc:	8b 50 18             	mov    0x18(%rax),%edx
  8059ff:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805a06:	00 00 00 
  805a09:	89 10                	mov    %edx,(%rax)
    return -1;
  805a0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805a10:	e9 6c 02 00 00       	jmpq   805c81 <lwip_accept+0x328>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  805a15:	48 8d 55 ce          	lea    -0x32(%rbp),%rdx
  805a19:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  805a1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805a21:	b9 00 00 00 00       	mov    $0x0,%ecx
  805a26:	48 89 c7             	mov    %rax,%rdi
  805a29:	48 b8 a5 96 81 00 00 	movabs $0x8196a5,%rax
  805a30:	00 00 00 
  805a33:	ff d0                	callq  *%rax
  805a35:	88 45 ef             	mov    %al,-0x11(%rbp)
  if (err != ERR_OK) {
  805a38:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  805a3c:	74 61                	je     805a9f <lwip_accept+0x146>
    netconn_delete(newconn);
  805a3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805a42:	48 89 c7             	mov    %rax,%rdi
  805a45:	48 b8 f7 95 81 00 00 	movabs $0x8195f7,%rax
  805a4c:	00 00 00 
  805a4f:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  805a51:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805a55:	f7 d8                	neg    %eax
  805a57:	83 f8 0e             	cmp    $0xe,%eax
  805a5a:	77 1a                	ja     805a76 <lwip_accept+0x11d>
  805a5c:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805a60:	89 c2                	mov    %eax,%edx
  805a62:	f7 da                	neg    %edx
  805a64:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  805a6b:	00 00 00 
  805a6e:	48 63 d2             	movslq %edx,%rdx
  805a71:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805a74:	eb 05                	jmp    805a7b <lwip_accept+0x122>
  805a76:	b8 05 00 00 00       	mov    $0x5,%eax
  805a7b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805a7f:	89 42 18             	mov    %eax,0x18(%rdx)
  805a82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805a86:	8b 50 18             	mov    0x18(%rax),%edx
  805a89:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805a90:	00 00 00 
  805a93:	89 10                	mov    %edx,(%rax)
    return -1;
  805a95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805a9a:	e9 e2 01 00 00       	jmpq   805c81 <lwip_accept+0x328>
  }

  memset(&sin, 0, sizeof(sin));
  805a9f:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  805aa3:	ba 10 00 00 00       	mov    $0x10,%edx
  805aa8:	be 00 00 00 00       	mov    $0x0,%esi
  805aad:	48 89 c7             	mov    %rax,%rdi
  805ab0:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  805ab7:	00 00 00 
  805aba:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  805abc:	c6 45 b0 10          	movb   $0x10,-0x50(%rbp)
  sin.sin_family = AF_INET;
  805ac0:	c6 45 b1 02          	movb   $0x2,-0x4f(%rbp)
  sin.sin_port = htons(port);
  805ac4:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
  805ac8:	0f b7 c0             	movzwl %ax,%eax
  805acb:	89 c7                	mov    %eax,%edi
  805acd:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  805ad4:	00 00 00 
  805ad7:	ff d0                	callq  *%rax
  805ad9:	66 89 45 b2          	mov    %ax,-0x4e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  805add:	8b 45 d0             	mov    -0x30(%rbp),%eax
  805ae0:	89 45 b4             	mov    %eax,-0x4c(%rbp)

  if (*addrlen > sizeof(sin))
  805ae3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805ae7:	8b 00                	mov    (%rax),%eax
  805ae9:	83 f8 10             	cmp    $0x10,%eax
  805aec:	76 0a                	jbe    805af8 <lwip_accept+0x19f>
    *addrlen = sizeof(sin);
  805aee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805af2:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  805af8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805afc:	8b 00                	mov    (%rax),%eax
  805afe:	89 c2                	mov    %eax,%edx
  805b00:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  805b04:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  805b08:	48 89 ce             	mov    %rcx,%rsi
  805b0b:	48 89 c7             	mov    %rax,%rdi
  805b0e:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  805b15:	00 00 00 
  805b18:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  805b1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805b1e:	48 89 c7             	mov    %rax,%rdi
  805b21:	48 b8 d4 57 80 00 00 	movabs $0x8057d4,%rax
  805b28:	00 00 00 
  805b2b:	ff d0                	callq  *%rax
  805b2d:	89 45 e8             	mov    %eax,-0x18(%rbp)
  if (newsock == -1) {
  805b30:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%rbp)
  805b34:	75 3b                	jne    805b71 <lwip_accept+0x218>
    netconn_delete(newconn);
  805b36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805b3a:	48 89 c7             	mov    %rax,%rdi
  805b3d:	48 b8 f7 95 81 00 00 	movabs $0x8195f7,%rax
  805b44:	00 00 00 
  805b47:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  805b49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805b4d:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  805b54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805b58:	8b 50 18             	mov    0x18(%rax),%edx
  805b5b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805b62:	00 00 00 
  805b65:	89 10                	mov    %edx,(%rax)
    return -1;
  805b67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805b6c:	e9 10 01 00 00       	jmpq   805c81 <lwip_accept+0x328>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  805b71:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  805b75:	78 06                	js     805b7d <lwip_accept+0x224>
  805b77:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  805b7b:	7e 2a                	jle    805ba7 <lwip_accept+0x24e>
  805b7d:	48 ba 3c 10 82 00 00 	movabs $0x82103c,%rdx
  805b84:	00 00 00 
  805b87:	be 25 01 00 00       	mov    $0x125,%esi
  805b8c:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  805b93:	00 00 00 
  805b96:	b8 00 00 00 00       	mov    $0x0,%eax
  805b9b:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  805ba2:	00 00 00 
  805ba5:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  805ba7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805bab:	48 ba 22 71 80 00 00 	movabs $0x807122,%rdx
  805bb2:	00 00 00 
  805bb5:	48 89 50 38          	mov    %rdx,0x38(%rax)
  nsock = &sockets[newsock];
  805bb9:	8b 45 e8             	mov    -0x18(%rbp),%eax
  805bbc:	48 98                	cltq   
  805bbe:	48 89 c2             	mov    %rax,%rdx
  805bc1:	48 c1 e2 05          	shl    $0x5,%rdx
  805bc5:	48 b8 a0 90 82 00 00 	movabs $0x8290a0,%rax
  805bcc:	00 00 00 
  805bcf:	48 01 d0             	add    %rdx,%rax
  805bd2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  805bd6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  805bdb:	75 2a                	jne    805c07 <lwip_accept+0x2ae>
  805bdd:	48 ba 68 10 82 00 00 	movabs $0x821068,%rdx
  805be4:	00 00 00 
  805be7:	be 28 01 00 00       	mov    $0x128,%esi
  805bec:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  805bf3:	00 00 00 
  805bf6:	b8 00 00 00 00       	mov    $0x0,%eax
  805bfb:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  805c02:	00 00 00 
  805c05:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  805c07:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805c0e:	00 00 00 
  805c11:	8b 00                	mov    (%rax),%eax
  805c13:	89 c7                	mov    %eax,%edi
  805c15:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  805c1c:	00 00 00 
  805c1f:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  805c21:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805c25:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  805c29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805c2d:	8b 40 20             	mov    0x20(%rax),%eax
  805c30:	f7 d0                	not    %eax
  805c32:	01 c2                	add    %eax,%edx
  805c34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805c38:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  805c3c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805c40:	8b 55 e8             	mov    -0x18(%rbp),%edx
  805c43:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  805c46:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805c4d:	00 00 00 
  805c50:	8b 00                	mov    (%rax),%eax
  805c52:	89 c7                	mov    %eax,%edi
  805c54:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  805c5b:	00 00 00 
  805c5e:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  805c60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c64:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805c6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c6f:	8b 50 18             	mov    0x18(%rax),%edx
  805c72:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805c79:	00 00 00 
  805c7c:	89 10                	mov    %edx,(%rax)
  return newsock;
  805c7e:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  805c81:	c9                   	leaveq 
  805c82:	c3                   	retq   

0000000000805c83 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  805c83:	55                   	push   %rbp
  805c84:	48 89 e5             	mov    %rsp,%rbp
  805c87:	48 83 ec 20          	sub    $0x20,%rsp
  805c8b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  805c8e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  805c92:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  805c95:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805c98:	89 c7                	mov    %eax,%edi
  805c9a:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  805ca1:	00 00 00 
  805ca4:	ff d0                	callq  *%rax
  805ca6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805caa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805caf:	75 0a                	jne    805cbb <lwip_bind+0x38>
    return -1;
  805cb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805cb6:	e9 fb 00 00 00       	jmpq   805db6 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  805cbb:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  805cbf:	75 0c                	jne    805ccd <lwip_bind+0x4a>
  805cc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805cc5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  805cc9:	3c 02                	cmp    $0x2,%al
  805ccb:	74 2a                	je     805cf7 <lwip_bind+0x74>
  805ccd:	48 ba 7f 10 82 00 00 	movabs $0x82107f,%rdx
  805cd4:	00 00 00 
  805cd7:	be 4a 01 00 00       	mov    $0x14a,%esi
  805cdc:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  805ce3:	00 00 00 
  805ce6:	b8 00 00 00 00       	mov    $0x0,%eax
  805ceb:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  805cf2:	00 00 00 
  805cf5:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  805cf7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805cfb:	8b 40 04             	mov    0x4(%rax),%eax
  805cfe:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  805d01:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805d05:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  805d09:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  805d0d:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805d11:	89 c7                	mov    %eax,%edi
  805d13:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  805d1a:	00 00 00 
  805d1d:	ff d0                	callq  *%rax
  805d1f:	0f b7 d0             	movzwl %ax,%edx
  805d22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d26:	48 8b 00             	mov    (%rax),%rax
  805d29:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  805d2d:	48 89 ce             	mov    %rcx,%rsi
  805d30:	48 89 c7             	mov    %rax,%rdi
  805d33:	48 b8 9b 97 81 00 00 	movabs $0x81979b,%rax
  805d3a:	00 00 00 
  805d3d:	ff d0                	callq  *%rax
  805d3f:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  805d42:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  805d46:	74 4b                	je     805d93 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  805d48:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  805d4c:	f7 d8                	neg    %eax
  805d4e:	83 f8 0e             	cmp    $0xe,%eax
  805d51:	77 1a                	ja     805d6d <lwip_bind+0xea>
  805d53:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  805d57:	89 c2                	mov    %eax,%edx
  805d59:	f7 da                	neg    %edx
  805d5b:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  805d62:	00 00 00 
  805d65:	48 63 d2             	movslq %edx,%rdx
  805d68:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805d6b:	eb 05                	jmp    805d72 <lwip_bind+0xef>
  805d6d:	b8 05 00 00 00       	mov    $0x5,%eax
  805d72:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805d76:	89 42 18             	mov    %eax,0x18(%rdx)
  805d79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d7d:	8b 50 18             	mov    0x18(%rax),%edx
  805d80:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805d87:	00 00 00 
  805d8a:	89 10                	mov    %edx,(%rax)
    return -1;
  805d8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805d91:	eb 23                	jmp    805db6 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  805d93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d97:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805d9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805da2:	8b 50 18             	mov    0x18(%rax),%edx
  805da5:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805dac:	00 00 00 
  805daf:	89 10                	mov    %edx,(%rax)
  return 0;
  805db1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805db6:	c9                   	leaveq 
  805db7:	c3                   	retq   

0000000000805db8 <lwip_close>:

int
lwip_close(int s)
{
  805db8:	55                   	push   %rbp
  805db9:	48 89 e5             	mov    %rsp,%rbp
  805dbc:	48 83 ec 20          	sub    $0x20,%rsp
  805dc0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  805dc3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805dc6:	89 c7                	mov    %eax,%edi
  805dc8:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  805dcf:	00 00 00 
  805dd2:	ff d0                	callq  *%rax
  805dd4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  805dd8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805ddd:	75 0a                	jne    805de9 <lwip_close+0x31>
    return -1;
  805ddf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805de4:	e9 b2 00 00 00       	jmpq   805e9b <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  805de9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805ded:	48 8b 00             	mov    (%rax),%rax
  805df0:	48 89 c7             	mov    %rax,%rdi
  805df3:	48 b8 f7 95 81 00 00 	movabs $0x8195f7,%rax
  805dfa:	00 00 00 
  805dfd:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  805dff:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805e06:	00 00 00 
  805e09:	8b 00                	mov    (%rax),%eax
  805e0b:	89 c7                	mov    %eax,%edi
  805e0d:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  805e14:	00 00 00 
  805e17:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  805e19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e1d:	48 8b 40 08          	mov    0x8(%rax),%rax
  805e21:	48 85 c0             	test   %rax,%rax
  805e24:	74 17                	je     805e3d <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  805e26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e2a:	48 8b 40 08          	mov    0x8(%rax),%rax
  805e2e:	48 89 c7             	mov    %rax,%rdi
  805e31:	48 b8 bc 88 80 00 00 	movabs $0x8088bc,%rax
  805e38:	00 00 00 
  805e3b:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  805e3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e41:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805e48:	00 
  sock->lastoffset = 0;
  805e49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e4d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  805e53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e57:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  805e5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e62:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805e69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e6d:	8b 50 18             	mov    0x18(%rax),%edx
  805e70:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805e77:	00 00 00 
  805e7a:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  805e7c:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  805e83:	00 00 00 
  805e86:	8b 00                	mov    (%rax),%eax
  805e88:	89 c7                	mov    %eax,%edi
  805e8a:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  805e91:	00 00 00 
  805e94:	ff d0                	callq  *%rax
  return 0;
  805e96:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805e9b:	c9                   	leaveq 
  805e9c:	c3                   	retq   

0000000000805e9d <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  805e9d:	55                   	push   %rbp
  805e9e:	48 89 e5             	mov    %rsp,%rbp
  805ea1:	48 83 ec 30          	sub    $0x30,%rsp
  805ea5:	89 7d dc             	mov    %edi,-0x24(%rbp)
  805ea8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  805eac:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  805eaf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  805eb2:	89 c7                	mov    %eax,%edi
  805eb4:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  805ebb:	00 00 00 
  805ebe:	ff d0                	callq  *%rax
  805ec0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  805ec4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  805ec9:	75 0a                	jne    805ed5 <lwip_connect+0x38>
    return -1;
  805ecb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805ed0:	e9 22 01 00 00       	jmpq   805ff7 <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  805ed5:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  805ed9:	75 0c                	jne    805ee7 <lwip_connect+0x4a>
  805edb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805edf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  805ee3:	3c 02                	cmp    $0x2,%al
  805ee5:	74 2a                	je     805f11 <lwip_connect+0x74>
  805ee7:	48 ba 9a 10 82 00 00 	movabs $0x82109a,%rdx
  805eee:	00 00 00 
  805ef1:	be 86 01 00 00       	mov    $0x186,%esi
  805ef6:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  805efd:	00 00 00 
  805f00:	b8 00 00 00 00       	mov    $0x0,%eax
  805f05:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  805f0c:	00 00 00 
  805f0f:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  805f11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805f15:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  805f19:	84 c0                	test   %al,%al
  805f1b:	75 1b                	jne    805f38 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  805f1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805f21:	48 8b 00             	mov    (%rax),%rax
  805f24:	48 89 c7             	mov    %rax,%rdi
  805f27:	48 b8 af 98 81 00 00 	movabs $0x8198af,%rax
  805f2e:	00 00 00 
  805f31:	ff d0                	callq  *%rax
  805f33:	88 45 ff             	mov    %al,-0x1(%rbp)
  805f36:	eb 4b                	jmp    805f83 <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  805f38:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805f3c:	8b 40 04             	mov    0x4(%rax),%eax
  805f3f:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  805f42:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805f46:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  805f4a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  805f4e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  805f52:	89 c7                	mov    %eax,%edi
  805f54:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  805f5b:	00 00 00 
  805f5e:	ff d0                	callq  *%rax
  805f60:	0f b7 d0             	movzwl %ax,%edx
  805f63:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805f67:	48 8b 00             	mov    (%rax),%rax
  805f6a:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  805f6e:	48 89 ce             	mov    %rcx,%rsi
  805f71:	48 89 c7             	mov    %rax,%rdi
  805f74:	48 b8 25 98 81 00 00 	movabs $0x819825,%rax
  805f7b:	00 00 00 
  805f7e:	ff d0                	callq  *%rax
  805f80:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  805f83:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  805f87:	74 4b                	je     805fd4 <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  805f89:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  805f8d:	f7 d8                	neg    %eax
  805f8f:	83 f8 0e             	cmp    $0xe,%eax
  805f92:	77 1a                	ja     805fae <lwip_connect+0x111>
  805f94:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  805f98:	89 c2                	mov    %eax,%edx
  805f9a:	f7 da                	neg    %edx
  805f9c:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  805fa3:	00 00 00 
  805fa6:	48 63 d2             	movslq %edx,%rdx
  805fa9:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805fac:	eb 05                	jmp    805fb3 <lwip_connect+0x116>
  805fae:	b8 05 00 00 00       	mov    $0x5,%eax
  805fb3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805fb7:	89 42 18             	mov    %eax,0x18(%rdx)
  805fba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805fbe:	8b 50 18             	mov    0x18(%rax),%edx
  805fc1:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805fc8:	00 00 00 
  805fcb:	89 10                	mov    %edx,(%rax)
    return -1;
  805fcd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805fd2:	eb 23                	jmp    805ff7 <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  805fd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805fd8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805fdf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805fe3:	8b 50 18             	mov    0x18(%rax),%edx
  805fe6:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  805fed:	00 00 00 
  805ff0:	89 10                	mov    %edx,(%rax)
  return 0;
  805ff2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805ff7:	c9                   	leaveq 
  805ff8:	c3                   	retq   

0000000000805ff9 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  805ff9:	55                   	push   %rbp
  805ffa:	48 89 e5             	mov    %rsp,%rbp
  805ffd:	48 83 ec 20          	sub    $0x20,%rsp
  806001:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806004:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  806007:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80600a:	89 c7                	mov    %eax,%edi
  80600c:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  806013:	00 00 00 
  806016:	ff d0                	callq  *%rax
  806018:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  80601c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806021:	75 0a                	jne    80602d <lwip_listen+0x34>
    return -1;
  806023:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806028:	e9 b2 00 00 00       	jmpq   8060df <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  80602d:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806031:	79 07                	jns    80603a <lwip_listen+0x41>
    backlog = 0;
  806033:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  80603a:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  806041:	7e 07                	jle    80604a <lwip_listen+0x51>
    backlog = 0xff;
  806043:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80604a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80604d:	0f b6 d0             	movzbl %al,%edx
  806050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806054:	48 8b 00             	mov    (%rax),%rax
  806057:	89 d6                	mov    %edx,%esi
  806059:	48 89 c7             	mov    %rax,%rdi
  80605c:	48 b8 1f 99 81 00 00 	movabs $0x81991f,%rax
  806063:	00 00 00 
  806066:	ff d0                	callq  *%rax
  806068:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  80606b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80606f:	74 4b                	je     8060bc <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806071:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806075:	f7 d8                	neg    %eax
  806077:	83 f8 0e             	cmp    $0xe,%eax
  80607a:	77 1a                	ja     806096 <lwip_listen+0x9d>
  80607c:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806080:	89 c2                	mov    %eax,%edx
  806082:	f7 da                	neg    %edx
  806084:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  80608b:	00 00 00 
  80608e:	48 63 d2             	movslq %edx,%rdx
  806091:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806094:	eb 05                	jmp    80609b <lwip_listen+0xa2>
  806096:	b8 05 00 00 00       	mov    $0x5,%eax
  80609b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80609f:	89 42 18             	mov    %eax,0x18(%rdx)
  8060a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060a6:	8b 50 18             	mov    0x18(%rax),%edx
  8060a9:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8060b0:	00 00 00 
  8060b3:	89 10                	mov    %edx,(%rax)
    return -1;
  8060b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8060ba:	eb 23                	jmp    8060df <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  8060bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060c0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8060c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8060cb:	8b 50 18             	mov    0x18(%rax),%edx
  8060ce:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8060d5:	00 00 00 
  8060d8:	89 10                	mov    %edx,(%rax)
  return 0;
  8060da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8060df:	c9                   	leaveq 
  8060e0:	c3                   	retq   

00000000008060e1 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8060e1:	55                   	push   %rbp
  8060e2:	48 89 e5             	mov    %rsp,%rbp
  8060e5:	48 83 ec 70          	sub    $0x70,%rsp
  8060e9:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8060ec:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8060f0:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8060f3:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  8060f6:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  8060fa:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  8060fe:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  806104:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  806108:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80610b:	89 c7                	mov    %eax,%edi
  80610d:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  806114:	00 00 00 
  806117:	ff d0                	callq  *%rax
  806119:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  80611d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806122:	75 0a                	jne    80612e <lwip_recvfrom+0x4d>
    return -1;
  806124:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806129:	e9 8d 03 00 00       	jmpq   8064bb <lwip_recvfrom+0x3da>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80612e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806132:	48 8b 40 08          	mov    0x8(%rax),%rax
  806136:	48 85 c0             	test   %rax,%rax
  806139:	74 11                	je     80614c <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  80613b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80613f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806143:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806147:	e9 0c 01 00 00       	jmpq   806258 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80614c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80614f:	83 e0 08             	and    $0x8,%eax
  806152:	85 c0                	test   %eax,%eax
  806154:	75 14                	jne    80616a <lwip_recvfrom+0x89>
  806156:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80615a:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80615e:	0f b7 c0             	movzwl %ax,%eax
  806161:	25 00 08 00 00       	and    $0x800,%eax
  806166:	85 c0                	test   %eax,%eax
  806168:	74 35                	je     80619f <lwip_recvfrom+0xbe>
  80616a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80616e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806172:	66 85 c0             	test   %ax,%ax
  806175:	75 28                	jne    80619f <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  806177:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80617b:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  806182:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806186:	8b 50 18             	mov    0x18(%rax),%edx
  806189:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806190:	00 00 00 
  806193:	89 10                	mov    %edx,(%rax)
        return -1;
  806195:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80619a:	e9 1c 03 00 00       	jmpq   8064bb <lwip_recvfrom+0x3da>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80619f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8061a3:	48 8b 00             	mov    (%rax),%rax
  8061a6:	48 89 c7             	mov    %rax,%rdi
  8061a9:	48 b8 56 9a 81 00 00 	movabs $0x819a56,%rax
  8061b0:	00 00 00 
  8061b3:	ff d0                	callq  *%rax
  8061b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8061b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8061bd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8061c1:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8061c5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8061ca:	0f 85 88 00 00 00    	jne    806258 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8061d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8061d4:	48 8b 00             	mov    (%rax),%rax
  8061d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8061db:	48 85 c0             	test   %rax,%rax
  8061de:	74 0f                	je     8061ef <lwip_recvfrom+0x10e>
  8061e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8061e4:	48 8b 00             	mov    (%rax),%rax
  8061e7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8061eb:	84 c0                	test   %al,%al
  8061ed:	74 40                	je     80622f <lwip_recvfrom+0x14e>
  8061ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8061f3:	48 8b 00             	mov    (%rax),%rax
  8061f6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8061fa:	0f be c0             	movsbl %al,%eax
  8061fd:	f7 d8                	neg    %eax
  8061ff:	83 f8 0e             	cmp    $0xe,%eax
  806202:	77 24                	ja     806228 <lwip_recvfrom+0x147>
  806204:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806208:	48 8b 00             	mov    (%rax),%rax
  80620b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  80620f:	0f be c0             	movsbl %al,%eax
  806212:	89 c2                	mov    %eax,%edx
  806214:	f7 da                	neg    %edx
  806216:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  80621d:	00 00 00 
  806220:	48 63 d2             	movslq %edx,%rdx
  806223:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806226:	eb 05                	jmp    80622d <lwip_recvfrom+0x14c>
  806228:	b8 05 00 00 00       	mov    $0x5,%eax
  80622d:	eb 05                	jmp    806234 <lwip_recvfrom+0x153>
  80622f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  806234:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  806238:	89 42 18             	mov    %eax,0x18(%rdx)
  80623b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80623f:	8b 50 18             	mov    0x18(%rax),%edx
  806242:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806249:	00 00 00 
  80624c:	89 10                	mov    %edx,(%rax)
        return 0;
  80624e:	b8 00 00 00 00       	mov    $0x0,%eax
  806253:	e9 63 02 00 00       	jmpq   8064bb <lwip_recvfrom+0x3da>
      }
    }

    buflen = netbuf_len(buf);
  806258:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80625c:	48 8b 00             	mov    (%rax),%rax
  80625f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806263:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  806267:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80626b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80626f:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  806273:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806277:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  80627a:	7d 0a                	jge    806286 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  80627c:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806280:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  806284:	eb 07                	jmp    80628d <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  806286:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806289:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80628d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806291:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806295:	0f b7 c8             	movzwl %ax,%ecx
  806298:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80629c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8062a0:	48 89 c6             	mov    %rax,%rsi
  8062a3:	48 03 75 b0          	add    -0x50(%rbp),%rsi
  8062a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8062ab:	48 8b 00             	mov    (%rax),%rax
  8062ae:	48 89 c7             	mov    %rax,%rdi
  8062b1:	48 b8 6b de 80 00 00 	movabs $0x80de6b,%rax
  8062b8:	00 00 00 
  8062bb:	ff d0                	callq  *%rax

    off += copylen;
  8062bd:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8062c1:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8062c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8062c9:	48 8b 00             	mov    (%rax),%rax
  8062cc:	48 89 c7             	mov    %rax,%rdi
  8062cf:	48 b8 60 96 81 00 00 	movabs $0x819660,%rax
  8062d6:	00 00 00 
  8062d9:	ff d0                	callq  *%rax
  8062db:	83 f8 10             	cmp    $0x10,%eax
  8062de:	75 35                	jne    806315 <lwip_recvfrom+0x234>
      len -= copylen;
  8062e0:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8062e4:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8062e7:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8062eb:	7e 22                	jle    80630f <lwip_recvfrom+0x22e>
  8062ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8062f1:	48 8b 00             	mov    (%rax),%rax
  8062f4:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  8062f8:	0f b6 c0             	movzbl %al,%eax
  8062fb:	83 e0 01             	and    $0x1,%eax
  8062fe:	84 c0                	test   %al,%al
  806300:	75 0d                	jne    80630f <lwip_recvfrom+0x22e>
  806302:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806306:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80630a:	66 85 c0             	test   %ax,%ax
  80630d:	75 0a                	jne    806319 <lwip_recvfrom+0x238>
        done = 1;
  80630f:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  806313:	eb 04                	jmp    806319 <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  806315:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  806319:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80631c:	83 e0 01             	and    $0x1,%eax
  80631f:	85 c0                	test   %eax,%eax
  806321:	75 70                	jne    806393 <lwip_recvfrom+0x2b2>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  806323:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806327:	48 8b 00             	mov    (%rax),%rax
  80632a:	8b 00                	mov    (%rax),%eax
  80632c:	83 f8 10             	cmp    $0x10,%eax
  80632f:	75 37                	jne    806368 <lwip_recvfrom+0x287>
  806331:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  806335:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806339:	89 d1                	mov    %edx,%ecx
  80633b:	29 c1                	sub    %eax,%ecx
  80633d:	89 c8                	mov    %ecx,%eax
  80633f:	85 c0                	test   %eax,%eax
  806341:	7e 25                	jle    806368 <lwip_recvfrom+0x287>
        sock->lastdata = buf;
  806343:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806347:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80634b:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  80634f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806353:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806357:	89 c2                	mov    %eax,%edx
  806359:	66 03 55 f6          	add    -0xa(%rbp),%dx
  80635d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806361:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  806365:	90                   	nop
  806366:	eb 2f                	jmp    806397 <lwip_recvfrom+0x2b6>
      } else {
        sock->lastdata = NULL;
  806368:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80636c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806373:	00 
        sock->lastoffset = 0;
  806374:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806378:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80637e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806382:	48 89 c7             	mov    %rax,%rdi
  806385:	48 b8 bc 88 80 00 00 	movabs $0x8088bc,%rax
  80638c:	00 00 00 
  80638f:	ff d0                	callq  *%rax
  806391:	eb 04                	jmp    806397 <lwip_recvfrom+0x2b6>
      }
    } else {
      done = 1;
  806393:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  806397:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  80639b:	0f 84 8d fd ff ff    	je     80612e <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  8063a1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8063a6:	0f 84 ed 00 00 00    	je     806499 <lwip_recvfrom+0x3b8>
  8063ac:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  8063b1:	0f 84 e2 00 00 00    	je     806499 <lwip_recvfrom+0x3b8>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8063b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8063bb:	48 8b 00             	mov    (%rax),%rax
  8063be:	48 89 c7             	mov    %rax,%rdi
  8063c1:	48 b8 60 96 81 00 00 	movabs $0x819660,%rax
  8063c8:	00 00 00 
  8063cb:	ff d0                	callq  *%rax
  8063cd:	83 f8 10             	cmp    $0x10,%eax
  8063d0:	75 31                	jne    806403 <lwip_recvfrom+0x322>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8063d2:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8063d6:	48 83 c0 04          	add    $0x4,%rax
  8063da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  8063de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8063e2:	48 8b 00             	mov    (%rax),%rax
  8063e5:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  8063e9:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8063ed:	b9 00 00 00 00       	mov    $0x0,%ecx
  8063f2:	48 89 c7             	mov    %rax,%rdi
  8063f5:	48 b8 a5 96 81 00 00 	movabs $0x8196a5,%rax
  8063fc:	00 00 00 
  8063ff:	ff d0                	callq  *%rax
  806401:	eb 18                	jmp    80641b <lwip_recvfrom+0x33a>
    } else {
      addr = netbuf_fromaddr(buf);
  806403:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806407:	48 8b 40 10          	mov    0x10(%rax),%rax
  80640b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  80640f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806413:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  806417:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  80641b:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80641f:	ba 10 00 00 00       	mov    $0x10,%edx
  806424:	be 00 00 00 00       	mov    $0x0,%esi
  806429:	48 89 c7             	mov    %rax,%rdi
  80642c:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806433:	00 00 00 
  806436:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  806438:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  80643c:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  806440:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  806444:	0f b7 c0             	movzwl %ax,%eax
  806447:	89 c7                	mov    %eax,%edi
  806449:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  806450:	00 00 00 
  806453:	ff d0                	callq  *%rax
  806455:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  806459:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80645d:	8b 00                	mov    (%rax),%eax
  80645f:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  806462:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806466:	8b 00                	mov    (%rax),%eax
  806468:	83 f8 10             	cmp    $0x10,%eax
  80646b:	76 0a                	jbe    806477 <lwip_recvfrom+0x396>
      *fromlen = sizeof(sin);
  80646d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806471:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806477:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80647b:	8b 00                	mov    (%rax),%eax
  80647d:	89 c2                	mov    %eax,%edx
  80647f:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806483:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806487:	48 89 ce             	mov    %rcx,%rsi
  80648a:	48 89 c7             	mov    %rax,%rdi
  80648d:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  806494:	00 00 00 
  806497:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806499:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80649d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8064a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064a8:	8b 50 18             	mov    0x18(%rax),%edx
  8064ab:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8064b2:	00 00 00 
  8064b5:	89 10                	mov    %edx,(%rax)
  return off;
  8064b7:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  8064bb:	c9                   	leaveq 
  8064bc:	c3                   	retq   

00000000008064bd <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  8064bd:	55                   	push   %rbp
  8064be:	48 89 e5             	mov    %rsp,%rbp
  8064c1:	48 83 ec 10          	sub    $0x10,%rsp
  8064c5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8064c8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8064cc:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8064cf:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8064d2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8064d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8064d9:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8064df:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8064e5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8064ea:	89 c7                	mov    %eax,%edi
  8064ec:	48 b8 e1 60 80 00 00 	movabs $0x8060e1,%rax
  8064f3:	00 00 00 
  8064f6:	ff d0                	callq  *%rax
}
  8064f8:	c9                   	leaveq 
  8064f9:	c3                   	retq   

00000000008064fa <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8064fa:	55                   	push   %rbp
  8064fb:	48 89 e5             	mov    %rsp,%rbp
  8064fe:	48 83 ec 20          	sub    $0x20,%rsp
  806502:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806505:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806509:	89 55 f8             	mov    %edx,-0x8(%rbp)
  80650c:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  80650f:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  806512:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806515:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806519:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80651c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806522:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806528:	89 c7                	mov    %eax,%edi
  80652a:	48 b8 e1 60 80 00 00 	movabs $0x8060e1,%rax
  806531:	00 00 00 
  806534:	ff d0                	callq  *%rax
}
  806536:	c9                   	leaveq 
  806537:	c3                   	retq   

0000000000806538 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806538:	55                   	push   %rbp
  806539:	48 89 e5             	mov    %rsp,%rbp
  80653c:	48 83 ec 30          	sub    $0x30,%rsp
  806540:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806543:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806547:	89 55 e8             	mov    %edx,-0x18(%rbp)
  80654a:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80654d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806550:	89 c7                	mov    %eax,%edi
  806552:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  806559:	00 00 00 
  80655c:	ff d0                	callq  *%rax
  80655e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806562:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806567:	75 0a                	jne    806573 <lwip_send+0x3b>
    return -1;
  806569:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80656e:	e9 c3 00 00 00       	jmpq   806636 <lwip_send+0xfe>

  if (sock->conn->type!=NETCONN_TCP) {
  806573:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806577:	48 8b 00             	mov    (%rax),%rax
  80657a:	8b 00                	mov    (%rax),%eax
  80657c:	83 f8 10             	cmp    $0x10,%eax
  80657f:	74 2c                	je     8065ad <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  806581:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806584:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806587:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  80658b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80658e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806594:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80659a:	89 c7                	mov    %eax,%edi
  80659c:	48 b8 38 66 80 00 00 	movabs $0x806638,%rax
  8065a3:	00 00 00 
  8065a6:	ff d0                	callq  *%rax
  8065a8:	e9 89 00 00 00       	jmpq   806636 <lwip_send+0xfe>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8065ad:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8065b0:	83 e0 10             	and    $0x10,%eax
  8065b3:	85 c0                	test   %eax,%eax
  8065b5:	74 07                	je     8065be <lwip_send+0x86>
  8065b7:	b8 03 00 00 00       	mov    $0x3,%eax
  8065bc:	eb 05                	jmp    8065c3 <lwip_send+0x8b>
  8065be:	b8 01 00 00 00       	mov    $0x1,%eax
  8065c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8065c7:	48 8b 3a             	mov    (%rdx),%rdi
  8065ca:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8065cd:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8065d1:	89 c1                	mov    %eax,%ecx
  8065d3:	48 b8 b5 9d 81 00 00 	movabs $0x819db5,%rax
  8065da:	00 00 00 
  8065dd:	ff d0                	callq  *%rax
  8065df:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8065e2:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  8065e6:	f7 d8                	neg    %eax
  8065e8:	83 f8 0e             	cmp    $0xe,%eax
  8065eb:	77 1a                	ja     806607 <lwip_send+0xcf>
  8065ed:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  8065f1:	89 c2                	mov    %eax,%edx
  8065f3:	f7 da                	neg    %edx
  8065f5:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  8065fc:	00 00 00 
  8065ff:	48 63 d2             	movslq %edx,%rdx
  806602:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806605:	eb 05                	jmp    80660c <lwip_send+0xd4>
  806607:	b8 05 00 00 00       	mov    $0x5,%eax
  80660c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  806610:	89 42 18             	mov    %eax,0x18(%rdx)
  806613:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806617:	8b 50 18             	mov    0x18(%rax),%edx
  80661a:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806621:	00 00 00 
  806624:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806626:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80662a:	75 05                	jne    806631 <lwip_send+0xf9>
  80662c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80662f:	eb 05                	jmp    806636 <lwip_send+0xfe>
  806631:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806636:	c9                   	leaveq 
  806637:	c3                   	retq   

0000000000806638 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806638:	55                   	push   %rbp
  806639:	48 89 e5             	mov    %rsp,%rbp
  80663c:	48 83 ec 60          	sub    $0x60,%rsp
  806640:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806643:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806647:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80664a:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  80664d:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806651:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806655:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806658:	89 c7                	mov    %eax,%edi
  80665a:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  806661:	00 00 00 
  806664:	ff d0                	callq  *%rax
  806666:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  80666a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80666f:	75 0a                	jne    80667b <lwip_sendto+0x43>
    return -1;
  806671:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806676:	e9 d8 01 00 00       	jmpq   806853 <lwip_sendto+0x21b>

  if (sock->conn->type==NETCONN_TCP) {
  80667b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80667f:	48 8b 00             	mov    (%rax),%rax
  806682:	8b 00                	mov    (%rax),%eax
  806684:	83 f8 10             	cmp    $0x10,%eax
  806687:	75 20                	jne    8066a9 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806689:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  80668c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80668f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806693:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806696:	89 c7                	mov    %eax,%edi
  806698:	48 b8 38 65 80 00 00 	movabs $0x806538,%rax
  80669f:	00 00 00 
  8066a2:	ff d0                	callq  *%rax
  8066a4:	e9 aa 01 00 00       	jmpq   806853 <lwip_sendto+0x21b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8066a9:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8066ad:	78 09                	js     8066b8 <lwip_sendto+0x80>
  8066af:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  8066b6:	7e 2a                	jle    8066e2 <lwip_sendto+0xaa>
  8066b8:	48 ba b8 10 82 00 00 	movabs $0x8210b8,%rdx
  8066bf:	00 00 00 
  8066c2:	be 97 02 00 00       	mov    $0x297,%esi
  8066c7:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  8066ce:	00 00 00 
  8066d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8066d6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8066dd:	00 00 00 
  8066e0:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8066e2:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8066e7:	75 06                	jne    8066ef <lwip_sendto+0xb7>
  8066e9:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  8066ed:	74 3c                	je     80672b <lwip_sendto+0xf3>
  8066ef:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  8066f3:	75 0c                	jne    806701 <lwip_sendto+0xc9>
  8066f5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8066f9:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8066fd:	3c 02                	cmp    $0x2,%al
  8066ff:	74 2a                	je     80672b <lwip_sendto+0xf3>
  806701:	48 ba dc 10 82 00 00 	movabs $0x8210dc,%rdx
  806708:	00 00 00 
  80670b:	be 9b 02 00 00       	mov    $0x29b,%esi
  806710:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  806717:	00 00 00 
  80671a:	b8 00 00 00 00       	mov    $0x0,%eax
  80671f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  806726:	00 00 00 
  806729:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  80672b:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806732:	00 
  806733:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806737:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  80673b:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806740:	74 39                	je     80677b <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806742:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806746:	8b 40 04             	mov    0x4(%rax),%eax
  806749:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80674c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806750:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806754:	0f b7 c0             	movzwl %ax,%eax
  806757:	89 c7                	mov    %eax,%edi
  806759:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  806760:	00 00 00 
  806763:	ff d0                	callq  *%rax
  806765:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806769:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80676d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806771:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806775:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806779:	eb 1b                	jmp    806796 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  80677b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806782:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806788:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80678f:	00 
    buf.port         = 0;
  806790:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806796:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806799:	0f b7 d0             	movzwl %ax,%edx
  80679c:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8067a0:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8067a4:	48 89 ce             	mov    %rcx,%rsi
  8067a7:	48 89 c7             	mov    %rax,%rdi
  8067aa:	48 b8 94 8a 80 00 00 	movabs $0x808a94,%rax
  8067b1:	00 00 00 
  8067b4:	ff d0                	callq  *%rax
  8067b6:	0f be c0             	movsbl %al,%eax
  8067b9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8067bc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8067c0:	75 23                	jne    8067e5 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  8067c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8067c6:	48 8b 00             	mov    (%rax),%rax
  8067c9:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  8067cd:	48 89 d6             	mov    %rdx,%rsi
  8067d0:	48 89 c7             	mov    %rax,%rdi
  8067d3:	48 b8 39 9d 81 00 00 	movabs $0x819d39,%rax
  8067da:	00 00 00 
  8067dd:	ff d0                	callq  *%rax
  8067df:	0f be c0             	movsbl %al,%eax
  8067e2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8067e5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8067e9:	48 85 c0             	test   %rax,%rax
  8067ec:	74 13                	je     806801 <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  8067ee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8067f2:	48 89 c7             	mov    %rax,%rdi
  8067f5:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8067fc:	00 00 00 
  8067ff:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  806801:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806804:	f7 d8                	neg    %eax
  806806:	83 f8 0e             	cmp    $0xe,%eax
  806809:	77 19                	ja     806824 <lwip_sendto+0x1ec>
  80680b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80680e:	89 c2                	mov    %eax,%edx
  806810:	f7 da                	neg    %edx
  806812:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  806819:	00 00 00 
  80681c:	48 63 d2             	movslq %edx,%rdx
  80681f:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806822:	eb 05                	jmp    806829 <lwip_sendto+0x1f1>
  806824:	b8 05 00 00 00       	mov    $0x5,%eax
  806829:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80682d:	89 42 18             	mov    %eax,0x18(%rdx)
  806830:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806834:	8b 50 18             	mov    0x18(%rax),%edx
  806837:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80683e:	00 00 00 
  806841:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806843:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806847:	75 05                	jne    80684e <lwip_sendto+0x216>
  806849:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80684c:	eb 05                	jmp    806853 <lwip_sendto+0x21b>
  80684e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806853:	c9                   	leaveq 
  806854:	c3                   	retq   

0000000000806855 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806855:	55                   	push   %rbp
  806856:	48 89 e5             	mov    %rsp,%rbp
  806859:	48 83 ec 20          	sub    $0x20,%rsp
  80685d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806860:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806863:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806866:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806869:	83 f8 02             	cmp    $0x2,%eax
  80686c:	74 38                	je     8068a6 <lwip_socket+0x51>
  80686e:	83 f8 03             	cmp    $0x3,%eax
  806871:	74 0a                	je     80687d <lwip_socket+0x28>
  806873:	83 f8 01             	cmp    $0x1,%eax
  806876:	74 66                	je     8068de <lwip_socket+0x89>
  806878:	e9 87 00 00 00       	jmpq   806904 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80687d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806880:	0f b6 c0             	movzbl %al,%eax
  806883:	48 ba 22 71 80 00 00 	movabs $0x807122,%rdx
  80688a:	00 00 00 
  80688d:	89 c6                	mov    %eax,%esi
  80688f:	bf 40 00 00 00       	mov    $0x40,%edi
  806894:	48 b8 54 94 81 00 00 	movabs $0x819454,%rax
  80689b:	00 00 00 
  80689e:	ff d0                	callq  *%rax
  8068a0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8068a4:	eb 78                	jmp    80691e <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8068a6:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  8068ad:	75 07                	jne    8068b6 <lwip_socket+0x61>
  8068af:	b8 21 00 00 00       	mov    $0x21,%eax
  8068b4:	eb 05                	jmp    8068bb <lwip_socket+0x66>
  8068b6:	b8 20 00 00 00       	mov    $0x20,%eax
  8068bb:	48 ba 22 71 80 00 00 	movabs $0x807122,%rdx
  8068c2:	00 00 00 
  8068c5:	be 00 00 00 00       	mov    $0x0,%esi
  8068ca:	89 c7                	mov    %eax,%edi
  8068cc:	48 b8 54 94 81 00 00 	movabs $0x819454,%rax
  8068d3:	00 00 00 
  8068d6:	ff d0                	callq  *%rax
  8068d8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8068dc:	eb 40                	jmp    80691e <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8068de:	48 ba 22 71 80 00 00 	movabs $0x807122,%rdx
  8068e5:	00 00 00 
  8068e8:	be 00 00 00 00       	mov    $0x0,%esi
  8068ed:	bf 10 00 00 00       	mov    $0x10,%edi
  8068f2:	48 b8 54 94 81 00 00 	movabs $0x819454,%rax
  8068f9:	00 00 00 
  8068fc:	ff d0                	callq  *%rax
  8068fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806902:	eb 1a                	jmp    80691e <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806904:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80690b:	00 00 00 
  80690e:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806914:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806919:	e9 81 00 00 00       	jmpq   80699f <lwip_socket+0x14a>
  }

  if (!conn) {
  80691e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806923:	75 17                	jne    80693c <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806925:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80692c:	00 00 00 
  80692f:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806935:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80693a:	eb 63                	jmp    80699f <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  80693c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806940:	48 89 c7             	mov    %rax,%rdi
  806943:	48 b8 d4 57 80 00 00 	movabs $0x8057d4,%rax
  80694a:	00 00 00 
  80694d:	ff d0                	callq  *%rax
  80694f:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806952:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806956:	75 2a                	jne    806982 <lwip_socket+0x12d>
    netconn_delete(conn);
  806958:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80695c:	48 89 c7             	mov    %rax,%rdi
  80695f:	48 b8 f7 95 81 00 00 	movabs $0x8195f7,%rax
  806966:	00 00 00 
  806969:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  80696b:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806972:	00 00 00 
  806975:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  80697b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806980:	eb 1d                	jmp    80699f <lwip_socket+0x14a>
  }
  conn->socket = i;
  806982:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806986:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806989:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  80698c:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806993:	00 00 00 
  806996:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  80699c:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  80699f:	c9                   	leaveq 
  8069a0:	c3                   	retq   

00000000008069a1 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  8069a1:	55                   	push   %rbp
  8069a2:	48 89 e5             	mov    %rsp,%rbp
  8069a5:	48 83 ec 10          	sub    $0x10,%rsp
  8069a9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8069ac:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8069b0:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  8069b3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8069b6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8069ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8069bd:	b9 00 00 00 00       	mov    $0x0,%ecx
  8069c2:	89 c7                	mov    %eax,%edi
  8069c4:	48 b8 38 65 80 00 00 	movabs $0x806538,%rax
  8069cb:	00 00 00 
  8069ce:	ff d0                	callq  *%rax
}
  8069d0:	c9                   	leaveq 
  8069d1:	c3                   	retq   

00000000008069d2 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  8069d2:	55                   	push   %rbp
  8069d3:	48 89 e5             	mov    %rsp,%rbp
  8069d6:	53                   	push   %rbx
  8069d7:	48 83 ec 68          	sub    $0x68,%rsp
  8069db:	89 7d ac             	mov    %edi,-0x54(%rbp)
  8069de:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8069e2:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8069e6:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  int i, nready = 0;
  8069ea:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  8069f1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8069f5:	ba 04 00 00 00       	mov    $0x4,%edx
  8069fa:	be 00 00 00 00       	mov    $0x0,%esi
  8069ff:	48 89 c7             	mov    %rax,%rdi
  806a02:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806a09:	00 00 00 
  806a0c:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  806a0e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806a12:	ba 04 00 00 00       	mov    $0x4,%edx
  806a17:	be 00 00 00 00       	mov    $0x0,%esi
  806a1c:	48 89 c7             	mov    %rax,%rdi
  806a1f:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806a26:	00 00 00 
  806a29:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  806a2b:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  806a2f:	ba 04 00 00 00       	mov    $0x4,%edx
  806a34:	be 00 00 00 00       	mov    $0x0,%esi
  806a39:	48 89 c7             	mov    %rax,%rdi
  806a3c:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806a43:	00 00 00 
  806a46:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806a48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  806a4f:	e9 31 01 00 00       	jmpq   806b85 <lwip_selscan+0x1b3>
    if (FD_ISSET(i, readset)) {
  806a54:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806a57:	8d 50 07             	lea    0x7(%rax),%edx
  806a5a:	85 c0                	test   %eax,%eax
  806a5c:	0f 48 c2             	cmovs  %edx,%eax
  806a5f:	c1 f8 03             	sar    $0x3,%eax
  806a62:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  806a66:	48 98                	cltq   
  806a68:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806a6c:	0f b6 d0             	movzbl %al,%edx
  806a6f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806a72:	83 e0 07             	and    $0x7,%eax
  806a75:	89 d3                	mov    %edx,%ebx
  806a77:	89 c1                	mov    %eax,%ecx
  806a79:	d3 fb                	sar    %cl,%ebx
  806a7b:	89 d8                	mov    %ebx,%eax
  806a7d:	83 e0 01             	and    $0x1,%eax
  806a80:	84 c0                	test   %al,%al
  806a82:	74 6d                	je     806af1 <lwip_selscan+0x11f>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  806a84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806a87:	89 c7                	mov    %eax,%edi
  806a89:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  806a90:	00 00 00 
  806a93:	ff d0                	callq  *%rax
  806a95:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  806a99:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  806a9e:	74 51                	je     806af1 <lwip_selscan+0x11f>
  806aa0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806aa4:	48 8b 40 08          	mov    0x8(%rax),%rax
  806aa8:	48 85 c0             	test   %rax,%rax
  806aab:	75 0d                	jne    806aba <lwip_selscan+0xe8>
  806aad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806ab1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806ab5:	66 85 c0             	test   %ax,%ax
  806ab8:	74 37                	je     806af1 <lwip_selscan+0x11f>
        FD_SET(i, &lreadset);
  806aba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806abd:	8d 50 07             	lea    0x7(%rax),%edx
  806ac0:	85 c0                	test   %eax,%eax
  806ac2:	0f 48 c2             	cmovs  %edx,%eax
  806ac5:	c1 f8 03             	sar    $0x3,%eax
  806ac8:	48 63 d0             	movslq %eax,%rdx
  806acb:	0f b6 54 15 d0       	movzbl -0x30(%rbp,%rdx,1),%edx
  806ad0:	89 d6                	mov    %edx,%esi
  806ad2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  806ad5:	83 e2 07             	and    $0x7,%edx
  806ad8:	bf 01 00 00 00       	mov    $0x1,%edi
  806add:	89 fb                	mov    %edi,%ebx
  806adf:	89 d1                	mov    %edx,%ecx
  806ae1:	d3 e3                	shl    %cl,%ebx
  806ae3:	89 da                	mov    %ebx,%edx
  806ae5:	09 f2                	or     %esi,%edx
  806ae7:	48 98                	cltq   
  806ae9:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  806aed:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  806af1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806af4:	8d 50 07             	lea    0x7(%rax),%edx
  806af7:	85 c0                	test   %eax,%eax
  806af9:	0f 48 c2             	cmovs  %edx,%eax
  806afc:	c1 f8 03             	sar    $0x3,%eax
  806aff:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  806b03:	48 98                	cltq   
  806b05:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806b09:	0f b6 d0             	movzbl %al,%edx
  806b0c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b0f:	83 e0 07             	and    $0x7,%eax
  806b12:	89 d3                	mov    %edx,%ebx
  806b14:	89 c1                	mov    %eax,%ecx
  806b16:	d3 fb                	sar    %cl,%ebx
  806b18:	89 d8                	mov    %ebx,%eax
  806b1a:	83 e0 01             	and    $0x1,%eax
  806b1d:	84 c0                	test   %al,%al
  806b1f:	74 60                	je     806b81 <lwip_selscan+0x1af>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  806b21:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b24:	89 c7                	mov    %eax,%edi
  806b26:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  806b2d:	00 00 00 
  806b30:	ff d0                	callq  *%rax
  806b32:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (p_sock && p_sock->sendevent) {
  806b36:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  806b3b:	74 44                	je     806b81 <lwip_selscan+0x1af>
  806b3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806b41:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  806b45:	66 85 c0             	test   %ax,%ax
  806b48:	74 37                	je     806b81 <lwip_selscan+0x1af>
        FD_SET(i, &lwriteset);
  806b4a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b4d:	8d 50 07             	lea    0x7(%rax),%edx
  806b50:	85 c0                	test   %eax,%eax
  806b52:	0f 48 c2             	cmovs  %edx,%eax
  806b55:	c1 f8 03             	sar    $0x3,%eax
  806b58:	48 63 d0             	movslq %eax,%rdx
  806b5b:	0f b6 54 15 c0       	movzbl -0x40(%rbp,%rdx,1),%edx
  806b60:	89 d6                	mov    %edx,%esi
  806b62:	8b 55 ec             	mov    -0x14(%rbp),%edx
  806b65:	83 e2 07             	and    $0x7,%edx
  806b68:	bf 01 00 00 00       	mov    $0x1,%edi
  806b6d:	89 fb                	mov    %edi,%ebx
  806b6f:	89 d1                	mov    %edx,%ecx
  806b71:	d3 e3                	shl    %cl,%ebx
  806b73:	89 da                	mov    %ebx,%edx
  806b75:	09 f2                	or     %esi,%edx
  806b77:	48 98                	cltq   
  806b79:	88 54 05 c0          	mov    %dl,-0x40(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  806b7d:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806b81:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  806b85:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806b88:	3b 45 ac             	cmp    -0x54(%rbp),%eax
  806b8b:	0f 8c c3 fe ff ff    	jl     806a54 <lwip_selscan+0x82>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  806b91:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806b95:	8b 55 d0             	mov    -0x30(%rbp),%edx
  806b98:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  806b9a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806b9e:	8b 55 c0             	mov    -0x40(%rbp),%edx
  806ba1:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  806ba3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  806ba7:	ba 04 00 00 00       	mov    $0x4,%edx
  806bac:	be 00 00 00 00       	mov    $0x0,%esi
  806bb1:	48 89 c7             	mov    %rax,%rdi
  806bb4:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806bbb:	00 00 00 
  806bbe:	ff d0                	callq  *%rax
  
  return nready;
  806bc0:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  806bc3:	48 83 c4 68          	add    $0x68,%rsp
  806bc7:	5b                   	pop    %rbx
  806bc8:	5d                   	pop    %rbp
  806bc9:	c3                   	retq   

0000000000806bca <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  806bca:	55                   	push   %rbp
  806bcb:	48 89 e5             	mov    %rsp,%rbp
  806bce:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  806bd5:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  806bd8:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  806bdc:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  806be3:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  806bea:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  806bf1:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  806bf8:	00 
  select_cb.readset = readset;
  806bf9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806bfd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  806c01:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806c08:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  806c0c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806c13:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  806c17:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  806c1e:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  806c25:	00 00 00 
  806c28:	8b 00                	mov    (%rax),%eax
  806c2a:	89 c7                	mov    %eax,%edi
  806c2c:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  806c33:	00 00 00 
  806c36:	ff d0                	callq  *%rax

  if (readset)
  806c38:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806c3d:	74 0b                	je     806c4a <lwip_select+0x80>
    lreadset = *readset;
  806c3f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806c43:	8b 00                	mov    (%rax),%eax
  806c45:	89 45 e0             	mov    %eax,-0x20(%rbp)
  806c48:	eb 1d                	jmp    806c67 <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  806c4a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806c4e:	ba 04 00 00 00       	mov    $0x4,%edx
  806c53:	be 00 00 00 00       	mov    $0x0,%esi
  806c58:	48 89 c7             	mov    %rax,%rdi
  806c5b:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806c62:	00 00 00 
  806c65:	ff d0                	callq  *%rax
  if (writeset)
  806c67:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806c6e:	00 
  806c6f:	74 0e                	je     806c7f <lwip_select+0xb5>
    lwriteset = *writeset;
  806c71:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806c78:	8b 00                	mov    (%rax),%eax
  806c7a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  806c7d:	eb 1d                	jmp    806c9c <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  806c7f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806c83:	ba 04 00 00 00       	mov    $0x4,%edx
  806c88:	be 00 00 00 00       	mov    $0x0,%esi
  806c8d:	48 89 c7             	mov    %rax,%rdi
  806c90:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806c97:	00 00 00 
  806c9a:	ff d0                	callq  *%rax
  if (exceptset)
  806c9c:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806ca3:	00 
  806ca4:	74 0e                	je     806cb4 <lwip_select+0xea>
    lexceptset = *exceptset;
  806ca6:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806cad:	8b 00                	mov    (%rax),%eax
  806caf:	89 45 c0             	mov    %eax,-0x40(%rbp)
  806cb2:	eb 1d                	jmp    806cd1 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  806cb4:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806cb8:	ba 04 00 00 00       	mov    $0x4,%edx
  806cbd:	be 00 00 00 00       	mov    $0x0,%esi
  806cc2:	48 89 c7             	mov    %rax,%rdi
  806cc5:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806ccc:	00 00 00 
  806ccf:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  806cd1:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806cd5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  806cd9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  806cdd:	8b 45 8c             	mov    -0x74(%rbp),%eax
  806ce0:	89 c7                	mov    %eax,%edi
  806ce2:	48 b8 d2 69 80 00 00 	movabs $0x8069d2,%rax
  806ce9:	00 00 00 
  806cec:	ff d0                	callq  *%rax
  806cee:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  806cf1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806cf5:	0f 85 bc 03 00 00    	jne    8070b7 <lwip_select+0x4ed>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  806cfb:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  806d02:	00 
  806d03:	0f 84 d3 00 00 00    	je     806ddc <lwip_select+0x212>
  806d09:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806d10:	48 8b 00             	mov    (%rax),%rax
  806d13:	48 85 c0             	test   %rax,%rax
  806d16:	0f 85 c0 00 00 00    	jne    806ddc <lwip_select+0x212>
  806d1c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806d23:	48 8b 40 08          	mov    0x8(%rax),%rax
  806d27:	48 85 c0             	test   %rax,%rax
  806d2a:	0f 85 ac 00 00 00    	jne    806ddc <lwip_select+0x212>
      sys_sem_signal(selectsem);
  806d30:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  806d37:	00 00 00 
  806d3a:	8b 00                	mov    (%rax),%eax
  806d3c:	89 c7                	mov    %eax,%edi
  806d3e:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  806d45:	00 00 00 
  806d48:	ff d0                	callq  *%rax
      if (readset)
  806d4a:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806d4f:	74 1d                	je     806d6e <lwip_select+0x1a4>
        FD_ZERO(readset);
  806d51:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806d55:	ba 04 00 00 00       	mov    $0x4,%edx
  806d5a:	be 00 00 00 00       	mov    $0x0,%esi
  806d5f:	48 89 c7             	mov    %rax,%rdi
  806d62:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806d69:	00 00 00 
  806d6c:	ff d0                	callq  *%rax
      if (writeset)
  806d6e:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806d75:	00 
  806d76:	74 20                	je     806d98 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  806d78:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806d7f:	ba 04 00 00 00       	mov    $0x4,%edx
  806d84:	be 00 00 00 00       	mov    $0x0,%esi
  806d89:	48 89 c7             	mov    %rax,%rdi
  806d8c:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806d93:	00 00 00 
  806d96:	ff d0                	callq  *%rax
      if (exceptset)
  806d98:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806d9f:	00 
  806da0:	74 20                	je     806dc2 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  806da2:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806da9:	ba 04 00 00 00       	mov    $0x4,%edx
  806dae:	be 00 00 00 00       	mov    $0x0,%esi
  806db3:	48 89 c7             	mov    %rax,%rdi
  806db6:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806dbd:	00 00 00 
  806dc0:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  806dc2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806dc9:	00 00 00 
  806dcc:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  806dd2:	b8 00 00 00 00       	mov    $0x0,%eax
  806dd7:	e9 44 03 00 00       	jmpq   807120 <lwip_select+0x556>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  806ddc:	bf 00 00 00 00       	mov    $0x0,%edi
  806de1:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  806de8:	00 00 00 
  806deb:	ff d0                	callq  *%rax
  806ded:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  806df0:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  806df7:	00 00 00 
  806dfa:	48 8b 00             	mov    (%rax),%rax
  806dfd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  806e01:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  806e08:	00 00 00 
  806e0b:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  806e0f:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  806e12:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  806e19:	00 00 00 
  806e1c:	8b 00                	mov    (%rax),%eax
  806e1e:	89 c7                	mov    %eax,%edi
  806e20:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  806e27:	00 00 00 
  806e2a:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  806e2c:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  806e33:	00 
  806e34:	75 09                	jne    806e3f <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  806e36:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  806e3d:	eb 58                	jmp    806e97 <lwip_select+0x2cd>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  806e3f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806e46:	48 8b 00             	mov    (%rax),%rax
  806e49:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  806e4f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806e56:	48 8b 40 08          	mov    0x8(%rax),%rax
  806e5a:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  806e61:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  806e68:	9b c4 20 
  806e6b:	48 89 c8             	mov    %rcx,%rax
  806e6e:	48 f7 ea             	imul   %rdx
  806e71:	48 c1 fa 07          	sar    $0x7,%rdx
  806e75:	48 89 c8             	mov    %rcx,%rax
  806e78:	48 c1 f8 3f          	sar    $0x3f,%rax
  806e7c:	48 89 d1             	mov    %rdx,%rcx
  806e7f:	48 29 c1             	sub    %rax,%rcx
  806e82:	48 89 c8             	mov    %rcx,%rax
  806e85:	01 f0                	add    %esi,%eax
  806e87:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  806e8a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  806e8e:	75 07                	jne    806e97 <lwip_select+0x2cd>
        msectimeout = 1;
  806e90:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  806e97:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  806e9a:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806e9d:	89 d6                	mov    %edx,%esi
  806e9f:	89 c7                	mov    %eax,%edi
  806ea1:	48 b8 87 e5 80 00 00 	movabs $0x80e587,%rax
  806ea8:	00 00 00 
  806eab:	ff d0                	callq  *%rax
  806ead:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  806eb0:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  806eb7:	00 00 00 
  806eba:	8b 00                	mov    (%rax),%eax
  806ebc:	89 c7                	mov    %eax,%edi
  806ebe:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  806ec5:	00 00 00 
  806ec8:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  806eca:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  806ed1:	00 00 00 
  806ed4:	48 8b 10             	mov    (%rax),%rdx
  806ed7:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  806edb:	48 39 c2             	cmp    %rax,%rdx
  806ede:	75 13                	jne    806ef3 <lwip_select+0x329>
      select_cb_list = select_cb.next;
  806ee0:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  806ee4:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  806eeb:	00 00 00 
  806eee:	48 89 10             	mov    %rdx,(%rax)
  806ef1:	eb 42                	jmp    806f35 <lwip_select+0x36b>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  806ef3:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  806efa:	00 00 00 
  806efd:	48 8b 00             	mov    (%rax),%rax
  806f00:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  806f04:	eb 28                	jmp    806f2e <lwip_select+0x364>
        if (p_selcb->next == &select_cb) {
  806f06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806f0a:	48 8b 10             	mov    (%rax),%rdx
  806f0d:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  806f11:	48 39 c2             	cmp    %rax,%rdx
  806f14:	75 0d                	jne    806f23 <lwip_select+0x359>
          p_selcb->next = select_cb.next;
  806f16:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  806f1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806f1e:	48 89 10             	mov    %rdx,(%rax)
          break;
  806f21:	eb 12                	jmp    806f35 <lwip_select+0x36b>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  806f23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806f27:	48 8b 00             	mov    (%rax),%rax
  806f2a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  806f2e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  806f33:	75 d1                	jne    806f06 <lwip_select+0x33c>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  806f35:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  806f3c:	00 00 00 
  806f3f:	8b 00                	mov    (%rax),%eax
  806f41:	89 c7                	mov    %eax,%edi
  806f43:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  806f4a:	00 00 00 
  806f4d:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  806f4f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  806f52:	89 c7                	mov    %eax,%edi
  806f54:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  806f5b:	00 00 00 
  806f5e:	ff d0                	callq  *%rax
    if (i == 0)  {
  806f60:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  806f64:	0f 85 92 00 00 00    	jne    806ffc <lwip_select+0x432>
      /* Timeout */
      if (readset)
  806f6a:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806f6f:	74 1d                	je     806f8e <lwip_select+0x3c4>
        FD_ZERO(readset);
  806f71:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806f75:	ba 04 00 00 00       	mov    $0x4,%edx
  806f7a:	be 00 00 00 00       	mov    $0x0,%esi
  806f7f:	48 89 c7             	mov    %rax,%rdi
  806f82:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806f89:	00 00 00 
  806f8c:	ff d0                	callq  *%rax
      if (writeset)
  806f8e:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806f95:	00 
  806f96:	74 20                	je     806fb8 <lwip_select+0x3ee>
        FD_ZERO(writeset);
  806f98:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806f9f:	ba 04 00 00 00       	mov    $0x4,%edx
  806fa4:	be 00 00 00 00       	mov    $0x0,%esi
  806fa9:	48 89 c7             	mov    %rax,%rdi
  806fac:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806fb3:	00 00 00 
  806fb6:	ff d0                	callq  *%rax
      if (exceptset)
  806fb8:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806fbf:	00 
  806fc0:	74 20                	je     806fe2 <lwip_select+0x418>
        FD_ZERO(exceptset);
  806fc2:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806fc9:	ba 04 00 00 00       	mov    $0x4,%edx
  806fce:	be 00 00 00 00       	mov    $0x0,%esi
  806fd3:	48 89 c7             	mov    %rax,%rdi
  806fd6:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  806fdd:	00 00 00 
  806fe0:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  806fe2:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  806fe9:	00 00 00 
  806fec:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  806ff2:	b8 00 00 00 00       	mov    $0x0,%eax
  806ff7:	e9 24 01 00 00       	jmpq   807120 <lwip_select+0x556>
    }
    
    if (readset)
  806ffc:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  807001:	74 0b                	je     80700e <lwip_select+0x444>
      lreadset = *readset;
  807003:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807007:	8b 00                	mov    (%rax),%eax
  807009:	89 45 e0             	mov    %eax,-0x20(%rbp)
  80700c:	eb 1d                	jmp    80702b <lwip_select+0x461>
    else
      FD_ZERO(&lreadset);
  80700e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807012:	ba 04 00 00 00       	mov    $0x4,%edx
  807017:	be 00 00 00 00       	mov    $0x0,%esi
  80701c:	48 89 c7             	mov    %rax,%rdi
  80701f:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  807026:	00 00 00 
  807029:	ff d0                	callq  *%rax
    if (writeset)
  80702b:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807032:	00 
  807033:	74 0e                	je     807043 <lwip_select+0x479>
      lwriteset = *writeset;
  807035:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80703c:	8b 00                	mov    (%rax),%eax
  80703e:	89 45 d0             	mov    %eax,-0x30(%rbp)
  807041:	eb 1d                	jmp    807060 <lwip_select+0x496>
    else
      FD_ZERO(&lwriteset);
  807043:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807047:	ba 04 00 00 00       	mov    $0x4,%edx
  80704c:	be 00 00 00 00       	mov    $0x0,%esi
  807051:	48 89 c7             	mov    %rax,%rdi
  807054:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  80705b:	00 00 00 
  80705e:	ff d0                	callq  *%rax
    if (exceptset)
  807060:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807067:	00 
  807068:	74 0e                	je     807078 <lwip_select+0x4ae>
      lexceptset = *exceptset;
  80706a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807071:	8b 00                	mov    (%rax),%eax
  807073:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807076:	eb 1d                	jmp    807095 <lwip_select+0x4cb>
    else
      FD_ZERO(&lexceptset);
  807078:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80707c:	ba 04 00 00 00       	mov    $0x4,%edx
  807081:	be 00 00 00 00       	mov    $0x0,%esi
  807086:	48 89 c7             	mov    %rax,%rdi
  807089:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  807090:	00 00 00 
  807093:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807095:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  807099:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80709d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8070a1:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8070a4:	89 c7                	mov    %eax,%edi
  8070a6:	48 b8 d2 69 80 00 00 	movabs $0x8069d2,%rax
  8070ad:	00 00 00 
  8070b0:	ff d0                	callq  *%rax
  8070b2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8070b5:	eb 1a                	jmp    8070d1 <lwip_select+0x507>
  } else
    sys_sem_signal(selectsem);
  8070b7:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8070be:	00 00 00 
  8070c1:	8b 00                	mov    (%rax),%eax
  8070c3:	89 c7                	mov    %eax,%edi
  8070c5:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8070cc:	00 00 00 
  8070cf:	ff d0                	callq  *%rax
  
  if (readset)
  8070d1:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8070d6:	74 09                	je     8070e1 <lwip_select+0x517>
    *readset = lreadset;
  8070d8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8070dc:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8070df:	89 10                	mov    %edx,(%rax)
  if (writeset)
  8070e1:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8070e8:	00 
  8070e9:	74 0c                	je     8070f7 <lwip_select+0x52d>
    *writeset = lwriteset;
  8070eb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8070f2:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8070f5:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  8070f7:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8070fe:	00 
  8070ff:	74 0c                	je     80710d <lwip_select+0x543>
    *exceptset = lexceptset;
  807101:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807108:	8b 55 c0             	mov    -0x40(%rbp),%edx
  80710b:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  80710d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807114:	00 00 00 
  807117:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  80711d:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  807120:	c9                   	leaveq 
  807121:	c3                   	retq   

0000000000807122 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  807122:	55                   	push   %rbp
  807123:	48 89 e5             	mov    %rsp,%rbp
  807126:	53                   	push   %rbx
  807127:	48 83 ec 38          	sub    $0x38,%rsp
  80712b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80712f:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  807132:	89 d0                	mov    %edx,%eax
  807134:	66 89 45 c0          	mov    %ax,-0x40(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  807138:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80713d:	0f 84 b8 02 00 00    	je     8073fb <event_callback+0x2d9>
    s = conn->socket;
  807143:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807147:	8b 40 20             	mov    0x20(%rax),%eax
  80714a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    if (s < 0) {
  80714d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  807151:	79 75                	jns    8071c8 <event_callback+0xa6>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  807153:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  80715a:	00 00 00 
  80715d:	8b 00                	mov    (%rax),%eax
  80715f:	89 c7                	mov    %eax,%edi
  807161:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  807168:	00 00 00 
  80716b:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  80716d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807171:	8b 40 20             	mov    0x20(%rax),%eax
  807174:	85 c0                	test   %eax,%eax
  807176:	79 36                	jns    8071ae <event_callback+0x8c>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807178:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80717c:	75 11                	jne    80718f <event_callback+0x6d>
          conn->socket--;
  80717e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807182:	8b 40 20             	mov    0x20(%rax),%eax
  807185:	8d 50 ff             	lea    -0x1(%rax),%edx
  807188:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80718c:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80718f:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  807196:	00 00 00 
  807199:	8b 00                	mov    (%rax),%eax
  80719b:	89 c7                	mov    %eax,%edi
  80719d:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8071a4:	00 00 00 
  8071a7:	ff d0                	callq  *%rax
        return;
  8071a9:	e9 51 02 00 00       	jmpq   8073ff <event_callback+0x2dd>
      }
      sys_sem_signal(socksem);
  8071ae:	48 b8 a8 94 82 00 00 	movabs $0x8294a8,%rax
  8071b5:	00 00 00 
  8071b8:	8b 00                	mov    (%rax),%eax
  8071ba:	89 c7                	mov    %eax,%edi
  8071bc:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8071c3:	00 00 00 
  8071c6:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  8071c8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8071cb:	89 c7                	mov    %eax,%edi
  8071cd:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  8071d4:	00 00 00 
  8071d7:	ff d0                	callq  *%rax
  8071d9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (!sock) {
  8071dd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8071e2:	0f 84 16 02 00 00    	je     8073fe <event_callback+0x2dc>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  8071e8:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8071ef:	00 00 00 
  8071f2:	8b 00                	mov    (%rax),%eax
  8071f4:	89 c7                	mov    %eax,%edi
  8071f6:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  8071fd:	00 00 00 
  807200:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  807202:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  807205:	83 f8 01             	cmp    $0x1,%eax
  807208:	74 26                	je     807230 <event_callback+0x10e>
  80720a:	83 f8 01             	cmp    $0x1,%eax
  80720d:	72 0c                	jb     80721b <event_callback+0xf9>
  80720f:	83 f8 02             	cmp    $0x2,%eax
  807212:	74 31                	je     807245 <event_callback+0x123>
  807214:	83 f8 03             	cmp    $0x3,%eax
  807217:	74 38                	je     807251 <event_callback+0x12f>
  807219:	eb 42                	jmp    80725d <event_callback+0x13b>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  80721b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80721f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807223:	8d 50 01             	lea    0x1(%rax),%edx
  807226:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80722a:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  80722e:	eb 57                	jmp    807287 <event_callback+0x165>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  807230:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807234:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807238:	8d 50 ff             	lea    -0x1(%rax),%edx
  80723b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80723f:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807243:	eb 42                	jmp    807287 <event_callback+0x165>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  807245:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807249:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  80724f:	eb 36                	jmp    807287 <event_callback+0x165>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  807251:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807255:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  80725b:	eb 2a                	jmp    807287 <event_callback+0x165>
    default:
      LWIP_ASSERT("unknown event", 0);
  80725d:	48 ba f9 10 82 00 00 	movabs $0x8210f9,%rdx
  807264:	00 00 00 
  807267:	be 17 04 00 00       	mov    $0x417,%esi
  80726c:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  807273:	00 00 00 
  807276:	b8 00 00 00 00       	mov    $0x0,%eax
  80727b:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  807282:	00 00 00 
  807285:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  807287:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  80728e:	00 00 00 
  807291:	8b 00                	mov    (%rax),%eax
  807293:	89 c7                	mov    %eax,%edi
  807295:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80729c:	00 00 00 
  80729f:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  8072a1:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8072a8:	00 00 00 
  8072ab:	8b 00                	mov    (%rax),%eax
  8072ad:	89 c7                	mov    %eax,%edi
  8072af:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  8072b6:	00 00 00 
  8072b9:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  8072bb:	48 b8 a0 94 82 00 00 	movabs $0x8294a0,%rax
  8072c2:	00 00 00 
  8072c5:	48 8b 00             	mov    (%rax),%rax
  8072c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8072cc:	e9 b6 00 00 00       	jmpq   807387 <event_callback+0x265>
      if (scb->sem_signalled == 0) {
  8072d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8072d5:	8b 40 20             	mov    0x20(%rax),%eax
  8072d8:	85 c0                	test   %eax,%eax
  8072da:	0f 85 9c 00 00 00    	jne    80737c <event_callback+0x25a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8072e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8072e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8072e8:	48 85 c0             	test   %rax,%rax
  8072eb:	74 41                	je     80732e <event_callback+0x20c>
  8072ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8072f1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8072f5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8072f8:	8d 48 07             	lea    0x7(%rax),%ecx
  8072fb:	85 c0                	test   %eax,%eax
  8072fd:	0f 48 c1             	cmovs  %ecx,%eax
  807300:	c1 f8 03             	sar    $0x3,%eax
  807303:	48 98                	cltq   
  807305:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807309:	0f b6 d0             	movzbl %al,%edx
  80730c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80730f:	83 e0 07             	and    $0x7,%eax
  807312:	89 d3                	mov    %edx,%ebx
  807314:	89 c1                	mov    %eax,%ecx
  807316:	d3 fb                	sar    %cl,%ebx
  807318:	89 d8                	mov    %ebx,%eax
  80731a:	83 e0 01             	and    $0x1,%eax
  80731d:	84 c0                	test   %al,%al
  80731f:	74 0d                	je     80732e <event_callback+0x20c>
          if (sock->rcvevent)
  807321:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807325:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807329:	66 85 c0             	test   %ax,%ax
  80732c:	75 66                	jne    807394 <event_callback+0x272>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  80732e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807332:	48 8b 40 10          	mov    0x10(%rax),%rax
  807336:	48 85 c0             	test   %rax,%rax
  807339:	74 41                	je     80737c <event_callback+0x25a>
  80733b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80733f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  807343:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807346:	8d 48 07             	lea    0x7(%rax),%ecx
  807349:	85 c0                	test   %eax,%eax
  80734b:	0f 48 c1             	cmovs  %ecx,%eax
  80734e:	c1 f8 03             	sar    $0x3,%eax
  807351:	48 98                	cltq   
  807353:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807357:	0f b6 d0             	movzbl %al,%edx
  80735a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80735d:	83 e0 07             	and    $0x7,%eax
  807360:	89 d3                	mov    %edx,%ebx
  807362:	89 c1                	mov    %eax,%ecx
  807364:	d3 fb                	sar    %cl,%ebx
  807366:	89 d8                	mov    %ebx,%eax
  807368:	83 e0 01             	and    $0x1,%eax
  80736b:	84 c0                	test   %al,%al
  80736d:	74 0d                	je     80737c <event_callback+0x25a>
          if (sock->sendevent)
  80736f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807373:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807377:	66 85 c0             	test   %ax,%ax
  80737a:	75 1b                	jne    807397 <event_callback+0x275>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  80737c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807380:	48 8b 00             	mov    (%rax),%rax
  807383:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  807387:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80738c:	0f 85 3f ff ff ff    	jne    8072d1 <event_callback+0x1af>
  807392:	eb 04                	jmp    807398 <event_callback+0x276>
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
          if (sock->rcvevent)
            break;
  807394:	90                   	nop
  807395:	eb 01                	jmp    807398 <event_callback+0x276>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
  807397:	90                   	nop
      }
    }
    if (scb) {
  807398:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80739d:	74 3f                	je     8073de <event_callback+0x2bc>
      scb->sem_signalled = 1;
  80739f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8073a3:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  8073aa:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8073b1:	00 00 00 
  8073b4:	8b 00                	mov    (%rax),%eax
  8073b6:	89 c7                	mov    %eax,%edi
  8073b8:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8073bf:	00 00 00 
  8073c2:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  8073c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8073c8:	8b 40 24             	mov    0x24(%rax),%eax
  8073cb:	89 c7                	mov    %eax,%edi
  8073cd:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8073d4:	00 00 00 
  8073d7:	ff d0                	callq  *%rax
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  8073d9:	e9 c3 fe ff ff       	jmpq   8072a1 <event_callback+0x17f>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  8073de:	48 b8 ac 94 82 00 00 	movabs $0x8294ac,%rax
  8073e5:	00 00 00 
  8073e8:	8b 00                	mov    (%rax),%eax
  8073ea:	89 c7                	mov    %eax,%edi
  8073ec:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8073f3:	00 00 00 
  8073f6:	ff d0                	callq  *%rax
      break;
  8073f8:	90                   	nop
  8073f9:	eb 04                	jmp    8073ff <event_callback+0x2dd>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
  8073fb:	90                   	nop
  8073fc:	eb 01                	jmp    8073ff <event_callback+0x2dd>
      sys_sem_signal(socksem);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
  8073fe:	90                   	nop
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
}
  8073ff:	48 83 c4 38          	add    $0x38,%rsp
  807403:	5b                   	pop    %rbx
  807404:	5d                   	pop    %rbp
  807405:	c3                   	retq   

0000000000807406 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  807406:	55                   	push   %rbp
  807407:	48 89 e5             	mov    %rsp,%rbp
  80740a:	48 83 ec 10          	sub    $0x10,%rsp
  80740e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  807411:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  807414:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807417:	89 c7                	mov    %eax,%edi
  807419:	48 b8 b8 5d 80 00 00 	movabs $0x805db8,%rax
  807420:	00 00 00 
  807423:	ff d0                	callq  *%rax
}
  807425:	c9                   	leaveq 
  807426:	c3                   	retq   

0000000000807427 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  807427:	55                   	push   %rbp
  807428:	48 89 e5             	mov    %rsp,%rbp
  80742b:	48 83 ec 50          	sub    $0x50,%rsp
  80742f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  807432:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  807436:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80743a:	89 c8                	mov    %ecx,%eax
  80743c:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  80743f:	8b 45 cc             	mov    -0x34(%rbp),%eax
  807442:	89 c7                	mov    %eax,%edi
  807444:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  80744b:	00 00 00 
  80744e:	ff d0                	callq  *%rax
  807450:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  807454:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807459:	75 0a                	jne    807465 <lwip_getaddrname+0x3e>
    return -1;
  80745b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807460:	e9 c9 00 00 00       	jmpq   80752e <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  807465:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807469:	ba 10 00 00 00       	mov    $0x10,%edx
  80746e:	be 00 00 00 00       	mov    $0x0,%esi
  807473:	48 89 c7             	mov    %rax,%rdi
  807476:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  80747d:	00 00 00 
  807480:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807482:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807486:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80748a:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  80748e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807492:	48 8b 00             	mov    (%rax),%rax
  807495:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807499:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  80749d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8074a1:	89 d1                	mov    %edx,%ecx
  8074a3:	48 89 fa             	mov    %rdi,%rdx
  8074a6:	48 89 c7             	mov    %rax,%rdi
  8074a9:	48 b8 a5 96 81 00 00 	movabs $0x8196a5,%rax
  8074b0:	00 00 00 
  8074b3:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8074b5:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  8074b9:	0f b7 c0             	movzwl %ax,%eax
  8074bc:	89 c7                	mov    %eax,%edi
  8074be:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8074c5:	00 00 00 
  8074c8:	ff d0                	callq  *%rax
  8074ca:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  8074ce:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8074d1:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  8074d4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8074d8:	8b 00                	mov    (%rax),%eax
  8074da:	83 f8 10             	cmp    $0x10,%eax
  8074dd:	76 0a                	jbe    8074e9 <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  8074df:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8074e3:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  8074e9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8074ed:	8b 00                	mov    (%rax),%eax
  8074ef:	89 c2                	mov    %eax,%edx
  8074f1:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8074f5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8074f9:	48 89 ce             	mov    %rcx,%rsi
  8074fc:	48 89 c7             	mov    %rax,%rdi
  8074ff:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  807506:	00 00 00 
  807509:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  80750b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80750f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  807516:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80751a:	8b 50 18             	mov    0x18(%rax),%edx
  80751d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807524:	00 00 00 
  807527:	89 10                	mov    %edx,(%rax)
  return 0;
  807529:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80752e:	c9                   	leaveq 
  80752f:	c3                   	retq   

0000000000807530 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  807530:	55                   	push   %rbp
  807531:	48 89 e5             	mov    %rsp,%rbp
  807534:	48 83 ec 20          	sub    $0x20,%rsp
  807538:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80753b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80753f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807543:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807547:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80754b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80754e:	b9 00 00 00 00       	mov    $0x0,%ecx
  807553:	89 c7                	mov    %eax,%edi
  807555:	48 b8 27 74 80 00 00 	movabs $0x807427,%rax
  80755c:	00 00 00 
  80755f:	ff d0                	callq  *%rax
}
  807561:	c9                   	leaveq 
  807562:	c3                   	retq   

0000000000807563 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807563:	55                   	push   %rbp
  807564:	48 89 e5             	mov    %rsp,%rbp
  807567:	48 83 ec 20          	sub    $0x20,%rsp
  80756b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80756e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807572:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807576:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80757a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80757e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807581:	b9 01 00 00 00       	mov    $0x1,%ecx
  807586:	89 c7                	mov    %eax,%edi
  807588:	48 b8 27 74 80 00 00 	movabs $0x807427,%rax
  80758f:	00 00 00 
  807592:	ff d0                	callq  *%rax
}
  807594:	c9                   	leaveq 
  807595:	c3                   	retq   

0000000000807596 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807596:	55                   	push   %rbp
  807597:	48 89 e5             	mov    %rsp,%rbp
  80759a:	48 83 ec 60          	sub    $0x60,%rsp
  80759e:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8075a1:	89 75 b8             	mov    %esi,-0x48(%rbp)
  8075a4:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  8075a7:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  8075ab:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  8075af:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  8075b3:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8075b6:	89 c7                	mov    %eax,%edi
  8075b8:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  8075bf:	00 00 00 
  8075c2:	ff d0                	callq  *%rax
  8075c4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8075c8:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8075cd:	75 0a                	jne    8075d9 <lwip_getsockopt+0x43>
    return -1;
  8075cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8075d4:	e9 14 02 00 00       	jmpq   8077ed <lwip_getsockopt+0x257>

  if ((NULL == optval) || (NULL == optlen)) {
  8075d9:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8075de:	74 07                	je     8075e7 <lwip_getsockopt+0x51>
  8075e0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8075e5:	75 28                	jne    80760f <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  8075e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8075eb:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  8075f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8075f6:	8b 50 18             	mov    0x18(%rax),%edx
  8075f9:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807600:	00 00 00 
  807603:	89 10                	mov    %edx,(%rax)
    return -1;
  807605:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80760a:	e9 de 01 00 00       	jmpq   8077ed <lwip_getsockopt+0x257>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80760f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807612:	83 f8 06             	cmp    $0x6,%eax
  807615:	0f 84 c2 00 00 00    	je     8076dd <lwip_getsockopt+0x147>
  80761b:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807620:	74 0d                	je     80762f <lwip_getsockopt+0x99>
  807622:	85 c0                	test   %eax,%eax
  807624:	0f 84 8e 00 00 00    	je     8076b8 <lwip_getsockopt+0x122>
  80762a:	e9 eb 00 00 00       	jmpq   80771a <lwip_getsockopt+0x184>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80762f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807632:	83 f8 20             	cmp    $0x20,%eax
  807635:	74 28                	je     80765f <lwip_getsockopt+0xc9>
  807637:	83 f8 20             	cmp    $0x20,%eax
  80763a:	7f 0c                	jg     807648 <lwip_getsockopt+0xb2>
  80763c:	83 f8 02             	cmp    $0x2,%eax
  80763f:	74 1e                	je     80765f <lwip_getsockopt+0xc9>
  807641:	83 f8 08             	cmp    $0x8,%eax
  807644:	74 19                	je     80765f <lwip_getsockopt+0xc9>
  807646:	eb 64                	jmp    8076ac <lwip_getsockopt+0x116>
  807648:	3d 07 10 00 00       	cmp    $0x1007,%eax
  80764d:	7c 5d                	jl     8076ac <lwip_getsockopt+0x116>
  80764f:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807654:	7e 09                	jle    80765f <lwip_getsockopt+0xc9>
  807656:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80765b:	74 13                	je     807670 <lwip_getsockopt+0xda>
  80765d:	eb 4d                	jmp    8076ac <lwip_getsockopt+0x116>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  80765f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807663:	8b 00                	mov    (%rax),%eax
  807665:	83 f8 03             	cmp    $0x3,%eax
  807668:	77 48                	ja     8076b2 <lwip_getsockopt+0x11c>
        err = EINVAL;
  80766a:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  80766e:	eb 42                	jmp    8076b2 <lwip_getsockopt+0x11c>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807670:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807674:	8b 00                	mov    (%rax),%eax
  807676:	83 f8 03             	cmp    $0x3,%eax
  807679:	77 04                	ja     80767f <lwip_getsockopt+0xe9>
        err = EINVAL;
  80767b:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80767f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807683:	48 8b 00             	mov    (%rax),%rax
  807686:	8b 00                	mov    (%rax),%eax
  807688:	83 f8 20             	cmp    $0x20,%eax
  80768b:	75 19                	jne    8076a6 <lwip_getsockopt+0x110>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  80768d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807691:	48 8b 00             	mov    (%rax),%rax
  807694:	48 8b 40 08          	mov    0x8(%rax),%rax
  807698:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80769c:	0f b6 c0             	movzbl %al,%eax
  80769f:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8076a2:	85 c0                	test   %eax,%eax
  8076a4:	74 0f                	je     8076b5 <lwip_getsockopt+0x11f>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  8076a6:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  8076aa:	eb 09                	jmp    8076b5 <lwip_getsockopt+0x11f>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8076ac:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8076b0:	eb 6c                	jmp    80771e <lwip_getsockopt+0x188>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  8076b2:	90                   	nop
  8076b3:	eb 01                	jmp    8076b6 <lwip_getsockopt+0x120>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  8076b5:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8076b6:	eb 66                	jmp    80771e <lwip_getsockopt+0x188>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8076b8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8076bb:	83 e8 01             	sub    $0x1,%eax
  8076be:	83 f8 01             	cmp    $0x1,%eax
  8076c1:	77 11                	ja     8076d4 <lwip_getsockopt+0x13e>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8076c3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8076c7:	8b 00                	mov    (%rax),%eax
  8076c9:	83 f8 03             	cmp    $0x3,%eax
  8076cc:	77 0c                	ja     8076da <lwip_getsockopt+0x144>
        err = EINVAL;
  8076ce:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  8076d2:	eb 06                	jmp    8076da <lwip_getsockopt+0x144>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8076d4:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8076d8:	eb 44                	jmp    80771e <lwip_getsockopt+0x188>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  8076da:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8076db:	eb 41                	jmp    80771e <lwip_getsockopt+0x188>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8076dd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8076e1:	8b 00                	mov    (%rax),%eax
  8076e3:	83 f8 03             	cmp    $0x3,%eax
  8076e6:	77 06                	ja     8076ee <lwip_getsockopt+0x158>
      err = EINVAL;
  8076e8:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  8076ec:	eb 30                	jmp    80771e <lwip_getsockopt+0x188>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8076ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8076f2:	48 8b 00             	mov    (%rax),%rax
  8076f5:	8b 00                	mov    (%rax),%eax
  8076f7:	83 f8 10             	cmp    $0x10,%eax
  8076fa:	74 0a                	je     807706 <lwip_getsockopt+0x170>
      return 0;
  8076fc:	b8 00 00 00 00       	mov    $0x0,%eax
  807701:	e9 e7 00 00 00       	jmpq   8077ed <lwip_getsockopt+0x257>

    switch (optname) {
  807706:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807709:	83 e8 01             	sub    $0x1,%eax
  80770c:	83 f8 01             	cmp    $0x1,%eax
  80770f:	77 03                	ja     807714 <lwip_getsockopt+0x17e>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807711:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807712:	eb 0a                	jmp    80771e <lwip_getsockopt+0x188>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  807714:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807718:	eb 04                	jmp    80771e <lwip_getsockopt+0x188>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  80771a:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  80771e:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807722:	74 28                	je     80774c <lwip_getsockopt+0x1b6>
    sock_set_errno(sock, err);
  807724:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807728:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80772c:	89 50 18             	mov    %edx,0x18(%rax)
  80772f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807733:	8b 50 18             	mov    0x18(%rax),%edx
  807736:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  80773d:	00 00 00 
  807740:	89 10                	mov    %edx,(%rax)
    return -1;
  807742:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807747:	e9 a1 00 00 00       	jmpq   8077ed <lwip_getsockopt+0x257>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  80774c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807750:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807754:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807757:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  80775a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80775d:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807760:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807764:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807768:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80776c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807770:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807774:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807777:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80777b:	ba 01 00 00 00       	mov    $0x1,%edx
  807780:	48 89 c6             	mov    %rax,%rsi
  807783:	48 bf ef 77 80 00 00 	movabs $0x8077ef,%rdi
  80778a:	00 00 00 
  80778d:	48 b8 48 85 80 00 00 	movabs $0x808548,%rax
  807794:	00 00 00 
  807797:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807799:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80779d:	48 8b 00             	mov    (%rax),%rax
  8077a0:	8b 40 14             	mov    0x14(%rax),%eax
  8077a3:	be 00 00 00 00       	mov    $0x0,%esi
  8077a8:	89 c7                	mov    %eax,%edi
  8077aa:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  8077b1:	00 00 00 
  8077b4:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  8077b6:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8077ba:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  8077bd:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  8077c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8077c5:	89 50 18             	mov    %edx,0x18(%rax)
  8077c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8077cc:	8b 50 18             	mov    0x18(%rax),%edx
  8077cf:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8077d6:	00 00 00 
  8077d9:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  8077db:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8077df:	74 07                	je     8077e8 <lwip_getsockopt+0x252>
  8077e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8077e6:	eb 05                	jmp    8077ed <lwip_getsockopt+0x257>
  8077e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8077ed:	c9                   	leaveq 
  8077ee:	c3                   	retq   

00000000008077ef <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  8077ef:	55                   	push   %rbp
  8077f0:	48 89 e5             	mov    %rsp,%rbp
  8077f3:	48 83 ec 40          	sub    $0x40,%rsp
  8077f7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8077fb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807800:	75 2a                	jne    80782c <lwip_getsockopt_internal+0x3d>
  807802:	48 ba 07 11 82 00 00 	movabs $0x821107,%rdx
  807809:	00 00 00 
  80780c:	be 38 05 00 00       	mov    $0x538,%esi
  807811:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  807818:	00 00 00 
  80781b:	b8 00 00 00 00       	mov    $0x0,%eax
  807820:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  807827:	00 00 00 
  80782a:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  80782c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807830:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807834:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807838:	48 8b 00             	mov    (%rax),%rax
  80783b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  80783f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807843:	8b 40 08             	mov    0x8(%rax),%eax
  807846:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807849:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80784d:	8b 40 0c             	mov    0xc(%rax),%eax
  807850:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807853:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807857:	8b 40 10             	mov    0x10(%rax),%eax
  80785a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  80785d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807861:	48 8b 40 18          	mov    0x18(%rax),%rax
  807865:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807869:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80786c:	83 f8 06             	cmp    $0x6,%eax
  80786f:	0f 84 b4 01 00 00    	je     807a29 <lwip_getsockopt_internal+0x23a>
  807875:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  80787a:	74 0d                	je     807889 <lwip_getsockopt_internal+0x9a>
  80787c:	85 c0                	test   %eax,%eax
  80787e:	0f 84 63 01 00 00    	je     8079e7 <lwip_getsockopt_internal+0x1f8>
  807884:	e9 e9 01 00 00       	jmpq   807a72 <lwip_getsockopt_internal+0x283>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807889:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80788c:	83 f8 20             	cmp    $0x20,%eax
  80788f:	74 36                	je     8078c7 <lwip_getsockopt_internal+0xd8>
  807891:	83 f8 20             	cmp    $0x20,%eax
  807894:	7f 0f                	jg     8078a5 <lwip_getsockopt_internal+0xb6>
  807896:	83 f8 02             	cmp    $0x2,%eax
  807899:	74 2c                	je     8078c7 <lwip_getsockopt_internal+0xd8>
  80789b:	83 f8 08             	cmp    $0x8,%eax
  80789e:	74 27                	je     8078c7 <lwip_getsockopt_internal+0xd8>
  8078a0:	e9 3d 01 00 00       	jmpq   8079e2 <lwip_getsockopt_internal+0x1f3>
  8078a5:	3d 08 10 00 00       	cmp    $0x1008,%eax
  8078aa:	74 3d                	je     8078e9 <lwip_getsockopt_internal+0xfa>
  8078ac:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  8078b1:	0f 84 0d 01 00 00    	je     8079c4 <lwip_getsockopt_internal+0x1d5>
  8078b7:	3d 07 10 00 00       	cmp    $0x1007,%eax
  8078bc:	0f 84 85 00 00 00    	je     807947 <lwip_getsockopt_internal+0x158>
  8078c2:	e9 1b 01 00 00       	jmpq   8079e2 <lwip_getsockopt_internal+0x1f3>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  8078c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078cb:	48 8b 00             	mov    (%rax),%rax
  8078ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  8078d2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8078d6:	0f b7 c0             	movzwl %ax,%eax
  8078d9:	89 c2                	mov    %eax,%edx
  8078db:	23 55 e4             	and    -0x1c(%rbp),%edx
  8078de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8078e2:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  8078e4:	e9 f9 00 00 00       	jmpq   8079e2 <lwip_getsockopt_internal+0x1f3>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  8078e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078ed:	48 8b 00             	mov    (%rax),%rax
  8078f0:	8b 00                	mov    (%rax),%eax
  8078f2:	25 f0 00 00 00       	and    $0xf0,%eax
  8078f7:	83 f8 20             	cmp    $0x20,%eax
  8078fa:	74 24                	je     807920 <lwip_getsockopt_internal+0x131>
  8078fc:	83 f8 40             	cmp    $0x40,%eax
  8078ff:	74 07                	je     807908 <lwip_getsockopt_internal+0x119>
  807901:	83 f8 10             	cmp    $0x10,%eax
  807904:	74 0e                	je     807914 <lwip_getsockopt_internal+0x125>
  807906:	eb 24                	jmp    80792c <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807908:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80790c:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807912:	eb 2e                	jmp    807942 <lwip_getsockopt_internal+0x153>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807914:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807918:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  80791e:	eb 22                	jmp    807942 <lwip_getsockopt_internal+0x153>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807920:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807924:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  80792a:	eb 16                	jmp    807942 <lwip_getsockopt_internal+0x153>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  80792c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807930:	48 8b 00             	mov    (%rax),%rax
  807933:	8b 00                	mov    (%rax),%eax
  807935:	89 c2                	mov    %eax,%edx
  807937:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80793b:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  80793d:	e9 a0 00 00 00       	jmpq   8079e2 <lwip_getsockopt_internal+0x1f3>
  807942:	e9 9b 00 00 00       	jmpq   8079e2 <lwip_getsockopt_internal+0x1f3>

    case SO_ERROR:
      if (sock->err == 0) {
  807947:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80794b:	8b 40 18             	mov    0x18(%rax),%eax
  80794e:	85 c0                	test   %eax,%eax
  807950:	75 58                	jne    8079aa <lwip_getsockopt_internal+0x1bb>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807952:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807956:	48 8b 00             	mov    (%rax),%rax
  807959:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  80795d:	0f be c0             	movsbl %al,%eax
  807960:	f7 d8                	neg    %eax
  807962:	83 f8 0e             	cmp    $0xe,%eax
  807965:	77 24                	ja     80798b <lwip_getsockopt_internal+0x19c>
  807967:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80796b:	48 8b 00             	mov    (%rax),%rax
  80796e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807972:	0f be c0             	movsbl %al,%eax
  807975:	89 c2                	mov    %eax,%edx
  807977:	f7 da                	neg    %edx
  807979:	48 b8 00 10 82 00 00 	movabs $0x821000,%rax
  807980:	00 00 00 
  807983:	48 63 d2             	movslq %edx,%rdx
  807986:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807989:	eb 05                	jmp    807990 <lwip_getsockopt_internal+0x1a1>
  80798b:	b8 05 00 00 00       	mov    $0x5,%eax
  807990:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807994:	89 42 18             	mov    %eax,0x18(%rdx)
  807997:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80799b:	8b 50 18             	mov    0x18(%rax),%edx
  80799e:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8079a5:	00 00 00 
  8079a8:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  8079aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079ae:	8b 50 18             	mov    0x18(%rax),%edx
  8079b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8079b5:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  8079b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079bb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  8079c2:	eb 1e                	jmp    8079e2 <lwip_getsockopt_internal+0x1f3>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  8079c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079c8:	48 8b 00             	mov    (%rax),%rax
  8079cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8079cf:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8079d3:	0f b6 c0             	movzbl %al,%eax
  8079d6:	89 c2                	mov    %eax,%edx
  8079d8:	83 e2 01             	and    $0x1,%edx
  8079db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8079df:	89 10                	mov    %edx,(%rax)
      break;
  8079e1:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  8079e2:	e9 8b 00 00 00       	jmpq   807a72 <lwip_getsockopt_internal+0x283>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8079e7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8079ea:	83 f8 01             	cmp    $0x1,%eax
  8079ed:	74 1f                	je     807a0e <lwip_getsockopt_internal+0x21f>
  8079ef:	83 f8 02             	cmp    $0x2,%eax
  8079f2:	75 33                	jne    807a27 <lwip_getsockopt_internal+0x238>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  8079f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079f8:	48 8b 00             	mov    (%rax),%rax
  8079fb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8079ff:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  807a03:	0f b6 d0             	movzbl %al,%edx
  807a06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807a0a:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  807a0c:	eb 19                	jmp    807a27 <lwip_getsockopt_internal+0x238>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  807a0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a12:	48 8b 00             	mov    (%rax),%rax
  807a15:	48 8b 40 08          	mov    0x8(%rax),%rax
  807a19:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  807a1d:	0f b6 d0             	movzbl %al,%edx
  807a20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807a24:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  807a26:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807a27:	eb 49                	jmp    807a72 <lwip_getsockopt_internal+0x283>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807a29:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807a2c:	83 f8 01             	cmp    $0x1,%eax
  807a2f:	74 07                	je     807a38 <lwip_getsockopt_internal+0x249>
  807a31:	83 f8 02             	cmp    $0x2,%eax
  807a34:	74 21                	je     807a57 <lwip_getsockopt_internal+0x268>
  807a36:	eb 39                	jmp    807a71 <lwip_getsockopt_internal+0x282>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  807a38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a3c:	48 8b 00             	mov    (%rax),%rax
  807a3f:	48 8b 40 08          	mov    0x8(%rax),%rax
  807a43:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  807a47:	0f b6 c0             	movzbl %al,%eax
  807a4a:	89 c2                	mov    %eax,%edx
  807a4c:	83 e2 40             	and    $0x40,%edx
  807a4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807a53:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  807a55:	eb 1a                	jmp    807a71 <lwip_getsockopt_internal+0x282>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  807a57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a5b:	48 8b 00             	mov    (%rax),%rax
  807a5e:	48 8b 40 08          	mov    0x8(%rax),%rax
  807a62:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  807a68:	89 c2                	mov    %eax,%edx
  807a6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807a6e:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  807a70:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807a71:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  807a72:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807a76:	48 8b 00             	mov    (%rax),%rax
  807a79:	8b 40 14             	mov    0x14(%rax),%eax
  807a7c:	89 c7                	mov    %eax,%edi
  807a7e:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  807a85:	00 00 00 
  807a88:	ff d0                	callq  *%rax
}
  807a8a:	c9                   	leaveq 
  807a8b:	c3                   	retq   

0000000000807a8c <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  807a8c:	55                   	push   %rbp
  807a8d:	48 89 e5             	mov    %rsp,%rbp
  807a90:	48 83 ec 60          	sub    $0x60,%rsp
  807a94:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807a97:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807a9a:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807a9d:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807aa1:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807aa5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807aa8:	89 c7                	mov    %eax,%edi
  807aaa:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  807ab1:	00 00 00 
  807ab4:	ff d0                	callq  *%rax
  807ab6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  807aba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807ac1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807ac6:	75 0a                	jne    807ad2 <lwip_setsockopt+0x46>
    return -1;
  807ac8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807acd:	e9 fc 01 00 00       	jmpq   807cce <lwip_setsockopt+0x242>

  if (NULL == optval) {
  807ad2:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807ad7:	75 28                	jne    807b01 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  807ad9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807add:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807ae4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ae8:	8b 50 18             	mov    0x18(%rax),%edx
  807aeb:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807af2:	00 00 00 
  807af5:	89 10                	mov    %edx,(%rax)
    return -1;
  807af7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807afc:	e9 cd 01 00 00       	jmpq   807cce <lwip_setsockopt+0x242>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807b01:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807b04:	83 f8 06             	cmp    $0x6,%eax
  807b07:	0f 84 ab 00 00 00    	je     807bb8 <lwip_setsockopt+0x12c>
  807b0d:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807b12:	74 09                	je     807b1d <lwip_setsockopt+0x91>
  807b14:	85 c0                	test   %eax,%eax
  807b16:	74 78                	je     807b90 <lwip_setsockopt+0x104>
  807b18:	e9 db 00 00 00       	jmpq   807bf8 <lwip_setsockopt+0x16c>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807b1d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807b20:	83 f8 20             	cmp    $0x20,%eax
  807b23:	74 0c                	je     807b31 <lwip_setsockopt+0xa5>
  807b25:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807b2a:	74 16                	je     807b42 <lwip_setsockopt+0xb6>
  807b2c:	83 f8 08             	cmp    $0x8,%eax
  807b2f:	75 50                	jne    807b81 <lwip_setsockopt+0xf5>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  807b31:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807b34:	83 f8 03             	cmp    $0x3,%eax
  807b37:	77 51                	ja     807b8a <lwip_setsockopt+0xfe>
        err = EINVAL;
  807b39:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807b40:	eb 48                	jmp    807b8a <lwip_setsockopt+0xfe>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  807b42:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807b45:	83 f8 03             	cmp    $0x3,%eax
  807b48:	77 07                	ja     807b51 <lwip_setsockopt+0xc5>
        err = EINVAL;
  807b4a:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807b51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b55:	48 8b 00             	mov    (%rax),%rax
  807b58:	8b 00                	mov    (%rax),%eax
  807b5a:	83 f8 20             	cmp    $0x20,%eax
  807b5d:	75 19                	jne    807b78 <lwip_setsockopt+0xec>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807b5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b63:	48 8b 00             	mov    (%rax),%rax
  807b66:	48 8b 40 08          	mov    0x8(%rax),%rax
  807b6a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807b6e:	0f b6 c0             	movzbl %al,%eax
  807b71:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807b74:	85 c0                	test   %eax,%eax
  807b76:	74 15                	je     807b8d <lwip_setsockopt+0x101>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807b78:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807b7f:	eb 0c                	jmp    807b8d <lwip_setsockopt+0x101>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807b81:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807b88:	eb 75                	jmp    807bff <lwip_setsockopt+0x173>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807b8a:	90                   	nop
  807b8b:	eb 01                	jmp    807b8e <lwip_setsockopt+0x102>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  807b8d:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807b8e:	eb 6f                	jmp    807bff <lwip_setsockopt+0x173>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807b90:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807b93:	83 e8 01             	sub    $0x1,%eax
  807b96:	83 f8 01             	cmp    $0x1,%eax
  807b99:	77 11                	ja     807bac <lwip_setsockopt+0x120>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  807b9b:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807b9e:	83 f8 03             	cmp    $0x3,%eax
  807ba1:	77 12                	ja     807bb5 <lwip_setsockopt+0x129>
        err = EINVAL;
  807ba3:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807baa:	eb 09                	jmp    807bb5 <lwip_setsockopt+0x129>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  807bac:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807bb3:	eb 4a                	jmp    807bff <lwip_setsockopt+0x173>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807bb5:	90                   	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807bb6:	eb 47                	jmp    807bff <lwip_setsockopt+0x173>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  807bb8:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807bbb:	83 f8 03             	cmp    $0x3,%eax
  807bbe:	77 09                	ja     807bc9 <lwip_setsockopt+0x13d>
      err = EINVAL;
  807bc0:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  807bc7:	eb 36                	jmp    807bff <lwip_setsockopt+0x173>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807bc9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bcd:	48 8b 00             	mov    (%rax),%rax
  807bd0:	8b 00                	mov    (%rax),%eax
  807bd2:	83 f8 10             	cmp    $0x10,%eax
  807bd5:	74 0a                	je     807be1 <lwip_setsockopt+0x155>
      return 0;
  807bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  807bdc:	e9 ed 00 00 00       	jmpq   807cce <lwip_setsockopt+0x242>

    switch (optname) {
  807be1:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807be4:	83 e8 01             	sub    $0x1,%eax
  807be7:	83 f8 01             	cmp    $0x1,%eax
  807bea:	77 03                	ja     807bef <lwip_setsockopt+0x163>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807bec:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807bed:	eb 10                	jmp    807bff <lwip_setsockopt+0x173>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807bef:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807bf6:	eb 07                	jmp    807bff <lwip_setsockopt+0x173>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  807bf8:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  807bff:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807c03:	74 27                	je     807c2c <lwip_setsockopt+0x1a0>
    sock_set_errno(sock, err);
  807c05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c09:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807c0c:	89 50 18             	mov    %edx,0x18(%rax)
  807c0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c13:	8b 50 18             	mov    0x18(%rax),%edx
  807c16:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807c1d:	00 00 00 
  807c20:	89 10                	mov    %edx,(%rax)
    return -1;
  807c22:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807c27:	e9 a2 00 00 00       	jmpq   807cce <lwip_setsockopt+0x242>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  807c2c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c30:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807c34:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807c37:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807c3a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807c3d:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  807c40:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807c44:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  807c48:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  807c4c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807c50:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807c53:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  807c56:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807c5a:	ba 01 00 00 00       	mov    $0x1,%edx
  807c5f:	48 89 c6             	mov    %rax,%rsi
  807c62:	48 bf d0 7c 80 00 00 	movabs $0x807cd0,%rdi
  807c69:	00 00 00 
  807c6c:	48 b8 48 85 80 00 00 	movabs $0x808548,%rax
  807c73:	00 00 00 
  807c76:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807c78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c7c:	48 8b 00             	mov    (%rax),%rax
  807c7f:	8b 40 14             	mov    0x14(%rax),%eax
  807c82:	be 00 00 00 00       	mov    $0x0,%esi
  807c87:	89 c7                	mov    %eax,%edi
  807c89:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  807c90:	00 00 00 
  807c93:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  807c95:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807c99:	0f be c0             	movsbl %al,%eax
  807c9c:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  807c9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ca3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807ca6:	89 50 18             	mov    %edx,0x18(%rax)
  807ca9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cad:	8b 50 18             	mov    0x18(%rax),%edx
  807cb0:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807cb7:	00 00 00 
  807cba:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807cbc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807cc0:	74 07                	je     807cc9 <lwip_setsockopt+0x23d>
  807cc2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807cc7:	eb 05                	jmp    807cce <lwip_setsockopt+0x242>
  807cc9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807cce:	c9                   	leaveq 
  807ccf:	c3                   	retq   

0000000000807cd0 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  807cd0:	55                   	push   %rbp
  807cd1:	48 89 e5             	mov    %rsp,%rbp
  807cd4:	48 83 ec 40          	sub    $0x40,%rsp
  807cd8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807cdc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807ce1:	75 2a                	jne    807d0d <lwip_setsockopt_internal+0x3d>
  807ce3:	48 ba 07 11 82 00 00 	movabs $0x821107,%rdx
  807cea:	00 00 00 
  807ced:	be ae 06 00 00       	mov    $0x6ae,%esi
  807cf2:	48 bf 51 10 82 00 00 	movabs $0x821051,%rdi
  807cf9:	00 00 00 
  807cfc:	b8 00 00 00 00       	mov    $0x0,%eax
  807d01:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  807d08:	00 00 00 
  807d0b:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807d0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807d11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807d15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d19:	48 8b 00             	mov    (%rax),%rax
  807d1c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807d20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d24:	8b 40 08             	mov    0x8(%rax),%eax
  807d27:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807d2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d2e:	8b 40 0c             	mov    0xc(%rax),%eax
  807d31:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807d34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d38:	8b 40 10             	mov    0x10(%rax),%eax
  807d3b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807d3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807d42:	48 8b 40 18          	mov    0x18(%rax),%rax
  807d46:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807d4a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807d4d:	83 f8 06             	cmp    $0x6,%eax
  807d50:	0f 84 10 01 00 00    	je     807e66 <lwip_setsockopt_internal+0x196>
  807d56:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807d5b:	74 0d                	je     807d6a <lwip_setsockopt_internal+0x9a>
  807d5d:	85 c0                	test   %eax,%eax
  807d5f:	0f 84 c7 00 00 00    	je     807e2c <lwip_setsockopt_internal+0x15c>
  807d65:	e9 72 01 00 00       	jmpq   807edc <lwip_setsockopt_internal+0x20c>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807d6a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807d6d:	83 f8 20             	cmp    $0x20,%eax
  807d70:	74 10                	je     807d82 <lwip_setsockopt_internal+0xb2>
  807d72:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807d77:	74 61                	je     807dda <lwip_setsockopt_internal+0x10a>
  807d79:	83 f8 08             	cmp    $0x8,%eax
  807d7c:	0f 85 a5 00 00 00    	jne    807e27 <lwip_setsockopt_internal+0x157>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  807d82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807d86:	8b 00                	mov    (%rax),%eax
  807d88:	85 c0                	test   %eax,%eax
  807d8a:	74 27                	je     807db3 <lwip_setsockopt_internal+0xe3>
        sock->conn->pcb.ip->so_options |= optname;
  807d8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d90:	48 8b 00             	mov    (%rax),%rax
  807d93:	48 8b 40 08          	mov    0x8(%rax),%rax
  807d97:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807d9b:	48 8b 12             	mov    (%rdx),%rdx
  807d9e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807da2:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  807da6:	89 d1                	mov    %edx,%ecx
  807da8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  807dab:	09 ca                	or     %ecx,%edx
  807dad:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807db1:	eb 74                	jmp    807e27 <lwip_setsockopt_internal+0x157>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  807db3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807db7:	48 8b 00             	mov    (%rax),%rax
  807dba:	48 8b 40 08          	mov    0x8(%rax),%rax
  807dbe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807dc2:	48 8b 12             	mov    (%rdx),%rdx
  807dc5:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807dc9:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  807dcd:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  807dd0:	f7 d1                	not    %ecx
  807dd2:	21 ca                	and    %ecx,%edx
  807dd4:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807dd8:	eb 4d                	jmp    807e27 <lwip_setsockopt_internal+0x157>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  807dda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807dde:	8b 00                	mov    (%rax),%eax
  807de0:	85 c0                	test   %eax,%eax
  807de2:	74 22                	je     807e06 <lwip_setsockopt_internal+0x136>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  807de4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807de8:	48 8b 00             	mov    (%rax),%rax
  807deb:	48 8b 40 08          	mov    0x8(%rax),%rax
  807def:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807df3:	48 8b 12             	mov    (%rdx),%rdx
  807df6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807dfa:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  807dfe:	83 ca 01             	or     $0x1,%edx
  807e01:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  807e04:	eb 20                	jmp    807e26 <lwip_setsockopt_internal+0x156>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  807e06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e0a:	48 8b 00             	mov    (%rax),%rax
  807e0d:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e11:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807e15:	48 8b 12             	mov    (%rdx),%rdx
  807e18:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807e1c:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  807e20:	83 e2 fe             	and    $0xfffffffe,%edx
  807e23:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  807e26:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  807e27:	e9 b0 00 00 00       	jmpq   807edc <lwip_setsockopt_internal+0x20c>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807e2c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807e2f:	83 f8 01             	cmp    $0x1,%eax
  807e32:	74 1b                	je     807e4f <lwip_setsockopt_internal+0x17f>
  807e34:	83 f8 02             	cmp    $0x2,%eax
  807e37:	75 2b                	jne    807e64 <lwip_setsockopt_internal+0x194>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  807e39:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e3d:	48 8b 00             	mov    (%rax),%rax
  807e40:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e44:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  807e48:	8b 12                	mov    (%rdx),%edx
  807e4a:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  807e4d:	eb 15                	jmp    807e64 <lwip_setsockopt_internal+0x194>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  807e4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e53:	48 8b 00             	mov    (%rax),%rax
  807e56:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e5a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  807e5e:	8b 12                	mov    (%rdx),%edx
  807e60:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  807e63:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807e64:	eb 76                	jmp    807edc <lwip_setsockopt_internal+0x20c>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807e66:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807e69:	83 f8 01             	cmp    $0x1,%eax
  807e6c:	74 07                	je     807e75 <lwip_setsockopt_internal+0x1a5>
  807e6e:	83 f8 02             	cmp    $0x2,%eax
  807e71:	74 50                	je     807ec3 <lwip_setsockopt_internal+0x1f3>
  807e73:	eb 66                	jmp    807edb <lwip_setsockopt_internal+0x20b>
    case TCP_NODELAY:
      if (*(int*)optval) {
  807e75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807e79:	8b 00                	mov    (%rax),%eax
  807e7b:	85 c0                	test   %eax,%eax
  807e7d:	74 22                	je     807ea1 <lwip_setsockopt_internal+0x1d1>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  807e7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e83:	48 8b 00             	mov    (%rax),%rax
  807e86:	48 8b 40 08          	mov    0x8(%rax),%rax
  807e8a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807e8e:	48 8b 12             	mov    (%rdx),%rdx
  807e91:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807e95:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  807e99:	83 ca 40             	or     $0x40,%edx
  807e9c:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  807e9f:	eb 3a                	jmp    807edb <lwip_setsockopt_internal+0x20b>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  807ea1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ea5:	48 8b 00             	mov    (%rax),%rax
  807ea8:	48 8b 40 08          	mov    0x8(%rax),%rax
  807eac:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807eb0:	48 8b 12             	mov    (%rdx),%rdx
  807eb3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807eb7:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  807ebb:	83 e2 bf             	and    $0xffffffbf,%edx
  807ebe:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  807ec1:	eb 18                	jmp    807edb <lwip_setsockopt_internal+0x20b>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  807ec3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ec7:	48 8b 00             	mov    (%rax),%rax
  807eca:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ece:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  807ed2:	8b 12                	mov    (%rdx),%edx
  807ed4:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  807eda:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807edb:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  807edc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ee0:	48 8b 00             	mov    (%rax),%rax
  807ee3:	8b 40 14             	mov    0x14(%rax),%eax
  807ee6:	89 c7                	mov    %eax,%edi
  807ee8:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  807eef:	00 00 00 
  807ef2:	ff d0                	callq  *%rax
}
  807ef4:	c9                   	leaveq 
  807ef5:	c3                   	retq   

0000000000807ef6 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  807ef6:	55                   	push   %rbp
  807ef7:	48 89 e5             	mov    %rsp,%rbp
  807efa:	48 83 ec 28          	sub    $0x28,%rsp
  807efe:	89 7d ec             	mov    %edi,-0x14(%rbp)
  807f01:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  807f05:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807f09:	8b 45 ec             	mov    -0x14(%rbp),%eax
  807f0c:	89 c7                	mov    %eax,%edi
  807f0e:	48 b8 60 57 80 00 00 	movabs $0x805760,%rax
  807f15:	00 00 00 
  807f18:	ff d0                	callq  *%rax
  807f1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  807f1e:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  807f24:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807f29:	75 0a                	jne    807f35 <lwip_ioctl+0x3f>
    return -1;
  807f2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f30:	e9 4d 01 00 00       	jmpq   808082 <lwip_ioctl+0x18c>

  switch (cmd) {
  807f35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  807f39:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  807f3f:	74 13                	je     807f54 <lwip_ioctl+0x5e>
  807f41:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  807f46:	48 39 d0             	cmp    %rdx,%rax
  807f49:	0f 84 ae 00 00 00    	je     807ffd <lwip_ioctl+0x107>
  807f4f:	e9 0b 01 00 00       	jmpq   80805f <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  807f54:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  807f59:	75 28                	jne    807f83 <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  807f5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f5f:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  807f66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f6a:	8b 50 18             	mov    0x18(%rax),%edx
  807f6d:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807f74:	00 00 00 
  807f77:	89 10                	mov    %edx,(%rax)
      return -1;
  807f79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f7e:	e9 ff 00 00 00       	jmpq   808082 <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  807f83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f87:	48 8b 00             	mov    (%rax),%rax
  807f8a:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  807f8e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f92:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  807f95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f99:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f9d:	48 85 c0             	test   %rax,%rax
  807fa0:	74 33                	je     807fd5 <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  807fa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fa6:	48 8b 40 08          	mov    0x8(%rax),%rax
  807faa:	48 8b 00             	mov    (%rax),%rax
  807fad:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  807fb1:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  807fb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fb9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  807fbd:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  807fc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fc5:	0f b7 00             	movzwl (%rax),%eax
  807fc8:	89 c2                	mov    %eax,%edx
  807fca:	66 03 55 f6          	add    -0xa(%rbp),%dx
  807fce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fd2:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  807fd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fd9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  807fe0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807fe4:	8b 50 18             	mov    0x18(%rax),%edx
  807fe7:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  807fee:	00 00 00 
  807ff1:	89 10                	mov    %edx,(%rax)
    return 0;
  807ff3:	b8 00 00 00 00       	mov    $0x0,%eax
  807ff8:	e9 85 00 00 00       	jmpq   808082 <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  807ffd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  808002:	74 21                	je     808025 <lwip_ioctl+0x12f>
  808004:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808008:	8b 00                	mov    (%rax),%eax
  80800a:	85 c0                	test   %eax,%eax
  80800c:	74 17                	je     808025 <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  80800e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808012:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  808016:	89 c2                	mov    %eax,%edx
  808018:	80 ce 08             	or     $0x8,%dh
  80801b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80801f:	66 89 50 16          	mov    %dx,0x16(%rax)
  808023:	eb 15                	jmp    80803a <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  808025:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808029:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80802d:	89 c2                	mov    %eax,%edx
  80802f:	80 e6 f7             	and    $0xf7,%dh
  808032:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808036:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  80803a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80803e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  808045:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808049:	8b 50 18             	mov    0x18(%rax),%edx
  80804c:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808053:	00 00 00 
  808056:	89 10                	mov    %edx,(%rax)
    return 0;
  808058:	b8 00 00 00 00       	mov    $0x0,%eax
  80805d:	eb 23                	jmp    808082 <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  80805f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808063:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  80806a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80806e:	8b 50 18             	mov    0x18(%rax),%edx
  808071:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  808078:	00 00 00 
  80807b:	89 10                	mov    %edx,(%rax)
    return -1;
  80807d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  808082:	c9                   	leaveq 
  808083:	c3                   	retq   

0000000000808084 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  808084:	55                   	push   %rbp
  808085:	48 89 e5             	mov    %rsp,%rbp
  808088:	48 83 ec 10          	sub    $0x10,%rsp
  80808c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  808090:	48 b8 58 e6 80 00 00 	movabs $0x80e658,%rax
  808097:	00 00 00 
  80809a:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80809c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8080a3:	00 00 00 
  8080a6:	48 8b 00             	mov    (%rax),%rax
  8080a9:	48 85 c0             	test   %rax,%rax
  8080ac:	75 12                	jne    8080c0 <tcpip_tcp_timer+0x3c>
  8080ae:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8080b5:	00 00 00 
  8080b8:	48 8b 00             	mov    (%rax),%rax
  8080bb:	48 85 c0             	test   %rax,%rax
  8080be:	74 22                	je     8080e2 <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8080c0:	ba 00 00 00 00       	mov    $0x0,%edx
  8080c5:	48 be 84 80 80 00 00 	movabs $0x808084,%rsi
  8080cc:	00 00 00 
  8080cf:	bf fa 00 00 00       	mov    $0xfa,%edi
  8080d4:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  8080db:	00 00 00 
  8080de:	ff d0                	callq  *%rax
  8080e0:	eb 10                	jmp    8080f2 <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8080e2:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8080e9:	00 00 00 
  8080ec:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  8080f2:	c9                   	leaveq 
  8080f3:	c3                   	retq   

00000000008080f4 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8080f4:	55                   	push   %rbp
  8080f5:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8080f8:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  8080ff:	00 00 00 
  808102:	8b 00                	mov    (%rax),%eax
  808104:	85 c0                	test   %eax,%eax
  808106:	75 54                	jne    80815c <tcp_timer_needed+0x68>
  808108:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80810f:	00 00 00 
  808112:	48 8b 00             	mov    (%rax),%rax
  808115:	48 85 c0             	test   %rax,%rax
  808118:	75 12                	jne    80812c <tcp_timer_needed+0x38>
  80811a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  808121:	00 00 00 
  808124:	48 8b 00             	mov    (%rax),%rax
  808127:	48 85 c0             	test   %rax,%rax
  80812a:	74 30                	je     80815c <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80812c:	48 b8 c0 94 82 00 00 	movabs $0x8294c0,%rax
  808133:	00 00 00 
  808136:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80813c:	ba 00 00 00 00       	mov    $0x0,%edx
  808141:	48 be 84 80 80 00 00 	movabs $0x808084,%rsi
  808148:	00 00 00 
  80814b:	bf fa 00 00 00       	mov    $0xfa,%edi
  808150:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  808157:	00 00 00 
  80815a:	ff d0                	callq  *%rax
  }
}
  80815c:	5d                   	pop    %rbp
  80815d:	c3                   	retq   

000000000080815e <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80815e:	55                   	push   %rbp
  80815f:	48 89 e5             	mov    %rsp,%rbp
  808162:	48 83 ec 10          	sub    $0x10,%rsp
  808166:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  80816a:	48 b8 ac 10 81 00 00 	movabs $0x8110ac,%rax
  808171:	00 00 00 
  808174:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808176:	ba 00 00 00 00       	mov    $0x0,%edx
  80817b:	48 be 5e 81 80 00 00 	movabs $0x80815e,%rsi
  808182:	00 00 00 
  808185:	bf e8 03 00 00       	mov    $0x3e8,%edi
  80818a:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  808191:	00 00 00 
  808194:	ff d0                	callq  *%rax
}
  808196:	c9                   	leaveq 
  808197:	c3                   	retq   

0000000000808198 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  808198:	55                   	push   %rbp
  808199:	48 89 e5             	mov    %rsp,%rbp
  80819c:	48 83 ec 10          	sub    $0x10,%rsp
  8081a0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  8081a4:	48 b8 52 55 81 00 00 	movabs $0x815552,%rax
  8081ab:	00 00 00 
  8081ae:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8081b0:	ba 00 00 00 00       	mov    $0x0,%edx
  8081b5:	48 be 98 81 80 00 00 	movabs $0x808198,%rsi
  8081bc:	00 00 00 
  8081bf:	bf 88 13 00 00       	mov    $0x1388,%edi
  8081c4:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  8081cb:	00 00 00 
  8081ce:	ff d0                	callq  *%rax
}
  8081d0:	c9                   	leaveq 
  8081d1:	c3                   	retq   

00000000008081d2 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8081d2:	55                   	push   %rbp
  8081d3:	48 89 e5             	mov    %rsp,%rbp
  8081d6:	48 83 ec 10          	sub    $0x10,%rsp
  8081da:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8081de:	48 b8 0c 93 80 00 00 	movabs $0x80930c,%rax
  8081e5:	00 00 00 
  8081e8:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8081ea:	ba 00 00 00 00       	mov    $0x0,%edx
  8081ef:	48 be d2 81 80 00 00 	movabs $0x8081d2,%rsi
  8081f6:	00 00 00 
  8081f9:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8081fe:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  808205:	00 00 00 
  808208:	ff d0                	callq  *%rax
}
  80820a:	c9                   	leaveq 
  80820b:	c3                   	retq   

000000000080820c <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  80820c:	55                   	push   %rbp
  80820d:	48 89 e5             	mov    %rsp,%rbp
  808210:	48 83 ec 10          	sub    $0x10,%rsp
  808214:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  808218:	48 b8 b0 93 80 00 00 	movabs $0x8093b0,%rax
  80821f:	00 00 00 
  808222:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  808224:	ba 00 00 00 00       	mov    $0x0,%edx
  808229:	48 be 0c 82 80 00 00 	movabs $0x80820c,%rsi
  808230:	00 00 00 
  808233:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808238:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  80823f:	00 00 00 
  808242:	ff d0                	callq  *%rax
}
  808244:	c9                   	leaveq 
  808245:	c3                   	retq   

0000000000808246 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  808246:	55                   	push   %rbp
  808247:	48 89 e5             	mov    %rsp,%rbp
  80824a:	48 83 ec 20          	sub    $0x20,%rsp
  80824e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808252:	ba 00 00 00 00       	mov    $0x0,%edx
  808257:	48 be 5e 81 80 00 00 	movabs $0x80815e,%rsi
  80825e:	00 00 00 
  808261:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808266:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  80826d:	00 00 00 
  808270:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  808272:	ba 00 00 00 00       	mov    $0x0,%edx
  808277:	48 be 98 81 80 00 00 	movabs $0x808198,%rsi
  80827e:	00 00 00 
  808281:	bf 88 13 00 00       	mov    $0x1388,%edi
  808286:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  80828d:	00 00 00 
  808290:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  808292:	ba 00 00 00 00       	mov    $0x0,%edx
  808297:	48 be d2 81 80 00 00 	movabs $0x8081d2,%rsi
  80829e:	00 00 00 
  8082a1:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8082a6:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  8082ad:	00 00 00 
  8082b0:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8082b2:	ba 00 00 00 00       	mov    $0x0,%edx
  8082b7:	48 be 0c 82 80 00 00 	movabs $0x80820c,%rsi
  8082be:	00 00 00 
  8082c1:	bf f4 01 00 00       	mov    $0x1f4,%edi
  8082c6:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  8082cd:	00 00 00 
  8082d0:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8082d2:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8082d9:	00 00 00 
  8082dc:	48 8b 00             	mov    (%rax),%rax
  8082df:	48 85 c0             	test   %rax,%rax
  8082e2:	74 1f                	je     808303 <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  8082e4:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  8082eb:	00 00 00 
  8082ee:	48 8b 10             	mov    (%rax),%rdx
  8082f1:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  8082f8:	00 00 00 
  8082fb:	48 8b 00             	mov    (%rax),%rax
  8082fe:	48 89 c7             	mov    %rax,%rdi
  808301:	ff d2                	callq  *%rdx
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  808303:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80830a:	00 00 00 
  80830d:	8b 00                	mov    (%rax),%eax
  80830f:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  808313:	48 89 d6             	mov    %rdx,%rsi
  808316:	89 c7                	mov    %eax,%edi
  808318:	48 b8 cc df 80 00 00 	movabs $0x80dfcc,%rax
  80831f:	00 00 00 
  808322:	ff d0                	callq  *%rax
    switch (msg->type) {
  808324:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808328:	8b 00                	mov    (%rax),%eax
  80832a:	83 f8 01             	cmp    $0x1,%eax
  80832d:	74 3d                	je     80836c <tcpip_thread+0x126>
  80832f:	83 f8 01             	cmp    $0x1,%eax
  808332:	72 17                	jb     80834b <tcpip_thread+0x105>
  808334:	83 f8 02             	cmp    $0x2,%eax
  808337:	0f 84 a8 00 00 00    	je     8083e5 <tcpip_thread+0x19f>
  80833d:	83 f8 03             	cmp    $0x3,%eax
  808340:	0f 84 ce 00 00 00    	je     808414 <tcpip_thread+0x1ce>
  808346:	e9 3b 01 00 00       	jmpq   808486 <tcpip_thread+0x240>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80834b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80834f:	48 8b 40 10          	mov    0x10(%rax),%rax
  808353:	48 8b 10             	mov    (%rax),%rdx
  808356:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80835a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80835e:	48 83 c0 08          	add    $0x8,%rax
  808362:	48 89 c7             	mov    %rax,%rdi
  808365:	ff d2                	callq  *%rdx
      break;
  808367:	e9 1b 01 00 00       	jmpq   808487 <tcpip_thread+0x241>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  80836c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808370:	48 8b 40 18          	mov    0x18(%rax),%rax
  808374:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808378:	0f b6 c0             	movzbl %al,%eax
  80837b:	83 e0 20             	and    $0x20,%eax
  80837e:	85 c0                	test   %eax,%eax
  808380:	74 24                	je     8083a6 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  808382:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808386:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80838a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80838e:	48 8b 40 10          	mov    0x10(%rax),%rax
  808392:	48 89 d6             	mov    %rdx,%rsi
  808395:	48 89 c7             	mov    %rax,%rdi
  808398:	48 b8 dd 6d 81 00 00 	movabs $0x816ddd,%rax
  80839f:	00 00 00 
  8083a2:	ff d0                	callq  *%rax
  8083a4:	eb 22                	jmp    8083c8 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8083a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083aa:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8083ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083b2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8083b6:	48 89 d6             	mov    %rdx,%rsi
  8083b9:	48 89 c7             	mov    %rax,%rdi
  8083bc:	48 b8 f2 08 81 00 00 	movabs $0x8108f2,%rax
  8083c3:	00 00 00 
  8083c6:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8083c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083cc:	48 89 c6             	mov    %rax,%rsi
  8083cf:	bf 09 00 00 00       	mov    $0x9,%edi
  8083d4:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  8083db:	00 00 00 
  8083de:	ff d0                	callq  *%rax
      break;
  8083e0:	e9 a2 00 00 00       	jmpq   808487 <tcpip_thread+0x241>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8083e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083e9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8083ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083f1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8083f5:	48 89 c7             	mov    %rax,%rdi
  8083f8:	ff d2                	callq  *%rdx
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8083fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8083fe:	48 89 c6             	mov    %rax,%rsi
  808401:	bf 08 00 00 00       	mov    $0x8,%edi
  808406:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80840d:	00 00 00 
  808410:	ff d0                	callq  *%rax
      break;
  808412:	eb 73                	jmp    808487 <tcpip_thread+0x241>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  808414:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808418:	8b 40 10             	mov    0x10(%rax),%eax
  80841b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80841e:	74 2a                	je     80844a <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  808420:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808424:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808428:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80842c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  808430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808434:	8b 40 10             	mov    0x10(%rax),%eax
  808437:	48 89 ce             	mov    %rcx,%rsi
  80843a:	89 c7                	mov    %eax,%edi
  80843c:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  808443:	00 00 00 
  808446:	ff d0                	callq  *%rax
  808448:	eb 22                	jmp    80846c <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80844a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80844e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808452:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808456:	48 8b 40 18          	mov    0x18(%rax),%rax
  80845a:	48 89 d6             	mov    %rdx,%rsi
  80845d:	48 89 c7             	mov    %rax,%rdi
  808460:	48 b8 22 e4 80 00 00 	movabs $0x80e422,%rax
  808467:	00 00 00 
  80846a:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80846c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808470:	48 89 c6             	mov    %rax,%rsi
  808473:	bf 08 00 00 00       	mov    $0x8,%edi
  808478:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80847f:	00 00 00 
  808482:	ff d0                	callq  *%rax
      break;
  808484:	eb 01                	jmp    808487 <tcpip_thread+0x241>

    default:
      break;
  808486:	90                   	nop
    }
  }
  808487:	e9 77 fe ff ff       	jmpq   808303 <tcpip_thread+0xbd>

000000000080848c <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  80848c:	55                   	push   %rbp
  80848d:	48 89 e5             	mov    %rsp,%rbp
  808490:	48 83 ec 20          	sub    $0x20,%rsp
  808494:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808498:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80849c:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8084a3:	00 00 00 
  8084a6:	8b 00                	mov    (%rax),%eax
  8084a8:	83 f8 ff             	cmp    $0xffffffff,%eax
  8084ab:	0f 84 90 00 00 00    	je     808541 <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8084b1:	bf 09 00 00 00       	mov    $0x9,%edi
  8084b6:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  8084bd:	00 00 00 
  8084c0:	ff d0                	callq  *%rax
  8084c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  8084c6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8084cb:	75 07                	jne    8084d4 <tcpip_input+0x48>
      return ERR_MEM;
  8084cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8084d2:	eb 72                	jmp    808546 <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  8084d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084d8:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  8084de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8084e6:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  8084ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8084ee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8084f2:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8084f6:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8084fd:	00 00 00 
  808500:	8b 00                	mov    (%rax),%eax
  808502:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808506:	48 89 d6             	mov    %rdx,%rsi
  808509:	89 c7                	mov    %eax,%edi
  80850b:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  808512:	00 00 00 
  808515:	ff d0                	callq  *%rax
  808517:	84 c0                	test   %al,%al
  808519:	74 1f                	je     80853a <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80851b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80851f:	48 89 c6             	mov    %rax,%rsi
  808522:	bf 09 00 00 00       	mov    $0x9,%edi
  808527:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80852e:	00 00 00 
  808531:	ff d0                	callq  *%rax
      return ERR_MEM;
  808533:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808538:	eb 0c                	jmp    808546 <tcpip_input+0xba>
    }
    return ERR_OK;
  80853a:	b8 00 00 00 00       	mov    $0x0,%eax
  80853f:	eb 05                	jmp    808546 <tcpip_input+0xba>
  }
  return ERR_VAL;
  808541:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808546:	c9                   	leaveq 
  808547:	c3                   	retq   

0000000000808548 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808548:	55                   	push   %rbp
  808549:	48 89 e5             	mov    %rsp,%rbp
  80854c:	48 83 ec 30          	sub    $0x30,%rsp
  808550:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808554:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808558:	89 d0                	mov    %edx,%eax
  80855a:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80855d:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808564:	00 00 00 
  808567:	8b 00                	mov    (%rax),%eax
  808569:	83 f8 ff             	cmp    $0xffffffff,%eax
  80856c:	0f 84 bc 00 00 00    	je     80862e <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808572:	bf 08 00 00 00       	mov    $0x8,%edi
  808577:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80857e:	00 00 00 
  808581:	ff d0                	callq  *%rax
  808583:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808587:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80858c:	75 0a                	jne    808598 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  80858e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808593:	e9 9b 00 00 00       	jmpq   808633 <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80859c:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  8085a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085a6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8085aa:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  8085ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085b2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8085b6:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  8085ba:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  8085be:	74 23                	je     8085e3 <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  8085c0:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8085c7:	00 00 00 
  8085ca:	8b 00                	mov    (%rax),%eax
  8085cc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8085d0:	48 89 d6             	mov    %rdx,%rsi
  8085d3:	89 c7                	mov    %eax,%edi
  8085d5:	48 b8 38 75 81 00 00 	movabs $0x817538,%rax
  8085dc:	00 00 00 
  8085df:	ff d0                	callq  *%rax
  8085e1:	eb 44                	jmp    808627 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8085e3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8085ea:	00 00 00 
  8085ed:	8b 00                	mov    (%rax),%eax
  8085ef:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8085f3:	48 89 d6             	mov    %rdx,%rsi
  8085f6:	89 c7                	mov    %eax,%edi
  8085f8:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  8085ff:	00 00 00 
  808602:	ff d0                	callq  *%rax
  808604:	84 c0                	test   %al,%al
  808606:	74 1f                	je     808627 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  808608:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80860c:	48 89 c6             	mov    %rax,%rsi
  80860f:	bf 08 00 00 00       	mov    $0x8,%edi
  808614:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80861b:	00 00 00 
  80861e:	ff d0                	callq  *%rax
        return ERR_MEM;
  808620:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808625:	eb 0c                	jmp    808633 <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808627:	b8 00 00 00 00       	mov    $0x0,%eax
  80862c:	eb 05                	jmp    808633 <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  80862e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808633:	c9                   	leaveq 
  808634:	c3                   	retq   

0000000000808635 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  808635:	55                   	push   %rbp
  808636:	48 89 e5             	mov    %rsp,%rbp
  808639:	48 83 ec 30          	sub    $0x30,%rsp
  80863d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808640:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808644:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808648:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80864f:	00 00 00 
  808652:	8b 00                	mov    (%rax),%eax
  808654:	83 f8 ff             	cmp    $0xffffffff,%eax
  808657:	74 77                	je     8086d0 <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808659:	bf 08 00 00 00       	mov    $0x8,%edi
  80865e:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  808665:	00 00 00 
  808668:	ff d0                	callq  *%rax
  80866a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  80866e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808673:	75 07                	jne    80867c <tcpip_timeout+0x47>
      return ERR_MEM;
  808675:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80867a:	eb 59                	jmp    8086d5 <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  80867c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808680:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808686:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80868a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80868d:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808690:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808694:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808698:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  80869c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086a0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8086a4:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  8086a8:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8086af:	00 00 00 
  8086b2:	8b 00                	mov    (%rax),%eax
  8086b4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8086b8:	48 89 d6             	mov    %rdx,%rsi
  8086bb:	89 c7                	mov    %eax,%edi
  8086bd:	48 b8 38 75 81 00 00 	movabs $0x817538,%rax
  8086c4:	00 00 00 
  8086c7:	ff d0                	callq  *%rax
    return ERR_OK;
  8086c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8086ce:	eb 05                	jmp    8086d5 <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  8086d0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8086d5:	c9                   	leaveq 
  8086d6:	c3                   	retq   

00000000008086d7 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8086d7:	55                   	push   %rbp
  8086d8:	48 89 e5             	mov    %rsp,%rbp
  8086db:	48 83 ec 40          	sub    $0x40,%rsp
  8086df:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8086e3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8086ea:	00 00 00 
  8086ed:	8b 00                	mov    (%rax),%eax
  8086ef:	83 f8 ff             	cmp    $0xffffffff,%eax
  8086f2:	74 55                	je     808749 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  8086f4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  8086fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8086ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  808703:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80870a:	00 00 00 
  80870d:	8b 00                	mov    (%rax),%eax
  80870f:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  808713:	48 89 d6             	mov    %rdx,%rsi
  808716:	89 c7                	mov    %eax,%edi
  808718:	48 b8 38 75 81 00 00 	movabs $0x817538,%rax
  80871f:	00 00 00 
  808722:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  808724:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808728:	48 8b 40 08          	mov    0x8(%rax),%rax
  80872c:	8b 40 14             	mov    0x14(%rax),%eax
  80872f:	be 00 00 00 00       	mov    $0x0,%esi
  808734:	89 c7                	mov    %eax,%edi
  808736:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  80873d:	00 00 00 
  808740:	ff d0                	callq  *%rax
    return ERR_OK;
  808742:	b8 00 00 00 00       	mov    $0x0,%eax
  808747:	eb 05                	jmp    80874e <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808749:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80874e:	c9                   	leaveq 
  80874f:	c3                   	retq   

0000000000808750 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808750:	55                   	push   %rbp
  808751:	48 89 e5             	mov    %rsp,%rbp
  808754:	48 83 ec 10          	sub    $0x10,%rsp
  808758:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80875c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808760:	48 b8 fe 8d 80 00 00 	movabs $0x808dfe,%rax
  808767:	00 00 00 
  80876a:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  80876c:	48 b8 b0 94 82 00 00 	movabs $0x8294b0,%rax
  808773:	00 00 00 
  808776:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80877a:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  80877d:	48 b8 b8 94 82 00 00 	movabs $0x8294b8,%rax
  808784:	00 00 00 
  808787:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80878b:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80878e:	bf 00 00 00 00       	mov    $0x0,%edi
  808793:	48 b8 36 71 81 00 00 	movabs $0x817136,%rax
  80879a:	00 00 00 
  80879d:	ff d0                	callq  *%rax
  80879f:	48 ba 78 81 82 00 00 	movabs $0x828178,%rdx
  8087a6:	00 00 00 
  8087a9:	89 02                	mov    %eax,(%rdx)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8087ab:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8087b1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8087b6:	ba 00 00 00 00       	mov    $0x0,%edx
  8087bb:	48 be 46 82 80 00 00 	movabs $0x808246,%rsi
  8087c2:	00 00 00 
  8087c5:	48 bf 13 11 82 00 00 	movabs $0x821113,%rdi
  8087cc:	00 00 00 
  8087cf:	48 b8 8d 80 81 00 00 	movabs $0x81808d,%rax
  8087d6:	00 00 00 
  8087d9:	ff d0                	callq  *%rax
}
  8087db:	c9                   	leaveq 
  8087dc:	c3                   	retq   

00000000008087dd <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8087dd:	55                   	push   %rbp
  8087de:	48 89 e5             	mov    %rsp,%rbp
  8087e1:	48 83 ec 20          	sub    $0x20,%rsp
  8087e5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  8087e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8087ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  8087f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087f5:	48 89 c7             	mov    %rax,%rdi
  8087f8:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8087ff:	00 00 00 
  808802:	ff d0                	callq  *%rax
}
  808804:	c9                   	leaveq 
  808805:	c3                   	retq   

0000000000808806 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  808806:	55                   	push   %rbp
  808807:	48 89 e5             	mov    %rsp,%rbp
  80880a:	48 83 ec 10          	sub    $0x10,%rsp
  80880e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  808812:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808816:	ba 00 00 00 00       	mov    $0x0,%edx
  80881b:	48 89 c6             	mov    %rax,%rsi
  80881e:	48 bf dd 87 80 00 00 	movabs $0x8087dd,%rdi
  808825:	00 00 00 
  808828:	48 b8 48 85 80 00 00 	movabs $0x808548,%rax
  80882f:	00 00 00 
  808832:	ff d0                	callq  *%rax
}
  808834:	c9                   	leaveq 
  808835:	c3                   	retq   

0000000000808836 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808836:	55                   	push   %rbp
  808837:	48 89 e5             	mov    %rsp,%rbp
  80883a:	48 83 ec 10          	sub    $0x10,%rsp
  80883e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808842:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808846:	ba 00 00 00 00       	mov    $0x0,%edx
  80884b:	48 89 c6             	mov    %rax,%rsi
  80884e:	48 bf f3 be 80 00 00 	movabs $0x80bef3,%rdi
  808855:	00 00 00 
  808858:	48 b8 48 85 80 00 00 	movabs $0x808548,%rax
  80885f:	00 00 00 
  808862:	ff d0                	callq  *%rax
}
  808864:	c9                   	leaveq 
  808865:	c3                   	retq   
	...

0000000000808868 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808868:	55                   	push   %rbp
  808869:	48 89 e5             	mov    %rsp,%rbp
  80886c:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808870:	bf 06 00 00 00       	mov    $0x6,%edi
  808875:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80887c:	00 00 00 
  80887f:	ff d0                	callq  *%rax
  808881:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808885:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80888a:	74 29                	je     8088b5 <netbuf_new+0x4d>
    buf->p = NULL;
  80888c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808890:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808897:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80889b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8088a2:	00 
    buf->addr = NULL;
  8088a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088a7:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8088ae:	00 
    return buf;
  8088af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088b3:	eb 05                	jmp    8088ba <netbuf_new+0x52>
  } else {
    return NULL;
  8088b5:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  8088ba:	c9                   	leaveq 
  8088bb:	c3                   	retq   

00000000008088bc <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8088bc:	55                   	push   %rbp
  8088bd:	48 89 e5             	mov    %rsp,%rbp
  8088c0:	48 83 ec 10          	sub    $0x10,%rsp
  8088c4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  8088c8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8088cd:	74 55                	je     808924 <netbuf_delete+0x68>
    if (buf->p != NULL) {
  8088cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088d3:	48 8b 00             	mov    (%rax),%rax
  8088d6:	48 85 c0             	test   %rax,%rax
  8088d9:	74 31                	je     80890c <netbuf_delete+0x50>
      pbuf_free(buf->p);
  8088db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088df:	48 8b 00             	mov    (%rax),%rax
  8088e2:	48 89 c7             	mov    %rax,%rdi
  8088e5:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8088ec:	00 00 00 
  8088ef:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  8088f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8088f5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8088fc:	00 
  8088fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808901:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808905:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808909:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  80890c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808910:	48 89 c6             	mov    %rax,%rsi
  808913:	bf 06 00 00 00       	mov    $0x6,%edi
  808918:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80891f:	00 00 00 
  808922:	ff d0                	callq  *%rax
  }
}
  808924:	c9                   	leaveq 
  808925:	c3                   	retq   

0000000000808926 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808926:	55                   	push   %rbp
  808927:	48 89 e5             	mov    %rsp,%rbp
  80892a:	48 83 ec 10          	sub    $0x10,%rsp
  80892e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808932:	89 f0                	mov    %esi,%eax
  808934:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808938:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80893d:	75 2a                	jne    808969 <netbuf_alloc+0x43>
  80893f:	48 ba 20 11 82 00 00 	movabs $0x821120,%rdx
  808946:	00 00 00 
  808949:	be 63 00 00 00       	mov    $0x63,%esi
  80894e:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808955:	00 00 00 
  808958:	b8 00 00 00 00       	mov    $0x0,%eax
  80895d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808964:	00 00 00 
  808967:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808969:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80896d:	48 8b 00             	mov    (%rax),%rax
  808970:	48 85 c0             	test   %rax,%rax
  808973:	74 16                	je     80898b <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808975:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808979:	48 8b 00             	mov    (%rax),%rax
  80897c:	48 89 c7             	mov    %rax,%rdi
  80897f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  808986:	00 00 00 
  808989:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  80898b:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80898f:	ba 00 00 00 00       	mov    $0x0,%edx
  808994:	89 c6                	mov    %eax,%esi
  808996:	bf 00 00 00 00       	mov    $0x0,%edi
  80899b:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  8089a2:	00 00 00 
  8089a5:	ff d0                	callq  *%rax
  8089a7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8089ab:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  8089ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089b2:	48 8b 00             	mov    (%rax),%rax
  8089b5:	48 85 c0             	test   %rax,%rax
  8089b8:	75 07                	jne    8089c1 <netbuf_alloc+0x9b>
     return NULL;
  8089ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8089bf:	eb 55                	jmp    808a16 <netbuf_alloc+0xf0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8089c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089c5:	48 8b 00             	mov    (%rax),%rax
  8089c8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8089cc:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  8089d0:	73 2a                	jae    8089fc <netbuf_alloc+0xd6>
  8089d2:	48 ba 50 11 82 00 00 	movabs $0x821150,%rdx
  8089d9:	00 00 00 
  8089dc:	be 6e 00 00 00       	mov    $0x6e,%esi
  8089e1:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  8089e8:	00 00 00 
  8089eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8089f0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8089f7:	00 00 00 
  8089fa:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8089fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a00:	48 8b 10             	mov    (%rax),%rdx
  808a03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a07:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  808a0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a0f:	48 8b 00             	mov    (%rax),%rax
  808a12:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  808a16:	c9                   	leaveq 
  808a17:	c3                   	retq   

0000000000808a18 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  808a18:	55                   	push   %rbp
  808a19:	48 89 e5             	mov    %rsp,%rbp
  808a1c:	48 83 ec 10          	sub    $0x10,%rsp
  808a20:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808a24:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808a29:	75 2a                	jne    808a55 <netbuf_free+0x3d>
  808a2b:	48 ba 74 11 82 00 00 	movabs $0x821174,%rdx
  808a32:	00 00 00 
  808a35:	be 7b 00 00 00       	mov    $0x7b,%esi
  808a3a:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808a41:	00 00 00 
  808a44:	b8 00 00 00 00       	mov    $0x0,%eax
  808a49:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808a50:	00 00 00 
  808a53:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808a55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a59:	48 8b 00             	mov    (%rax),%rax
  808a5c:	48 85 c0             	test   %rax,%rax
  808a5f:	74 16                	je     808a77 <netbuf_free+0x5f>
    pbuf_free(buf->p);
  808a61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a65:	48 8b 00             	mov    (%rax),%rax
  808a68:	48 89 c7             	mov    %rax,%rdi
  808a6b:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  808a72:	00 00 00 
  808a75:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  808a77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a7b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808a82:	00 
  808a83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a87:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808a8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a8f:	48 89 10             	mov    %rdx,(%rax)
}
  808a92:	c9                   	leaveq 
  808a93:	c3                   	retq   

0000000000808a94 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  808a94:	55                   	push   %rbp
  808a95:	48 89 e5             	mov    %rsp,%rbp
  808a98:	48 83 ec 20          	sub    $0x20,%rsp
  808a9c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808aa0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808aa4:	89 d0                	mov    %edx,%eax
  808aa6:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  808aaa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808aaf:	75 2a                	jne    808adb <netbuf_ref+0x47>
  808ab1:	48 ba 8d 11 82 00 00 	movabs $0x82118d,%rdx
  808ab8:	00 00 00 
  808abb:	be 8e 00 00 00       	mov    $0x8e,%esi
  808ac0:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808ac7:	00 00 00 
  808aca:	b8 00 00 00 00       	mov    $0x0,%eax
  808acf:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808ad6:	00 00 00 
  808ad9:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808adb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808adf:	48 8b 00             	mov    (%rax),%rax
  808ae2:	48 85 c0             	test   %rax,%rax
  808ae5:	74 16                	je     808afd <netbuf_ref+0x69>
    pbuf_free(buf->p);
  808ae7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808aeb:	48 8b 00             	mov    (%rax),%rax
  808aee:	48 89 c7             	mov    %rax,%rdi
  808af1:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  808af8:	00 00 00 
  808afb:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  808afd:	ba 02 00 00 00       	mov    $0x2,%edx
  808b02:	be 00 00 00 00       	mov    $0x0,%esi
  808b07:	bf 00 00 00 00       	mov    $0x0,%edi
  808b0c:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  808b13:	00 00 00 
  808b16:	ff d0                	callq  *%rax
  808b18:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b1c:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808b1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b23:	48 8b 00             	mov    (%rax),%rax
  808b26:	48 85 c0             	test   %rax,%rax
  808b29:	75 13                	jne    808b3e <netbuf_ref+0xaa>
    buf->ptr = NULL;
  808b2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b2f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808b36:	00 
    return ERR_MEM;
  808b37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808b3c:	eb 41                	jmp    808b7f <netbuf_ref+0xeb>
  }
  buf->p->payload = (void*)dataptr;
  808b3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b42:	48 8b 00             	mov    (%rax),%rax
  808b45:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808b49:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  808b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b51:	48 8b 10             	mov    (%rax),%rdx
  808b54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b58:	48 8b 00             	mov    (%rax),%rax
  808b5b:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  808b5f:	66 89 48 10          	mov    %cx,0x10(%rax)
  808b63:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808b67:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  808b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b6f:	48 8b 10             	mov    (%rax),%rdx
  808b72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b76:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  808b7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808b7f:	c9                   	leaveq 
  808b80:	c3                   	retq   

0000000000808b81 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  808b81:	55                   	push   %rbp
  808b82:	48 89 e5             	mov    %rsp,%rbp
  808b85:	48 83 ec 10          	sub    $0x10,%rsp
  808b89:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808b8d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  808b91:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b96:	75 2a                	jne    808bc2 <netbuf_chain+0x41>
  808b98:	48 ba a5 11 82 00 00 	movabs $0x8211a5,%rdx
  808b9f:	00 00 00 
  808ba2:	be a6 00 00 00       	mov    $0xa6,%esi
  808ba7:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808bae:	00 00 00 
  808bb1:	b8 00 00 00 00       	mov    $0x0,%eax
  808bb6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808bbd:	00 00 00 
  808bc0:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  808bc2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808bc7:	75 2a                	jne    808bf3 <netbuf_chain+0x72>
  808bc9:	48 ba be 11 82 00 00 	movabs $0x8211be,%rdx
  808bd0:	00 00 00 
  808bd3:	be a7 00 00 00       	mov    $0xa7,%esi
  808bd8:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808bdf:	00 00 00 
  808be2:	b8 00 00 00 00       	mov    $0x0,%eax
  808be7:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808bee:	00 00 00 
  808bf1:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  808bf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808bf7:	48 8b 10             	mov    (%rax),%rdx
  808bfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bfe:	48 8b 00             	mov    (%rax),%rax
  808c01:	48 89 d6             	mov    %rdx,%rsi
  808c04:	48 89 c7             	mov    %rax,%rdi
  808c07:	48 b8 76 da 80 00 00 	movabs $0x80da76,%rax
  808c0e:	00 00 00 
  808c11:	ff d0                	callq  *%rax
  head->ptr = head->p;
  808c13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c17:	48 8b 10             	mov    (%rax),%rdx
  808c1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c1e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  808c22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808c26:	48 89 c6             	mov    %rax,%rsi
  808c29:	bf 06 00 00 00       	mov    $0x6,%edi
  808c2e:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  808c35:	00 00 00 
  808c38:	ff d0                	callq  *%rax
}
  808c3a:	c9                   	leaveq 
  808c3b:	c3                   	retq   

0000000000808c3c <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  808c3c:	55                   	push   %rbp
  808c3d:	48 89 e5             	mov    %rsp,%rbp
  808c40:	48 83 ec 20          	sub    $0x20,%rsp
  808c44:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808c48:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808c4c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  808c50:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c55:	75 2a                	jne    808c81 <netbuf_data+0x45>
  808c57:	48 ba d9 11 82 00 00 	movabs $0x8211d9,%rdx
  808c5e:	00 00 00 
  808c61:	be b9 00 00 00       	mov    $0xb9,%esi
  808c66:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808c6d:	00 00 00 
  808c70:	b8 00 00 00 00       	mov    $0x0,%eax
  808c75:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808c7c:	00 00 00 
  808c7f:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  808c81:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808c86:	75 2a                	jne    808cb2 <netbuf_data+0x76>
  808c88:	48 ba f2 11 82 00 00 	movabs $0x8211f2,%rdx
  808c8f:	00 00 00 
  808c92:	be ba 00 00 00       	mov    $0xba,%esi
  808c97:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808c9e:	00 00 00 
  808ca1:	b8 00 00 00 00       	mov    $0x0,%eax
  808ca6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808cad:	00 00 00 
  808cb0:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  808cb2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  808cb7:	75 2a                	jne    808ce3 <netbuf_data+0xa7>
  808cb9:	48 ba 0f 12 82 00 00 	movabs $0x82120f,%rdx
  808cc0:	00 00 00 
  808cc3:	be bb 00 00 00       	mov    $0xbb,%esi
  808cc8:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808ccf:	00 00 00 
  808cd2:	b8 00 00 00 00       	mov    $0x0,%eax
  808cd7:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808cde:	00 00 00 
  808ce1:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  808ce3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ce7:	48 8b 40 08          	mov    0x8(%rax),%rax
  808ceb:	48 85 c0             	test   %rax,%rax
  808cee:	75 07                	jne    808cf7 <netbuf_data+0xbb>
    return ERR_BUF;
  808cf0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808cf5:	eb 2b                	jmp    808d22 <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  808cf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cfb:	48 8b 40 08          	mov    0x8(%rax),%rax
  808cff:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808d03:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808d07:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  808d0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d0e:	48 8b 40 08          	mov    0x8(%rax),%rax
  808d12:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  808d16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808d1a:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  808d1d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808d22:	c9                   	leaveq 
  808d23:	c3                   	retq   

0000000000808d24 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  808d24:	55                   	push   %rbp
  808d25:	48 89 e5             	mov    %rsp,%rbp
  808d28:	48 83 ec 10          	sub    $0x10,%rsp
  808d2c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  808d30:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808d35:	75 2a                	jne    808d61 <netbuf_next+0x3d>
  808d37:	48 ba 74 11 82 00 00 	movabs $0x821174,%rdx
  808d3e:	00 00 00 
  808d41:	be d2 00 00 00       	mov    $0xd2,%esi
  808d46:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808d4d:	00 00 00 
  808d50:	b8 00 00 00 00       	mov    $0x0,%eax
  808d55:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808d5c:	00 00 00 
  808d5f:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  808d61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d65:	48 8b 40 08          	mov    0x8(%rax),%rax
  808d69:	48 8b 00             	mov    (%rax),%rax
  808d6c:	48 85 c0             	test   %rax,%rax
  808d6f:	75 07                	jne    808d78 <netbuf_next+0x54>
    return -1;
  808d71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808d76:	eb 2f                	jmp    808da7 <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  808d78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d7c:	48 8b 40 08          	mov    0x8(%rax),%rax
  808d80:	48 8b 10             	mov    (%rax),%rdx
  808d83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d87:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  808d8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d8f:	48 8b 40 08          	mov    0x8(%rax),%rax
  808d93:	48 8b 00             	mov    (%rax),%rax
  808d96:	48 85 c0             	test   %rax,%rax
  808d99:	75 07                	jne    808da2 <netbuf_next+0x7e>
    return 1;
  808d9b:	b8 01 00 00 00       	mov    $0x1,%eax
  808da0:	eb 05                	jmp    808da7 <netbuf_next+0x83>
  }
  return 0;
  808da2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808da7:	c9                   	leaveq 
  808da8:	c3                   	retq   

0000000000808da9 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  808da9:	55                   	push   %rbp
  808daa:	48 89 e5             	mov    %rsp,%rbp
  808dad:	48 83 ec 10          	sub    $0x10,%rsp
  808db1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808db5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808dba:	75 2a                	jne    808de6 <netbuf_first+0x3d>
  808dbc:	48 ba 74 11 82 00 00 	movabs $0x821174,%rdx
  808dc3:	00 00 00 
  808dc6:	be e7 00 00 00       	mov    $0xe7,%esi
  808dcb:	48 bf 3a 11 82 00 00 	movabs $0x82113a,%rdi
  808dd2:	00 00 00 
  808dd5:	b8 00 00 00 00       	mov    $0x0,%eax
  808dda:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  808de1:	00 00 00 
  808de4:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  808de6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dea:	48 8b 10             	mov    (%rax),%rdx
  808ded:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808df1:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  808df5:	c9                   	leaveq 
  808df6:	c3                   	retq   
	...

0000000000808df8 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  808df8:	55                   	push   %rbp
  808df9:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  808dfc:	5d                   	pop    %rbp
  808dfd:	c3                   	retq   

0000000000808dfe <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  808dfe:	55                   	push   %rbp
  808dff:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  808e02:	48 b8 f8 8d 80 00 00 	movabs $0x808df8,%rax
  808e09:	00 00 00 
  808e0c:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  808e0e:	48 b8 f0 6e 81 00 00 	movabs $0x816ef0,%rax
  808e15:	00 00 00 
  808e18:	ff d0                	callq  *%rax
  mem_init();
  808e1a:	48 b8 09 be 80 00 00 	movabs $0x80be09,%rax
  808e21:	00 00 00 
  808e24:	ff d0                	callq  *%rax
  memp_init();
  808e26:	48 b8 80 c7 80 00 00 	movabs $0x80c780,%rax
  808e2d:	00 00 00 
  808e30:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  808e32:	48 b8 20 57 80 00 00 	movabs $0x805720,%rax
  808e39:	00 00 00 
  808e3c:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  808e3e:	5d                   	pop    %rbp
  808e3f:	c3                   	retq   

0000000000808e40 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  808e40:	55                   	push   %rbp
  808e41:	48 89 e5             	mov    %rsp,%rbp
  808e44:	48 83 ec 20          	sub    $0x20,%rsp
  808e48:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808e4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e50:	48 8b 40 38          	mov    0x38(%rax),%rax
  808e54:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  808e58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e5c:	48 89 c7             	mov    %rax,%rdi
  808e5f:	48 b8 1f ce 80 00 00 	movabs $0x80ce1f,%rax
  808e66:	00 00 00 
  808e69:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  808e6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e6f:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  808e76:	00 00 00 
  808e79:	48 89 c7             	mov    %rax,%rdi
  808e7c:	48 b8 37 cc 80 00 00 	movabs $0x80cc37,%rax
  808e83:	00 00 00 
  808e86:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  808e88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808e8c:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  808e93:	00 00 00 
  808e96:	48 89 c7             	mov    %rax,%rdi
  808e99:	48 b8 3d cd 80 00 00 	movabs $0x80cd3d,%rax
  808ea0:	00 00 00 
  808ea3:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  808ea5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808ea9:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  808eb0:	00 00 00 
  808eb3:	48 89 c7             	mov    %rax,%rdi
  808eb6:	48 b8 6a cd 80 00 00 	movabs $0x80cd6a,%rax
  808ebd:	00 00 00 
  808ec0:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  808ec2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ec6:	be 0c 00 00 00       	mov    $0xc,%esi
  808ecb:	48 89 c7             	mov    %rax,%rdi
  808ece:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  808ed5:	00 00 00 
  808ed8:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  808eda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808ede:	48 89 c7             	mov    %rax,%rdi
  808ee1:	48 b8 fa 9f 80 00 00 	movabs $0x809ffa,%rax
  808ee8:	00 00 00 
  808eeb:	ff d0                	callq  *%rax
}
  808eed:	c9                   	leaveq 
  808eee:	c3                   	retq   

0000000000808eef <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  808eef:	55                   	push   %rbp
  808ef0:	48 89 e5             	mov    %rsp,%rbp
  808ef3:	48 83 ec 20          	sub    $0x20,%rsp
  808ef7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808efb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808eff:	48 8b 40 38          	mov    0x38(%rax),%rax
  808f03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  808f07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f0b:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  808f0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f13:	ba 00 00 00 00       	mov    $0x0,%edx
  808f18:	48 89 ce             	mov    %rcx,%rsi
  808f1b:	48 89 c7             	mov    %rax,%rdi
  808f1e:	48 b8 9b 66 81 00 00 	movabs $0x81669b,%rax
  808f25:	00 00 00 
  808f28:	ff d0                	callq  *%rax
  808f2a:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  808f2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f31:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  808f35:	8d 50 01             	lea    0x1(%rax),%edx
  808f38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f3c:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  808f3f:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  808f45:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808f49:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  808f4f:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808f54:	89 c8                	mov    %ecx,%eax
  808f56:	f7 ea                	imul   %edx
  808f58:	c1 fa 05             	sar    $0x5,%edx
  808f5b:	89 c8                	mov    %ecx,%eax
  808f5d:	c1 f8 1f             	sar    $0x1f,%eax
  808f60:	89 d1                	mov    %edx,%ecx
  808f62:	29 c1                	sub    %eax,%ecx
  808f64:	89 c8                	mov    %ecx,%eax
  808f66:	89 c2                	mov    %eax,%edx
  808f68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f6c:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  808f70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f74:	be 08 00 00 00       	mov    $0x8,%esi
  808f79:	48 89 c7             	mov    %rax,%rdi
  808f7c:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  808f83:	00 00 00 
  808f86:	ff d0                	callq  *%rax
}
  808f88:	c9                   	leaveq 
  808f89:	c3                   	retq   

0000000000808f8a <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  808f8a:	55                   	push   %rbp
  808f8b:	48 89 e5             	mov    %rsp,%rbp
  808f8e:	48 83 ec 20          	sub    $0x20,%rsp
  808f92:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  808f96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808f9a:	48 8b 40 38          	mov    0x38(%rax),%rax
  808f9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  808fa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fa6:	be 36 00 00 00       	mov    $0x36,%esi
  808fab:	48 89 c7             	mov    %rax,%rdi
  808fae:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  808fb5:	00 00 00 
  808fb8:	ff d0                	callq  *%rax
  808fba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  808fbe:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808fc3:	74 69                	je     80902e <dhcp_handle_offer+0xa4>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  808fc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808fc9:	48 83 c0 02          	add    $0x2,%rax
  808fcd:	48 89 c7             	mov    %rax,%rdi
  808fd0:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  808fd7:	00 00 00 
  808fda:	ff d0                	callq  *%rax
  808fdc:	89 c7                	mov    %eax,%edi
  808fde:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  808fe5:	00 00 00 
  808fe8:	ff d0                	callq  *%rax
  808fea:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808fee:	89 42 48             	mov    %eax,0x48(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  808ff1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ff5:	48 8b 40 18          	mov    0x18(%rax),%rax
  808ff9:	48 83 c0 10          	add    $0x10,%rax
  808ffd:	48 85 c0             	test   %rax,%rax
  809000:	74 0d                	je     80900f <dhcp_handle_offer+0x85>
  809002:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809006:	48 8b 40 18          	mov    0x18(%rax),%rax
  80900a:	8b 40 10             	mov    0x10(%rax),%eax
  80900d:	eb 05                	jmp    809014 <dhcp_handle_offer+0x8a>
  80900f:	b8 00 00 00 00       	mov    $0x0,%eax
  809014:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809018:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  80901b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80901f:	48 89 c7             	mov    %rax,%rdi
  809022:	48 b8 30 90 80 00 00 	movabs $0x809030,%rax
  809029:	00 00 00 
  80902c:	ff d0                	callq  *%rax
  }
}
  80902e:	c9                   	leaveq 
  80902f:	c3                   	retq   

0000000000809030 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  809030:	55                   	push   %rbp
  809031:	48 89 e5             	mov    %rsp,%rbp
  809034:	48 83 ec 20          	sub    $0x20,%rsp
  809038:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80903c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809040:	48 8b 40 38          	mov    0x38(%rax),%rax
  809044:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809048:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80904c:	48 89 c7             	mov    %rax,%rdi
  80904f:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  809056:	00 00 00 
  809059:	ff d0                	callq  *%rax
  80905b:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80905e:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809062:	0f 85 3a 02 00 00    	jne    8092a2 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80906c:	ba 01 00 00 00       	mov    $0x1,%edx
  809071:	be 35 00 00 00       	mov    $0x35,%esi
  809076:	48 89 c7             	mov    %rax,%rdi
  809079:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809080:	00 00 00 
  809083:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  809085:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809089:	be 03 00 00 00       	mov    $0x3,%esi
  80908e:	48 89 c7             	mov    %rax,%rdi
  809091:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  809098:	00 00 00 
  80909b:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80909d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090a1:	ba 02 00 00 00       	mov    $0x2,%edx
  8090a6:	be 39 00 00 00       	mov    $0x39,%esi
  8090ab:	48 89 c7             	mov    %rax,%rdi
  8090ae:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  8090b5:	00 00 00 
  8090b8:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  8090ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090be:	be 40 02 00 00       	mov    $0x240,%esi
  8090c3:	48 89 c7             	mov    %rax,%rdi
  8090c6:	48 b8 55 ad 80 00 00 	movabs $0x80ad55,%rax
  8090cd:	00 00 00 
  8090d0:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8090d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090d6:	ba 04 00 00 00       	mov    $0x4,%edx
  8090db:	be 32 00 00 00       	mov    $0x32,%esi
  8090e0:	48 89 c7             	mov    %rax,%rdi
  8090e3:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  8090ea:	00 00 00 
  8090ed:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8090ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090f3:	8b 40 4c             	mov    0x4c(%rax),%eax
  8090f6:	89 c7                	mov    %eax,%edi
  8090f8:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  8090ff:	00 00 00 
  809102:	ff d0                	callq  *%rax
  809104:	89 c2                	mov    %eax,%edx
  809106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80910a:	89 d6                	mov    %edx,%esi
  80910c:	48 89 c7             	mov    %rax,%rdi
  80910f:	48 b8 04 ae 80 00 00 	movabs $0x80ae04,%rax
  809116:	00 00 00 
  809119:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80911b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80911f:	ba 04 00 00 00       	mov    $0x4,%edx
  809124:	be 36 00 00 00       	mov    $0x36,%esi
  809129:	48 89 c7             	mov    %rax,%rdi
  80912c:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809133:	00 00 00 
  809136:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  809138:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80913c:	8b 40 48             	mov    0x48(%rax),%eax
  80913f:	89 c7                	mov    %eax,%edi
  809141:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  809148:	00 00 00 
  80914b:	ff d0                	callq  *%rax
  80914d:	89 c2                	mov    %eax,%edx
  80914f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809153:	89 d6                	mov    %edx,%esi
  809155:	48 89 c7             	mov    %rax,%rdi
  809158:	48 b8 04 ae 80 00 00 	movabs $0x80ae04,%rax
  80915f:	00 00 00 
  809162:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  809164:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809168:	ba 04 00 00 00       	mov    $0x4,%edx
  80916d:	be 37 00 00 00       	mov    $0x37,%esi
  809172:	48 89 c7             	mov    %rax,%rdi
  809175:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80917c:	00 00 00 
  80917f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  809181:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809185:	be 01 00 00 00       	mov    $0x1,%esi
  80918a:	48 89 c7             	mov    %rax,%rdi
  80918d:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  809194:	00 00 00 
  809197:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  809199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80919d:	be 03 00 00 00       	mov    $0x3,%esi
  8091a2:	48 89 c7             	mov    %rax,%rdi
  8091a5:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  8091ac:	00 00 00 
  8091af:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8091b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091b5:	be 1c 00 00 00       	mov    $0x1c,%esi
  8091ba:	48 89 c7             	mov    %rax,%rdi
  8091bd:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  8091c4:	00 00 00 
  8091c7:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8091c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091cd:	be 06 00 00 00       	mov    $0x6,%esi
  8091d2:	48 89 c7             	mov    %rax,%rdi
  8091d5:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  8091dc:	00 00 00 
  8091df:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8091e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091e5:	48 89 c7             	mov    %rax,%rdi
  8091e8:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  8091ef:	00 00 00 
  8091f2:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8091f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091f8:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8091fc:	66 05 f0 00          	add    $0xf0,%ax
  809200:	0f b7 d0             	movzwl %ax,%edx
  809203:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809207:	48 8b 40 30          	mov    0x30(%rax),%rax
  80920b:	89 d6                	mov    %edx,%esi
  80920d:	48 89 c7             	mov    %rax,%rdi
  809210:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  809217:	00 00 00 
  80921a:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80921c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809220:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809228:	48 8b 40 08          	mov    0x8(%rax),%rax
  80922c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809230:	49 89 d0             	mov    %rdx,%r8
  809233:	b9 43 00 00 00       	mov    $0x43,%ecx
  809238:	48 ba 2c 20 82 00 00 	movabs $0x82202c,%rdx
  80923f:	00 00 00 
  809242:	48 89 c7             	mov    %rax,%rdi
  809245:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  80924c:	00 00 00 
  80924f:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809251:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809255:	48 8b 40 08          	mov    0x8(%rax),%rax
  809259:	ba 43 00 00 00       	mov    $0x43,%edx
  80925e:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  809265:	00 00 00 
  809268:	48 89 c7             	mov    %rax,%rdi
  80926b:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  809272:	00 00 00 
  809275:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809277:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80927b:	48 89 c7             	mov    %rax,%rdi
  80927e:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  809285:	00 00 00 
  809288:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80928a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80928e:	be 01 00 00 00       	mov    $0x1,%esi
  809293:	48 89 c7             	mov    %rax,%rdi
  809296:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  80929d:	00 00 00 
  8092a0:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8092a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092a6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8092aa:	8d 50 01             	lea    0x1(%rax),%edx
  8092ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092b1:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8092b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092b8:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8092bc:	3c 03                	cmp    $0x3,%al
  8092be:	77 12                	ja     8092d2 <dhcp_select+0x2a2>
  8092c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092c4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8092c8:	0f b6 c0             	movzbl %al,%eax
  8092cb:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  8092d0:	eb 05                	jmp    8092d7 <dhcp_select+0x2a7>
  8092d2:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  8092d7:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8092db:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8092df:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8092e5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8092ea:	89 c8                	mov    %ecx,%eax
  8092ec:	f7 ea                	imul   %edx
  8092ee:	c1 fa 05             	sar    $0x5,%edx
  8092f1:	89 c8                	mov    %ecx,%eax
  8092f3:	c1 f8 1f             	sar    $0x1f,%eax
  8092f6:	89 d1                	mov    %edx,%ecx
  8092f8:	29 c1                	sub    %eax,%ecx
  8092fa:	89 c8                	mov    %ecx,%eax
  8092fc:	89 c2                	mov    %eax,%edx
  8092fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809302:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  809306:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80930a:	c9                   	leaveq 
  80930b:	c3                   	retq   

000000000080930c <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  80930c:	55                   	push   %rbp
  80930d:	48 89 e5             	mov    %rsp,%rbp
  809310:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  809314:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80931b:	00 00 00 
  80931e:	48 8b 00             	mov    (%rax),%rax
  809321:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  809325:	eb 7c                	jmp    8093a3 <dhcp_coarse_tmr+0x97>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  809327:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80932b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80932f:	48 85 c0             	test   %rax,%rax
  809332:	74 64                	je     809398 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  809334:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809338:	48 8b 40 38          	mov    0x38(%rax),%rax
  80933c:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  809340:	66 83 fa 01          	cmp    $0x1,%dx
  809344:	0f 94 c1             	sete   %cl
  809347:	83 ea 01             	sub    $0x1,%edx
  80934a:	66 89 50 46          	mov    %dx,0x46(%rax)
  80934e:	84 c9                	test   %cl,%cl
  809350:	74 15                	je     809367 <dhcp_coarse_tmr+0x5b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  809352:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809356:	48 89 c7             	mov    %rax,%rdi
  809359:	48 b8 f1 95 80 00 00 	movabs $0x8095f1,%rax
  809360:	00 00 00 
  809363:	ff d0                	callq  *%rax
  809365:	eb 31                	jmp    809398 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  809367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80936b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80936f:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  809373:	66 83 fa 01          	cmp    $0x1,%dx
  809377:	0f 94 c1             	sete   %cl
  80937a:	83 ea 01             	sub    $0x1,%edx
  80937d:	66 89 50 44          	mov    %dx,0x44(%rax)
  809381:	84 c9                	test   %cl,%cl
  809383:	74 13                	je     809398 <dhcp_coarse_tmr+0x8c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  809385:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809389:	48 89 c7             	mov    %rax,%rdi
  80938c:	48 b8 a3 95 80 00 00 	movabs $0x8095a3,%rax
  809393:	00 00 00 
  809396:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  809398:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80939c:	48 8b 00             	mov    (%rax),%rax
  80939f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8093a3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8093a8:	0f 85 79 ff ff ff    	jne    809327 <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  8093ae:	c9                   	leaveq 
  8093af:	c3                   	retq   

00000000008093b0 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  8093b0:	55                   	push   %rbp
  8093b1:	48 89 e5             	mov    %rsp,%rbp
  8093b4:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  8093b8:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8093bf:	00 00 00 
  8093c2:	48 8b 00             	mov    (%rax),%rax
  8093c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  8093c9:	eb 77                	jmp    809442 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8093cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093cf:	48 8b 40 38          	mov    0x38(%rax),%rax
  8093d3:	48 85 c0             	test   %rax,%rax
  8093d6:	74 5f                	je     809437 <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8093d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093dc:	48 8b 40 38          	mov    0x38(%rax),%rax
  8093e0:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8093e4:	66 83 f8 01          	cmp    $0x1,%ax
  8093e8:	76 15                	jbe    8093ff <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  8093ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093ee:	48 8b 40 38          	mov    0x38(%rax),%rax
  8093f2:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8093f6:	83 ea 01             	sub    $0x1,%edx
  8093f9:	66 89 50 42          	mov    %dx,0x42(%rax)
  8093fd:	eb 38                	jmp    809437 <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8093ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809403:	48 8b 40 38          	mov    0x38(%rax),%rax
  809407:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  80940b:	66 83 f8 01          	cmp    $0x1,%ax
  80940f:	75 26                	jne    809437 <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  809411:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809415:	48 8b 40 38          	mov    0x38(%rax),%rax
  809419:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  80941d:	83 ea 01             	sub    $0x1,%edx
  809420:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  809424:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809428:	48 89 c7             	mov    %rax,%rdi
  80942b:	48 b8 4b 94 80 00 00 	movabs $0x80944b,%rax
  809432:	00 00 00 
  809435:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  809437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80943b:	48 8b 00             	mov    (%rax),%rax
  80943e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  809442:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809447:	75 82                	jne    8093cb <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  809449:	c9                   	leaveq 
  80944a:	c3                   	retq   

000000000080944b <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  80944b:	55                   	push   %rbp
  80944c:	48 89 e5             	mov    %rsp,%rbp
  80944f:	48 83 ec 20          	sub    $0x20,%rsp
  809453:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80945b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80945f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809463:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809467:	0f b6 00             	movzbl (%rax),%eax
  80946a:	3c 0c                	cmp    $0xc,%al
  80946c:	74 0b                	je     809479 <dhcp_timeout+0x2e>
  80946e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809472:	0f b6 00             	movzbl (%rax),%eax
  809475:	3c 06                	cmp    $0x6,%al
  809477:	75 18                	jne    809491 <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  809479:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80947d:	48 89 c7             	mov    %rax,%rdi
  809480:	48 b8 fa 9f 80 00 00 	movabs $0x809ffa,%rax
  809487:	00 00 00 
  80948a:	ff d0                	callq  *%rax
  80948c:	e9 10 01 00 00       	jmpq   8095a1 <dhcp_timeout+0x156>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809491:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809495:	0f b6 00             	movzbl (%rax),%eax
  809498:	3c 01                	cmp    $0x1,%al
  80949a:	75 4f                	jne    8094eb <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  80949c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094a0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8094a4:	3c 05                	cmp    $0x5,%al
  8094a6:	77 18                	ja     8094c0 <dhcp_timeout+0x75>
      dhcp_select(netif);
  8094a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094ac:	48 89 c7             	mov    %rax,%rdi
  8094af:	48 b8 30 90 80 00 00 	movabs $0x809030,%rax
  8094b6:	00 00 00 
  8094b9:	ff d0                	callq  *%rax
  8094bb:	e9 e1 00 00 00       	jmpq   8095a1 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  8094c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094c4:	48 89 c7             	mov    %rax,%rdi
  8094c7:	48 b8 8b a8 80 00 00 	movabs $0x80a88b,%rax
  8094ce:	00 00 00 
  8094d1:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  8094d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8094d7:	48 89 c7             	mov    %rax,%rdi
  8094da:	48 b8 fa 9f 80 00 00 	movabs $0x809ffa,%rax
  8094e1:	00 00 00 
  8094e4:	ff d0                	callq  *%rax
  8094e6:	e9 b6 00 00 00       	jmpq   8095a1 <dhcp_timeout+0x156>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8094eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094ef:	0f b6 00             	movzbl (%rax),%eax
  8094f2:	3c 08                	cmp    $0x8,%al
  8094f4:	75 39                	jne    80952f <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  8094f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094fa:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8094fe:	3c 01                	cmp    $0x1,%al
  809500:	77 18                	ja     80951a <dhcp_timeout+0xcf>
      dhcp_check(netif);
  809502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809506:	48 89 c7             	mov    %rax,%rdi
  809509:	48 b8 ef 8e 80 00 00 	movabs $0x808eef,%rax
  809510:	00 00 00 
  809513:	ff d0                	callq  *%rax
  809515:	e9 87 00 00 00       	jmpq   8095a1 <dhcp_timeout+0x156>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  80951a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80951e:	48 89 c7             	mov    %rax,%rdi
  809521:	48 b8 5e a2 80 00 00 	movabs $0x80a25e,%rax
  809528:	00 00 00 
  80952b:	ff d0                	callq  *%rax
  80952d:	eb 72                	jmp    8095a1 <dhcp_timeout+0x156>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  80952f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809533:	0f b6 00             	movzbl (%rax),%eax
  809536:	3c 05                	cmp    $0x5,%al
  809538:	75 15                	jne    80954f <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  80953a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80953e:	48 89 c7             	mov    %rax,%rdi
  809541:	48 b8 f2 a4 80 00 00 	movabs $0x80a4f2,%rax
  809548:	00 00 00 
  80954b:	ff d0                	callq  *%rax
  80954d:	eb 52                	jmp    8095a1 <dhcp_timeout+0x156>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  80954f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809553:	0f b6 00             	movzbl (%rax),%eax
  809556:	3c 04                	cmp    $0x4,%al
  809558:	75 47                	jne    8095a1 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  80955a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80955e:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809562:	3c 08                	cmp    $0x8,%al
  809564:	77 15                	ja     80957b <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  809566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80956a:	48 89 c7             	mov    %rax,%rdi
  80956d:	48 b8 be a6 80 00 00 	movabs $0x80a6be,%rax
  809574:	00 00 00 
  809577:	ff d0                	callq  *%rax
  809579:	eb 26                	jmp    8095a1 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  80957b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80957f:	48 89 c7             	mov    %rax,%rdi
  809582:	48 b8 8b a8 80 00 00 	movabs $0x80a88b,%rax
  809589:	00 00 00 
  80958c:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  80958e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809592:	48 89 c7             	mov    %rax,%rdi
  809595:	48 b8 fa 9f 80 00 00 	movabs $0x809ffa,%rax
  80959c:	00 00 00 
  80959f:	ff d0                	callq  *%rax
    }
  }
}
  8095a1:	c9                   	leaveq 
  8095a2:	c3                   	retq   

00000000008095a3 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  8095a3:	55                   	push   %rbp
  8095a4:	48 89 e5             	mov    %rsp,%rbp
  8095a7:	48 83 ec 20          	sub    $0x20,%rsp
  8095ab:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8095af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095b3:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8095bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095bf:	0f b6 00             	movzbl (%rax),%eax
  8095c2:	3c 01                	cmp    $0x1,%al
  8095c4:	74 16                	je     8095dc <dhcp_t1_timeout+0x39>
  8095c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095ca:	0f b6 00             	movzbl (%rax),%eax
  8095cd:	3c 0a                	cmp    $0xa,%al
  8095cf:	74 0b                	je     8095dc <dhcp_t1_timeout+0x39>
  8095d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095d5:	0f b6 00             	movzbl (%rax),%eax
  8095d8:	3c 05                	cmp    $0x5,%al
  8095da:	75 13                	jne    8095ef <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  8095dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8095e0:	48 89 c7             	mov    %rax,%rdi
  8095e3:	48 b8 f2 a4 80 00 00 	movabs $0x80a4f2,%rax
  8095ea:	00 00 00 
  8095ed:	ff d0                	callq  *%rax
  }
}
  8095ef:	c9                   	leaveq 
  8095f0:	c3                   	retq   

00000000008095f1 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  8095f1:	55                   	push   %rbp
  8095f2:	48 89 e5             	mov    %rsp,%rbp
  8095f5:	48 83 ec 20          	sub    $0x20,%rsp
  8095f9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8095fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809601:	48 8b 40 38          	mov    0x38(%rax),%rax
  809605:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  809609:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80960d:	0f b6 00             	movzbl (%rax),%eax
  809610:	3c 01                	cmp    $0x1,%al
  809612:	74 16                	je     80962a <dhcp_t2_timeout+0x39>
  809614:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809618:	0f b6 00             	movzbl (%rax),%eax
  80961b:	3c 0a                	cmp    $0xa,%al
  80961d:	74 0b                	je     80962a <dhcp_t2_timeout+0x39>
  80961f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809623:	0f b6 00             	movzbl (%rax),%eax
  809626:	3c 05                	cmp    $0x5,%al
  809628:	75 13                	jne    80963d <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  80962a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80962e:	48 89 c7             	mov    %rax,%rdi
  809631:	48 b8 be a6 80 00 00 	movabs $0x80a6be,%rax
  809638:	00 00 00 
  80963b:	ff d0                	callq  *%rax
  }
}
  80963d:	c9                   	leaveq 
  80963e:	c3                   	retq   

000000000080963f <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  80963f:	55                   	push   %rbp
  809640:	48 89 e5             	mov    %rsp,%rbp
  809643:	53                   	push   %rbx
  809644:	48 83 ec 38          	sub    $0x38,%rsp
  809648:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80964c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809650:	48 8b 40 38          	mov    0x38(%rax),%rax
  809654:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809658:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80965c:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809663:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809667:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  80966e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809672:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809679:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80967d:	be 33 00 00 00       	mov    $0x33,%esi
  809682:	48 89 c7             	mov    %rax,%rdi
  809685:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  80968c:	00 00 00 
  80968f:	ff d0                	callq  *%rax
  809691:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809695:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80969a:	74 1e                	je     8096ba <dhcp_handle_ack+0x7b>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80969c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8096a0:	48 83 c0 02          	add    $0x2,%rax
  8096a4:	48 89 c7             	mov    %rax,%rdi
  8096a7:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  8096ae:	00 00 00 
  8096b1:	ff d0                	callq  *%rax
  8096b3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8096b7:	89 42 68             	mov    %eax,0x68(%rdx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  8096ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8096be:	be 3a 00 00 00       	mov    $0x3a,%esi
  8096c3:	48 89 c7             	mov    %rax,%rdi
  8096c6:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  8096cd:	00 00 00 
  8096d0:	ff d0                	callq  *%rax
  8096d2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8096d6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8096db:	74 20                	je     8096fd <dhcp_handle_ack+0xbe>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8096dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8096e1:	48 83 c0 02          	add    $0x2,%rax
  8096e5:	48 89 c7             	mov    %rax,%rdi
  8096e8:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  8096ef:	00 00 00 
  8096f2:	ff d0                	callq  *%rax
  8096f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8096f8:	89 42 6c             	mov    %eax,0x6c(%rdx)
  8096fb:	eb 12                	jmp    80970f <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8096fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809701:	8b 40 68             	mov    0x68(%rax),%eax
  809704:	89 c2                	mov    %eax,%edx
  809706:	d1 ea                	shr    %edx
  809708:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80970c:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  80970f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809713:	be 3b 00 00 00       	mov    $0x3b,%esi
  809718:	48 89 c7             	mov    %rax,%rdi
  80971b:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  809722:	00 00 00 
  809725:	ff d0                	callq  *%rax
  809727:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80972b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809730:	74 20                	je     809752 <dhcp_handle_ack+0x113>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809732:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809736:	48 83 c0 02          	add    $0x2,%rax
  80973a:	48 89 c7             	mov    %rax,%rdi
  80973d:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  809744:	00 00 00 
  809747:	ff d0                	callq  *%rax
  809749:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80974d:	89 42 70             	mov    %eax,0x70(%rdx)
  809750:	eb 0e                	jmp    809760 <dhcp_handle_ack+0x121>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809752:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809756:	8b 50 68             	mov    0x68(%rax),%edx
  809759:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80975d:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809760:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809764:	48 8b 40 18          	mov    0x18(%rax),%rax
  809768:	48 83 c0 10          	add    $0x10,%rax
  80976c:	48 85 c0             	test   %rax,%rax
  80976f:	74 0d                	je     80977e <dhcp_handle_ack+0x13f>
  809771:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809775:	48 8b 40 18          	mov    0x18(%rax),%rax
  809779:	8b 40 10             	mov    0x10(%rax),%eax
  80977c:	eb 05                	jmp    809783 <dhcp_handle_ack+0x144>
  80977e:	b8 00 00 00 00       	mov    $0x0,%eax
  809783:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809787:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  80978a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80978e:	be 01 00 00 00       	mov    $0x1,%esi
  809793:	48 89 c7             	mov    %rax,%rdi
  809796:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  80979d:	00 00 00 
  8097a0:	ff d0                	callq  *%rax
  8097a2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8097a6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8097ab:	74 2c                	je     8097d9 <dhcp_handle_ack+0x19a>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8097ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8097b1:	48 83 c0 02          	add    $0x2,%rax
  8097b5:	48 89 c7             	mov    %rax,%rdi
  8097b8:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  8097bf:	00 00 00 
  8097c2:	ff d0                	callq  *%rax
  8097c4:	89 c7                	mov    %eax,%edi
  8097c6:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  8097cd:	00 00 00 
  8097d0:	ff d0                	callq  *%rax
  8097d2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8097d6:	89 42 50             	mov    %eax,0x50(%rdx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8097d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8097dd:	be 03 00 00 00       	mov    $0x3,%esi
  8097e2:	48 89 c7             	mov    %rax,%rdi
  8097e5:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  8097ec:	00 00 00 
  8097ef:	ff d0                	callq  *%rax
  8097f1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8097f5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8097fa:	74 2c                	je     809828 <dhcp_handle_ack+0x1e9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8097fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809800:	48 83 c0 02          	add    $0x2,%rax
  809804:	48 89 c7             	mov    %rax,%rdi
  809807:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  80980e:	00 00 00 
  809811:	ff d0                	callq  *%rax
  809813:	89 c7                	mov    %eax,%edi
  809815:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80981c:	00 00 00 
  80981f:	ff d0                	callq  *%rax
  809821:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809825:	89 42 54             	mov    %eax,0x54(%rdx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809828:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80982c:	be 1c 00 00 00       	mov    $0x1c,%esi
  809831:	48 89 c7             	mov    %rax,%rdi
  809834:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  80983b:	00 00 00 
  80983e:	ff d0                	callq  *%rax
  809840:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809844:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809849:	74 2c                	je     809877 <dhcp_handle_ack+0x238>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80984b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80984f:	48 83 c0 02          	add    $0x2,%rax
  809853:	48 89 c7             	mov    %rax,%rdi
  809856:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  80985d:	00 00 00 
  809860:	ff d0                	callq  *%rax
  809862:	89 c7                	mov    %eax,%edi
  809864:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80986b:	00 00 00 
  80986e:	ff d0                	callq  *%rax
  809870:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809874:	89 42 58             	mov    %eax,0x58(%rdx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809877:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80987b:	be 06 00 00 00       	mov    $0x6,%esi
  809880:	48 89 c7             	mov    %rax,%rdi
  809883:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  80988a:	00 00 00 
  80988d:	ff d0                	callq  *%rax
  80988f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809893:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809898:	0f 84 93 00 00 00    	je     809931 <dhcp_handle_ack+0x2f2>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  80989e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8098a2:	48 83 c0 01          	add    $0x1,%rax
  8098a6:	48 89 c7             	mov    %rax,%rdi
  8098a9:	48 b8 51 bb 80 00 00 	movabs $0x80bb51,%rax
  8098b0:	00 00 00 
  8098b3:	ff d0                	callq  *%rax
  8098b5:	c0 e8 02             	shr    $0x2,%al
  8098b8:	0f b6 d0             	movzbl %al,%edx
  8098bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8098bf:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  8098c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8098c6:	8b 40 5c             	mov    0x5c(%rax),%eax
  8098c9:	83 f8 02             	cmp    $0x2,%eax
  8098cc:	76 0b                	jbe    8098d9 <dhcp_handle_ack+0x29a>
      dhcp->dns_count = DHCP_MAX_DNS;
  8098ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8098d2:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  8098d9:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  8098dd:	eb 43                	jmp    809922 <dhcp_handle_ack+0x2e3>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  8098df:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  8098e3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8098e7:	c1 e0 02             	shl    $0x2,%eax
  8098ea:	83 c0 02             	add    $0x2,%eax
  8098ed:	48 98                	cltq   
  8098ef:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8098f3:	48 89 c7             	mov    %rax,%rdi
  8098f6:	48 b8 66 bb 80 00 00 	movabs $0x80bb66,%rax
  8098fd:	00 00 00 
  809900:	ff d0                	callq  *%rax
  809902:	89 c7                	mov    %eax,%edi
  809904:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80990b:	00 00 00 
  80990e:	ff d0                	callq  *%rax
  809910:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809914:	48 63 cb             	movslq %ebx,%rcx
  809917:	48 83 c1 18          	add    $0x18,%rcx
  80991b:	89 04 8a             	mov    %eax,(%rdx,%rcx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  80991e:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  809922:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809926:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80992a:	8b 40 5c             	mov    0x5c(%rax),%eax
  80992d:	39 c2                	cmp    %eax,%edx
  80992f:	72 ae                	jb     8098df <dhcp_handle_ack+0x2a0>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809931:	48 83 c4 38          	add    $0x38,%rsp
  809935:	5b                   	pop    %rbx
  809936:	5d                   	pop    %rbp
  809937:	c3                   	retq   

0000000000809938 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809938:	55                   	push   %rbp
  809939:	48 89 e5             	mov    %rsp,%rbp
  80993c:	48 83 ec 20          	sub    $0x20,%rsp
  809940:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809944:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809948:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80994d:	75 2a                	jne    809979 <dhcp_start+0x41>
  80994f:	48 ba 28 12 82 00 00 	movabs $0x821228,%rdx
  809956:	00 00 00 
  809959:	be 38 02 00 00       	mov    $0x238,%esi
  80995e:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  809965:	00 00 00 
  809968:	b8 00 00 00 00       	mov    $0x0,%eax
  80996d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  809974:	00 00 00 
  809977:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809979:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80997d:	48 8b 40 38          	mov    0x38(%rax),%rax
  809981:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809989:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80998d:	89 c2                	mov    %eax,%edx
  80998f:	83 e2 f7             	and    $0xfffffff7,%edx
  809992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809996:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809999:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80999e:	75 32                	jne    8099d2 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8099a0:	bf 78 00 00 00       	mov    $0x78,%edi
  8099a5:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  8099ac:	00 00 00 
  8099af:	ff d0                	callq  *%rax
  8099b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  8099b5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8099ba:	75 0a                	jne    8099c6 <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  8099bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8099c1:	e9 3a 01 00 00       	jmpq   809b00 <dhcp_start+0x1c8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8099c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8099ca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8099ce:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8099d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8099d6:	ba 78 00 00 00       	mov    $0x78,%edx
  8099db:	be 00 00 00 00       	mov    $0x0,%esi
  8099e0:	48 89 c7             	mov    %rax,%rdi
  8099e3:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  8099ea:	00 00 00 
  8099ed:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8099ef:	48 b8 09 54 81 00 00 	movabs $0x815409,%rax
  8099f6:	00 00 00 
  8099f9:	ff d0                	callq  *%rax
  8099fb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8099ff:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809a03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a07:	48 8b 40 08          	mov    0x8(%rax),%rax
  809a0b:	48 85 c0             	test   %rax,%rax
  809a0e:	75 31                	jne    809a41 <dhcp_start+0x109>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  809a10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a14:	48 89 c7             	mov    %rax,%rdi
  809a17:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  809a1e:	00 00 00 
  809a21:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  809a23:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  809a2a:	00 
  809a2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809a2f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809a33:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  809a37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809a3c:	e9 bf 00 00 00       	jmpq   809b00 <dhcp_start+0x1c8>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809a41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a45:	48 8b 40 08          	mov    0x8(%rax),%rax
  809a49:	ba 44 00 00 00       	mov    $0x44,%edx
  809a4e:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  809a55:	00 00 00 
  809a58:	48 89 c7             	mov    %rax,%rdi
  809a5b:	48 b8 b3 50 81 00 00 	movabs $0x8150b3,%rax
  809a62:	00 00 00 
  809a65:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809a67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a6b:	48 8b 40 08          	mov    0x8(%rax),%rax
  809a6f:	ba 43 00 00 00       	mov    $0x43,%edx
  809a74:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  809a7b:	00 00 00 
  809a7e:	48 89 c7             	mov    %rax,%rdi
  809a81:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  809a88:	00 00 00 
  809a8b:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  809a8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809a91:	48 8b 40 08          	mov    0x8(%rax),%rax
  809a95:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809a99:	48 be ad b1 80 00 00 	movabs $0x80b1ad,%rsi
  809aa0:	00 00 00 
  809aa3:	48 89 c7             	mov    %rax,%rdi
  809aa6:	48 b8 31 53 81 00 00 	movabs $0x815331,%rax
  809aad:	00 00 00 
  809ab0:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  809ab2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ab6:	48 89 c7             	mov    %rax,%rdi
  809ab9:	48 b8 fa 9f 80 00 00 	movabs $0x809ffa,%rax
  809ac0:	00 00 00 
  809ac3:	ff d0                	callq  *%rax
  809ac5:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  809ac8:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809acc:	74 1a                	je     809ae8 <dhcp_start+0x1b0>
    /* free resources allocated above */
    dhcp_stop(netif);
  809ace:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ad2:	48 89 c7             	mov    %rax,%rdi
  809ad5:	48 b8 fb aa 80 00 00 	movabs $0x80aafb,%rax
  809adc:	00 00 00 
  809adf:	ff d0                	callq  *%rax
    return ERR_MEM;
  809ae1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ae6:	eb 18                	jmp    809b00 <dhcp_start+0x1c8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  809ae8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809aec:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809af0:	89 c2                	mov    %eax,%edx
  809af2:	83 ca 08             	or     $0x8,%edx
  809af5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809af9:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  809afc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809b00:	c9                   	leaveq 
  809b01:	c3                   	retq   

0000000000809b02 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  809b02:	55                   	push   %rbp
  809b03:	48 89 e5             	mov    %rsp,%rbp
  809b06:	48 83 ec 30          	sub    $0x30,%rsp
  809b0a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  809b0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809b12:	48 8b 40 38          	mov    0x38(%rax),%rax
  809b16:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809b1a:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  809b1e:	bf 78 00 00 00       	mov    $0x78,%edi
  809b23:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  809b2a:	00 00 00 
  809b2d:	ff d0                	callq  *%rax
  809b2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  809b33:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809b38:	0f 84 39 02 00 00    	je     809d77 <dhcp_inform+0x275>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  809b3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809b42:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809b46:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  809b4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b4e:	ba 78 00 00 00       	mov    $0x78,%edx
  809b53:	be 00 00 00 00       	mov    $0x0,%esi
  809b58:	48 89 c7             	mov    %rax,%rdi
  809b5b:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  809b62:	00 00 00 
  809b65:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  809b67:	48 b8 09 54 81 00 00 	movabs $0x815409,%rax
  809b6e:	00 00 00 
  809b71:	ff d0                	callq  *%rax
  809b73:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809b77:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809b7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809b83:	48 85 c0             	test   %rax,%rax
  809b86:	75 18                	jne    809ba0 <dhcp_inform+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  809b88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b8c:	48 89 c7             	mov    %rax,%rdi
  809b8f:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  809b96:	00 00 00 
  809b99:	ff d0                	callq  *%rax
    return;
  809b9b:	e9 d8 01 00 00       	jmpq   809d78 <dhcp_inform+0x276>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809ba0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ba4:	48 89 c7             	mov    %rax,%rdi
  809ba7:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  809bae:	00 00 00 
  809bb1:	ff d0                	callq  *%rax
  809bb3:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809bb6:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809bba:	0f 85 5f 01 00 00    	jne    809d1f <dhcp_inform+0x21d>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809bc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bc4:	ba 01 00 00 00       	mov    $0x1,%edx
  809bc9:	be 35 00 00 00       	mov    $0x35,%esi
  809bce:	48 89 c7             	mov    %rax,%rdi
  809bd1:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809bd8:	00 00 00 
  809bdb:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  809bdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809be1:	be 08 00 00 00       	mov    $0x8,%esi
  809be6:	48 89 c7             	mov    %rax,%rdi
  809be9:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  809bf0:	00 00 00 
  809bf3:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809bf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809bf9:	ba 02 00 00 00       	mov    $0x2,%edx
  809bfe:	be 39 00 00 00       	mov    $0x39,%esi
  809c03:	48 89 c7             	mov    %rax,%rdi
  809c06:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809c0d:	00 00 00 
  809c10:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  809c12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c16:	be 40 02 00 00       	mov    $0x240,%esi
  809c1b:	48 89 c7             	mov    %rax,%rdi
  809c1e:	48 b8 55 ad 80 00 00 	movabs $0x80ad55,%rax
  809c25:	00 00 00 
  809c28:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809c2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c2e:	48 89 c7             	mov    %rax,%rdi
  809c31:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  809c38:	00 00 00 
  809c3b:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809c3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c41:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809c45:	66 05 f0 00          	add    $0xf0,%ax
  809c49:	0f b7 d0             	movzwl %ax,%edx
  809c4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c50:	48 8b 40 30          	mov    0x30(%rax),%rax
  809c54:	89 d6                	mov    %edx,%esi
  809c56:	48 89 c7             	mov    %rax,%rdi
  809c59:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  809c60:	00 00 00 
  809c63:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809c65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c69:	48 8b 40 08          	mov    0x8(%rax),%rax
  809c6d:	ba 44 00 00 00       	mov    $0x44,%edx
  809c72:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  809c79:	00 00 00 
  809c7c:	48 89 c7             	mov    %rax,%rdi
  809c7f:	48 b8 b3 50 81 00 00 	movabs $0x8150b3,%rax
  809c86:	00 00 00 
  809c89:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  809c8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c8f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809c93:	ba 43 00 00 00       	mov    $0x43,%edx
  809c98:	48 be 2c 20 82 00 00 	movabs $0x82202c,%rsi
  809c9f:	00 00 00 
  809ca2:	48 89 c7             	mov    %rax,%rdi
  809ca5:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  809cac:	00 00 00 
  809caf:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809cb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809cb5:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809cb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809cbd:	48 8b 40 08          	mov    0x8(%rax),%rax
  809cc1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  809cc5:	49 89 d0             	mov    %rdx,%r8
  809cc8:	b9 43 00 00 00       	mov    $0x43,%ecx
  809ccd:	48 ba 2c 20 82 00 00 	movabs $0x82202c,%rdx
  809cd4:	00 00 00 
  809cd7:	48 89 c7             	mov    %rax,%rdi
  809cda:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  809ce1:	00 00 00 
  809ce4:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809ce6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809cea:	48 8b 40 08          	mov    0x8(%rax),%rax
  809cee:	ba 43 00 00 00       	mov    $0x43,%edx
  809cf3:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  809cfa:	00 00 00 
  809cfd:	48 89 c7             	mov    %rax,%rdi
  809d00:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  809d07:	00 00 00 
  809d0a:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809d0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d10:	48 89 c7             	mov    %rax,%rdi
  809d13:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  809d1a:	00 00 00 
  809d1d:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  809d1f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809d24:	74 52                	je     809d78 <dhcp_inform+0x276>
    if (dhcp->pcb != NULL) {
  809d26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d2a:	48 8b 40 08          	mov    0x8(%rax),%rax
  809d2e:	48 85 c0             	test   %rax,%rax
  809d31:	74 17                	je     809d4a <dhcp_inform+0x248>
      udp_remove(dhcp->pcb);
  809d33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d37:	48 8b 40 08          	mov    0x8(%rax),%rax
  809d3b:	48 89 c7             	mov    %rax,%rdi
  809d3e:	48 b8 5f 53 81 00 00 	movabs $0x81535f,%rax
  809d45:	00 00 00 
  809d48:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  809d4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d4e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  809d55:	00 
    mem_free((void *)dhcp);
  809d56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d5a:	48 89 c7             	mov    %rax,%rdi
  809d5d:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  809d64:	00 00 00 
  809d67:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  809d69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d6d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809d71:	48 89 50 38          	mov    %rdx,0x38(%rax)
  809d75:	eb 01                	jmp    809d78 <dhcp_inform+0x276>
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  809d77:	90                   	nop
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  809d78:	c9                   	leaveq 
  809d79:	c3                   	retq   

0000000000809d7a <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  809d7a:	55                   	push   %rbp
  809d7b:	48 89 e5             	mov    %rsp,%rbp
  809d7e:	48 83 ec 10          	sub    $0x10,%rsp
  809d82:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809d86:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809d8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809d8f:	75 2a                	jne    809dbb <dhcp_arp_reply+0x41>
  809d91:	48 ba 28 12 82 00 00 	movabs $0x821228,%rdx
  809d98:	00 00 00 
  809d9b:	be b5 02 00 00       	mov    $0x2b5,%esi
  809da0:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  809da7:	00 00 00 
  809daa:	b8 00 00 00 00       	mov    $0x0,%eax
  809daf:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  809db6:	00 00 00 
  809db9:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  809dbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809dbf:	48 8b 40 38          	mov    0x38(%rax),%rax
  809dc3:	48 85 c0             	test   %rax,%rax
  809dc6:	74 37                	je     809dff <dhcp_arp_reply+0x85>
  809dc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809dcc:	48 8b 40 38          	mov    0x38(%rax),%rax
  809dd0:	0f b6 00             	movzbl (%rax),%eax
  809dd3:	3c 08                	cmp    $0x8,%al
  809dd5:	75 28                	jne    809dff <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  809dd7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809ddb:	8b 10                	mov    (%rax),%edx
  809ddd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809de1:	48 8b 40 38          	mov    0x38(%rax),%rax
  809de5:	8b 40 4c             	mov    0x4c(%rax),%eax
  809de8:	39 c2                	cmp    %eax,%edx
  809dea:	75 13                	jne    809dff <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  809dec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809df0:	48 89 c7             	mov    %rax,%rdi
  809df3:	48 b8 01 9e 80 00 00 	movabs $0x809e01,%rax
  809dfa:	00 00 00 
  809dfd:	ff d0                	callq  *%rax
    }
  }
}
  809dff:	c9                   	leaveq 
  809e00:	c3                   	retq   

0000000000809e01 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  809e01:	55                   	push   %rbp
  809e02:	48 89 e5             	mov    %rsp,%rbp
  809e05:	48 83 ec 20          	sub    $0x20,%rsp
  809e09:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809e0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e11:	48 8b 40 38          	mov    0x38(%rax),%rax
  809e15:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809e19:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  809e1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809e21:	be 0c 00 00 00       	mov    $0xc,%esi
  809e26:	48 89 c7             	mov    %rax,%rdi
  809e29:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  809e30:	00 00 00 
  809e33:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809e35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e39:	48 89 c7             	mov    %rax,%rdi
  809e3c:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  809e43:	00 00 00 
  809e46:	ff d0                	callq  *%rax
  809e48:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809e4b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809e4f:	0f 85 5c 01 00 00    	jne    809fb1 <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809e55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809e59:	ba 01 00 00 00       	mov    $0x1,%edx
  809e5e:	be 35 00 00 00       	mov    $0x35,%esi
  809e63:	48 89 c7             	mov    %rax,%rdi
  809e66:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809e6d:	00 00 00 
  809e70:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  809e72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809e76:	be 04 00 00 00       	mov    $0x4,%esi
  809e7b:	48 89 c7             	mov    %rax,%rdi
  809e7e:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  809e85:	00 00 00 
  809e88:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809e8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809e8e:	ba 02 00 00 00       	mov    $0x2,%edx
  809e93:	be 39 00 00 00       	mov    $0x39,%esi
  809e98:	48 89 c7             	mov    %rax,%rdi
  809e9b:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809ea2:	00 00 00 
  809ea5:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  809ea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809eab:	be 40 02 00 00       	mov    $0x240,%esi
  809eb0:	48 89 c7             	mov    %rax,%rdi
  809eb3:	48 b8 55 ad 80 00 00 	movabs $0x80ad55,%rax
  809eba:	00 00 00 
  809ebd:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  809ebf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ec3:	ba 04 00 00 00       	mov    $0x4,%edx
  809ec8:	be 32 00 00 00       	mov    $0x32,%esi
  809ecd:	48 89 c7             	mov    %rax,%rdi
  809ed0:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  809ed7:	00 00 00 
  809eda:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  809edc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ee0:	8b 40 4c             	mov    0x4c(%rax),%eax
  809ee3:	89 c7                	mov    %eax,%edi
  809ee5:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  809eec:	00 00 00 
  809eef:	ff d0                	callq  *%rax
  809ef1:	89 c2                	mov    %eax,%edx
  809ef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ef7:	89 d6                	mov    %edx,%esi
  809ef9:	48 89 c7             	mov    %rax,%rdi
  809efc:	48 b8 04 ae 80 00 00 	movabs $0x80ae04,%rax
  809f03:	00 00 00 
  809f06:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809f08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f0c:	48 89 c7             	mov    %rax,%rdi
  809f0f:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  809f16:	00 00 00 
  809f19:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809f1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f1f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809f23:	66 05 f0 00          	add    $0xf0,%ax
  809f27:	0f b7 d0             	movzwl %ax,%edx
  809f2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f2e:	48 8b 40 30          	mov    0x30(%rax),%rax
  809f32:	89 d6                	mov    %edx,%esi
  809f34:	48 89 c7             	mov    %rax,%rdi
  809f37:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  809f3e:	00 00 00 
  809f41:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809f43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f47:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f4b:	ba 43 00 00 00       	mov    $0x43,%edx
  809f50:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  809f57:	00 00 00 
  809f5a:	48 89 c7             	mov    %rax,%rdi
  809f5d:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  809f64:	00 00 00 
  809f67:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809f69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f6d:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809f71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f75:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f79:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809f7d:	49 89 d0             	mov    %rdx,%r8
  809f80:	b9 43 00 00 00       	mov    $0x43,%ecx
  809f85:	48 ba 2c 20 82 00 00 	movabs $0x82202c,%rdx
  809f8c:	00 00 00 
  809f8f:	48 89 c7             	mov    %rax,%rdi
  809f92:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  809f99:	00 00 00 
  809f9c:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809f9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809fa2:	48 89 c7             	mov    %rax,%rdi
  809fa5:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  809fac:	00 00 00 
  809faf:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809fb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fb5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809fb9:	8d 50 01             	lea    0x1(%rax),%edx
  809fbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fc0:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  809fc3:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  809fc9:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809fcd:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  809fd3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809fd8:	89 c8                	mov    %ecx,%eax
  809fda:	f7 ea                	imul   %edx
  809fdc:	c1 fa 05             	sar    $0x5,%edx
  809fdf:	89 c8                	mov    %ecx,%eax
  809fe1:	c1 f8 1f             	sar    $0x1f,%eax
  809fe4:	89 d1                	mov    %edx,%ecx
  809fe6:	29 c1                	sub    %eax,%ecx
  809fe8:	89 c8                	mov    %ecx,%eax
  809fea:	89 c2                	mov    %eax,%edx
  809fec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809ff0:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  809ff4:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809ff8:	c9                   	leaveq 
  809ff9:	c3                   	retq   

0000000000809ffa <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  809ffa:	55                   	push   %rbp
  809ffb:	48 89 e5             	mov    %rsp,%rbp
  809ffe:	48 83 ec 20          	sub    $0x20,%rsp
  80a002:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a006:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a00a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a00e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a012:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a016:	48 b8 28 20 82 00 00 	movabs $0x822028,%rax
  80a01d:	00 00 00 
  80a020:	8b 10                	mov    (%rax),%edx
  80a022:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a026:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a029:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a02d:	48 89 c7             	mov    %rax,%rdi
  80a030:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  80a037:	00 00 00 
  80a03a:	ff d0                	callq  *%rax
  80a03c:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a03f:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a043:	0f 85 a8 01 00 00    	jne    80a1f1 <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a049:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a04d:	ba 01 00 00 00       	mov    $0x1,%edx
  80a052:	be 35 00 00 00       	mov    $0x35,%esi
  80a057:	48 89 c7             	mov    %rax,%rdi
  80a05a:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a061:	00 00 00 
  80a064:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a066:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a06a:	be 01 00 00 00       	mov    $0x1,%esi
  80a06f:	48 89 c7             	mov    %rax,%rdi
  80a072:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a079:	00 00 00 
  80a07c:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a07e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a082:	ba 02 00 00 00       	mov    $0x2,%edx
  80a087:	be 39 00 00 00       	mov    $0x39,%esi
  80a08c:	48 89 c7             	mov    %rax,%rdi
  80a08f:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a096:	00 00 00 
  80a099:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a09b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a09f:	be 40 02 00 00       	mov    $0x240,%esi
  80a0a4:	48 89 c7             	mov    %rax,%rdi
  80a0a7:	48 b8 55 ad 80 00 00 	movabs $0x80ad55,%rax
  80a0ae:	00 00 00 
  80a0b1:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a0b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0b7:	ba 04 00 00 00       	mov    $0x4,%edx
  80a0bc:	be 37 00 00 00       	mov    $0x37,%esi
  80a0c1:	48 89 c7             	mov    %rax,%rdi
  80a0c4:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a0cb:	00 00 00 
  80a0ce:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a0d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0d4:	be 01 00 00 00       	mov    $0x1,%esi
  80a0d9:	48 89 c7             	mov    %rax,%rdi
  80a0dc:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a0e3:	00 00 00 
  80a0e6:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a0e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0ec:	be 03 00 00 00       	mov    $0x3,%esi
  80a0f1:	48 89 c7             	mov    %rax,%rdi
  80a0f4:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a0fb:	00 00 00 
  80a0fe:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a100:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a104:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a109:	48 89 c7             	mov    %rax,%rdi
  80a10c:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a113:	00 00 00 
  80a116:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a118:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a11c:	be 06 00 00 00       	mov    $0x6,%esi
  80a121:	48 89 c7             	mov    %rax,%rdi
  80a124:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a12b:	00 00 00 
  80a12e:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a130:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a134:	48 89 c7             	mov    %rax,%rdi
  80a137:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  80a13e:	00 00 00 
  80a141:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a143:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a147:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a14b:	66 05 f0 00          	add    $0xf0,%ax
  80a14f:	0f b7 d0             	movzwl %ax,%edx
  80a152:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a156:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a15a:	89 d6                	mov    %edx,%esi
  80a15c:	48 89 c7             	mov    %rax,%rdi
  80a15f:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  80a166:	00 00 00 
  80a169:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a16b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a16f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a173:	ba 43 00 00 00       	mov    $0x43,%edx
  80a178:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  80a17f:	00 00 00 
  80a182:	48 89 c7             	mov    %rax,%rdi
  80a185:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  80a18c:	00 00 00 
  80a18f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a191:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a195:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a199:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a19d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a1a1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a1a5:	49 89 d0             	mov    %rdx,%r8
  80a1a8:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a1ad:	48 ba 2c 20 82 00 00 	movabs $0x82202c,%rdx
  80a1b4:	00 00 00 
  80a1b7:	48 89 c7             	mov    %rax,%rdi
  80a1ba:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  80a1c1:	00 00 00 
  80a1c4:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a1c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1ca:	48 89 c7             	mov    %rax,%rdi
  80a1cd:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  80a1d4:	00 00 00 
  80a1d7:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a1d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1dd:	be 06 00 00 00       	mov    $0x6,%esi
  80a1e2:	48 89 c7             	mov    %rax,%rdi
  80a1e5:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  80a1ec:	00 00 00 
  80a1ef:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a1f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1f5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a1f9:	8d 50 01             	lea    0x1(%rax),%edx
  80a1fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a200:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a203:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a207:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a20b:	3c 03                	cmp    $0x3,%al
  80a20d:	77 15                	ja     80a224 <dhcp_discover+0x22a>
  80a20f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a213:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a217:	0f b6 c0             	movzbl %al,%eax
  80a21a:	83 c0 01             	add    $0x1,%eax
  80a21d:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a222:	eb 05                	jmp    80a229 <dhcp_discover+0x22f>
  80a224:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a229:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a22d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a231:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a237:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a23c:	89 c8                	mov    %ecx,%eax
  80a23e:	f7 ea                	imul   %edx
  80a240:	c1 fa 05             	sar    $0x5,%edx
  80a243:	89 c8                	mov    %ecx,%eax
  80a245:	c1 f8 1f             	sar    $0x1f,%eax
  80a248:	89 d1                	mov    %edx,%ecx
  80a24a:	29 c1                	sub    %eax,%ecx
  80a24c:	89 c8                	mov    %ecx,%eax
  80a24e:	89 c2                	mov    %eax,%edx
  80a250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a254:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a258:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a25c:	c9                   	leaveq 
  80a25d:	c3                   	retq   

000000000080a25e <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a25e:	55                   	push   %rbp
  80a25f:	48 89 e5             	mov    %rsp,%rbp
  80a262:	53                   	push   %rbx
  80a263:	48 83 ec 48          	sub    $0x48,%rsp
  80a267:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a26b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80a270:	75 2a                	jne    80a29c <dhcp_bind+0x3e>
  80a272:	48 ba 4b 12 82 00 00 	movabs $0x82124b,%rdx
  80a279:	00 00 00 
  80a27c:	be 3d 03 00 00       	mov    $0x33d,%esi
  80a281:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80a288:	00 00 00 
  80a28b:	b8 00 00 00 00       	mov    $0x0,%eax
  80a290:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80a297:	00 00 00 
  80a29a:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a29c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a2a0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a2a4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a2a8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80a2ad:	75 2a                	jne    80a2d9 <dhcp_bind+0x7b>
  80a2af:	48 ba 64 12 82 00 00 	movabs $0x821264,%rdx
  80a2b6:	00 00 00 
  80a2b9:	be 3f 03 00 00       	mov    $0x33f,%esi
  80a2be:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80a2c5:	00 00 00 
  80a2c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80a2cd:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80a2d4:	00 00 00 
  80a2d7:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a2d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a2dd:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a2e0:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a2e3:	74 53                	je     80a338 <dhcp_bind+0xda>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a2e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a2e9:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a2ec:	83 c0 1e             	add    $0x1e,%eax
  80a2ef:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80a2f2:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a2f7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80a2fa:	f7 e2                	mul    %edx
  80a2fc:	89 d0                	mov    %edx,%eax
  80a2fe:	c1 e8 05             	shr    $0x5,%eax
  80a301:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a304:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a30b:	76 07                	jbe    80a314 <dhcp_bind+0xb6>
      timeout = 0xffff;
  80a30d:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a314:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a317:	89 c2                	mov    %eax,%edx
  80a319:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a31d:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a321:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a325:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a329:	66 85 c0             	test   %ax,%ax
  80a32c:	75 0a                	jne    80a338 <dhcp_bind+0xda>
      dhcp->t1_timeout = 1;
  80a32e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a332:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a338:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a33c:	8b 40 70             	mov    0x70(%rax),%eax
  80a33f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a342:	74 53                	je     80a397 <dhcp_bind+0x139>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a344:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a348:	8b 40 70             	mov    0x70(%rax),%eax
  80a34b:	83 c0 1e             	add    $0x1e,%eax
  80a34e:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80a351:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a356:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80a359:	f7 e2                	mul    %edx
  80a35b:	89 d0                	mov    %edx,%eax
  80a35d:	c1 e8 05             	shr    $0x5,%eax
  80a360:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a363:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a36a:	76 07                	jbe    80a373 <dhcp_bind+0x115>
      timeout = 0xffff;
  80a36c:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a373:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a376:	89 c2                	mov    %eax,%edx
  80a378:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a37c:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a380:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a384:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a388:	66 85 c0             	test   %ax,%ax
  80a38b:	75 0a                	jne    80a397 <dhcp_bind+0x139>
      dhcp->t2_timeout = 1;
  80a38d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a391:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a397:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a39b:	48 83 c0 50          	add    $0x50,%rax
  80a39f:	48 85 c0             	test   %rax,%rax
  80a3a2:	74 09                	je     80a3ad <dhcp_bind+0x14f>
  80a3a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a3a8:	8b 40 50             	mov    0x50(%rax),%eax
  80a3ab:	eb 05                	jmp    80a3b2 <dhcp_bind+0x154>
  80a3ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80a3b2:	89 45 d0             	mov    %eax,-0x30(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a3b5:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a3b8:	85 c0                	test   %eax,%eax
  80a3ba:	75 65                	jne    80a421 <dhcp_bind+0x1c3>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a3bc:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a3bf:	89 c7                	mov    %eax,%edi
  80a3c1:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  80a3c8:	00 00 00 
  80a3cb:	ff d0                	callq  *%rax
  80a3cd:	c1 e8 18             	shr    $0x18,%eax
  80a3d0:	88 45 df             	mov    %al,-0x21(%rbp)
    if (first_octet <= 127) {
  80a3d3:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80a3d7:	84 c0                	test   %al,%al
  80a3d9:	78 16                	js     80a3f1 <dhcp_bind+0x193>
      sn_mask.addr = htonl(0xff000000);
  80a3db:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80a3e0:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80a3e7:	00 00 00 
  80a3ea:	ff d0                	callq  *%rax
  80a3ec:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a3ef:	eb 30                	jmp    80a421 <dhcp_bind+0x1c3>
    } else if (first_octet >= 192) {
  80a3f1:	80 7d df bf          	cmpb   $0xbf,-0x21(%rbp)
  80a3f5:	76 16                	jbe    80a40d <dhcp_bind+0x1af>
      sn_mask.addr = htonl(0xffffff00);
  80a3f7:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80a3fc:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80a403:	00 00 00 
  80a406:	ff d0                	callq  *%rax
  80a408:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a40b:	eb 14                	jmp    80a421 <dhcp_bind+0x1c3>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80a40d:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80a412:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80a419:	00 00 00 
  80a41c:	ff d0                	callq  *%rax
  80a41e:	89 45 d0             	mov    %eax,-0x30(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80a421:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a425:	48 83 c0 54          	add    $0x54,%rax
  80a429:	48 85 c0             	test   %rax,%rax
  80a42c:	74 09                	je     80a437 <dhcp_bind+0x1d9>
  80a42e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a432:	8b 40 54             	mov    0x54(%rax),%eax
  80a435:	eb 05                	jmp    80a43c <dhcp_bind+0x1de>
  80a437:	b8 00 00 00 00       	mov    $0x0,%eax
  80a43c:	89 45 c0             	mov    %eax,-0x40(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80a43f:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80a442:	85 c0                	test   %eax,%eax
  80a444:	75 28                	jne    80a46e <dhcp_bind+0x210>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80a446:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a44a:	8b 50 4c             	mov    0x4c(%rax),%edx
  80a44d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a450:	21 d0                	and    %edx,%eax
  80a452:	89 45 c0             	mov    %eax,-0x40(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80a455:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  80a458:	bf 01 00 00 00       	mov    $0x1,%edi
  80a45d:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80a464:	00 00 00 
  80a467:	ff d0                	callq  *%rax
  80a469:	09 d8                	or     %ebx,%eax
  80a46b:	89 45 c0             	mov    %eax,-0x40(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80a46e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a472:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80a476:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a47a:	48 89 d6             	mov    %rdx,%rsi
  80a47d:	48 89 c7             	mov    %rax,%rdi
  80a480:	48 b8 37 cc 80 00 00 	movabs $0x80cc37,%rax
  80a487:	00 00 00 
  80a48a:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80a48c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80a490:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a494:	48 89 d6             	mov    %rdx,%rsi
  80a497:	48 89 c7             	mov    %rax,%rdi
  80a49a:	48 b8 6a cd 80 00 00 	movabs $0x80cd6a,%rax
  80a4a1:	00 00 00 
  80a4a4:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80a4a6:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80a4aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a4ae:	48 89 d6             	mov    %rdx,%rsi
  80a4b1:	48 89 c7             	mov    %rax,%rdi
  80a4b4:	48 b8 3d cd 80 00 00 	movabs $0x80cd3d,%rax
  80a4bb:	00 00 00 
  80a4be:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80a4c0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a4c4:	48 89 c7             	mov    %rax,%rdi
  80a4c7:	48 b8 b6 cd 80 00 00 	movabs $0x80cdb6,%rax
  80a4ce:	00 00 00 
  80a4d1:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80a4d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a4d7:	be 0a 00 00 00       	mov    $0xa,%esi
  80a4dc:	48 89 c7             	mov    %rax,%rdi
  80a4df:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  80a4e6:	00 00 00 
  80a4e9:	ff d0                	callq  *%rax
}
  80a4eb:	48 83 c4 48          	add    $0x48,%rsp
  80a4ef:	5b                   	pop    %rbx
  80a4f0:	5d                   	pop    %rbp
  80a4f1:	c3                   	retq   

000000000080a4f2 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80a4f2:	55                   	push   %rbp
  80a4f3:	48 89 e5             	mov    %rsp,%rbp
  80a4f6:	48 83 ec 20          	sub    $0x20,%rsp
  80a4fa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a4fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a502:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a506:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80a50a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a50e:	be 05 00 00 00       	mov    $0x5,%esi
  80a513:	48 89 c7             	mov    %rax,%rdi
  80a516:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  80a51d:	00 00 00 
  80a520:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a522:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a526:	48 89 c7             	mov    %rax,%rdi
  80a529:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  80a530:	00 00 00 
  80a533:	ff d0                	callq  *%rax
  80a535:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a538:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a53c:	0f 85 12 01 00 00    	jne    80a654 <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a542:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a546:	ba 01 00 00 00       	mov    $0x1,%edx
  80a54b:	be 35 00 00 00       	mov    $0x35,%esi
  80a550:	48 89 c7             	mov    %rax,%rdi
  80a553:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a55a:	00 00 00 
  80a55d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a55f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a563:	be 03 00 00 00       	mov    $0x3,%esi
  80a568:	48 89 c7             	mov    %rax,%rdi
  80a56b:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a572:	00 00 00 
  80a575:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a577:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a57b:	ba 02 00 00 00       	mov    $0x2,%edx
  80a580:	be 39 00 00 00       	mov    $0x39,%esi
  80a585:	48 89 c7             	mov    %rax,%rdi
  80a588:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a58f:	00 00 00 
  80a592:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80a594:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a598:	be 40 02 00 00       	mov    $0x240,%esi
  80a59d:	48 89 c7             	mov    %rax,%rdi
  80a5a0:	48 b8 55 ad 80 00 00 	movabs $0x80ad55,%rax
  80a5a7:	00 00 00 
  80a5aa:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80a5ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5b0:	48 89 c7             	mov    %rax,%rdi
  80a5b3:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  80a5ba:	00 00 00 
  80a5bd:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a5bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5c3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a5c7:	66 05 f0 00          	add    $0xf0,%ax
  80a5cb:	0f b7 d0             	movzwl %ax,%edx
  80a5ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5d2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a5d6:	89 d6                	mov    %edx,%esi
  80a5d8:	48 89 c7             	mov    %rax,%rdi
  80a5db:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  80a5e2:	00 00 00 
  80a5e5:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80a5e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5eb:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80a5ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a5f3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a5f7:	ba 43 00 00 00       	mov    $0x43,%edx
  80a5fc:	48 89 ce             	mov    %rcx,%rsi
  80a5ff:	48 89 c7             	mov    %rax,%rdi
  80a602:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  80a609:	00 00 00 
  80a60c:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80a60e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a612:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80a616:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a61a:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a61e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a622:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a626:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80a62a:	49 89 c8             	mov    %rcx,%r8
  80a62d:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a632:	48 89 c7             	mov    %rax,%rdi
  80a635:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  80a63c:	00 00 00 
  80a63f:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a641:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a645:	48 89 c7             	mov    %rax,%rdi
  80a648:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  80a64f:	00 00 00 
  80a652:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a658:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a65c:	8d 50 01             	lea    0x1(%rax),%edx
  80a65f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a663:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80a666:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a66a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a66e:	3c 09                	cmp    $0x9,%al
  80a670:	77 12                	ja     80a684 <dhcp_renew+0x192>
  80a672:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a676:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a67a:	0f b6 c0             	movzbl %al,%eax
  80a67d:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80a682:	eb 05                	jmp    80a689 <dhcp_renew+0x197>
  80a684:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80a689:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a68d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a691:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a697:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a69c:	89 c8                	mov    %ecx,%eax
  80a69e:	f7 ea                	imul   %edx
  80a6a0:	c1 fa 05             	sar    $0x5,%edx
  80a6a3:	89 c8                	mov    %ecx,%eax
  80a6a5:	c1 f8 1f             	sar    $0x1f,%eax
  80a6a8:	89 d1                	mov    %edx,%ecx
  80a6aa:	29 c1                	sub    %eax,%ecx
  80a6ac:	89 c8                	mov    %ecx,%eax
  80a6ae:	89 c2                	mov    %eax,%edx
  80a6b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6b4:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a6b8:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a6bc:	c9                   	leaveq 
  80a6bd:	c3                   	retq   

000000000080a6be <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80a6be:	55                   	push   %rbp
  80a6bf:	48 89 e5             	mov    %rsp,%rbp
  80a6c2:	48 83 ec 20          	sub    $0x20,%rsp
  80a6c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a6ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a6ce:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a6d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80a6d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6da:	be 04 00 00 00       	mov    $0x4,%esi
  80a6df:	48 89 c7             	mov    %rax,%rdi
  80a6e2:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  80a6e9:	00 00 00 
  80a6ec:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a6ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a6f2:	48 89 c7             	mov    %rax,%rdi
  80a6f5:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  80a6fc:	00 00 00 
  80a6ff:	ff d0                	callq  *%rax
  80a701:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a704:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a708:	0f 85 13 01 00 00    	jne    80a821 <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a70e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a712:	ba 01 00 00 00       	mov    $0x1,%edx
  80a717:	be 35 00 00 00       	mov    $0x35,%esi
  80a71c:	48 89 c7             	mov    %rax,%rdi
  80a71f:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a726:	00 00 00 
  80a729:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a72b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a72f:	be 03 00 00 00       	mov    $0x3,%esi
  80a734:	48 89 c7             	mov    %rax,%rdi
  80a737:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a73e:	00 00 00 
  80a741:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a743:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a747:	ba 02 00 00 00       	mov    $0x2,%edx
  80a74c:	be 39 00 00 00       	mov    $0x39,%esi
  80a751:	48 89 c7             	mov    %rax,%rdi
  80a754:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a75b:	00 00 00 
  80a75e:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a760:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a764:	be 40 02 00 00       	mov    $0x240,%esi
  80a769:	48 89 c7             	mov    %rax,%rdi
  80a76c:	48 b8 55 ad 80 00 00 	movabs $0x80ad55,%rax
  80a773:	00 00 00 
  80a776:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80a778:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a77c:	48 89 c7             	mov    %rax,%rdi
  80a77f:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  80a786:	00 00 00 
  80a789:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a78b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a78f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a793:	66 05 f0 00          	add    $0xf0,%ax
  80a797:	0f b7 d0             	movzwl %ax,%edx
  80a79a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a79e:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a7a2:	89 d6                	mov    %edx,%esi
  80a7a4:	48 89 c7             	mov    %rax,%rdi
  80a7a7:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  80a7ae:	00 00 00 
  80a7b1:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a7b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a7bb:	ba 43 00 00 00       	mov    $0x43,%edx
  80a7c0:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  80a7c7:	00 00 00 
  80a7ca:	48 89 c7             	mov    %rax,%rdi
  80a7cd:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  80a7d4:	00 00 00 
  80a7d7:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a7d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7dd:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a7e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7e5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a7e9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a7ed:	49 89 d0             	mov    %rdx,%r8
  80a7f0:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a7f5:	48 ba 2c 20 82 00 00 	movabs $0x82202c,%rdx
  80a7fc:	00 00 00 
  80a7ff:	48 89 c7             	mov    %rax,%rdi
  80a802:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  80a809:	00 00 00 
  80a80c:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a80e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a812:	48 89 c7             	mov    %rax,%rdi
  80a815:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  80a81c:	00 00 00 
  80a81f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a825:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a829:	8d 50 01             	lea    0x1(%rax),%edx
  80a82c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a830:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80a833:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a837:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a83b:	3c 09                	cmp    $0x9,%al
  80a83d:	77 12                	ja     80a851 <dhcp_rebind+0x193>
  80a83f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a843:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a847:	0f b6 c0             	movzbl %al,%eax
  80a84a:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a84f:	eb 05                	jmp    80a856 <dhcp_rebind+0x198>
  80a851:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a856:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a85a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a85e:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a864:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a869:	89 c8                	mov    %ecx,%eax
  80a86b:	f7 ea                	imul   %edx
  80a86d:	c1 fa 05             	sar    $0x5,%edx
  80a870:	89 c8                	mov    %ecx,%eax
  80a872:	c1 f8 1f             	sar    $0x1f,%eax
  80a875:	89 d1                	mov    %edx,%ecx
  80a877:	29 c1                	sub    %eax,%ecx
  80a879:	89 c8                	mov    %ecx,%eax
  80a87b:	89 c2                	mov    %eax,%edx
  80a87d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a881:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a885:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a889:	c9                   	leaveq 
  80a88a:	c3                   	retq   

000000000080a88b <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80a88b:	55                   	push   %rbp
  80a88c:	48 89 e5             	mov    %rsp,%rbp
  80a88f:	48 83 ec 20          	sub    $0x20,%rsp
  80a893:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a897:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a89b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a89f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80a8a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8a7:	be 0d 00 00 00       	mov    $0xd,%esi
  80a8ac:	48 89 c7             	mov    %rax,%rdi
  80a8af:	48 b8 f7 ab 80 00 00 	movabs $0x80abf7,%rax
  80a8b6:	00 00 00 
  80a8b9:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80a8bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8bf:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80a8c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8ca:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80a8d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8d5:	8b 50 50             	mov    0x50(%rax),%edx
  80a8d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8dc:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80a8df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8e3:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80a8ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8ee:	8b 50 58             	mov    0x58(%rax),%edx
  80a8f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8f5:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80a8f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8fc:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80a903:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a907:	8b 50 70             	mov    0x70(%rax),%edx
  80a90a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a90e:	89 50 6c             	mov    %edx,0x6c(%rax)
  80a911:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a915:	8b 50 6c             	mov    0x6c(%rax),%edx
  80a918:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a91c:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80a91f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a923:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a92a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a92e:	48 89 c7             	mov    %rax,%rdi
  80a931:	48 b8 04 b4 80 00 00 	movabs $0x80b404,%rax
  80a938:	00 00 00 
  80a93b:	ff d0                	callq  *%rax
  80a93d:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a940:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a944:	0f 85 dd 00 00 00    	jne    80aa27 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a94a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a94e:	ba 01 00 00 00       	mov    $0x1,%edx
  80a953:	be 35 00 00 00       	mov    $0x35,%esi
  80a958:	48 89 c7             	mov    %rax,%rdi
  80a95b:	48 b8 28 ac 80 00 00 	movabs $0x80ac28,%rax
  80a962:	00 00 00 
  80a965:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80a967:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a96b:	be 07 00 00 00       	mov    $0x7,%esi
  80a970:	48 89 c7             	mov    %rax,%rdi
  80a973:	48 b8 dd ac 80 00 00 	movabs $0x80acdd,%rax
  80a97a:	00 00 00 
  80a97d:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a97f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a983:	48 89 c7             	mov    %rax,%rdi
  80a986:	48 b8 67 b8 80 00 00 	movabs $0x80b867,%rax
  80a98d:	00 00 00 
  80a990:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a992:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a996:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a99a:	66 05 f0 00          	add    $0xf0,%ax
  80a99e:	0f b7 d0             	movzwl %ax,%edx
  80a9a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9a5:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a9a9:	89 d6                	mov    %edx,%esi
  80a9ab:	48 89 c7             	mov    %rax,%rdi
  80a9ae:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  80a9b5:	00 00 00 
  80a9b8:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80a9ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9be:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80a9c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a9ca:	ba 43 00 00 00       	mov    $0x43,%edx
  80a9cf:	48 89 ce             	mov    %rcx,%rsi
  80a9d2:	48 89 c7             	mov    %rax,%rdi
  80a9d5:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  80a9dc:	00 00 00 
  80a9df:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80a9e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9e5:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80a9e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9ed:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a9f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a9f9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80a9fd:	49 89 c8             	mov    %rcx,%r8
  80aa00:	b9 43 00 00 00       	mov    $0x43,%ecx
  80aa05:	48 89 c7             	mov    %rax,%rdi
  80aa08:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  80aa0f:	00 00 00 
  80aa12:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80aa14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa18:	48 89 c7             	mov    %rax,%rdi
  80aa1b:	48 b8 41 b7 80 00 00 	movabs $0x80b741,%rax
  80aa22:	00 00 00 
  80aa25:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80aa27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa2b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aa2f:	8d 50 01             	lea    0x1(%rax),%edx
  80aa32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa36:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80aa39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa3d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aa41:	3c 09                	cmp    $0x9,%al
  80aa43:	77 12                	ja     80aa57 <dhcp_release+0x1cc>
  80aa45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa49:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aa4d:	0f b6 c0             	movzbl %al,%eax
  80aa50:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80aa55:	eb 05                	jmp    80aa5c <dhcp_release+0x1d1>
  80aa57:	b8 10 27 00 00       	mov    $0x2710,%eax
  80aa5c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80aa60:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80aa64:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80aa6a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80aa6f:	89 c8                	mov    %ecx,%eax
  80aa71:	f7 ea                	imul   %edx
  80aa73:	c1 fa 05             	sar    $0x5,%edx
  80aa76:	89 c8                	mov    %ecx,%eax
  80aa78:	c1 f8 1f             	sar    $0x1f,%eax
  80aa7b:	89 d1                	mov    %edx,%ecx
  80aa7d:	29 c1                	sub    %eax,%ecx
  80aa7f:	89 c8                	mov    %ecx,%eax
  80aa81:	89 c2                	mov    %eax,%edx
  80aa83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa87:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80aa8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa8f:	48 89 c7             	mov    %rax,%rdi
  80aa92:	48 b8 1f ce 80 00 00 	movabs $0x80ce1f,%rax
  80aa99:	00 00 00 
  80aa9c:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80aa9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aaa2:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  80aaa9:	00 00 00 
  80aaac:	48 89 c7             	mov    %rax,%rdi
  80aaaf:	48 b8 37 cc 80 00 00 	movabs $0x80cc37,%rax
  80aab6:	00 00 00 
  80aab9:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80aabb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aabf:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  80aac6:	00 00 00 
  80aac9:	48 89 c7             	mov    %rax,%rdi
  80aacc:	48 b8 3d cd 80 00 00 	movabs $0x80cd3d,%rax
  80aad3:	00 00 00 
  80aad6:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80aad8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aadc:	48 be 28 20 82 00 00 	movabs $0x822028,%rsi
  80aae3:	00 00 00 
  80aae6:	48 89 c7             	mov    %rax,%rdi
  80aae9:	48 b8 6a cd 80 00 00 	movabs $0x80cd6a,%rax
  80aaf0:	00 00 00 
  80aaf3:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80aaf5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80aaf9:	c9                   	leaveq 
  80aafa:	c3                   	retq   

000000000080aafb <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80aafb:	55                   	push   %rbp
  80aafc:	48 89 e5             	mov    %rsp,%rbp
  80aaff:	48 83 ec 20          	sub    $0x20,%rsp
  80ab03:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ab07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab0b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ab0f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80ab13:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ab18:	75 2a                	jne    80ab44 <dhcp_stop+0x49>
  80ab1a:	48 ba 7c 12 82 00 00 	movabs $0x82127c,%rdx
  80ab21:	00 00 00 
  80ab24:	be 2c 04 00 00       	mov    $0x42c,%esi
  80ab29:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80ab30:	00 00 00 
  80ab33:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab38:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ab3f:	00 00 00 
  80ab42:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80ab44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab48:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80ab4c:	89 c2                	mov    %eax,%edx
  80ab4e:	83 e2 f7             	and    $0xfffffff7,%edx
  80ab51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab55:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80ab58:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ab5d:	0f 84 92 00 00 00    	je     80abf5 <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80ab63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab67:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ab6b:	48 85 c0             	test   %rax,%rax
  80ab6e:	74 23                	je     80ab93 <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80ab70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab74:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ab78:	48 89 c7             	mov    %rax,%rdi
  80ab7b:	48 b8 5f 53 81 00 00 	movabs $0x81535f,%rax
  80ab82:	00 00 00 
  80ab85:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80ab87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab8b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80ab92:	00 
    }
    if (dhcp->p != NULL) {
  80ab93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab97:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ab9b:	48 85 c0             	test   %rax,%rax
  80ab9e:	74 23                	je     80abc3 <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80aba0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aba4:	48 8b 40 10          	mov    0x10(%rax),%rax
  80aba8:	48 89 c7             	mov    %rax,%rdi
  80abab:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80abb2:	00 00 00 
  80abb5:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80abb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abbb:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80abc2:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80abc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abc7:	48 89 c7             	mov    %rax,%rdi
  80abca:	48 b8 35 b1 80 00 00 	movabs $0x80b135,%rax
  80abd1:	00 00 00 
  80abd4:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80abd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abda:	48 89 c7             	mov    %rax,%rdi
  80abdd:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  80abe4:	00 00 00 
  80abe7:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80abe9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80abed:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80abf4:	00 
  }
}
  80abf5:	c9                   	leaveq 
  80abf6:	c3                   	retq   

000000000080abf7 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80abf7:	55                   	push   %rbp
  80abf8:	48 89 e5             	mov    %rsp,%rbp
  80abfb:	48 83 ec 10          	sub    $0x10,%rsp
  80abff:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ac03:	89 f0                	mov    %esi,%eax
  80ac05:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80ac08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac0c:	0f b6 00             	movzbl (%rax),%eax
  80ac0f:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80ac12:	74 12                	je     80ac26 <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80ac14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac18:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80ac1c:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80ac1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac22:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80ac26:	c9                   	leaveq 
  80ac27:	c3                   	retq   

000000000080ac28 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80ac28:	55                   	push   %rbp
  80ac29:	48 89 e5             	mov    %rsp,%rbp
  80ac2c:	48 83 ec 10          	sub    $0x10,%rsp
  80ac30:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ac34:	89 f1                	mov    %esi,%ecx
  80ac36:	89 d0                	mov    %edx,%eax
  80ac38:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80ac3b:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80ac3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac42:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ac46:	0f b7 d0             	movzwl %ax,%edx
  80ac49:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80ac4d:	01 d0                	add    %edx,%eax
  80ac4f:	83 c0 02             	add    $0x2,%eax
  80ac52:	83 f8 44             	cmp    $0x44,%eax
  80ac55:	76 2a                	jbe    80ac81 <dhcp_option+0x59>
  80ac57:	48 ba 98 12 82 00 00 	movabs $0x821298,%rdx
  80ac5e:	00 00 00 
  80ac61:	be 5a 04 00 00       	mov    $0x45a,%esi
  80ac66:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80ac6d:	00 00 00 
  80ac70:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac75:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ac7c:	00 00 00 
  80ac7f:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80ac81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac85:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80ac89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac8d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ac91:	0f b7 d0             	movzwl %ax,%edx
  80ac94:	48 63 d2             	movslq %edx,%rdx
  80ac97:	0f b6 75 f4          	movzbl -0xc(%rbp),%esi
  80ac9b:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80aca2:	00 
  80aca3:	8d 50 01             	lea    0x1(%rax),%edx
  80aca6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acaa:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80acae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acb2:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80acb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acba:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80acbe:	0f b7 d0             	movzwl %ax,%edx
  80acc1:	48 63 d2             	movslq %edx,%rdx
  80acc4:	0f b6 75 f0          	movzbl -0x10(%rbp),%esi
  80acc8:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80accf:	00 
  80acd0:	8d 50 01             	lea    0x1(%rax),%edx
  80acd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acd7:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80acdb:	c9                   	leaveq 
  80acdc:	c3                   	retq   

000000000080acdd <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80acdd:	55                   	push   %rbp
  80acde:	48 89 e5             	mov    %rsp,%rbp
  80ace1:	48 83 ec 10          	sub    $0x10,%rsp
  80ace5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ace9:	89 f0                	mov    %esi,%eax
  80aceb:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80acee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80acf2:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80acf6:	66 83 f8 43          	cmp    $0x43,%ax
  80acfa:	76 2a                	jbe    80ad26 <dhcp_option_byte+0x49>
  80acfc:	48 ba e0 12 82 00 00 	movabs $0x8212e0,%rdx
  80ad03:	00 00 00 
  80ad06:	be 65 04 00 00       	mov    $0x465,%esi
  80ad0b:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80ad12:	00 00 00 
  80ad15:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad1a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ad21:	00 00 00 
  80ad24:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80ad26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad2a:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80ad2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad32:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ad36:	0f b7 d0             	movzwl %ax,%edx
  80ad39:	48 63 d2             	movslq %edx,%rdx
  80ad3c:	0f b6 75 f4          	movzbl -0xc(%rbp),%esi
  80ad40:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80ad47:	00 
  80ad48:	8d 50 01             	lea    0x1(%rax),%edx
  80ad4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad4f:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80ad53:	c9                   	leaveq 
  80ad54:	c3                   	retq   

000000000080ad55 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80ad55:	55                   	push   %rbp
  80ad56:	48 89 e5             	mov    %rsp,%rbp
  80ad59:	48 83 ec 10          	sub    $0x10,%rsp
  80ad5d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ad61:	89 f0                	mov    %esi,%eax
  80ad63:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80ad67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad6b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ad6f:	0f b7 c0             	movzwl %ax,%eax
  80ad72:	83 c0 02             	add    $0x2,%eax
  80ad75:	83 f8 44             	cmp    $0x44,%eax
  80ad78:	76 2a                	jbe    80ada4 <dhcp_option_short+0x4f>
  80ad7a:	48 ba 20 13 82 00 00 	movabs $0x821320,%rdx
  80ad81:	00 00 00 
  80ad84:	be 6c 04 00 00       	mov    $0x46c,%esi
  80ad89:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80ad90:	00 00 00 
  80ad93:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad98:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ad9f:	00 00 00 
  80ada2:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80ada4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ada8:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80adac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adb0:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80adb4:	0f b7 d0             	movzwl %ax,%edx
  80adb7:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  80adbb:	66 c1 ee 08          	shr    $0x8,%si
  80adbf:	48 63 d2             	movslq %edx,%rdx
  80adc2:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80adc9:	00 
  80adca:	8d 50 01             	lea    0x1(%rax),%edx
  80adcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80add1:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80add5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80add9:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80addd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ade1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ade5:	0f b7 d0             	movzwl %ax,%edx
  80ade8:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  80adec:	48 63 d2             	movslq %edx,%rdx
  80adef:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80adf6:	00 
  80adf7:	8d 50 01             	lea    0x1(%rax),%edx
  80adfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adfe:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80ae02:	c9                   	leaveq 
  80ae03:	c3                   	retq   

000000000080ae04 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80ae04:	55                   	push   %rbp
  80ae05:	48 89 e5             	mov    %rsp,%rbp
  80ae08:	48 83 ec 10          	sub    $0x10,%rsp
  80ae0c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ae10:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80ae13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae17:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae1b:	0f b7 c0             	movzwl %ax,%eax
  80ae1e:	83 c0 04             	add    $0x4,%eax
  80ae21:	83 f8 44             	cmp    $0x44,%eax
  80ae24:	76 2a                	jbe    80ae50 <dhcp_option_long+0x4c>
  80ae26:	48 ba 68 13 82 00 00 	movabs $0x821368,%rdx
  80ae2d:	00 00 00 
  80ae30:	be 74 04 00 00       	mov    $0x474,%esi
  80ae35:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80ae3c:	00 00 00 
  80ae3f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae44:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ae4b:	00 00 00 
  80ae4e:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80ae50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae54:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80ae58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae5c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae60:	0f b7 d0             	movzwl %ax,%edx
  80ae63:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80ae66:	c1 ee 18             	shr    $0x18,%esi
  80ae69:	48 63 d2             	movslq %edx,%rdx
  80ae6c:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80ae73:	00 
  80ae74:	8d 50 01             	lea    0x1(%rax),%edx
  80ae77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae7b:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80ae7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae83:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80ae87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae8b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae8f:	0f b7 d0             	movzwl %ax,%edx
  80ae92:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80ae95:	81 e6 00 00 ff 00    	and    $0xff0000,%esi
  80ae9b:	48 c1 ee 10          	shr    $0x10,%rsi
  80ae9f:	48 63 d2             	movslq %edx,%rdx
  80aea2:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80aea9:	00 
  80aeaa:	8d 50 01             	lea    0x1(%rax),%edx
  80aead:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeb1:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80aeb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeb9:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80aebd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aec1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aec5:	0f b7 d0             	movzwl %ax,%edx
  80aec8:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80aecb:	81 e6 00 ff 00 00    	and    $0xff00,%esi
  80aed1:	48 c1 ee 08          	shr    $0x8,%rsi
  80aed5:	48 63 d2             	movslq %edx,%rdx
  80aed8:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80aedf:	00 
  80aee0:	8d 50 01             	lea    0x1(%rax),%edx
  80aee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aee7:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80aeeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeef:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80aef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aef7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aefb:	0f b7 d0             	movzwl %ax,%edx
  80aefe:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80af01:	48 63 d2             	movslq %edx,%rdx
  80af04:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80af0b:	00 
  80af0c:	8d 50 01             	lea    0x1(%rax),%edx
  80af0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af13:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80af17:	c9                   	leaveq 
  80af18:	c3                   	retq   

000000000080af19 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80af19:	55                   	push   %rbp
  80af1a:	48 89 e5             	mov    %rsp,%rbp
  80af1d:	48 83 ec 20          	sub    $0x20,%rsp
  80af21:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80af25:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80af2a:	75 2a                	jne    80af56 <dhcp_unfold_reply+0x3d>
  80af2c:	48 ba a8 13 82 00 00 	movabs $0x8213a8,%rdx
  80af33:	00 00 00 
  80af36:	be 89 04 00 00       	mov    $0x489,%esi
  80af3b:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80af42:	00 00 00 
  80af45:	b8 00 00 00 00       	mov    $0x0,%eax
  80af4a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80af51:	00 00 00 
  80af54:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80af56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af5a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80af5e:	48 85 c0             	test   %rax,%rax
  80af61:	75 2a                	jne    80af8d <dhcp_unfold_reply+0x74>
  80af63:	48 ba b5 13 82 00 00 	movabs $0x8213b5,%rdx
  80af6a:	00 00 00 
  80af6d:	be 8a 04 00 00       	mov    $0x48a,%esi
  80af72:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80af79:	00 00 00 
  80af7c:	b8 00 00 00 00       	mov    $0x0,%eax
  80af81:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80af88:	00 00 00 
  80af8b:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80af8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80af91:	48 89 c7             	mov    %rax,%rdi
  80af94:	48 b8 35 b1 80 00 00 	movabs $0x80b135,%rax
  80af9b:	00 00 00 
  80af9e:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80afa0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afa4:	48 8b 40 10          	mov    0x10(%rax),%rax
  80afa8:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80afac:	66 3d f0 00          	cmp    $0xf0,%ax
  80afb0:	76 52                	jbe    80b004 <dhcp_unfold_reply+0xeb>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80afb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afb6:	48 8b 40 10          	mov    0x10(%rax),%rax
  80afba:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80afbe:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80afc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afc8:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80afcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80afd0:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80afd4:	0f b7 c0             	movzwl %ax,%eax
  80afd7:	89 c7                	mov    %eax,%edi
  80afd9:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  80afe0:	00 00 00 
  80afe3:	ff d0                	callq  *%rax
  80afe5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80afe9:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (dhcp->options_in == NULL) {
  80afed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aff1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80aff5:	48 85 c0             	test   %rax,%rax
  80aff8:	75 0a                	jne    80b004 <dhcp_unfold_reply+0xeb>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80affa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80afff:	e9 2f 01 00 00       	jmpq   80b133 <dhcp_unfold_reply+0x21a>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b004:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b009:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  80b010:	00 00 00 
  80b013:	ff d0                	callq  *%rax
  80b015:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b019:	48 89 42 18          	mov    %rax,0x18(%rdx)
  if (dhcp->msg_in == NULL) {
  80b01d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b021:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b025:	48 85 c0             	test   %rax,%rax
  80b028:	75 2d                	jne    80b057 <dhcp_unfold_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b02a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b02e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b032:	48 89 c7             	mov    %rax,%rdi
  80b035:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  80b03c:	00 00 00 
  80b03f:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b041:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b045:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b04c:	00 
    return ERR_MEM;
  80b04d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b052:	e9 dc 00 00 00       	jmpq   80b133 <dhcp_unfold_reply+0x21a>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b057:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b05b:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b05f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b063:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b067:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b06c:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b071:	48 89 c7             	mov    %rax,%rdi
  80b074:	48 b8 6b de 80 00 00 	movabs $0x80de6b,%rax
  80b07b:	00 00 00 
  80b07e:	ff d0                	callq  *%rax
  80b080:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b084:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b08a:	74 2a                	je     80b0b6 <dhcp_unfold_reply+0x19d>
  80b08c:	48 ba c8 13 82 00 00 	movabs $0x8213c8,%rdx
  80b093:	00 00 00 
  80b096:	be a0 04 00 00       	mov    $0x4a0,%esi
  80b09b:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b0a2:	00 00 00 
  80b0a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0aa:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b0b1:	00 00 00 
  80b0b4:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b0b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0ba:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b0be:	48 85 c0             	test   %rax,%rax
  80b0c1:	74 6b                	je     80b12e <dhcp_unfold_reply+0x215>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b0c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0c7:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b0cb:	0f b7 d0             	movzwl %ax,%edx
  80b0ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0d2:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b0d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0da:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b0de:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b0e3:	48 89 c7             	mov    %rax,%rdi
  80b0e6:	48 b8 6b de 80 00 00 	movabs $0x80de6b,%rax
  80b0ed:	00 00 00 
  80b0f0:	ff d0                	callq  *%rax
  80b0f2:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b0f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b0fa:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b0fe:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b102:	74 2a                	je     80b12e <dhcp_unfold_reply+0x215>
  80b104:	48 ba fa 13 82 00 00 	movabs $0x8213fa,%rdx
  80b10b:	00 00 00 
  80b10e:	be a7 04 00 00       	mov    $0x4a7,%esi
  80b113:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b11a:	00 00 00 
  80b11d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b122:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b129:	00 00 00 
  80b12c:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b12e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b133:	c9                   	leaveq 
  80b134:	c3                   	retq   

000000000080b135 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b135:	55                   	push   %rbp
  80b136:	48 89 e5             	mov    %rsp,%rbp
  80b139:	48 83 ec 10          	sub    $0x10,%rsp
  80b13d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b141:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b145:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b149:	48 85 c0             	test   %rax,%rax
  80b14c:	74 23                	je     80b171 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b14e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b152:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b156:	48 89 c7             	mov    %rax,%rdi
  80b159:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  80b160:	00 00 00 
  80b163:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b165:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b169:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b170:	00 
  }
  if (dhcp->options_in) {
  80b171:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b175:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b179:	48 85 c0             	test   %rax,%rax
  80b17c:	74 2d                	je     80b1ab <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b17e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b182:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b186:	48 89 c7             	mov    %rax,%rdi
  80b189:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  80b190:	00 00 00 
  80b193:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b199:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b1a0:	00 
    dhcp->options_in_len = 0;
  80b1a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b1a5:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b1ab:	c9                   	leaveq 
  80b1ac:	c3                   	retq   

000000000080b1ad <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b1ad:	55                   	push   %rbp
  80b1ae:	48 89 e5             	mov    %rsp,%rbp
  80b1b1:	48 83 ec 60          	sub    $0x60,%rsp
  80b1b5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b1b9:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b1bd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b1c1:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b1c5:	44 89 c0             	mov    %r8d,%eax
  80b1c8:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b1cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b1d0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b1d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b1d8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b1dc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b1e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b1e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b1e8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b1ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b1f0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b1f4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b1f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b1fc:	0f b6 00             	movzbl (%rax),%eax
  80b1ff:	3c 02                	cmp    $0x2,%al
  80b201:	0f 85 cf 01 00 00    	jne    80b3d6 <dhcp_recv+0x229>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b207:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b20b:	eb 2a                	jmp    80b237 <dhcp_recv+0x8a>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b20d:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b211:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b215:	48 98                	cltq   
  80b217:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b21c:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b220:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b224:	48 98                	cltq   
  80b226:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b22b:	38 c1                	cmp    %al,%cl
  80b22d:	0f 85 a6 01 00 00    	jne    80b3d9 <dhcp_recv+0x22c>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b233:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  80b237:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b23b:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b23f:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b242:	77 c9                	ja     80b20d <dhcp_recv+0x60>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b244:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b248:	8b 40 04             	mov    0x4(%rax),%eax
  80b24b:	89 c7                	mov    %eax,%edi
  80b24d:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  80b254:	00 00 00 
  80b257:	ff d0                	callq  *%rax
  80b259:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b25d:	8b 52 04             	mov    0x4(%rdx),%edx
  80b260:	39 d0                	cmp    %edx,%eax
  80b262:	0f 85 74 01 00 00    	jne    80b3dc <dhcp_recv+0x22f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b268:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b26c:	48 89 c7             	mov    %rax,%rdi
  80b26f:	48 b8 19 af 80 00 00 	movabs $0x80af19,%rax
  80b276:	00 00 00 
  80b279:	ff d0                	callq  *%rax
  80b27b:	84 c0                	test   %al,%al
  80b27d:	0f 85 5c 01 00 00    	jne    80b3df <dhcp_recv+0x232>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b283:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b287:	be 35 00 00 00       	mov    $0x35,%esi
  80b28c:	48 89 c7             	mov    %rax,%rdi
  80b28f:	48 b8 c5 b9 80 00 00 	movabs $0x80b9c5,%rax
  80b296:	00 00 00 
  80b299:	ff d0                	callq  *%rax
  80b29b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b29f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b2a4:	0f 84 38 01 00 00    	je     80b3e2 <dhcp_recv+0x235>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b2aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b2ae:	48 83 c0 02          	add    $0x2,%rax
  80b2b2:	48 89 c7             	mov    %rax,%rdi
  80b2b5:	48 b8 51 bb 80 00 00 	movabs $0x80bb51,%rax
  80b2bc:	00 00 00 
  80b2bf:	ff d0                	callq  *%rax
  80b2c1:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b2c4:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b2c8:	0f 85 87 00 00 00    	jne    80b355 <dhcp_recv+0x1a8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b2ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2d2:	0f b6 00             	movzbl (%rax),%eax
  80b2d5:	3c 01                	cmp    $0x1,%al
  80b2d7:	75 35                	jne    80b30e <dhcp_recv+0x161>
      dhcp_handle_ack(netif);
  80b2d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b2dd:	48 89 c7             	mov    %rax,%rdi
  80b2e0:	48 b8 3f 96 80 00 00 	movabs $0x80963f,%rax
  80b2e7:	00 00 00 
  80b2ea:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b2ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2f0:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b2f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b2fa:	48 89 c7             	mov    %rax,%rdi
  80b2fd:	48 b8 ef 8e 80 00 00 	movabs $0x808eef,%rax
  80b304:	00 00 00 
  80b307:	ff d0                	callq  *%rax
  80b309:	e9 d5 00 00 00       	jmpq   80b3e3 <dhcp_recv+0x236>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b30e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b312:	0f b6 00             	movzbl (%rax),%eax
  80b315:	3c 03                	cmp    $0x3,%al
  80b317:	74 1a                	je     80b333 <dhcp_recv+0x186>
  80b319:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b31d:	0f b6 00             	movzbl (%rax),%eax
  80b320:	3c 04                	cmp    $0x4,%al
  80b322:	74 0f                	je     80b333 <dhcp_recv+0x186>
  80b324:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b328:	0f b6 00             	movzbl (%rax),%eax
  80b32b:	3c 05                	cmp    $0x5,%al
  80b32d:	0f 85 b0 00 00 00    	jne    80b3e3 <dhcp_recv+0x236>
      dhcp->request_timeout = 0;
  80b333:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b337:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b33d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b341:	48 89 c7             	mov    %rax,%rdi
  80b344:	48 b8 5e a2 80 00 00 	movabs $0x80a25e,%rax
  80b34b:	00 00 00 
  80b34e:	ff d0                	callq  *%rax
  80b350:	e9 8e 00 00 00       	jmpq   80b3e3 <dhcp_recv+0x236>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b355:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b359:	75 4b                	jne    80b3a6 <dhcp_recv+0x1f9>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b35b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b35f:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b362:	3c 03                	cmp    $0x3,%al
  80b364:	74 21                	je     80b387 <dhcp_recv+0x1da>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b366:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b36a:	0f b6 00             	movzbl (%rax),%eax
  80b36d:	3c 01                	cmp    $0x1,%al
  80b36f:	74 16                	je     80b387 <dhcp_recv+0x1da>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b371:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b375:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b378:	3c 04                	cmp    $0x4,%al
  80b37a:	74 0b                	je     80b387 <dhcp_recv+0x1da>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b37c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b380:	0f b6 00             	movzbl (%rax),%eax
  80b383:	3c 05                	cmp    $0x5,%al
  80b385:	75 1f                	jne    80b3a6 <dhcp_recv+0x1f9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b387:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b38b:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b391:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b395:	48 89 c7             	mov    %rax,%rdi
  80b398:	48 b8 40 8e 80 00 00 	movabs $0x808e40,%rax
  80b39f:	00 00 00 
  80b3a2:	ff d0                	callq  *%rax
  80b3a4:	eb 3d                	jmp    80b3e3 <dhcp_recv+0x236>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b3a6:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b3aa:	75 37                	jne    80b3e3 <dhcp_recv+0x236>
  80b3ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b3b0:	0f b6 00             	movzbl (%rax),%eax
  80b3b3:	3c 06                	cmp    $0x6,%al
  80b3b5:	75 2c                	jne    80b3e3 <dhcp_recv+0x236>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b3b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b3bb:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b3c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b3c5:	48 89 c7             	mov    %rax,%rdi
  80b3c8:	48 b8 8a 8f 80 00 00 	movabs $0x808f8a,%rax
  80b3cf:	00 00 00 
  80b3d2:	ff d0                	callq  *%rax
  80b3d4:	eb 0d                	jmp    80b3e3 <dhcp_recv+0x236>
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b3d6:	90                   	nop
  80b3d7:	eb 0a                	jmp    80b3e3 <dhcp_recv+0x236>
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80b3d9:	90                   	nop
  80b3da:	eb 07                	jmp    80b3e3 <dhcp_recv+0x236>
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80b3dc:	90                   	nop
  80b3dd:	eb 04                	jmp    80b3e3 <dhcp_recv+0x236>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80b3df:	90                   	nop
  80b3e0:	eb 01                	jmp    80b3e3 <dhcp_recv+0x236>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  if (options_ptr == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80b3e2:	90                   	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80b3e3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b3e7:	48 89 c7             	mov    %rax,%rdi
  80b3ea:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80b3f1:	00 00 00 
  80b3f4:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80b3f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b3fa:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b401:	00 
}
  80b402:	c9                   	leaveq 
  80b403:	c3                   	retq   

000000000080b404 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80b404:	55                   	push   %rbp
  80b405:	48 89 e5             	mov    %rsp,%rbp
  80b408:	53                   	push   %rbx
  80b409:	48 83 ec 28          	sub    $0x28,%rsp
  80b40d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80b411:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b416:	75 2a                	jne    80b442 <dhcp_create_request+0x3e>
  80b418:	48 ba 18 14 82 00 00 	movabs $0x821418,%rdx
  80b41f:	00 00 00 
  80b422:	be 2d 05 00 00       	mov    $0x52d,%esi
  80b427:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b42e:	00 00 00 
  80b431:	b8 00 00 00 00       	mov    $0x0,%eax
  80b436:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b43d:	00 00 00 
  80b440:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b442:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b446:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b44a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80b44e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80b453:	75 2a                	jne    80b47f <dhcp_create_request+0x7b>
  80b455:	48 ba 40 14 82 00 00 	movabs $0x821440,%rdx
  80b45c:	00 00 00 
  80b45f:	be 2f 05 00 00       	mov    $0x52f,%esi
  80b464:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b46b:	00 00 00 
  80b46e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b473:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b47a:	00 00 00 
  80b47d:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80b47f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b483:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b487:	48 85 c0             	test   %rax,%rax
  80b48a:	74 2a                	je     80b4b6 <dhcp_create_request+0xb2>
  80b48c:	48 ba 68 14 82 00 00 	movabs $0x821468,%rdx
  80b493:	00 00 00 
  80b496:	be 30 05 00 00       	mov    $0x530,%esi
  80b49b:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b4a2:	00 00 00 
  80b4a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b4aa:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b4b1:	00 00 00 
  80b4b4:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80b4b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b4ba:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b4be:	48 85 c0             	test   %rax,%rax
  80b4c1:	74 2a                	je     80b4ed <dhcp_create_request+0xe9>
  80b4c3:	48 ba 98 14 82 00 00 	movabs $0x821498,%rdx
  80b4ca:	00 00 00 
  80b4cd:	be 31 05 00 00       	mov    $0x531,%esi
  80b4d2:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b4d9:	00 00 00 
  80b4dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80b4e1:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b4e8:	00 00 00 
  80b4eb:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80b4ed:	ba 00 00 00 00       	mov    $0x0,%edx
  80b4f2:	be 34 01 00 00       	mov    $0x134,%esi
  80b4f7:	bf 00 00 00 00       	mov    $0x0,%edi
  80b4fc:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  80b503:	00 00 00 
  80b506:	ff d0                	callq  *%rax
  80b508:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b50c:	48 89 42 30          	mov    %rax,0x30(%rdx)
  if (dhcp->p_out == NULL) {
  80b510:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b514:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b518:	48 85 c0             	test   %rax,%rax
  80b51b:	75 0a                	jne    80b527 <dhcp_create_request+0x123>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80b51d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b522:	e9 13 02 00 00       	jmpq   80b73a <dhcp_create_request+0x336>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80b527:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b52b:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b52f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80b533:	66 3d 33 01          	cmp    $0x133,%ax
  80b537:	77 2a                	ja     80b563 <dhcp_create_request+0x15f>
  80b539:	48 ba c8 14 82 00 00 	movabs $0x8214c8,%rdx
  80b540:	00 00 00 
  80b543:	be 38 05 00 00       	mov    $0x538,%esi
  80b548:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b54f:	00 00 00 
  80b552:	b8 00 00 00 00       	mov    $0x0,%eax
  80b557:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b55e:	00 00 00 
  80b561:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80b563:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80b56a:	00 00 00 
  80b56d:	8b 00                	mov    (%rax),%eax
  80b56f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b573:	89 42 04             	mov    %eax,0x4(%rdx)
  80b576:	8d 50 01             	lea    0x1(%rax),%edx
  80b579:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80b580:	00 00 00 
  80b583:	89 10                	mov    %edx,(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80b585:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b589:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b58d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80b591:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b595:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80b599:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b59d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b5a1:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80b5a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5a8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b5ac:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80b5b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5b4:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b5b8:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80b5bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5c0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b5c4:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80b5c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5cc:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b5d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5d4:	8b 40 04             	mov    0x4(%rax),%eax
  80b5d7:	89 c7                	mov    %eax,%edi
  80b5d9:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80b5e0:	00 00 00 
  80b5e3:	ff d0                	callq  *%rax
  80b5e5:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80b5e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5ec:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b5f0:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80b5f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b5fa:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b5fe:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80b604:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b608:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b60c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b610:	8b 52 08             	mov    0x8(%rdx),%edx
  80b613:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80b616:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b61a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b61e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80b625:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b629:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b62d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80b634:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b638:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b63c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b643:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b649:	eb 3f                	jmp    80b68a <dhcp_create_request+0x286>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80b64b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b64f:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b653:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80b657:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b65b:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b65f:	0f b6 c0             	movzbl %al,%eax
  80b662:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80b666:	76 11                	jbe    80b679 <dhcp_create_request+0x275>
  80b668:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b66c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b670:	48 98                	cltq   
  80b672:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80b677:	eb 05                	jmp    80b67e <dhcp_create_request+0x27a>
  80b679:	b8 00 00 00 00       	mov    $0x0,%eax
  80b67e:	48 63 d6             	movslq %esi,%rdx
  80b681:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b685:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b68a:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80b68f:	76 ba                	jbe    80b64b <dhcp_create_request+0x247>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b691:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b697:	eb 18                	jmp    80b6b1 <dhcp_create_request+0x2ad>
    dhcp->msg_out->sname[i] = 0;
  80b699:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b69d:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b6a1:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b6a5:	48 98                	cltq   
  80b6a7:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b6ac:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b6b1:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80b6b6:	76 e1                	jbe    80b699 <dhcp_create_request+0x295>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b6b8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b6be:	eb 18                	jmp    80b6d8 <dhcp_create_request+0x2d4>
    dhcp->msg_out->file[i] = 0;
  80b6c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b6c4:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b6c8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b6cc:	48 98                	cltq   
  80b6ce:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b6d3:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b6d8:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80b6dd:	76 e1                	jbe    80b6c0 <dhcp_create_request+0x2bc>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80b6df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b6e3:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b6e7:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80b6ec:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80b6f3:	00 00 00 
  80b6f6:	ff d0                	callq  *%rax
  80b6f8:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80b6fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b702:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b708:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b70e:	eb 1e                	jmp    80b72e <dhcp_create_request+0x32a>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80b710:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b714:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b718:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b71c:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80b720:	48 98                	cltq   
  80b722:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b729:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b72e:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80b733:	76 db                	jbe    80b710 <dhcp_create_request+0x30c>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80b735:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b73a:	48 83 c4 28          	add    $0x28,%rsp
  80b73e:	5b                   	pop    %rbx
  80b73f:	5d                   	pop    %rbp
  80b740:	c3                   	retq   

000000000080b741 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80b741:	55                   	push   %rbp
  80b742:	48 89 e5             	mov    %rsp,%rbp
  80b745:	48 83 ec 20          	sub    $0x20,%rsp
  80b749:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80b74d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b752:	75 2a                	jne    80b77e <dhcp_delete_request+0x3d>
  80b754:	48 ba 10 15 82 00 00 	movabs $0x821510,%rdx
  80b75b:	00 00 00 
  80b75e:	be 69 05 00 00       	mov    $0x569,%esi
  80b763:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b76a:	00 00 00 
  80b76d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b772:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b779:	00 00 00 
  80b77c:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b77e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b782:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b786:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80b78a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b78f:	75 2a                	jne    80b7bb <dhcp_delete_request+0x7a>
  80b791:	48 ba 38 15 82 00 00 	movabs $0x821538,%rdx
  80b798:	00 00 00 
  80b79b:	be 6b 05 00 00       	mov    $0x56b,%esi
  80b7a0:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b7a7:	00 00 00 
  80b7aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80b7af:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b7b6:	00 00 00 
  80b7b9:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80b7bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b7bf:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b7c3:	48 85 c0             	test   %rax,%rax
  80b7c6:	75 2a                	jne    80b7f2 <dhcp_delete_request+0xb1>
  80b7c8:	48 ba 60 15 82 00 00 	movabs $0x821560,%rdx
  80b7cf:	00 00 00 
  80b7d2:	be 6c 05 00 00       	mov    $0x56c,%esi
  80b7d7:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b7de:	00 00 00 
  80b7e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80b7e6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b7ed:	00 00 00 
  80b7f0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80b7f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b7f6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7fa:	48 85 c0             	test   %rax,%rax
  80b7fd:	75 2a                	jne    80b829 <dhcp_delete_request+0xe8>
  80b7ff:	48 ba 90 15 82 00 00 	movabs $0x821590,%rdx
  80b806:	00 00 00 
  80b809:	be 6d 05 00 00       	mov    $0x56d,%esi
  80b80e:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b815:	00 00 00 
  80b818:	b8 00 00 00 00       	mov    $0x0,%eax
  80b81d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b824:	00 00 00 
  80b827:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80b829:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b82d:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b831:	48 85 c0             	test   %rax,%rax
  80b834:	74 17                	je     80b84d <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80b836:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b83a:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b83e:	48 89 c7             	mov    %rax,%rdi
  80b841:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80b848:	00 00 00 
  80b84b:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80b84d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b851:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80b858:	00 
  dhcp->msg_out = NULL;
  80b859:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b85d:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80b864:	00 
}
  80b865:	c9                   	leaveq 
  80b866:	c3                   	retq   

000000000080b867 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80b867:	55                   	push   %rbp
  80b868:	48 89 e5             	mov    %rsp,%rbp
  80b86b:	48 83 ec 10          	sub    $0x10,%rsp
  80b86f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80b873:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b878:	75 2a                	jne    80b8a4 <dhcp_option_trailer+0x3d>
  80b87a:	48 ba c0 15 82 00 00 	movabs $0x8215c0,%rdx
  80b881:	00 00 00 
  80b884:	be 80 05 00 00       	mov    $0x580,%esi
  80b889:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b890:	00 00 00 
  80b893:	b8 00 00 00 00       	mov    $0x0,%eax
  80b898:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b89f:	00 00 00 
  80b8a2:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80b8a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b8a8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b8ac:	48 85 c0             	test   %rax,%rax
  80b8af:	75 2a                	jne    80b8db <dhcp_option_trailer+0x74>
  80b8b1:	48 ba e8 15 82 00 00 	movabs $0x8215e8,%rdx
  80b8b8:	00 00 00 
  80b8bb:	be 81 05 00 00       	mov    $0x581,%esi
  80b8c0:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b8c7:	00 00 00 
  80b8ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8cf:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b8d6:	00 00 00 
  80b8d9:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b8db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b8df:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b8e3:	66 83 f8 43          	cmp    $0x43,%ax
  80b8e7:	76 2a                	jbe    80b913 <dhcp_option_trailer+0xac>
  80b8e9:	48 ba 18 16 82 00 00 	movabs $0x821618,%rdx
  80b8f0:	00 00 00 
  80b8f3:	be 82 05 00 00       	mov    $0x582,%esi
  80b8f8:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b8ff:	00 00 00 
  80b902:	b8 00 00 00 00       	mov    $0x0,%eax
  80b907:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b90e:	00 00 00 
  80b911:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80b913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b917:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b91b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b91f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b923:	0f b7 d0             	movzwl %ax,%edx
  80b926:	48 63 d2             	movslq %edx,%rdx
  80b929:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%rcx,%rdx,1)
  80b930:	ff 
  80b931:	8d 50 01             	lea    0x1(%rax),%edx
  80b934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b938:	66 89 50 40          	mov    %dx,0x40(%rax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80b93c:	eb 61                	jmp    80b99f <dhcp_option_trailer+0x138>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80b93e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b942:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b946:	66 83 f8 43          	cmp    $0x43,%ax
  80b94a:	76 2a                	jbe    80b976 <dhcp_option_trailer+0x10f>
  80b94c:	48 ba 18 16 82 00 00 	movabs $0x821618,%rdx
  80b953:	00 00 00 
  80b956:	be 87 05 00 00       	mov    $0x587,%esi
  80b95b:	48 bf 36 12 82 00 00 	movabs $0x821236,%rdi
  80b962:	00 00 00 
  80b965:	b8 00 00 00 00       	mov    $0x0,%eax
  80b96a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80b971:	00 00 00 
  80b974:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80b976:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b97a:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b97e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b982:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b986:	0f b7 d0             	movzwl %ax,%edx
  80b989:	48 63 d2             	movslq %edx,%rdx
  80b98c:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%rcx,%rdx,1)
  80b993:	00 
  80b994:	8d 50 01             	lea    0x1(%rax),%edx
  80b997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b99b:	66 89 50 40          	mov    %dx,0x40(%rax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80b99f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b9a3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b9a7:	66 83 f8 43          	cmp    $0x43,%ax
  80b9ab:	76 91                	jbe    80b93e <dhcp_option_trailer+0xd7>
  80b9ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b9b1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b9b5:	0f b7 c0             	movzwl %ax,%eax
  80b9b8:	83 e0 03             	and    $0x3,%eax
  80b9bb:	85 c0                	test   %eax,%eax
  80b9bd:	0f 85 7b ff ff ff    	jne    80b93e <dhcp_option_trailer+0xd7>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80b9c3:	c9                   	leaveq 
  80b9c4:	c3                   	retq   

000000000080b9c5 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80b9c5:	55                   	push   %rbp
  80b9c6:	48 89 e5             	mov    %rsp,%rbp
  80b9c9:	48 83 ec 30          	sub    $0x30,%rsp
  80b9cd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80b9d1:	89 f0                	mov    %esi,%eax
  80b9d3:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80b9d6:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80b9da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b9de:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b9e2:	48 85 c0             	test   %rax,%rax
  80b9e5:	0f 84 5f 01 00 00    	je     80bb4a <dhcp_get_option_ptr+0x185>
  80b9eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b9ef:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b9f3:	66 85 c0             	test   %ax,%ax
  80b9f6:	0f 84 4e 01 00 00    	je     80bb4a <dhcp_get_option_ptr+0x185>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80b9fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ba00:	48 8b 40 20          	mov    0x20(%rax),%rax
  80ba04:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80ba08:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80ba0e:	eb 64                	jmp    80ba74 <dhcp_get_option_ptr+0xaf>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80ba10:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80ba14:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80ba18:	0f b6 00             	movzbl (%rax),%eax
  80ba1b:	3c 34                	cmp    $0x34,%al
  80ba1d:	75 1a                	jne    80ba39 <dhcp_get_option_ptr+0x74>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80ba1f:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80ba24:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80ba28:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80ba2c:	0f b6 00             	movzbl (%rax),%eax
  80ba2f:	88 45 ff             	mov    %al,-0x1(%rbp)
  80ba32:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80ba37:	eb 3b                	jmp    80ba74 <dhcp_get_option_ptr+0xaf>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80ba39:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80ba3d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80ba41:	0f b6 00             	movzbl (%rax),%eax
  80ba44:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80ba47:	75 0d                	jne    80ba56 <dhcp_get_option_ptr+0x91>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80ba49:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80ba4d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80ba51:	e9 f9 00 00 00       	jmpq   80bb4f <dhcp_get_option_ptr+0x18a>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80ba56:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80ba5b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80ba5f:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80ba63:	0f b6 00             	movzbl (%rax),%eax
  80ba66:	0f b6 c0             	movzbl %al,%eax
  80ba69:	66 03 45 ee          	add    -0x12(%rbp),%ax
  80ba6d:	83 c0 01             	add    $0x1,%eax
  80ba70:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80ba74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ba78:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ba7c:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80ba80:	76 13                	jbe    80ba95 <dhcp_get_option_ptr+0xd0>
  80ba82:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80ba86:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80ba8a:	0f b6 00             	movzbl (%rax),%eax
  80ba8d:	3c ff                	cmp    $0xff,%al
  80ba8f:	0f 85 7b ff ff ff    	jne    80ba10 <dhcp_get_option_ptr+0x4b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80ba95:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ba99:	0f 84 ab 00 00 00    	je     80bb4a <dhcp_get_option_ptr+0x185>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80ba9f:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80baa3:	75 18                	jne    80babd <dhcp_get_option_ptr+0xf8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80baa5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80baa9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80baad:	48 83 c0 6c          	add    $0x6c,%rax
  80bab1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80bab5:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80babb:	eb 34                	jmp    80baf1 <dhcp_get_option_ptr+0x12c>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80babd:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80bac1:	75 18                	jne    80badb <dhcp_get_option_ptr+0x116>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bac3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bac7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bacb:	48 83 c0 2c          	add    $0x2c,%rax
  80bacf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80bad3:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80bad9:	eb 16                	jmp    80baf1 <dhcp_get_option_ptr+0x12c>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80badb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80badf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bae3:	48 83 c0 2c          	add    $0x2c,%rax
  80bae7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80baeb:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80baf1:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80baf7:	eb 38                	jmp    80bb31 <dhcp_get_option_ptr+0x16c>
        if (options[offset] == option_type) {
  80baf9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bafd:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bb01:	0f b6 00             	movzbl (%rax),%eax
  80bb04:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bb07:	75 0a                	jne    80bb13 <dhcp_get_option_ptr+0x14e>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80bb09:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb0d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bb11:	eb 3c                	jmp    80bb4f <dhcp_get_option_ptr+0x18a>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80bb13:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
          offset += 1 + options[offset];
  80bb18:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb1c:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bb20:	0f b6 00             	movzbl (%rax),%eax
  80bb23:	0f b6 c0             	movzbl %al,%eax
  80bb26:	66 03 45 ee          	add    -0x12(%rbp),%ax
  80bb2a:	83 c0 01             	add    $0x1,%eax
  80bb2d:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80bb31:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb35:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80bb39:	73 0f                	jae    80bb4a <dhcp_get_option_ptr+0x185>
  80bb3b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bb3f:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bb43:	0f b6 00             	movzbl (%rax),%eax
  80bb46:	3c ff                	cmp    $0xff,%al
  80bb48:	75 af                	jne    80baf9 <dhcp_get_option_ptr+0x134>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80bb4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bb4f:	c9                   	leaveq 
  80bb50:	c3                   	retq   

000000000080bb51 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80bb51:	55                   	push   %rbp
  80bb52:	48 89 e5             	mov    %rsp,%rbp
  80bb55:	48 83 ec 08          	sub    $0x8,%rsp
  80bb59:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80bb5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb61:	0f b6 00             	movzbl (%rax),%eax
}
  80bb64:	c9                   	leaveq 
  80bb65:	c3                   	retq   

000000000080bb66 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80bb66:	55                   	push   %rbp
  80bb67:	48 89 e5             	mov    %rsp,%rbp
  80bb6a:	48 83 ec 18          	sub    $0x18,%rsp
  80bb6e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80bb72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bb76:	0f b6 00             	movzbl (%rax),%eax
  80bb79:	0f b6 c0             	movzbl %al,%eax
  80bb7c:	c1 e0 18             	shl    $0x18,%eax
  80bb7f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80bb82:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80bb87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bb8b:	0f b6 00             	movzbl (%rax),%eax
  80bb8e:	0f b6 c0             	movzbl %al,%eax
  80bb91:	c1 e0 10             	shl    $0x10,%eax
  80bb94:	09 45 fc             	or     %eax,-0x4(%rbp)
  80bb97:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80bb9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bba0:	0f b6 00             	movzbl (%rax),%eax
  80bba3:	0f b6 c0             	movzbl %al,%eax
  80bba6:	c1 e0 08             	shl    $0x8,%eax
  80bba9:	09 45 fc             	or     %eax,-0x4(%rbp)
  80bbac:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  value |= (u32_t)(*ptr++);
  80bbb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bbb5:	0f b6 00             	movzbl (%rax),%eax
  80bbb8:	0f b6 c0             	movzbl %al,%eax
  80bbbb:	09 45 fc             	or     %eax,-0x4(%rbp)
  80bbbe:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80bbc3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80bbc6:	c9                   	leaveq 
  80bbc7:	c3                   	retq   

000000000080bbc8 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80bbc8:	55                   	push   %rbp
  80bbc9:	48 89 e5             	mov    %rsp,%rbp
  80bbcc:	53                   	push   %rbx
  80bbcd:	48 83 ec 28          	sub    $0x28,%rsp
  80bbd1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80bbd5:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bbdc:	00 00 00 
  80bbdf:	48 8b 00             	mov    (%rax),%rax
  80bbe2:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80bbe6:	73 2a                	jae    80bc12 <plug_holes+0x4a>
  80bbe8:	48 ba 58 16 82 00 00 	movabs $0x821658,%rdx
  80bbef:	00 00 00 
  80bbf2:	be e3 00 00 00       	mov    $0xe3,%esi
  80bbf7:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80bbfe:	00 00 00 
  80bc01:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc06:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80bc0d:	00 00 00 
  80bc10:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80bc12:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80bc19:	00 00 00 
  80bc1c:	48 8b 00             	mov    (%rax),%rax
  80bc1f:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80bc23:	72 2a                	jb     80bc4f <plug_holes+0x87>
  80bc25:	48 ba 83 16 82 00 00 	movabs $0x821683,%rdx
  80bc2c:	00 00 00 
  80bc2f:	be e4 00 00 00       	mov    $0xe4,%esi
  80bc34:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80bc3b:	00 00 00 
  80bc3e:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc43:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80bc4a:	00 00 00 
  80bc4d:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80bc4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc53:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bc57:	84 c0                	test   %al,%al
  80bc59:	74 2a                	je     80bc85 <plug_holes+0xbd>
  80bc5b:	48 ba 9d 16 82 00 00 	movabs $0x82169d,%rdx
  80bc62:	00 00 00 
  80bc65:	be e5 00 00 00       	mov    $0xe5,%esi
  80bc6a:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80bc71:	00 00 00 
  80bc74:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc79:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80bc80:	00 00 00 
  80bc83:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80bc85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc89:	8b 00                	mov    (%rax),%eax
  80bc8b:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80bc90:	76 2a                	jbe    80bcbc <plug_holes+0xf4>
  80bc92:	48 ba b8 16 82 00 00 	movabs $0x8216b8,%rdx
  80bc99:	00 00 00 
  80bc9c:	be e8 00 00 00       	mov    $0xe8,%esi
  80bca1:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80bca8:	00 00 00 
  80bcab:	b8 00 00 00 00       	mov    $0x0,%eax
  80bcb0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80bcb7:	00 00 00 
  80bcba:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80bcbc:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bcc3:	00 00 00 
  80bcc6:	48 8b 10             	mov    (%rax),%rdx
  80bcc9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bccd:	8b 00                	mov    (%rax),%eax
  80bccf:	89 c0                	mov    %eax,%eax
  80bcd1:	48 01 d0             	add    %rdx,%rax
  80bcd4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80bcd8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bcdc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80bce0:	0f 84 84 00 00 00    	je     80bd6a <plug_holes+0x1a2>
  80bce6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bcea:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bcee:	84 c0                	test   %al,%al
  80bcf0:	75 78                	jne    80bd6a <plug_holes+0x1a2>
  80bcf2:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80bcf9:	00 00 00 
  80bcfc:	48 8b 00             	mov    (%rax),%rax
  80bcff:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bd03:	74 65                	je     80bd6a <plug_holes+0x1a2>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80bd05:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80bd0c:	00 00 00 
  80bd0f:	48 8b 00             	mov    (%rax),%rax
  80bd12:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80bd16:	75 11                	jne    80bd29 <plug_holes+0x161>
      lfree = mem;
  80bd18:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80bd1f:	00 00 00 
  80bd22:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bd26:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80bd29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd2d:	8b 10                	mov    (%rax),%edx
  80bd2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bd33:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80bd35:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bd3c:	00 00 00 
  80bd3f:	48 8b 10             	mov    (%rax),%rdx
  80bd42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd46:	8b 00                	mov    (%rax),%eax
  80bd48:	89 c0                	mov    %eax,%eax
  80bd4a:	48 01 c2             	add    %rax,%rdx
  80bd4d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80bd51:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bd58:	00 00 00 
  80bd5b:	48 8b 00             	mov    (%rax),%rax
  80bd5e:	48 89 cb             	mov    %rcx,%rbx
  80bd61:	48 29 c3             	sub    %rax,%rbx
  80bd64:	48 89 d8             	mov    %rbx,%rax
  80bd67:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80bd6a:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bd71:	00 00 00 
  80bd74:	48 8b 10             	mov    (%rax),%rdx
  80bd77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bd7b:	8b 40 04             	mov    0x4(%rax),%eax
  80bd7e:	89 c0                	mov    %eax,%eax
  80bd80:	48 01 d0             	add    %rdx,%rax
  80bd83:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80bd87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bd8b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80bd8f:	74 71                	je     80be02 <plug_holes+0x23a>
  80bd91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bd95:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bd99:	84 c0                	test   %al,%al
  80bd9b:	75 65                	jne    80be02 <plug_holes+0x23a>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80bd9d:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80bda4:	00 00 00 
  80bda7:	48 8b 00             	mov    (%rax),%rax
  80bdaa:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80bdae:	75 11                	jne    80bdc1 <plug_holes+0x1f9>
      lfree = pmem;
  80bdb0:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80bdb7:	00 00 00 
  80bdba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80bdbe:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80bdc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bdc5:	8b 10                	mov    (%rax),%edx
  80bdc7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bdcb:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80bdcd:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bdd4:	00 00 00 
  80bdd7:	48 8b 10             	mov    (%rax),%rdx
  80bdda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bdde:	8b 00                	mov    (%rax),%eax
  80bde0:	89 c0                	mov    %eax,%eax
  80bde2:	48 01 c2             	add    %rax,%rdx
  80bde5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80bde9:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bdf0:	00 00 00 
  80bdf3:	48 8b 00             	mov    (%rax),%rax
  80bdf6:	48 89 cb             	mov    %rcx,%rbx
  80bdf9:	48 29 c3             	sub    %rax,%rbx
  80bdfc:	48 89 d8             	mov    %rbx,%rax
  80bdff:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80be02:	48 83 c4 28          	add    $0x28,%rsp
  80be06:	5b                   	pop    %rbx
  80be07:	5d                   	pop    %rbp
  80be08:	c3                   	retq   

000000000080be09 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80be09:	55                   	push   %rbp
  80be0a:	48 89 e5             	mov    %rsp,%rbp
  80be0d:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80be11:	48 b8 e0 94 82 00 00 	movabs $0x8294e0,%rax
  80be18:	00 00 00 
  80be1b:	48 83 c0 03          	add    $0x3,%rax
  80be1f:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80be23:	48 89 c2             	mov    %rax,%rdx
  80be26:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80be2d:	00 00 00 
  80be30:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80be33:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80be3a:	00 00 00 
  80be3d:	48 8b 00             	mov    (%rax),%rax
  80be40:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80be44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be48:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80be4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be52:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80be59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80be5d:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80be61:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80be68:	00 00 00 
  80be6b:	48 8b 00             	mov    (%rax),%rax
  80be6e:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80be75:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80be7c:	00 00 00 
  80be7f:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80be82:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80be89:	00 00 00 
  80be8c:	48 8b 00             	mov    (%rax),%rax
  80be8f:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80be93:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80be9a:	00 00 00 
  80be9d:	48 8b 00             	mov    (%rax),%rax
  80bea0:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80bea6:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80bead:	00 00 00 
  80beb0:	48 8b 00             	mov    (%rax),%rax
  80beb3:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80beba:	bf 01 00 00 00       	mov    $0x1,%edi
  80bebf:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  80bec6:	00 00 00 
  80bec9:	ff d0                	callq  *%rax
  80becb:	48 ba 18 95 a4 00 00 	movabs $0xa49518,%rdx
  80bed2:	00 00 00 
  80bed5:	89 02                	mov    %eax,(%rdx)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80bed7:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bede:	00 00 00 
  80bee1:	48 8b 10             	mov    (%rax),%rdx
  80bee4:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80beeb:	00 00 00 
  80beee:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80bef1:	c9                   	leaveq 
  80bef2:	c3                   	retq   

000000000080bef3 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80bef3:	55                   	push   %rbp
  80bef4:	48 89 e5             	mov    %rsp,%rbp
  80bef7:	48 83 ec 20          	sub    $0x20,%rsp
  80befb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80beff:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80bf04:	0f 84 70 01 00 00    	je     80c07a <mem_free+0x187>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80bf0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bf0e:	83 e0 03             	and    $0x3,%eax
  80bf11:	48 85 c0             	test   %rax,%rax
  80bf14:	74 2a                	je     80bf40 <mem_free+0x4d>
  80bf16:	48 ba e8 16 82 00 00 	movabs $0x8216e8,%rdx
  80bf1d:	00 00 00 
  80bf20:	be 30 01 00 00       	mov    $0x130,%esi
  80bf25:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80bf2c:	00 00 00 
  80bf2f:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf34:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80bf3b:	00 00 00 
  80bf3e:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80bf40:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bf47:	00 00 00 
  80bf4a:	48 8b 00             	mov    (%rax),%rax
  80bf4d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bf51:	72 13                	jb     80bf66 <mem_free+0x73>
  80bf53:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80bf5a:	00 00 00 
  80bf5d:	48 8b 00             	mov    (%rax),%rax
  80bf60:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bf64:	72 2a                	jb     80bf90 <mem_free+0x9d>
  80bf66:	48 ba 09 17 82 00 00 	movabs $0x821709,%rdx
  80bf6d:	00 00 00 
  80bf70:	be 33 01 00 00       	mov    $0x133,%esi
  80bf75:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80bf7c:	00 00 00 
  80bf7f:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf84:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80bf8b:	00 00 00 
  80bf8e:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80bf90:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80bf97:	00 00 00 
  80bf9a:	48 8b 00             	mov    (%rax),%rax
  80bf9d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bfa1:	0f 82 d6 00 00 00    	jb     80c07d <mem_free+0x18a>
  80bfa7:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80bfae:	00 00 00 
  80bfb1:	48 8b 00             	mov    (%rax),%rax
  80bfb4:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bfb8:	0f 83 bf 00 00 00    	jae    80c07d <mem_free+0x18a>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80bfbe:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80bfc5:	00 00 00 
  80bfc8:	8b 00                	mov    (%rax),%eax
  80bfca:	be 00 00 00 00       	mov    $0x0,%esi
  80bfcf:	89 c7                	mov    %eax,%edi
  80bfd1:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  80bfd8:	00 00 00 
  80bfdb:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80bfdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bfe1:	48 83 e8 0c          	sub    $0xc,%rax
  80bfe5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80bfe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bfed:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bff1:	84 c0                	test   %al,%al
  80bff3:	75 2a                	jne    80c01f <mem_free+0x12c>
  80bff5:	48 ba 20 17 82 00 00 	movabs $0x821720,%rdx
  80bffc:	00 00 00 
  80bfff:	be 43 01 00 00       	mov    $0x143,%esi
  80c004:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c00b:	00 00 00 
  80c00e:	b8 00 00 00 00       	mov    $0x0,%eax
  80c013:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c01a:	00 00 00 
  80c01d:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c01f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c023:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c027:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c02e:	00 00 00 
  80c031:	48 8b 00             	mov    (%rax),%rax
  80c034:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c038:	73 11                	jae    80c04b <mem_free+0x158>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c03a:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c041:	00 00 00 
  80c044:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c048:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c04b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c04f:	48 89 c7             	mov    %rax,%rdi
  80c052:	48 b8 c8 bb 80 00 00 	movabs $0x80bbc8,%rax
  80c059:	00 00 00 
  80c05c:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c05e:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c065:	00 00 00 
  80c068:	8b 00                	mov    (%rax),%eax
  80c06a:	89 c7                	mov    %eax,%edi
  80c06c:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80c073:	00 00 00 
  80c076:	ff d0                	callq  *%rax
  80c078:	eb 04                	jmp    80c07e <mem_free+0x18b>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c07a:	90                   	nop
  80c07b:	eb 01                	jmp    80c07e <mem_free+0x18b>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c07d:	90                   	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
  80c07e:	c9                   	leaveq 
  80c07f:	c3                   	retq   

000000000080c080 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c080:	55                   	push   %rbp
  80c081:	48 89 e5             	mov    %rsp,%rbp
  80c084:	48 83 ec 30          	sub    $0x30,%rsp
  80c088:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c08c:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c08f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c092:	83 c0 03             	add    $0x3,%eax
  80c095:	83 e0 fc             	and    $0xfffffffc,%eax
  80c098:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c09b:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c09f:	77 07                	ja     80c0a8 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c0a1:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c0a8:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c0af:	76 0a                	jbe    80c0bb <mem_realloc+0x3b>
    return NULL;
  80c0b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80c0b6:	e9 dc 02 00 00       	jmpq   80c397 <mem_realloc+0x317>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c0bb:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c0c2:	00 00 00 
  80c0c5:	48 8b 00             	mov    (%rax),%rax
  80c0c8:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c0cc:	72 13                	jb     80c0e1 <mem_realloc+0x61>
  80c0ce:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c0d5:	00 00 00 
  80c0d8:	48 8b 00             	mov    (%rax),%rax
  80c0db:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c0df:	72 2a                	jb     80c10b <mem_realloc+0x8b>
  80c0e1:	48 ba 34 17 82 00 00 	movabs $0x821734,%rdx
  80c0e8:	00 00 00 
  80c0eb:	be 79 01 00 00       	mov    $0x179,%esi
  80c0f0:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c0f7:	00 00 00 
  80c0fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80c0ff:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c106:	00 00 00 
  80c109:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c10b:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c112:	00 00 00 
  80c115:	48 8b 00             	mov    (%rax),%rax
  80c118:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c11c:	72 13                	jb     80c131 <mem_realloc+0xb1>
  80c11e:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c125:	00 00 00 
  80c128:	48 8b 00             	mov    (%rax),%rax
  80c12b:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c12f:	72 09                	jb     80c13a <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c131:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c135:	e9 5d 02 00 00       	jmpq   80c397 <mem_realloc+0x317>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c13a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c13e:	48 83 e8 0c          	sub    $0xc,%rax
  80c142:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c146:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c14a:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c151:	00 00 00 
  80c154:	48 8b 00             	mov    (%rax),%rax
  80c157:	48 89 d1             	mov    %rdx,%rcx
  80c15a:	48 29 c1             	sub    %rax,%rcx
  80c15d:	48 89 c8             	mov    %rcx,%rax
  80c160:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c163:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c167:	8b 00                	mov    (%rax),%eax
  80c169:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c16c:	83 e8 0c             	sub    $0xc,%eax
  80c16f:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c172:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c175:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c178:	76 2a                	jbe    80c1a4 <mem_realloc+0x124>
  80c17a:	48 ba 50 17 82 00 00 	movabs $0x821750,%rdx
  80c181:	00 00 00 
  80c184:	be 8a 01 00 00       	mov    $0x18a,%esi
  80c189:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c190:	00 00 00 
  80c193:	b8 00 00 00 00       	mov    $0x0,%eax
  80c198:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c19f:	00 00 00 
  80c1a2:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c1a4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c1a7:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c1aa:	76 0a                	jbe    80c1b6 <mem_realloc+0x136>
    /* not supported */
    return NULL;
  80c1ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1b1:	e9 e1 01 00 00       	jmpq   80c397 <mem_realloc+0x317>
  }
  if (newsize == size) {
  80c1b6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c1b9:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c1bc:	75 09                	jne    80c1c7 <mem_realloc+0x147>
    /* No change in size, simply return */
    return rmem;
  80c1be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c1c2:	e9 d0 01 00 00       	jmpq   80c397 <mem_realloc+0x317>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c1c7:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c1ce:	00 00 00 
  80c1d1:	8b 00                	mov    (%rax),%eax
  80c1d3:	be 00 00 00 00       	mov    $0x0,%esi
  80c1d8:	89 c7                	mov    %eax,%edi
  80c1da:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  80c1e1:	00 00 00 
  80c1e4:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c1e6:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c1ed:	00 00 00 
  80c1f0:	48 8b 10             	mov    (%rax),%rdx
  80c1f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c1f7:	8b 00                	mov    (%rax),%eax
  80c1f9:	89 c0                	mov    %eax,%eax
  80c1fb:	48 01 d0             	add    %rdx,%rax
  80c1fe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c206:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c20a:	84 c0                	test   %al,%al
  80c20c:	0f 85 b9 00 00 00    	jne    80c2cb <mem_realloc+0x24b>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c212:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c216:	8b 00                	mov    (%rax),%eax
  80c218:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c21b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c21e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c221:	01 d0                	add    %edx,%eax
  80c223:	83 c0 0c             	add    $0xc,%eax
  80c226:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c229:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c230:	00 00 00 
  80c233:	48 8b 00             	mov    (%rax),%rax
  80c236:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c23a:	75 20                	jne    80c25c <mem_realloc+0x1dc>
      lfree = (struct mem *)&ram[ptr2];
  80c23c:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c243:	00 00 00 
  80c246:	48 8b 10             	mov    (%rax),%rdx
  80c249:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c24c:	48 01 c2             	add    %rax,%rdx
  80c24f:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c256:	00 00 00 
  80c259:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c25c:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c263:	00 00 00 
  80c266:	48 8b 10             	mov    (%rax),%rdx
  80c269:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c26c:	48 01 d0             	add    %rdx,%rax
  80c26f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c273:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c277:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c27b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c27f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c282:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c284:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c288:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c28b:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c28e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c292:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c295:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c297:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c29b:	8b 00                	mov    (%rax),%eax
  80c29d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c2a2:	0f 84 d1 00 00 00    	je     80c379 <mem_realloc+0x2f9>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c2a8:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c2af:	00 00 00 
  80c2b2:	48 8b 10             	mov    (%rax),%rdx
  80c2b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c2b9:	8b 00                	mov    (%rax),%eax
  80c2bb:	89 c0                	mov    %eax,%eax
  80c2bd:	48 01 c2             	add    %rax,%rdx
  80c2c0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c2c3:	89 42 04             	mov    %eax,0x4(%rdx)
  80c2c6:	e9 ae 00 00 00       	jmpq   80c379 <mem_realloc+0x2f9>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c2cb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c2ce:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c2d2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c2d5:	48 39 c2             	cmp    %rax,%rdx
  80c2d8:	0f 87 9b 00 00 00    	ja     80c379 <mem_realloc+0x2f9>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c2de:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c2e1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c2e4:	01 d0                	add    %edx,%eax
  80c2e6:	83 c0 0c             	add    $0xc,%eax
  80c2e9:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c2ec:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c2f3:	00 00 00 
  80c2f6:	48 8b 10             	mov    (%rax),%rdx
  80c2f9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c2fc:	48 01 d0             	add    %rdx,%rax
  80c2ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c303:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c30a:	00 00 00 
  80c30d:	48 8b 00             	mov    (%rax),%rax
  80c310:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c314:	73 11                	jae    80c327 <mem_realloc+0x2a7>
      lfree = mem2;
  80c316:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c31d:	00 00 00 
  80c320:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c324:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c327:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c32b:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c32f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c333:	8b 10                	mov    (%rax),%edx
  80c335:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c339:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c33b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c33f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c342:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c345:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c349:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c34c:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c34e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c352:	8b 00                	mov    (%rax),%eax
  80c354:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c359:	74 1e                	je     80c379 <mem_realloc+0x2f9>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c35b:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c362:	00 00 00 
  80c365:	48 8b 10             	mov    (%rax),%rdx
  80c368:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c36c:	8b 00                	mov    (%rax),%eax
  80c36e:	89 c0                	mov    %eax,%eax
  80c370:	48 01 c2             	add    %rax,%rdx
  80c373:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c376:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c379:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c380:	00 00 00 
  80c383:	8b 00                	mov    (%rax),%eax
  80c385:	89 c7                	mov    %eax,%edi
  80c387:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80c38e:	00 00 00 
  80c391:	ff d0                	callq  *%rax
  return rmem;
  80c393:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80c397:	c9                   	leaveq 
  80c398:	c3                   	retq   

000000000080c399 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80c399:	55                   	push   %rbp
  80c39a:	48 89 e5             	mov    %rsp,%rbp
  80c39d:	48 83 ec 30          	sub    $0x30,%rsp
  80c3a1:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80c3a4:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80c3a8:	75 0a                	jne    80c3b4 <mem_malloc+0x1b>
    return NULL;
  80c3aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80c3af:	e9 74 03 00 00       	jmpq   80c728 <mem_malloc+0x38f>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80c3b4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c3b7:	83 c0 03             	add    $0x3,%eax
  80c3ba:	83 e0 fc             	and    $0xfffffffc,%eax
  80c3bd:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80c3c0:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80c3c4:	77 07                	ja     80c3cd <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80c3c6:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80c3cd:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80c3d4:	76 0a                	jbe    80c3e0 <mem_malloc+0x47>
    return NULL;
  80c3d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80c3db:	e9 48 03 00 00       	jmpq   80c728 <mem_malloc+0x38f>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80c3e0:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c3e7:	00 00 00 
  80c3ea:	8b 00                	mov    (%rax),%eax
  80c3ec:	be 00 00 00 00       	mov    $0x0,%esi
  80c3f1:	89 c7                	mov    %eax,%edi
  80c3f3:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  80c3fa:	00 00 00 
  80c3fd:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c3ff:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c406:	00 00 00 
  80c409:	48 8b 00             	mov    (%rax),%rax
  80c40c:	48 89 c2             	mov    %rax,%rdx
  80c40f:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c416:	00 00 00 
  80c419:	48 8b 00             	mov    (%rax),%rax
  80c41c:	48 89 d1             	mov    %rdx,%rcx
  80c41f:	48 29 c1             	sub    %rax,%rcx
  80c422:	48 89 c8             	mov    %rcx,%rax
  80c425:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80c428:	e9 cb 02 00 00       	jmpq   80c6f8 <mem_malloc+0x35f>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80c42d:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c434:	00 00 00 
  80c437:	48 8b 10             	mov    (%rax),%rdx
  80c43a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c43d:	48 01 d0             	add    %rdx,%rax
  80c440:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c444:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c448:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c44c:	84 c0                	test   %al,%al
  80c44e:	0f 85 8c 02 00 00    	jne    80c6e0 <mem_malloc+0x347>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80c454:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c458:	8b 00                	mov    (%rax),%eax
  80c45a:	89 c2                	mov    %eax,%edx
  80c45c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c45f:	48 89 d1             	mov    %rdx,%rcx
  80c462:	48 29 c1             	sub    %rax,%rcx
  80c465:	48 89 c8             	mov    %rcx,%rax
  80c468:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c46c:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c46f:	48 39 c2             	cmp    %rax,%rdx
  80c472:	0f 82 68 02 00 00    	jb     80c6e0 <mem_malloc+0x347>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80c478:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c47c:	8b 00                	mov    (%rax),%eax
  80c47e:	89 c2                	mov    %eax,%edx
  80c480:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c483:	48 89 d1             	mov    %rdx,%rcx
  80c486:	48 29 c1             	sub    %rax,%rcx
  80c489:	48 89 c8             	mov    %rcx,%rax
  80c48c:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c490:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c493:	48 83 c0 18          	add    $0x18,%rax
  80c497:	48 39 c2             	cmp    %rax,%rdx
  80c49a:	0f 82 81 00 00 00    	jb     80c521 <mem_malloc+0x188>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80c4a0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c4a3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c4a6:	01 d0                	add    %edx,%eax
  80c4a8:	83 c0 0c             	add    $0xc,%eax
  80c4ab:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80c4ae:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c4b5:	00 00 00 
  80c4b8:	48 8b 10             	mov    (%rax),%rdx
  80c4bb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c4be:	48 01 d0             	add    %rdx,%rax
  80c4c1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80c4c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c4c9:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80c4cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c4d1:	8b 10                	mov    (%rax),%edx
  80c4d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c4d7:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80c4d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c4dd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c4e0:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80c4e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c4e7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c4ea:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80c4ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c4f0:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80c4f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c4f8:	8b 00                	mov    (%rax),%eax
  80c4fa:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c4ff:	74 28                	je     80c529 <mem_malloc+0x190>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c501:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c508:	00 00 00 
  80c50b:	48 8b 10             	mov    (%rax),%rdx
  80c50e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c512:	8b 00                	mov    (%rax),%eax
  80c514:	89 c0                	mov    %eax,%eax
  80c516:	48 01 c2             	add    %rax,%rdx
  80c519:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c51c:	89 42 04             	mov    %eax,0x4(%rdx)
  80c51f:	eb 08                	jmp    80c529 <mem_malloc+0x190>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80c521:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c525:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80c529:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c530:	00 00 00 
  80c533:	48 8b 00             	mov    (%rax),%rax
  80c536:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80c53a:	0f 85 c2 00 00 00    	jne    80c602 <mem_malloc+0x269>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80c540:	eb 2e                	jmp    80c570 <mem_malloc+0x1d7>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80c542:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c549:	00 00 00 
  80c54c:	48 8b 10             	mov    (%rax),%rdx
  80c54f:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c556:	00 00 00 
  80c559:	48 8b 00             	mov    (%rax),%rax
  80c55c:	8b 00                	mov    (%rax),%eax
  80c55e:	89 c0                	mov    %eax,%eax
  80c560:	48 01 c2             	add    %rax,%rdx
  80c563:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c56a:	00 00 00 
  80c56d:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80c570:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c577:	00 00 00 
  80c57a:	48 8b 00             	mov    (%rax),%rax
  80c57d:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c581:	84 c0                	test   %al,%al
  80c583:	74 1f                	je     80c5a4 <mem_malloc+0x20b>
  80c585:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c58c:	00 00 00 
  80c58f:	48 8b 10             	mov    (%rax),%rdx
  80c592:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c599:	00 00 00 
  80c59c:	48 8b 00             	mov    (%rax),%rax
  80c59f:	48 39 c2             	cmp    %rax,%rdx
  80c5a2:	75 9e                	jne    80c542 <mem_malloc+0x1a9>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80c5a4:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c5ab:	00 00 00 
  80c5ae:	48 8b 10             	mov    (%rax),%rdx
  80c5b1:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c5b8:	00 00 00 
  80c5bb:	48 8b 00             	mov    (%rax),%rax
  80c5be:	48 39 c2             	cmp    %rax,%rdx
  80c5c1:	74 3f                	je     80c602 <mem_malloc+0x269>
  80c5c3:	48 b8 10 95 a4 00 00 	movabs $0xa49510,%rax
  80c5ca:	00 00 00 
  80c5cd:	48 8b 00             	mov    (%rax),%rax
  80c5d0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c5d4:	84 c0                	test   %al,%al
  80c5d6:	74 2a                	je     80c602 <mem_malloc+0x269>
  80c5d8:	48 ba 73 17 82 00 00 	movabs $0x821773,%rdx
  80c5df:	00 00 00 
  80c5e2:	be 46 02 00 00       	mov    $0x246,%esi
  80c5e7:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c5ee:	00 00 00 
  80c5f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5f6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c5fd:	00 00 00 
  80c600:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80c602:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c609:	00 00 00 
  80c60c:	8b 00                	mov    (%rax),%eax
  80c60e:	89 c7                	mov    %eax,%edi
  80c610:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80c617:	00 00 00 
  80c61a:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80c61c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80c61f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c623:	48 01 d0             	add    %rdx,%rax
  80c626:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80c62a:	48 b8 08 95 a4 00 00 	movabs $0xa49508,%rax
  80c631:	00 00 00 
  80c634:	48 8b 00             	mov    (%rax),%rax
  80c637:	48 39 c2             	cmp    %rax,%rdx
  80c63a:	76 2a                	jbe    80c666 <mem_malloc+0x2cd>
  80c63c:	48 ba 90 17 82 00 00 	movabs $0x821790,%rdx
  80c643:	00 00 00 
  80c646:	be 4b 02 00 00       	mov    $0x24b,%esi
  80c64b:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c652:	00 00 00 
  80c655:	b8 00 00 00 00       	mov    $0x0,%eax
  80c65a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c661:	00 00 00 
  80c664:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80c666:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c66a:	48 83 c0 0c          	add    $0xc,%rax
  80c66e:	83 e0 03             	and    $0x3,%eax
  80c671:	48 85 c0             	test   %rax,%rax
  80c674:	74 2a                	je     80c6a0 <mem_malloc+0x307>
  80c676:	48 ba c0 17 82 00 00 	movabs $0x8217c0,%rdx
  80c67d:	00 00 00 
  80c680:	be 4d 02 00 00       	mov    $0x24d,%esi
  80c685:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c68c:	00 00 00 
  80c68f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c694:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c69b:	00 00 00 
  80c69e:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80c6a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6a4:	83 e0 03             	and    $0x3,%eax
  80c6a7:	48 85 c0             	test   %rax,%rax
  80c6aa:	74 2a                	je     80c6d6 <mem_malloc+0x33d>
  80c6ac:	48 ba f0 17 82 00 00 	movabs $0x8217f0,%rdx
  80c6b3:	00 00 00 
  80c6b6:	be 4f 02 00 00       	mov    $0x24f,%esi
  80c6bb:	48 bf 6f 16 82 00 00 	movabs $0x82166f,%rdi
  80c6c2:	00 00 00 
  80c6c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c6ca:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c6d1:	00 00 00 
  80c6d4:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80c6d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6da:	48 83 c0 0c          	add    $0xc,%rax
  80c6de:	eb 48                	jmp    80c728 <mem_malloc+0x38f>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80c6e0:	48 b8 00 95 a4 00 00 	movabs $0xa49500,%rax
  80c6e7:	00 00 00 
  80c6ea:	48 8b 10             	mov    (%rax),%rdx
  80c6ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c6f0:	48 01 d0             	add    %rdx,%rax
  80c6f3:	8b 00                	mov    (%rax),%eax
  80c6f5:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c6f8:	b8 00 00 22 00       	mov    $0x220000,%eax
  80c6fd:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80c700:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80c703:	0f 87 24 fd ff ff    	ja     80c42d <mem_malloc+0x94>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80c709:	48 b8 18 95 a4 00 00 	movabs $0xa49518,%rax
  80c710:	00 00 00 
  80c713:	8b 00                	mov    (%rax),%eax
  80c715:	89 c7                	mov    %eax,%edi
  80c717:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80c71e:	00 00 00 
  80c721:	ff d0                	callq  *%rax
  return NULL;
  80c723:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c728:	c9                   	leaveq 
  80c729:	c3                   	retq   

000000000080c72a <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80c72a:	55                   	push   %rbp
  80c72b:	48 89 e5             	mov    %rsp,%rbp
  80c72e:	48 83 ec 20          	sub    $0x20,%rsp
  80c732:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80c735:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80c738:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c73b:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80c73f:	89 c7                	mov    %eax,%edi
  80c741:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  80c748:	00 00 00 
  80c74b:	ff d0                	callq  *%rax
  80c74d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80c751:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c756:	74 21                	je     80c779 <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80c758:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c75b:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80c75f:	89 c2                	mov    %eax,%edx
  80c761:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c765:	be 00 00 00 00       	mov    $0x0,%esi
  80c76a:	48 89 c7             	mov    %rax,%rdi
  80c76d:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  80c774:	00 00 00 
  80c777:	ff d0                	callq  *%rax
  }
  return p;
  80c779:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80c77d:	c9                   	leaveq 
  80c77e:	c3                   	retq   
	...

000000000080c780 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80c780:	55                   	push   %rbp
  80c781:	48 89 e5             	mov    %rsp,%rbp
  80c784:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80c788:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80c78e:	eb 05                	jmp    80c795 <memp_init+0x15>
  80c790:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80c795:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80c79a:	76 f4                	jbe    80c790 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80c79c:	48 b8 a0 95 a4 00 00 	movabs $0xa495a0,%rax
  80c7a3:	00 00 00 
  80c7a6:	48 83 c0 03          	add    $0x3,%rax
  80c7aa:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c7ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80c7b2:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80c7b8:	e9 97 00 00 00       	jmpq   80c854 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80c7bd:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c7c1:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c7c8:	00 00 00 
  80c7cb:	48 63 d2             	movslq %edx,%rdx
  80c7ce:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80c7d5:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80c7d6:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80c7dc:	eb 56                	jmp    80c834 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80c7de:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c7e2:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c7e9:	00 00 00 
  80c7ec:	48 63 d2             	movslq %edx,%rdx
  80c7ef:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80c7f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c7f7:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80c7fa:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c7fe:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c805:	00 00 00 
  80c808:	48 63 d2             	movslq %edx,%rdx
  80c80b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80c80f:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80c813:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c817:	48 b8 20 18 82 00 00 	movabs $0x821820,%rax
  80c81e:	00 00 00 
  80c821:	48 63 d2             	movslq %edx,%rdx
  80c824:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80c828:	0f b7 c0             	movzwl %ax,%eax
  80c82b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80c82f:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80c834:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c838:	48 b8 40 18 82 00 00 	movabs $0x821840,%rax
  80c83f:	00 00 00 
  80c842:	48 63 d2             	movslq %edx,%rdx
  80c845:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80c849:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80c84d:	77 8f                	ja     80c7de <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80c84f:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80c854:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80c859:	0f 86 5e ff ff ff    	jbe    80c7bd <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80c85f:	c9                   	leaveq 
  80c860:	c3                   	retq   

000000000080c861 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80c861:	55                   	push   %rbp
  80c862:	48 89 e5             	mov    %rsp,%rbp
  80c865:	48 83 ec 20          	sub    $0x20,%rsp
  80c869:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80c86c:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80c870:	76 2a                	jbe    80c89c <memp_malloc+0x3b>
  80c872:	48 ba ef 18 82 00 00 	movabs $0x8218ef,%rdx
  80c879:	00 00 00 
  80c87c:	be 2d 01 00 00       	mov    $0x12d,%esi
  80c881:	48 bf 0c 19 82 00 00 	movabs $0x82190c,%rdi
  80c888:	00 00 00 
  80c88b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c890:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c897:	00 00 00 
  80c89a:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80c89c:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c8a3:	00 00 00 
  80c8a6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c8a9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80c8ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80c8b1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c8b6:	74 4e                	je     80c906 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80c8b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c8bc:	48 8b 08             	mov    (%rax),%rcx
  80c8bf:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c8c6:	00 00 00 
  80c8c9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c8cc:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80c8d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c8d4:	83 e0 03             	and    $0x3,%eax
  80c8d7:	48 85 c0             	test   %rax,%rax
  80c8da:	74 2a                	je     80c906 <memp_malloc+0xa5>
  80c8dc:	48 ba 28 19 82 00 00 	movabs $0x821928,%rdx
  80c8e3:	00 00 00 
  80c8e6:	be 3f 01 00 00       	mov    $0x13f,%esi
  80c8eb:	48 bf 0c 19 82 00 00 	movabs $0x82190c,%rdi
  80c8f2:	00 00 00 
  80c8f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c8fa:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c901:	00 00 00 
  80c904:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80c906:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80c90a:	c9                   	leaveq 
  80c90b:	c3                   	retq   

000000000080c90c <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80c90c:	55                   	push   %rbp
  80c90d:	48 89 e5             	mov    %rsp,%rbp
  80c910:	48 83 ec 20          	sub    $0x20,%rsp
  80c914:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80c917:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80c91b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80c920:	74 6d                	je     80c98f <memp_free+0x83>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80c922:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c926:	83 e0 03             	and    $0x3,%eax
  80c929:	48 85 c0             	test   %rax,%rax
  80c92c:	74 2a                	je     80c958 <memp_free+0x4c>
  80c92e:	48 ba 50 19 82 00 00 	movabs $0x821950,%rdx
  80c935:	00 00 00 
  80c938:	be 5b 01 00 00       	mov    $0x15b,%esi
  80c93d:	48 bf 0c 19 82 00 00 	movabs $0x82190c,%rdi
  80c944:	00 00 00 
  80c947:	b8 00 00 00 00       	mov    $0x0,%eax
  80c94c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80c953:	00 00 00 
  80c956:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80c958:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c95c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80c960:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c967:	00 00 00 
  80c96a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c96d:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80c971:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c975:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80c978:	48 b8 20 95 a4 00 00 	movabs $0xa49520,%rax
  80c97f:	00 00 00 
  80c982:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c985:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80c989:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  80c98d:	eb 01                	jmp    80c990 <memp_free+0x84>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  80c98f:	90                   	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80c990:	c9                   	leaveq 
  80c991:	c3                   	retq   
	...

000000000080c994 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80c994:	55                   	push   %rbp
  80c995:	48 89 e5             	mov    %rsp,%rbp
  80c998:	48 83 ec 30          	sub    $0x30,%rsp
  80c99c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80c9a0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80c9a4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80c9a8:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80c9ac:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80c9b0:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80c9b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9b8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80c9bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9c3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80c9ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9ce:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80c9d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9d9:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80c9dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9e1:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80c9e8:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80c9e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9ed:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80c9f1:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80c9f5:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80c9fc:	00 00 00 
  80c9ff:	0f b6 00             	movzbl (%rax),%eax
  80ca02:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ca06:	88 42 4d             	mov    %al,0x4d(%rdx)
  80ca09:	8d 50 01             	lea    0x1(%rax),%edx
  80ca0c:	48 b8 4c b0 b4 00 00 	movabs $0xb4b04c,%rax
  80ca13:	00 00 00 
  80ca16:	88 10                	mov    %dl,(%rax)
  netif->input = input;
  80ca18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca1c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80ca20:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80ca24:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80ca28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ca2c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80ca30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca34:	48 89 c7             	mov    %rax,%rdi
  80ca37:	48 b8 86 ca 80 00 00 	movabs $0x80ca86,%rax
  80ca3e:	00 00 00 
  80ca41:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80ca43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca47:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80ca4b:	48 89 c7             	mov    %rax,%rdi
  80ca4e:	ff d2                	callq  *%rdx
  80ca50:	84 c0                	test   %al,%al
  80ca52:	74 07                	je     80ca5b <netif_add+0xc7>
    return NULL;
  80ca54:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca59:	eb 29                	jmp    80ca84 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80ca5b:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80ca62:	00 00 00 
  80ca65:	48 8b 10             	mov    (%rax),%rdx
  80ca68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca6c:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80ca6f:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80ca76:	00 00 00 
  80ca79:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ca7d:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80ca80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80ca84:	c9                   	leaveq 
  80ca85:	c3                   	retq   

000000000080ca86 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80ca86:	55                   	push   %rbp
  80ca87:	48 89 e5             	mov    %rsp,%rbp
  80ca8a:	48 83 ec 20          	sub    $0x20,%rsp
  80ca8e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ca92:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80ca96:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80ca9a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80ca9e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80caa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80caa6:	48 89 d6             	mov    %rdx,%rsi
  80caa9:	48 89 c7             	mov    %rax,%rdi
  80caac:	48 b8 37 cc 80 00 00 	movabs $0x80cc37,%rax
  80cab3:	00 00 00 
  80cab6:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80cab8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cabc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cac0:	48 89 d6             	mov    %rdx,%rsi
  80cac3:	48 89 c7             	mov    %rax,%rdi
  80cac6:	48 b8 6a cd 80 00 00 	movabs $0x80cd6a,%rax
  80cacd:	00 00 00 
  80cad0:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80cad2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80cad6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cada:	48 89 d6             	mov    %rdx,%rsi
  80cadd:	48 89 c7             	mov    %rax,%rdi
  80cae0:	48 b8 3d cd 80 00 00 	movabs $0x80cd3d,%rax
  80cae7:	00 00 00 
  80caea:	ff d0                	callq  *%rax
}
  80caec:	c9                   	leaveq 
  80caed:	c3                   	retq   

000000000080caee <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80caee:	55                   	push   %rbp
  80caef:	48 89 e5             	mov    %rsp,%rbp
  80caf2:	48 83 ec 20          	sub    $0x20,%rsp
  80caf6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80cafa:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80caff:	0f 84 98 00 00 00    	je     80cb9d <netif_remove+0xaf>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80cb05:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cb0c:	00 00 00 
  80cb0f:	48 8b 00             	mov    (%rax),%rax
  80cb12:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cb16:	75 16                	jne    80cb2e <netif_remove+0x40>
    netif_list = netif->next;
  80cb18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cb1c:	48 8b 10             	mov    (%rax),%rdx
  80cb1f:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cb26:	00 00 00 
  80cb29:	48 89 10             	mov    %rdx,(%rax)
  80cb2c:	eb 49                	jmp    80cb77 <netif_remove+0x89>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80cb2e:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cb35:	00 00 00 
  80cb38:	48 8b 00             	mov    (%rax),%rax
  80cb3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cb3f:	eb 28                	jmp    80cb69 <netif_remove+0x7b>
      if (tmpNetif->next == netif) {
  80cb41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb45:	48 8b 00             	mov    (%rax),%rax
  80cb48:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cb4c:	75 10                	jne    80cb5e <netif_remove+0x70>
        tmpNetif->next = netif->next;
  80cb4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cb52:	48 8b 10             	mov    (%rax),%rdx
  80cb55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb59:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80cb5c:	eb 12                	jmp    80cb70 <netif_remove+0x82>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80cb5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb62:	48 8b 00             	mov    (%rax),%rax
  80cb65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cb69:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cb6e:	75 d1                	jne    80cb41 <netif_remove+0x53>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80cb70:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cb75:	74 29                	je     80cba0 <netif_remove+0xb2>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80cb77:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80cb7e:	00 00 00 
  80cb81:	48 8b 00             	mov    (%rax),%rax
  80cb84:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cb88:	75 17                	jne    80cba1 <netif_remove+0xb3>
    /* reset default netif */
    netif_set_default(NULL);
  80cb8a:	bf 00 00 00 00       	mov    $0x0,%edi
  80cb8f:	48 b8 97 cd 80 00 00 	movabs $0x80cd97,%rax
  80cb96:	00 00 00 
  80cb99:	ff d0                	callq  *%rax
  80cb9b:	eb 04                	jmp    80cba1 <netif_remove+0xb3>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
  80cb9d:	90                   	nop
  80cb9e:	eb 01                	jmp    80cba1 <netif_remove+0xb3>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  80cba0:	90                   	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80cba1:	c9                   	leaveq 
  80cba2:	c3                   	retq   

000000000080cba3 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80cba3:	55                   	push   %rbp
  80cba4:	48 89 e5             	mov    %rsp,%rbp
  80cba7:	48 83 ec 18          	sub    $0x18,%rsp
  80cbab:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80cbaf:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cbb4:	75 07                	jne    80cbbd <netif_find+0x1a>
    return NULL;
  80cbb6:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbbb:	eb 78                	jmp    80cc35 <netif_find+0x92>
  }

  num = name[2] - '0';
  80cbbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cbc1:	48 83 c0 02          	add    $0x2,%rax
  80cbc5:	0f b6 00             	movzbl (%rax),%eax
  80cbc8:	83 e8 30             	sub    $0x30,%eax
  80cbcb:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80cbce:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cbd5:	00 00 00 
  80cbd8:	48 8b 00             	mov    (%rax),%rax
  80cbdb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cbdf:	eb 48                	jmp    80cc29 <netif_find+0x86>
    if (num == netif->num &&
  80cbe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbe5:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80cbe9:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80cbec:	75 30                	jne    80cc1e <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80cbee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cbf2:	0f b6 10             	movzbl (%rax),%edx
  80cbf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbf9:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80cbfd:	38 c2                	cmp    %al,%dl
  80cbff:	75 1d                	jne    80cc1e <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80cc01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cc05:	48 83 c0 01          	add    $0x1,%rax
  80cc09:	0f b6 10             	movzbl (%rax),%edx
  80cc0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc10:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80cc14:	38 c2                	cmp    %al,%dl
  80cc16:	75 06                	jne    80cc1e <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80cc18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc1c:	eb 17                	jmp    80cc35 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80cc1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc22:	48 8b 00             	mov    (%rax),%rax
  80cc25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cc29:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cc2e:	75 b1                	jne    80cbe1 <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80cc30:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80cc35:	c9                   	leaveq 
  80cc36:	c3                   	retq   

000000000080cc37 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80cc37:	55                   	push   %rbp
  80cc38:	48 89 e5             	mov    %rsp,%rbp
  80cc3b:	48 83 ec 30          	sub    $0x30,%rsp
  80cc3f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80cc43:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80cc47:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cc4b:	8b 10                	mov    (%rax),%edx
  80cc4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80cc51:	8b 40 08             	mov    0x8(%rax),%eax
  80cc54:	39 c2                	cmp    %eax,%edx
  80cc56:	0f 84 c4 00 00 00    	je     80cd20 <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80cc5c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80cc63:	00 00 00 
  80cc66:	48 8b 00             	mov    (%rax),%rax
  80cc69:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80cc6d:	eb 46                	jmp    80ccb5 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80cc6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc73:	8b 10                	mov    (%rax),%edx
  80cc75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80cc79:	8b 40 08             	mov    0x8(%rax),%eax
  80cc7c:	39 c2                	cmp    %eax,%edx
  80cc7e:	75 29                	jne    80cca9 <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80cc80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc84:	48 8b 40 10          	mov    0x10(%rax),%rax
  80cc88:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80cc8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc90:	48 89 c7             	mov    %rax,%rdi
  80cc93:	48 b8 31 e9 80 00 00 	movabs $0x80e931,%rax
  80cc9a:	00 00 00 
  80cc9d:	ff d0                	callq  *%rax
        pcb = next;
  80cc9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cca3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cca7:	eb 0c                	jmp    80ccb5 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80cca9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccad:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ccb1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80ccb5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ccba:	75 b3                	jne    80cc6f <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80ccbc:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80ccc3:	00 00 00 
  80ccc6:	48 8b 00             	mov    (%rax),%rax
  80ccc9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80cccd:	eb 4a                	jmp    80cd19 <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80cccf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ccd3:	48 85 c0             	test   %rax,%rax
  80ccd6:	74 35                	je     80cd0d <netif_set_ipaddr+0xd6>
  80ccd8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ccdc:	8b 00                	mov    (%rax),%eax
  80ccde:	85 c0                	test   %eax,%eax
  80cce0:	74 2b                	je     80cd0d <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80cce2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cce6:	8b 10                	mov    (%rax),%edx
  80cce8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ccec:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80ccef:	39 c2                	cmp    %eax,%edx
  80ccf1:	75 1a                	jne    80cd0d <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80ccf3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80ccf8:	74 08                	je     80cd02 <netif_set_ipaddr+0xcb>
  80ccfa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80ccfe:	8b 00                	mov    (%rax),%eax
  80cd00:	eb 05                	jmp    80cd07 <netif_set_ipaddr+0xd0>
  80cd02:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd07:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80cd0b:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80cd0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cd11:	48 8b 40 10          	mov    0x10(%rax),%rax
  80cd15:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80cd19:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cd1e:	75 af                	jne    80cccf <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80cd20:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80cd25:	74 08                	je     80cd2f <netif_set_ipaddr+0xf8>
  80cd27:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cd2b:	8b 00                	mov    (%rax),%eax
  80cd2d:	eb 05                	jmp    80cd34 <netif_set_ipaddr+0xfd>
  80cd2f:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd34:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cd38:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80cd3b:	c9                   	leaveq 
  80cd3c:	c3                   	retq   

000000000080cd3d <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80cd3d:	55                   	push   %rbp
  80cd3e:	48 89 e5             	mov    %rsp,%rbp
  80cd41:	48 83 ec 10          	sub    $0x10,%rsp
  80cd45:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cd49:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80cd4d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cd52:	74 08                	je     80cd5c <netif_set_gw+0x1f>
  80cd54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cd58:	8b 00                	mov    (%rax),%eax
  80cd5a:	eb 05                	jmp    80cd61 <netif_set_gw+0x24>
  80cd5c:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd61:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cd65:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80cd68:	c9                   	leaveq 
  80cd69:	c3                   	retq   

000000000080cd6a <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80cd6a:	55                   	push   %rbp
  80cd6b:	48 89 e5             	mov    %rsp,%rbp
  80cd6e:	48 83 ec 10          	sub    $0x10,%rsp
  80cd72:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cd76:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80cd7a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cd7f:	74 08                	je     80cd89 <netif_set_netmask+0x1f>
  80cd81:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cd85:	8b 00                	mov    (%rax),%eax
  80cd87:	eb 05                	jmp    80cd8e <netif_set_netmask+0x24>
  80cd89:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd8e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cd92:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80cd95:	c9                   	leaveq 
  80cd96:	c3                   	retq   

000000000080cd97 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80cd97:	55                   	push   %rbp
  80cd98:	48 89 e5             	mov    %rsp,%rbp
  80cd9b:	48 83 ec 08          	sub    $0x8,%rsp
  80cd9f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80cda3:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80cdaa:	00 00 00 
  80cdad:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cdb1:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80cdb4:	c9                   	leaveq 
  80cdb5:	c3                   	retq   

000000000080cdb6 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80cdb6:	55                   	push   %rbp
  80cdb7:	48 89 e5             	mov    %rsp,%rbp
  80cdba:	48 83 ec 10          	sub    $0x10,%rsp
  80cdbe:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80cdc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdc6:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80cdca:	0f b6 c0             	movzbl %al,%eax
  80cdcd:	83 e0 01             	and    $0x1,%eax
  80cdd0:	85 c0                	test   %eax,%eax
  80cdd2:	75 49                	jne    80ce1d <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80cdd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdd8:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80cddc:	89 c2                	mov    %eax,%edx
  80cdde:	83 ca 01             	or     $0x1,%edx
  80cde1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cde5:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80cde8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdec:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80cdf0:	0f b6 c0             	movzbl %al,%eax
  80cdf3:	83 e0 20             	and    $0x20,%eax
  80cdf6:	85 c0                	test   %eax,%eax
  80cdf8:	74 23                	je     80ce1d <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80cdfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdfe:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80ce02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce06:	ba 00 00 00 00       	mov    $0x0,%edx
  80ce0b:	48 89 ce             	mov    %rcx,%rsi
  80ce0e:	48 89 c7             	mov    %rax,%rdi
  80ce11:	48 b8 9b 66 81 00 00 	movabs $0x81669b,%rax
  80ce18:	00 00 00 
  80ce1b:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80ce1d:	c9                   	leaveq 
  80ce1e:	c3                   	retq   

000000000080ce1f <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80ce1f:	55                   	push   %rbp
  80ce20:	48 89 e5             	mov    %rsp,%rbp
  80ce23:	48 83 ec 08          	sub    $0x8,%rsp
  80ce27:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80ce2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce2f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80ce33:	0f b6 c0             	movzbl %al,%eax
  80ce36:	83 e0 01             	and    $0x1,%eax
  80ce39:	84 c0                	test   %al,%al
  80ce3b:	74 14                	je     80ce51 <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80ce3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce41:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80ce45:	89 c2                	mov    %eax,%edx
  80ce47:	83 e2 fe             	and    $0xfffffffe,%edx
  80ce4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce4e:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80ce51:	c9                   	leaveq 
  80ce52:	c3                   	retq   

000000000080ce53 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80ce53:	55                   	push   %rbp
  80ce54:	48 89 e5             	mov    %rsp,%rbp
  80ce57:	48 83 ec 08          	sub    $0x8,%rsp
  80ce5b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80ce5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce63:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80ce67:	83 e0 01             	and    $0x1,%eax
}
  80ce6a:	c9                   	leaveq 
  80ce6b:	c3                   	retq   

000000000080ce6c <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80ce6c:	55                   	push   %rbp
  80ce6d:	48 89 e5             	mov    %rsp,%rbp
  80ce70:	48 83 ec 30          	sub    $0x30,%rsp
  80ce74:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80ce77:	89 f0                	mov    %esi,%eax
  80ce79:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80ce7c:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80ce80:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80ce86:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80ce89:	83 f8 01             	cmp    $0x1,%eax
  80ce8c:	74 16                	je     80cea4 <pbuf_alloc+0x38>
  80ce8e:	83 f8 01             	cmp    $0x1,%eax
  80ce91:	72 0c                	jb     80ce9f <pbuf_alloc+0x33>
  80ce93:	83 f8 02             	cmp    $0x2,%eax
  80ce96:	74 11                	je     80cea9 <pbuf_alloc+0x3d>
  80ce98:	83 f8 03             	cmp    $0x3,%eax
  80ce9b:	74 3d                	je     80ceda <pbuf_alloc+0x6e>
  80ce9d:	eb 11                	jmp    80ceb0 <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80ce9f:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80cea4:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80cea9:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80ceae:	eb 2b                	jmp    80cedb <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80ceb0:	48 ba 70 19 82 00 00 	movabs $0x821970,%rdx
  80ceb7:	00 00 00 
  80ceba:	be 8a 00 00 00       	mov    $0x8a,%esi
  80cebf:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80cec6:	00 00 00 
  80cec9:	b8 00 00 00 00       	mov    $0x0,%eax
  80cece:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ced5:	00 00 00 
  80ced8:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80ceda:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80cedb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80cede:	83 f8 02             	cmp    $0x2,%eax
  80cee1:	77 0e                	ja     80cef1 <pbuf_alloc+0x85>
  80cee3:	83 f8 01             	cmp    $0x1,%eax
  80cee6:	0f 83 a9 03 00 00    	jae    80d295 <pbuf_alloc+0x429>
  80ceec:	e9 d9 02 00 00       	jmpq   80d1ca <pbuf_alloc+0x35e>
  80cef1:	83 f8 03             	cmp    $0x3,%eax
  80cef4:	0f 85 02 04 00 00    	jne    80d2fc <pbuf_alloc+0x490>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80cefa:	bf 0d 00 00 00       	mov    $0xd,%edi
  80ceff:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80cf06:	00 00 00 
  80cf09:	ff d0                	callq  *%rax
  80cf0b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80cf0f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cf14:	75 0a                	jne    80cf20 <pbuf_alloc+0xb4>
      return NULL;
  80cf16:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf1b:	e9 1d 04 00 00       	jmpq   80d33d <pbuf_alloc+0x4d1>
    }
    p->type = type;
  80cf20:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80cf23:	89 c2                	mov    %eax,%edx
  80cf25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf29:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80cf2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80cf37:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80cf3b:	48 83 c0 18          	add    $0x18,%rax
  80cf3f:	48 03 45 f8          	add    -0x8(%rbp),%rax
  80cf43:	48 83 c0 03          	add    $0x3,%rax
  80cf47:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80cf4b:	48 89 c2             	mov    %rax,%rdx
  80cf4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf52:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80cf56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf5a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80cf5e:	83 e0 03             	and    $0x3,%eax
  80cf61:	48 85 c0             	test   %rax,%rax
  80cf64:	74 2a                	je     80cf90 <pbuf_alloc+0x124>
  80cf66:	48 ba a0 19 82 00 00 	movabs $0x8219a0,%rdx
  80cf6d:	00 00 00 
  80cf70:	be 9c 00 00 00       	mov    $0x9c,%esi
  80cf75:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80cf7c:	00 00 00 
  80cf7f:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf84:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80cf8b:	00 00 00 
  80cf8e:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80cf90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cf94:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80cf98:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80cf9c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80cfa0:	83 c0 03             	add    $0x3,%eax
  80cfa3:	89 c2                	mov    %eax,%edx
  80cfa5:	83 e2 fc             	and    $0xfffffffc,%edx
  80cfa8:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80cfad:	89 c1                	mov    %eax,%ecx
  80cfaf:	29 d1                	sub    %edx,%ecx
  80cfb1:	89 ca                	mov    %ecx,%edx
  80cfb3:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80cfb7:	39 c2                	cmp    %eax,%edx
  80cfb9:	0f 4e c2             	cmovle %edx,%eax
  80cfbc:	89 c2                	mov    %eax,%edx
  80cfbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfc2:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80cfc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfca:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80cfce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfd2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80cfd6:	0f b7 c0             	movzwl %ax,%eax
  80cfd9:	48 01 c2             	add    %rax,%rdx
  80cfdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfe0:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80cfe6:	48 39 c2             	cmp    %rax,%rdx
  80cfe9:	76 2a                	jbe    80d015 <pbuf_alloc+0x1a9>
  80cfeb:	48 ba d0 19 82 00 00 	movabs $0x8219d0,%rdx
  80cff2:	00 00 00 
  80cff5:	be a3 00 00 00       	mov    $0xa3,%esi
  80cffa:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d001:	00 00 00 
  80d004:	b8 00 00 00 00       	mov    $0x0,%eax
  80d009:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d010:	00 00 00 
  80d013:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d015:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d019:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d01f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d023:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d027:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d02b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d02f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d033:	0f b7 c0             	movzwl %ax,%eax
  80d036:	89 d1                	mov    %edx,%ecx
  80d038:	29 c1                	sub    %eax,%ecx
  80d03a:	89 c8                	mov    %ecx,%eax
  80d03c:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d03f:	e9 77 01 00 00       	jmpq   80d1bb <pbuf_alloc+0x34f>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d044:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d049:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80d050:	00 00 00 
  80d053:	ff d0                	callq  *%rax
  80d055:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d059:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d05e:	75 1d                	jne    80d07d <pbuf_alloc+0x211>
        /* free chain so far allocated */
        pbuf_free(p);
  80d060:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d064:	48 89 c7             	mov    %rax,%rdi
  80d067:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80d06e:	00 00 00 
  80d071:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d073:	b8 00 00 00 00       	mov    $0x0,%eax
  80d078:	e9 c0 02 00 00       	jmpq   80d33d <pbuf_alloc+0x4d1>
      }
      q->type = type;
  80d07d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d080:	89 c2                	mov    %eax,%edx
  80d082:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d086:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d089:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d08d:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d091:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d095:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d09c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d0a0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d0a4:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d0a7:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d0ae:	7e 2a                	jle    80d0da <pbuf_alloc+0x26e>
  80d0b0:	48 ba 01 1a 82 00 00 	movabs $0x821a01,%rdx
  80d0b7:	00 00 00 
  80d0ba:	be bc 00 00 00       	mov    $0xbc,%esi
  80d0bf:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d0c6:	00 00 00 
  80d0c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d0ce:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d0d5:	00 00 00 
  80d0d8:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d0da:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d0dd:	89 c2                	mov    %eax,%edx
  80d0df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d0e3:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d0e7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d0ea:	66 3d cf 07          	cmp    $0x7cf,%ax
  80d0ee:	77 05                	ja     80d0f5 <pbuf_alloc+0x289>
  80d0f0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d0f3:	eb 05                	jmp    80d0fa <pbuf_alloc+0x28e>
  80d0f5:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d0fa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d0fe:	66 89 42 12          	mov    %ax,0x12(%rdx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d102:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d106:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d10a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d10e:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d112:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d116:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d11a:	83 e0 03             	and    $0x3,%eax
  80d11d:	48 85 c0             	test   %rax,%rax
  80d120:	74 2a                	je     80d14c <pbuf_alloc+0x2e0>
  80d122:	48 ba 18 1a 82 00 00 	movabs $0x821a18,%rdx
  80d129:	00 00 00 
  80d12c:	be c2 00 00 00       	mov    $0xc2,%esi
  80d131:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d138:	00 00 00 
  80d13b:	b8 00 00 00 00       	mov    $0x0,%eax
  80d140:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d147:	00 00 00 
  80d14a:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d14c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d150:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d154:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d158:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d15c:	0f b7 c0             	movzwl %ax,%eax
  80d15f:	48 01 c2             	add    %rax,%rdx
  80d162:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d166:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d16c:	48 39 c2             	cmp    %rax,%rdx
  80d16f:	76 2a                	jbe    80d19b <pbuf_alloc+0x32f>
  80d171:	48 ba d0 19 82 00 00 	movabs $0x8219d0,%rdx
  80d178:	00 00 00 
  80d17b:	be c5 00 00 00       	mov    $0xc5,%esi
  80d180:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d187:	00 00 00 
  80d18a:	b8 00 00 00 00       	mov    $0x0,%eax
  80d18f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d196:	00 00 00 
  80d199:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d19b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d19f:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d1a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d1a9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d1ad:	0f b7 c0             	movzwl %ax,%eax
  80d1b0:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d1b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d1b7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d1bb:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d1bf:	0f 8f 7f fe ff ff    	jg     80d044 <pbuf_alloc+0x1d8>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d1c5:	e9 5d 01 00 00       	jmpq   80d327 <pbuf_alloc+0x4bb>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d1ca:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d1ce:	83 c0 1b             	add    $0x1b,%eax
  80d1d1:	89 c2                	mov    %eax,%edx
  80d1d3:	83 e2 fc             	and    $0xfffffffc,%edx
  80d1d6:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d1da:	83 c0 03             	add    $0x3,%eax
  80d1dd:	83 e0 fc             	and    $0xfffffffc,%eax
  80d1e0:	01 d0                	add    %edx,%eax
  80d1e2:	89 c7                	mov    %eax,%edi
  80d1e4:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  80d1eb:	00 00 00 
  80d1ee:	ff d0                	callq  *%rax
  80d1f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d1f4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d1f9:	75 0a                	jne    80d205 <pbuf_alloc+0x399>
      return NULL;
  80d1fb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d200:	e9 38 01 00 00       	jmpq   80d33d <pbuf_alloc+0x4d1>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d205:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d209:	48 83 c0 18          	add    $0x18,%rax
  80d20d:	48 03 45 f8          	add    -0x8(%rbp),%rax
  80d211:	48 83 c0 03          	add    $0x3,%rax
  80d215:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d219:	48 89 c2             	mov    %rax,%rdx
  80d21c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d220:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d224:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d228:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d22c:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d234:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d238:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d23c:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d240:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d244:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d24b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d24e:	89 c2                	mov    %eax,%edx
  80d250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d254:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d257:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d25b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d25f:	83 e0 03             	and    $0x3,%eax
  80d262:	48 85 c0             	test   %rax,%rax
  80d265:	0f 84 bb 00 00 00    	je     80d326 <pbuf_alloc+0x4ba>
  80d26b:	48 ba 48 1a 82 00 00 	movabs $0x821a48,%rdx
  80d272:	00 00 00 
  80d275:	be dd 00 00 00       	mov    $0xdd,%esi
  80d27a:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d281:	00 00 00 
  80d284:	b8 00 00 00 00       	mov    $0x0,%eax
  80d289:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d290:	00 00 00 
  80d293:	ff d1                	callq  *%rcx
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d295:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d29a:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80d2a1:	00 00 00 
  80d2a4:	ff d0                	callq  *%rax
  80d2a6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d2aa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d2af:	75 0a                	jne    80d2bb <pbuf_alloc+0x44f>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d2b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d2b6:	e9 82 00 00 00       	jmpq   80d33d <pbuf_alloc+0x4d1>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d2bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2bf:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d2c6:	00 
    p->len = p->tot_len = length;
  80d2c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2cb:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d2cf:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d2d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2d7:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d2db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2df:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d2e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2e7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d2ee:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d2f1:	89 c2                	mov    %eax,%edx
  80d2f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d2f7:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d2fa:	eb 2b                	jmp    80d327 <pbuf_alloc+0x4bb>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d2fc:	48 ba 73 1a 82 00 00 	movabs $0x821a73,%rdx
  80d303:	00 00 00 
  80d306:	be f1 00 00 00       	mov    $0xf1,%esi
  80d30b:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d312:	00 00 00 
  80d315:	b8 00 00 00 00       	mov    $0x0,%eax
  80d31a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d321:	00 00 00 
  80d324:	ff d1                	callq  *%rcx
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d326:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d327:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d32b:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d331:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d335:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d339:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d33d:	c9                   	leaveq 
  80d33e:	c3                   	retq   

000000000080d33f <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d33f:	55                   	push   %rbp
  80d340:	48 89 e5             	mov    %rsp,%rbp
  80d343:	48 83 ec 20          	sub    $0x20,%rsp
  80d347:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d34b:	89 f0                	mov    %esi,%eax
  80d34d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d351:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d356:	75 2a                	jne    80d382 <pbuf_realloc+0x43>
  80d358:	48 ba 8e 1a 82 00 00 	movabs $0x821a8e,%rdx
  80d35f:	00 00 00 
  80d362:	be 13 01 00 00       	mov    $0x113,%esi
  80d367:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d36e:	00 00 00 
  80d371:	b8 00 00 00 00       	mov    $0x0,%eax
  80d376:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d37d:	00 00 00 
  80d380:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d382:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d386:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d38a:	3c 03                	cmp    $0x3,%al
  80d38c:	74 4e                	je     80d3dc <pbuf_realloc+0x9d>
  80d38e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d392:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d396:	3c 01                	cmp    $0x1,%al
  80d398:	74 42                	je     80d3dc <pbuf_realloc+0x9d>
  80d39a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d39e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d3a2:	84 c0                	test   %al,%al
  80d3a4:	74 36                	je     80d3dc <pbuf_realloc+0x9d>
  80d3a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d3aa:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d3ae:	3c 02                	cmp    $0x2,%al
  80d3b0:	74 2a                	je     80d3dc <pbuf_realloc+0x9d>
  80d3b2:	48 ba a6 1a 82 00 00 	movabs $0x821aa6,%rdx
  80d3b9:	00 00 00 
  80d3bc:	be 17 01 00 00       	mov    $0x117,%esi
  80d3c1:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d3c8:	00 00 00 
  80d3cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3d0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d3d7:	00 00 00 
  80d3da:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80d3dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d3e0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d3e4:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80d3e8:	0f 86 9e 01 00 00    	jbe    80d58c <pbuf_realloc+0x24d>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80d3ee:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80d3f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d3f6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d3fa:	0f b7 c0             	movzwl %ax,%eax
  80d3fd:	89 d1                	mov    %edx,%ecx
  80d3ff:	29 c1                	sub    %eax,%ecx
  80d401:	89 c8                	mov    %ecx,%eax
  80d403:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80d406:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d40a:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80d40e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d412:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d416:	e9 90 00 00 00       	jmpq   80d4ab <pbuf_realloc+0x16c>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80d41b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d41f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d423:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80d427:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80d42e:	7e 2a                	jle    80d45a <pbuf_realloc+0x11b>
  80d430:	48 ba c1 1a 82 00 00 	movabs $0x821ac1,%rdx
  80d437:	00 00 00 
  80d43a:	be 2b 01 00 00       	mov    $0x12b,%esi
  80d43f:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d446:	00 00 00 
  80d449:	b8 00 00 00 00       	mov    $0x0,%eax
  80d44e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d455:	00 00 00 
  80d458:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80d45a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d45e:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d462:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80d465:	01 c2                	add    %eax,%edx
  80d467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d46b:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80d46f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d473:	48 8b 00             	mov    (%rax),%rax
  80d476:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80d47a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d47f:	75 2a                	jne    80d4ab <pbuf_realloc+0x16c>
  80d481:	48 ba d2 1a 82 00 00 	movabs $0x821ad2,%rdx
  80d488:	00 00 00 
  80d48b:	be 2f 01 00 00       	mov    $0x12f,%esi
  80d490:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d497:	00 00 00 
  80d49a:	b8 00 00 00 00       	mov    $0x0,%eax
  80d49f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d4a6:	00 00 00 
  80d4a9:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d4ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4af:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d4b3:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d4b7:	0f 82 5e ff ff ff    	jb     80d41b <pbuf_realloc+0xdc>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80d4bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4c1:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d4c5:	84 c0                	test   %al,%al
  80d4c7:	75 78                	jne    80d541 <pbuf_realloc+0x202>
  80d4c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4cd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d4d1:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d4d5:	74 6a                	je     80d541 <pbuf_realloc+0x202>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80d4d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4db:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d4df:	48 89 c2             	mov    %rax,%rdx
  80d4e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4e6:	48 89 d1             	mov    %rdx,%rcx
  80d4e9:	48 29 c1             	sub    %rax,%rcx
  80d4ec:	48 89 c8             	mov    %rcx,%rax
  80d4ef:	89 c2                	mov    %eax,%edx
  80d4f1:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80d4f5:	01 c2                	add    %eax,%edx
  80d4f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4fb:	89 d6                	mov    %edx,%esi
  80d4fd:	48 89 c7             	mov    %rax,%rdi
  80d500:	48 b8 80 c0 80 00 00 	movabs $0x80c080,%rax
  80d507:	00 00 00 
  80d50a:	ff d0                	callq  *%rax
  80d50c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80d510:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d515:	75 2a                	jne    80d541 <pbuf_realloc+0x202>
  80d517:	48 ba ea 1a 82 00 00 	movabs $0x821aea,%rdx
  80d51e:	00 00 00 
  80d521:	be 39 01 00 00       	mov    $0x139,%esi
  80d526:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d52d:	00 00 00 
  80d530:	b8 00 00 00 00       	mov    $0x0,%eax
  80d535:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d53c:	00 00 00 
  80d53f:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80d541:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d545:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80d549:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80d54d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d551:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d555:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d559:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80d55d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d561:	48 8b 00             	mov    (%rax),%rax
  80d564:	48 85 c0             	test   %rax,%rax
  80d567:	74 16                	je     80d57f <pbuf_realloc+0x240>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80d569:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d56d:	48 8b 00             	mov    (%rax),%rax
  80d570:	48 89 c7             	mov    %rax,%rdi
  80d573:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80d57a:	00 00 00 
  80d57d:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80d57f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d583:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  80d58a:	eb 01                	jmp    80d58d <pbuf_realloc+0x24e>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
  80d58c:	90                   	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
  80d58d:	c9                   	leaveq 
  80d58e:	c3                   	retq   

000000000080d58f <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80d58f:	55                   	push   %rbp
  80d590:	48 89 e5             	mov    %rsp,%rbp
  80d593:	48 83 ec 20          	sub    $0x20,%rsp
  80d597:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d59b:	89 f0                	mov    %esi,%eax
  80d59d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80d5a1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d5a6:	75 2a                	jne    80d5d2 <pbuf_header+0x43>
  80d5a8:	48 ba 05 1b 82 00 00 	movabs $0x821b05,%rdx
  80d5af:	00 00 00 
  80d5b2:	be 64 01 00 00       	mov    $0x164,%esi
  80d5b7:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d5be:	00 00 00 
  80d5c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5c6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d5cd:	00 00 00 
  80d5d0:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80d5d2:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d5d7:	74 07                	je     80d5e0 <pbuf_header+0x51>
  80d5d9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d5de:	75 0a                	jne    80d5ea <pbuf_header+0x5b>
    return 0;
  80d5e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5e5:	e9 66 01 00 00       	jmpq   80d750 <pbuf_header+0x1c1>
 
  if (header_size_increment < 0){
  80d5ea:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d5ef:	79 42                	jns    80d633 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80d5f1:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d5f5:	f7 d8                	neg    %eax
  80d5f7:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80d5fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d5ff:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d603:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d607:	73 32                	jae    80d63b <pbuf_header+0xac>
  80d609:	48 ba 0f 1b 82 00 00 	movabs $0x821b0f,%rdx
  80d610:	00 00 00 
  80d613:	be 6b 01 00 00       	mov    $0x16b,%esi
  80d618:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d61f:	00 00 00 
  80d622:	b8 00 00 00 00       	mov    $0x0,%eax
  80d627:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d62e:	00 00 00 
  80d631:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80d633:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d637:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80d63b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d63f:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d643:	0f b6 c0             	movzbl %al,%eax
  80d646:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80d64a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d64e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d652:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80d656:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80d65b:	74 07                	je     80d664 <pbuf_header+0xd5>
  80d65d:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80d662:	75 4a                	jne    80d6ae <pbuf_header+0x11f>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80d664:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d668:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d66c:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d671:	48 f7 da             	neg    %rdx
  80d674:	48 01 c2             	add    %rax,%rdx
  80d677:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d67b:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80d67f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d683:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d687:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d68b:	48 83 c2 18          	add    $0x18,%rdx
  80d68f:	48 39 d0             	cmp    %rdx,%rax
  80d692:	0f 83 87 00 00 00    	jae    80d71f <pbuf_header+0x190>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80d698:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d69c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d6a0:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80d6a4:	b8 01 00 00 00       	mov    $0x1,%eax
  80d6a9:	e9 a2 00 00 00       	jmpq   80d750 <pbuf_header+0x1c1>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80d6ae:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80d6b3:	74 07                	je     80d6bc <pbuf_header+0x12d>
  80d6b5:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80d6ba:	75 39                	jne    80d6f5 <pbuf_header+0x166>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d6bc:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d6c1:	79 2b                	jns    80d6ee <pbuf_header+0x15f>
  80d6c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6c7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d6cb:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d6cf:	72 1d                	jb     80d6ee <pbuf_header+0x15f>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80d6d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6d5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d6d9:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d6de:	48 f7 da             	neg    %rdx
  80d6e1:	48 01 c2             	add    %rax,%rdx
  80d6e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d6e8:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d6ec:	eb 31                	jmp    80d71f <pbuf_header+0x190>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80d6ee:	b8 01 00 00 00       	mov    $0x1,%eax
  80d6f3:	eb 5b                	jmp    80d750 <pbuf_header+0x1c1>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80d6f5:	48 ba 2d 1b 82 00 00 	movabs $0x821b2d,%rdx
  80d6fc:	00 00 00 
  80d6ff:	be 9a 01 00 00       	mov    $0x19a,%esi
  80d704:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d70b:	00 00 00 
  80d70e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d713:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d71a:	00 00 00 
  80d71d:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80d71f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d723:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d727:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d72b:	01 c2                	add    %eax,%edx
  80d72d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d731:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80d735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d739:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d73d:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d741:	01 c2                	add    %eax,%edx
  80d743:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d747:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80d74b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d750:	c9                   	leaveq 
  80d751:	c3                   	retq   

000000000080d752 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80d752:	55                   	push   %rbp
  80d753:	48 89 e5             	mov    %rsp,%rbp
  80d756:	48 83 ec 30          	sub    $0x30,%rsp
  80d75a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80d75e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d763:	75 3b                	jne    80d7a0 <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80d765:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d76a:	75 2a                	jne    80d796 <pbuf_free+0x44>
  80d76c:	48 ba 05 1b 82 00 00 	movabs $0x821b05,%rdx
  80d773:	00 00 00 
  80d776:	be d0 01 00 00       	mov    $0x1d0,%esi
  80d77b:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d782:	00 00 00 
  80d785:	b8 00 00 00 00       	mov    $0x0,%eax
  80d78a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d791:	00 00 00 
  80d794:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80d796:	b8 00 00 00 00       	mov    $0x0,%eax
  80d79b:	e9 5f 01 00 00       	jmpq   80d8ff <pbuf_free+0x1ad>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80d7a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d7a4:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d7a8:	84 c0                	test   %al,%al
  80d7aa:	74 4e                	je     80d7fa <pbuf_free+0xa8>
  80d7ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d7b0:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d7b4:	3c 01                	cmp    $0x1,%al
  80d7b6:	74 42                	je     80d7fa <pbuf_free+0xa8>
  80d7b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d7bc:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d7c0:	3c 02                	cmp    $0x2,%al
  80d7c2:	74 36                	je     80d7fa <pbuf_free+0xa8>
  80d7c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d7c8:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d7cc:	3c 03                	cmp    $0x3,%al
  80d7ce:	74 2a                	je     80d7fa <pbuf_free+0xa8>
  80d7d0:	48 ba 3b 1b 82 00 00 	movabs $0x821b3b,%rdx
  80d7d7:	00 00 00 
  80d7da:	be db 01 00 00       	mov    $0x1db,%esi
  80d7df:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d7e6:	00 00 00 
  80d7e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7ee:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d7f5:	00 00 00 
  80d7f8:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80d7fa:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80d7fe:	e9 ed 00 00 00       	jmpq   80d8f0 <pbuf_free+0x19e>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80d803:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d807:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d80b:	66 85 c0             	test   %ax,%ax
  80d80e:	75 2a                	jne    80d83a <pbuf_free+0xe8>
  80d810:	48 ba 50 1b 82 00 00 	movabs $0x821b50,%rdx
  80d817:	00 00 00 
  80d81a:	be e8 01 00 00       	mov    $0x1e8,%esi
  80d81f:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d826:	00 00 00 
  80d829:	b8 00 00 00 00       	mov    $0x0,%eax
  80d82e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d835:	00 00 00 
  80d838:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80d83a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d83e:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d842:	8d 50 ff             	lea    -0x1(%rax),%edx
  80d845:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d849:	66 89 50 16          	mov    %dx,0x16(%rax)
  80d84d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d851:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d855:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80d859:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80d85e:	0f 85 84 00 00 00    	jne    80d8e8 <pbuf_free+0x196>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80d864:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d868:	48 8b 00             	mov    (%rax),%rax
  80d86b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80d86f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d873:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d877:	0f b6 c0             	movzbl %al,%eax
  80d87a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80d87e:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80d883:	75 1a                	jne    80d89f <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80d885:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d889:	48 89 c6             	mov    %rax,%rsi
  80d88c:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d891:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80d898:	00 00 00 
  80d89b:	ff d0                	callq  *%rax
  80d89d:	eb 3b                	jmp    80d8da <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80d89f:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80d8a4:	74 07                	je     80d8ad <pbuf_free+0x15b>
  80d8a6:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80d8ab:	75 1a                	jne    80d8c7 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80d8ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d8b1:	48 89 c6             	mov    %rax,%rsi
  80d8b4:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d8b9:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80d8c0:	00 00 00 
  80d8c3:	ff d0                	callq  *%rax
  80d8c5:	eb 13                	jmp    80d8da <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80d8c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d8cb:	48 89 c7             	mov    %rax,%rdi
  80d8ce:	48 b8 f3 be 80 00 00 	movabs $0x80bef3,%rax
  80d8d5:	00 00 00 
  80d8d8:	ff d0                	callq  *%rax
      }
      count++;
  80d8da:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80d8de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d8e2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80d8e6:	eb 08                	jmp    80d8f0 <pbuf_free+0x19e>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80d8e8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80d8ef:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80d8f0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d8f5:	0f 85 08 ff ff ff    	jne    80d803 <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80d8fb:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80d8ff:	c9                   	leaveq 
  80d900:	c3                   	retq   

000000000080d901 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80d901:	55                   	push   %rbp
  80d902:	48 89 e5             	mov    %rsp,%rbp
  80d905:	48 83 ec 18          	sub    $0x18,%rsp
  80d909:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80d90d:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80d911:	eb 0f                	jmp    80d922 <pbuf_clen+0x21>
    ++len;
  80d913:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80d917:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d91b:	48 8b 00             	mov    (%rax),%rax
  80d91e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80d922:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d927:	75 ea                	jne    80d913 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80d929:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80d92d:	c9                   	leaveq 
  80d92e:	c3                   	retq   

000000000080d92f <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80d92f:	55                   	push   %rbp
  80d930:	48 89 e5             	mov    %rsp,%rbp
  80d933:	48 83 ec 08          	sub    $0x8,%rsp
  80d937:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80d93b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d940:	74 13                	je     80d955 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80d942:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d946:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d94a:	8d 50 01             	lea    0x1(%rax),%edx
  80d94d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d951:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80d955:	c9                   	leaveq 
  80d956:	c3                   	retq   

000000000080d957 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80d957:	55                   	push   %rbp
  80d958:	48 89 e5             	mov    %rsp,%rbp
  80d95b:	48 83 ec 20          	sub    $0x20,%rsp
  80d95f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d963:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80d967:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d96c:	74 07                	je     80d975 <pbuf_cat+0x1e>
  80d96e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d973:	75 2a                	jne    80d99f <pbuf_cat+0x48>
  80d975:	48 ba 68 1b 82 00 00 	movabs $0x821b68,%rdx
  80d97c:	00 00 00 
  80d97f:	be 42 02 00 00       	mov    $0x242,%esi
  80d984:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80d98b:	00 00 00 
  80d98e:	b8 00 00 00 00       	mov    $0x0,%eax
  80d993:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80d99a:	00 00 00 
  80d99d:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80d99f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d9a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d9a7:	eb 25                	jmp    80d9ce <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80d9a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9ad:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d9b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d9b5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d9b9:	01 c2                	add    %eax,%edx
  80d9bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9bf:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80d9c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9c7:	48 8b 00             	mov    (%rax),%rax
  80d9ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80d9ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9d2:	48 8b 00             	mov    (%rax),%rax
  80d9d5:	48 85 c0             	test   %rax,%rax
  80d9d8:	75 cf                	jne    80d9a9 <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80d9da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9de:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d9e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d9e6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d9ea:	66 39 c2             	cmp    %ax,%dx
  80d9ed:	74 2a                	je     80da19 <pbuf_cat+0xc2>
  80d9ef:	48 ba a0 1b 82 00 00 	movabs $0x821ba0,%rdx
  80d9f6:	00 00 00 
  80d9f9:	be 4a 02 00 00       	mov    $0x24a,%esi
  80d9fe:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80da05:	00 00 00 
  80da08:	b8 00 00 00 00       	mov    $0x0,%eax
  80da0d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80da14:	00 00 00 
  80da17:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80da19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da1d:	48 8b 00             	mov    (%rax),%rax
  80da20:	48 85 c0             	test   %rax,%rax
  80da23:	74 2a                	je     80da4f <pbuf_cat+0xf8>
  80da25:	48 ba cd 1b 82 00 00 	movabs $0x821bcd,%rdx
  80da2c:	00 00 00 
  80da2f:	be 4b 02 00 00       	mov    $0x24b,%esi
  80da34:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80da3b:	00 00 00 
  80da3e:	b8 00 00 00 00       	mov    $0x0,%eax
  80da43:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80da4a:	00 00 00 
  80da4d:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80da4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da53:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80da57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80da5b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80da5f:	01 c2                	add    %eax,%edx
  80da61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da65:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80da69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da6d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80da71:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80da74:	c9                   	leaveq 
  80da75:	c3                   	retq   

000000000080da76 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80da76:	55                   	push   %rbp
  80da77:	48 89 e5             	mov    %rsp,%rbp
  80da7a:	48 83 ec 10          	sub    $0x10,%rsp
  80da7e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80da82:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80da86:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80da8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80da8e:	48 89 d6             	mov    %rdx,%rsi
  80da91:	48 89 c7             	mov    %rax,%rdi
  80da94:	48 b8 57 d9 80 00 00 	movabs $0x80d957,%rax
  80da9b:	00 00 00 
  80da9e:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80daa0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80daa4:	48 89 c7             	mov    %rax,%rdi
  80daa7:	48 b8 2f d9 80 00 00 	movabs $0x80d92f,%rax
  80daae:	00 00 00 
  80dab1:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80dab3:	c9                   	leaveq 
  80dab4:	c3                   	retq   

000000000080dab5 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80dab5:	55                   	push   %rbp
  80dab6:	48 89 e5             	mov    %rsp,%rbp
  80dab9:	53                   	push   %rbx
  80daba:	48 83 ec 28          	sub    $0x28,%rsp
  80dabe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80dac2:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  /* tail */
  q = p->next;
  80dac6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80daca:	48 8b 00             	mov    (%rax),%rax
  80dacd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80dad1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80dad6:	0f 84 a1 00 00 00    	je     80db7d <pbuf_dechain+0xc8>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80dadc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dae0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dae4:	0f b7 d0             	movzwl %ax,%edx
  80dae7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80daeb:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80daef:	0f b7 c8             	movzwl %ax,%ecx
  80daf2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80daf6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dafa:	0f b7 c0             	movzwl %ax,%eax
  80dafd:	89 cb                	mov    %ecx,%ebx
  80daff:	29 c3                	sub    %eax,%ebx
  80db01:	89 d8                	mov    %ebx,%eax
  80db03:	39 c2                	cmp    %eax,%edx
  80db05:	74 2a                	je     80db31 <pbuf_dechain+0x7c>
  80db07:	48 ba e0 1b 82 00 00 	movabs $0x821be0,%rdx
  80db0e:	00 00 00 
  80db11:	be 80 02 00 00       	mov    $0x280,%esi
  80db16:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80db1d:	00 00 00 
  80db20:	b8 00 00 00 00       	mov    $0x0,%eax
  80db25:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80db2c:	00 00 00 
  80db2f:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80db31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db35:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80db39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db3d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80db41:	66 29 c2             	sub    %ax,%dx
  80db44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80db48:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80db4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db50:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80db57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db5b:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80db5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db63:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80db67:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80db6b:	48 89 c7             	mov    %rax,%rdi
  80db6e:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80db75:	00 00 00 
  80db78:	ff d0                	callq  *%rax
  80db7a:	88 45 ef             	mov    %al,-0x11(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80db7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db81:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80db85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80db89:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80db8d:	66 39 c2             	cmp    %ax,%dx
  80db90:	74 2a                	je     80dbbc <pbuf_dechain+0x107>
  80db92:	48 ba 02 1c 82 00 00 	movabs $0x821c02,%rdx
  80db99:	00 00 00 
  80db9c:	be 91 02 00 00       	mov    $0x291,%esi
  80dba1:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80dba8:	00 00 00 
  80dbab:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbb0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80dbb7:	00 00 00 
  80dbba:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80dbbc:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80dbc0:	75 06                	jne    80dbc8 <pbuf_dechain+0x113>
  80dbc2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dbc6:	eb 05                	jmp    80dbcd <pbuf_dechain+0x118>
  80dbc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80dbcd:	48 83 c4 28          	add    $0x28,%rsp
  80dbd1:	5b                   	pop    %rbx
  80dbd2:	5d                   	pop    %rbp
  80dbd3:	c3                   	retq   

000000000080dbd4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80dbd4:	55                   	push   %rbp
  80dbd5:	48 89 e5             	mov    %rsp,%rbp
  80dbd8:	53                   	push   %rbx
  80dbd9:	48 83 ec 28          	sub    $0x28,%rsp
  80dbdd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80dbe1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80dbe5:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80dbeb:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80dbf1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dbf6:	74 1c                	je     80dc14 <pbuf_copy+0x40>
  80dbf8:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80dbfd:	74 15                	je     80dc14 <pbuf_copy+0x40>
  80dbff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dc03:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dc07:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dc0b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dc0f:	66 39 c2             	cmp    %ax,%dx
  80dc12:	73 2a                	jae    80dc3e <pbuf_copy+0x6a>
  80dc14:	48 ba 18 1c 82 00 00 	movabs $0x821c18,%rdx
  80dc1b:	00 00 00 
  80dc1e:	be b1 02 00 00       	mov    $0x2b1,%esi
  80dc23:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80dc2a:	00 00 00 
  80dc2d:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc32:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80dc39:	00 00 00 
  80dc3c:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80dc3e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dc43:	75 2a                	jne    80dc6f <pbuf_copy+0x9b>
  80dc45:	48 ba 48 1c 82 00 00 	movabs $0x821c48,%rdx
  80dc4c:	00 00 00 
  80dc4f:	be b6 02 00 00       	mov    $0x2b6,%esi
  80dc54:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80dc5b:	00 00 00 
  80dc5e:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc63:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80dc6a:	00 00 00 
  80dc6d:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80dc6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dc73:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dc77:	0f b7 d0             	movzwl %ax,%edx
  80dc7a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80dc7e:	89 d1                	mov    %edx,%ecx
  80dc80:	29 c1                	sub    %eax,%ecx
  80dc82:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dc86:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dc8a:	0f b7 d0             	movzwl %ax,%edx
  80dc8d:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80dc91:	89 d3                	mov    %edx,%ebx
  80dc93:	29 c3                	sub    %eax,%ebx
  80dc95:	89 d8                	mov    %ebx,%eax
  80dc97:	39 c1                	cmp    %eax,%ecx
  80dc99:	7c 12                	jl     80dcad <pbuf_copy+0xd9>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80dc9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dc9f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dca3:	66 2b 45 ec          	sub    -0x14(%rbp),%ax
  80dca7:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
  80dcab:	eb 10                	jmp    80dcbd <pbuf_copy+0xe9>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80dcad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dcb1:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dcb5:	66 2b 45 ee          	sub    -0x12(%rbp),%ax
  80dcb9:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80dcbd:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  80dcc1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80dcc5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80dcc9:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  80dccd:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80dcd1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80dcd5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80dcd9:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80dcdd:	48 01 d1             	add    %rdx,%rcx
  80dce0:	48 89 c2             	mov    %rax,%rdx
  80dce3:	48 89 cf             	mov    %rcx,%rdi
  80dce6:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  80dced:	00 00 00 
  80dcf0:	ff d0                	callq  *%rax
    offset_to += len;
  80dcf2:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  80dcf6:	66 01 45 ee          	add    %ax,-0x12(%rbp)
    offset_from += len;
  80dcfa:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  80dcfe:	66 01 45 ec          	add    %ax,-0x14(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80dd02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd06:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd0a:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80dd0e:	73 2a                	jae    80dd3a <pbuf_copy+0x166>
  80dd10:	48 ba 55 1c 82 00 00 	movabs $0x821c55,%rdx
  80dd17:	00 00 00 
  80dd1a:	be c2 02 00 00       	mov    $0x2c2,%esi
  80dd1f:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80dd26:	00 00 00 
  80dd29:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd2e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80dd35:	00 00 00 
  80dd38:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80dd3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd3e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd42:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80dd46:	75 11                	jne    80dd59 <pbuf_copy+0x185>
      /* on to next p_to (if any) */
      offset_to = 0;
  80dd48:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
      p_to = p_to->next;
  80dd4e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd52:	48 8b 00             	mov    (%rax),%rax
  80dd55:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80dd59:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dd5d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd61:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80dd65:	73 2a                	jae    80dd91 <pbuf_copy+0x1bd>
  80dd67:	48 ba 6c 1c 82 00 00 	movabs $0x821c6c,%rdx
  80dd6e:	00 00 00 
  80dd71:	be c8 02 00 00       	mov    $0x2c8,%esi
  80dd76:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80dd7d:	00 00 00 
  80dd80:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd85:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80dd8c:	00 00 00 
  80dd8f:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80dd91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dd95:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd99:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80dd9d:	77 11                	ja     80ddb0 <pbuf_copy+0x1dc>
      /* on to next p_from (if any) */
      offset_from = 0;
  80dd9f:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%rbp)
      p_from = p_from->next;
  80dda5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dda9:	48 8b 00             	mov    (%rax),%rax
  80ddac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80ddb0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80ddb5:	74 4b                	je     80de02 <pbuf_copy+0x22e>
  80ddb7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80ddbb:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80ddbf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80ddc3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80ddc7:	66 39 c2             	cmp    %ax,%dx
  80ddca:	75 36                	jne    80de02 <pbuf_copy+0x22e>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80ddcc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80ddd0:	48 8b 00             	mov    (%rax),%rax
  80ddd3:	48 85 c0             	test   %rax,%rax
  80ddd6:	74 2a                	je     80de02 <pbuf_copy+0x22e>
  80ddd8:	48 ba 88 1c 82 00 00 	movabs $0x821c88,%rdx
  80dddf:	00 00 00 
  80dde2:	be d2 02 00 00       	mov    $0x2d2,%esi
  80dde7:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80ddee:	00 00 00 
  80ddf1:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddf6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80ddfd:	00 00 00 
  80de00:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80de02:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80de07:	74 4b                	je     80de54 <pbuf_copy+0x280>
  80de09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de0d:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80de11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de15:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80de19:	66 39 c2             	cmp    %ax,%dx
  80de1c:	75 36                	jne    80de54 <pbuf_copy+0x280>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80de1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de22:	48 8b 00             	mov    (%rax),%rax
  80de25:	48 85 c0             	test   %rax,%rax
  80de28:	74 2a                	je     80de54 <pbuf_copy+0x280>
  80de2a:	48 ba 88 1c 82 00 00 	movabs $0x821c88,%rdx
  80de31:	00 00 00 
  80de34:	be d7 02 00 00       	mov    $0x2d7,%esi
  80de39:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80de40:	00 00 00 
  80de43:	b8 00 00 00 00       	mov    $0x0,%eax
  80de48:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80de4f:	00 00 00 
  80de52:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80de54:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80de59:	0f 85 df fd ff ff    	jne    80dc3e <pbuf_copy+0x6a>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80de5f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80de64:	48 83 c4 28          	add    $0x28,%rsp
  80de68:	5b                   	pop    %rbx
  80de69:	5d                   	pop    %rbp
  80de6a:	c3                   	retq   

000000000080de6b <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80de6b:	55                   	push   %rbp
  80de6c:	48 89 e5             	mov    %rsp,%rbp
  80de6f:	48 83 ec 30          	sub    $0x30,%rsp
  80de73:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80de77:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80de7b:	89 c8                	mov    %ecx,%eax
  80de7d:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80de81:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80de85:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80de8b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80de90:	75 2a                	jne    80debc <pbuf_copy_partial+0x51>
  80de92:	48 ba b8 1c 82 00 00 	movabs $0x821cb8,%rdx
  80de99:	00 00 00 
  80de9c:	be ef 02 00 00       	mov    $0x2ef,%esi
  80dea1:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80dea8:	00 00 00 
  80deab:	b8 00 00 00 00       	mov    $0x0,%eax
  80deb0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80deb7:	00 00 00 
  80deba:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80debc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80dec1:	75 2a                	jne    80deed <pbuf_copy_partial+0x82>
  80dec3:	48 ba e0 1c 82 00 00 	movabs $0x821ce0,%rdx
  80deca:	00 00 00 
  80decd:	be f0 02 00 00       	mov    $0x2f0,%esi
  80ded2:	48 bf 8b 19 82 00 00 	movabs $0x82198b,%rdi
  80ded9:	00 00 00 
  80dedc:	b8 00 00 00 00       	mov    $0x0,%eax
  80dee1:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80dee8:	00 00 00 
  80deeb:	ff d1                	callq  *%rcx

  left = 0;
  80deed:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80def3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80def8:	74 07                	je     80df01 <pbuf_copy_partial+0x96>
  80defa:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80deff:	75 0a                	jne    80df0b <pbuf_copy_partial+0xa0>
    return 0;
  80df01:	b8 00 00 00 00       	mov    $0x0,%eax
  80df06:	e9 be 00 00 00       	jmpq   80dfc9 <pbuf_copy_partial+0x15e>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80df0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80df0f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80df13:	e9 9b 00 00 00       	jmpq   80dfb3 <pbuf_copy_partial+0x148>
    if ((offset != 0) && (offset >= p->len)) {
  80df18:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80df1d:	74 1c                	je     80df3b <pbuf_copy_partial+0xd0>
  80df1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df23:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df27:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80df2b:	77 0e                	ja     80df3b <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80df2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df31:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df35:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80df39:	eb 6d                	jmp    80dfa8 <pbuf_copy_partial+0x13d>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80df3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df3f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df43:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80df47:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80df4b:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80df4f:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80df53:	76 08                	jbe    80df5d <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80df55:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80df59:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80df5d:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  80df61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80df65:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80df69:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80df6d:	48 01 c1             	add    %rax,%rcx
  80df70:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80df74:	48 03 45 e0          	add    -0x20(%rbp),%rax
  80df78:	48 89 ce             	mov    %rcx,%rsi
  80df7b:	48 89 c7             	mov    %rax,%rdi
  80df7e:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  80df85:	00 00 00 
  80df88:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80df8a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80df8e:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80df92:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80df96:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80df9a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80df9e:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80dfa2:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80dfa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dfac:	48 8b 00             	mov    (%rax),%rax
  80dfaf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dfb3:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80dfb8:	74 0b                	je     80dfc5 <pbuf_copy_partial+0x15a>
  80dfba:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80dfbf:	0f 85 53 ff ff ff    	jne    80df18 <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80dfc5:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80dfc9:	c9                   	leaveq 
  80dfca:	c3                   	retq   
	...

000000000080dfcc <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80dfcc:	55                   	push   %rbp
  80dfcd:	48 89 e5             	mov    %rsp,%rbp
  80dfd0:	48 83 ec 40          	sub    $0x40,%rsp
  80dfd4:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80dfd7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80dfdb:	eb 01                	jmp    80dfde <sys_mbox_fetch+0x12>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80dfdd:	90                   	nop
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80dfde:	48 b8 79 82 81 00 00 	movabs $0x818279,%rax
  80dfe5:	00 00 00 
  80dfe8:	ff d0                	callq  *%rax
  80dfea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80dfee:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80dff3:	74 0c                	je     80e001 <sys_mbox_fetch+0x35>
  80dff5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dff9:	48 8b 00             	mov    (%rax),%rax
  80dffc:	48 85 c0             	test   %rax,%rax
  80dfff:	75 25                	jne    80e026 <sys_mbox_fetch+0x5a>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e001:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e005:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e008:	ba 00 00 00 00       	mov    $0x0,%edx
  80e00d:	48 89 ce             	mov    %rcx,%rsi
  80e010:	89 c7                	mov    %eax,%edi
  80e012:	48 b8 90 7d 81 00 00 	movabs $0x817d90,%rax
  80e019:	00 00 00 
  80e01c:	ff d0                	callq  *%rax
  80e01e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e021:	e9 e0 00 00 00       	jmpq   80e106 <sys_mbox_fetch+0x13a>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e026:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e02a:	48 8b 00             	mov    (%rax),%rax
  80e02d:	8b 40 08             	mov    0x8(%rax),%eax
  80e030:	85 c0                	test   %eax,%eax
  80e032:	74 27                	je     80e05b <sys_mbox_fetch+0x8f>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e034:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e038:	48 8b 00             	mov    (%rax),%rax
  80e03b:	8b 50 08             	mov    0x8(%rax),%edx
  80e03e:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e042:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e045:	48 89 ce             	mov    %rcx,%rsi
  80e048:	89 c7                	mov    %eax,%edi
  80e04a:	48 b8 90 7d 81 00 00 	movabs $0x817d90,%rax
  80e051:	00 00 00 
  80e054:	ff d0                	callq  *%rax
  80e056:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e059:	eb 07                	jmp    80e062 <sys_mbox_fetch+0x96>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e05b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e062:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e066:	75 68                	jne    80e0d0 <sys_mbox_fetch+0x104>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e068:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e06c:	48 8b 00             	mov    (%rax),%rax
  80e06f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e077:	48 8b 10             	mov    (%rax),%rdx
  80e07a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e07e:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e081:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e085:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e089:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e08d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e091:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e095:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e099:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e09d:	48 89 c6             	mov    %rax,%rsi
  80e0a0:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e0a5:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e0ac:	00 00 00 
  80e0af:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e0b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e0b5:	48 85 c0             	test   %rax,%rax
  80e0b8:	0f 84 1f ff ff ff    	je     80dfdd <sys_mbox_fetch+0x11>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e0be:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80e0c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e0c6:	48 89 c7             	mov    %rax,%rdi
  80e0c9:	ff d2                	callq  *%rdx
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e0cb:	e9 0d ff ff ff       	jmpq   80dfdd <sys_mbox_fetch+0x11>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e0d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e0d4:	48 8b 00             	mov    (%rax),%rax
  80e0d7:	8b 40 08             	mov    0x8(%rax),%eax
  80e0da:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e0dd:	76 19                	jbe    80e0f8 <sys_mbox_fetch+0x12c>
        timeouts->next->time -= time_needed;
  80e0df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e0e3:	48 8b 00             	mov    (%rax),%rax
  80e0e6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e0ea:	48 8b 12             	mov    (%rdx),%rdx
  80e0ed:	8b 52 08             	mov    0x8(%rdx),%edx
  80e0f0:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e0f3:	89 50 08             	mov    %edx,0x8(%rax)
  80e0f6:	eb 0e                	jmp    80e106 <sys_mbox_fetch+0x13a>
      } else {
        timeouts->next->time = 0;
  80e0f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e0fc:	48 8b 00             	mov    (%rax),%rax
  80e0ff:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e106:	c9                   	leaveq 
  80e107:	c3                   	retq   

000000000080e108 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e108:	55                   	push   %rbp
  80e109:	48 89 e5             	mov    %rsp,%rbp
  80e10c:	48 83 ec 40          	sub    $0x40,%rsp
  80e110:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e113:	eb 01                	jmp    80e116 <sys_sem_wait+0xe>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e115:	90                   	nop
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e116:	48 b8 79 82 81 00 00 	movabs $0x818279,%rax
  80e11d:	00 00 00 
  80e120:	ff d0                	callq  *%rax
  80e122:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e126:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e12b:	74 0c                	je     80e139 <sys_sem_wait+0x31>
  80e12d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e131:	48 8b 00             	mov    (%rax),%rax
  80e134:	48 85 c0             	test   %rax,%rax
  80e137:	75 1b                	jne    80e154 <sys_sem_wait+0x4c>
    sys_arch_sem_wait(sem, 0);
  80e139:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e13c:	be 00 00 00 00       	mov    $0x0,%esi
  80e141:	89 c7                	mov    %eax,%edi
  80e143:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  80e14a:	00 00 00 
  80e14d:	ff d0                	callq  *%rax
  80e14f:	e9 db 00 00 00       	jmpq   80e22f <sys_sem_wait+0x127>
  } else {
    if (timeouts->next->time > 0) {
  80e154:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e158:	48 8b 00             	mov    (%rax),%rax
  80e15b:	8b 40 08             	mov    0x8(%rax),%eax
  80e15e:	85 c0                	test   %eax,%eax
  80e160:	74 22                	je     80e184 <sys_sem_wait+0x7c>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e162:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e166:	48 8b 00             	mov    (%rax),%rax
  80e169:	8b 50 08             	mov    0x8(%rax),%edx
  80e16c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e16f:	89 d6                	mov    %edx,%esi
  80e171:	89 c7                	mov    %eax,%edi
  80e173:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  80e17a:	00 00 00 
  80e17d:	ff d0                	callq  *%rax
  80e17f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e182:	eb 07                	jmp    80e18b <sys_sem_wait+0x83>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e184:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e18b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e18f:	75 68                	jne    80e1f9 <sys_sem_wait+0xf1>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e191:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e195:	48 8b 00             	mov    (%rax),%rax
  80e198:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e19c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1a0:	48 8b 10             	mov    (%rax),%rdx
  80e1a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1a7:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e1aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1ae:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e1b2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e1b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1ba:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e1be:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e1c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e1c6:	48 89 c6             	mov    %rax,%rsi
  80e1c9:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e1ce:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e1d5:	00 00 00 
  80e1d8:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e1da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e1de:	48 85 c0             	test   %rax,%rax
  80e1e1:	0f 84 2e ff ff ff    	je     80e115 <sys_sem_wait+0xd>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e1e7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80e1eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e1ef:	48 89 c7             	mov    %rax,%rdi
  80e1f2:	ff d2                	callq  *%rdx
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e1f4:	e9 1c ff ff ff       	jmpq   80e115 <sys_sem_wait+0xd>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e1f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1fd:	48 8b 00             	mov    (%rax),%rax
  80e200:	8b 40 08             	mov    0x8(%rax),%eax
  80e203:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e206:	76 19                	jbe    80e221 <sys_sem_wait+0x119>
        timeouts->next->time -= time_needed;
  80e208:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e20c:	48 8b 00             	mov    (%rax),%rax
  80e20f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e213:	48 8b 12             	mov    (%rdx),%rdx
  80e216:	8b 52 08             	mov    0x8(%rdx),%edx
  80e219:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e21c:	89 50 08             	mov    %edx,0x8(%rax)
  80e21f:	eb 0e                	jmp    80e22f <sys_sem_wait+0x127>
      } else {
        timeouts->next->time = 0;
  80e221:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e225:	48 8b 00             	mov    (%rax),%rax
  80e228:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e22f:	c9                   	leaveq 
  80e230:	c3                   	retq   

000000000080e231 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e231:	55                   	push   %rbp
  80e232:	48 89 e5             	mov    %rsp,%rbp
  80e235:	53                   	push   %rbx
  80e236:	48 83 ec 48          	sub    $0x48,%rsp
  80e23a:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e23d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80e241:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e245:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e24a:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80e251:	00 00 00 
  80e254:	ff d0                	callq  *%rax
  80e256:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (timeout == NULL) {
  80e25a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e25f:	75 35                	jne    80e296 <sys_timeout+0x65>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e261:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e266:	0f 85 ab 01 00 00    	jne    80e417 <sys_timeout+0x1e6>
  80e26c:	48 ba 08 1d 82 00 00 	movabs $0x821d08,%rdx
  80e273:	00 00 00 
  80e276:	be c3 00 00 00       	mov    $0xc3,%esi
  80e27b:	48 bf 25 1d 82 00 00 	movabs $0x821d25,%rdi
  80e282:	00 00 00 
  80e285:	b8 00 00 00 00       	mov    $0x0,%eax
  80e28a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80e291:	00 00 00 
  80e294:	ff d1                	callq  *%rcx
    return;
  }
  timeout->next = NULL;
  80e296:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e29a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e2a1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80e2a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e2a9:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e2ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e2b1:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80e2b5:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e2b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e2bd:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80e2c0:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e2c3:	48 b8 79 82 81 00 00 	movabs $0x818279,%rax
  80e2ca:	00 00 00 
  80e2cd:	ff d0                	callq  *%rax
  80e2cf:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e2d3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80e2d8:	75 35                	jne    80e30f <sys_timeout+0xde>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e2da:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80e2df:	0f 85 35 01 00 00    	jne    80e41a <sys_timeout+0x1e9>
  80e2e5:	48 ba 39 1d 82 00 00 	movabs $0x821d39,%rdx
  80e2ec:	00 00 00 
  80e2ef:	be d1 00 00 00       	mov    $0xd1,%esi
  80e2f4:	48 bf 25 1d 82 00 00 	movabs $0x821d25,%rdi
  80e2fb:	00 00 00 
  80e2fe:	b8 00 00 00 00       	mov    $0x0,%eax
  80e303:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80e30a:	00 00 00 
  80e30d:	ff d1                	callq  *%rcx
    return;
  }

  if (timeouts->next == NULL) {
  80e30f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e313:	48 8b 00             	mov    (%rax),%rax
  80e316:	48 85 c0             	test   %rax,%rax
  80e319:	75 10                	jne    80e32b <sys_timeout+0xfa>
    timeouts->next = timeout;
  80e31b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e31f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e323:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e326:	e9 f0 00 00 00       	jmpq   80e41b <sys_timeout+0x1ea>
  }

  if (timeouts->next->time > msecs) {
  80e32b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e32f:	48 8b 00             	mov    (%rax),%rax
  80e332:	8b 40 08             	mov    0x8(%rax),%eax
  80e335:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80e338:	76 35                	jbe    80e36f <sys_timeout+0x13e>
    timeouts->next->time -= msecs;
  80e33a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e33e:	48 8b 00             	mov    (%rax),%rax
  80e341:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80e345:	48 8b 12             	mov    (%rdx),%rdx
  80e348:	8b 52 08             	mov    0x8(%rdx),%edx
  80e34b:	2b 55 cc             	sub    -0x34(%rbp),%edx
  80e34e:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e351:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e355:	48 8b 10             	mov    (%rax),%rdx
  80e358:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e35c:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e35f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e363:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e367:	48 89 10             	mov    %rdx,(%rax)
  80e36a:	e9 ac 00 00 00       	jmpq   80e41b <sys_timeout+0x1ea>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e36f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e373:	48 8b 00             	mov    (%rax),%rax
  80e376:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80e37a:	e9 8b 00 00 00       	jmpq   80e40a <sys_timeout+0x1d9>
      timeout->time -= t->time;
  80e37f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e383:	8b 50 08             	mov    0x8(%rax),%edx
  80e386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e38a:	8b 40 08             	mov    0x8(%rax),%eax
  80e38d:	29 c2                	sub    %eax,%edx
  80e38f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e393:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80e396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e39a:	48 8b 00             	mov    (%rax),%rax
  80e39d:	48 85 c0             	test   %rax,%rax
  80e3a0:	74 15                	je     80e3b7 <sys_timeout+0x186>
  80e3a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3a6:	48 8b 00             	mov    (%rax),%rax
  80e3a9:	8b 50 08             	mov    0x8(%rax),%edx
  80e3ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3b0:	8b 40 08             	mov    0x8(%rax),%eax
  80e3b3:	39 c2                	cmp    %eax,%edx
  80e3b5:	76 48                	jbe    80e3ff <sys_timeout+0x1ce>
        if (t->next != NULL) {
  80e3b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3bb:	48 8b 00             	mov    (%rax),%rax
  80e3be:	48 85 c0             	test   %rax,%rax
  80e3c1:	74 21                	je     80e3e4 <sys_timeout+0x1b3>
          t->next->time -= timeout->time;
  80e3c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3c7:	48 8b 00             	mov    (%rax),%rax
  80e3ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e3ce:	48 8b 12             	mov    (%rdx),%rdx
  80e3d1:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e3d4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e3d8:	8b 52 08             	mov    0x8(%rdx),%edx
  80e3db:	89 cb                	mov    %ecx,%ebx
  80e3dd:	29 d3                	sub    %edx,%ebx
  80e3df:	89 da                	mov    %ebx,%edx
  80e3e1:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80e3e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3e8:	48 8b 10             	mov    (%rax),%rdx
  80e3eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3ef:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80e3f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3f6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e3fa:	48 89 10             	mov    %rdx,(%rax)
        break;
  80e3fd:	eb 1c                	jmp    80e41b <sys_timeout+0x1ea>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e3ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e403:	48 8b 00             	mov    (%rax),%rax
  80e406:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80e40a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e40f:	0f 85 6a ff ff ff    	jne    80e37f <sys_timeout+0x14e>
  80e415:	eb 04                	jmp    80e41b <sys_timeout+0x1ea>
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  80e417:	90                   	nop
  80e418:	eb 01                	jmp    80e41b <sys_timeout+0x1ea>
  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
  80e41a:	90                   	nop
        t->next = timeout;
        break;
      }
    }
  }
}
  80e41b:	48 83 c4 48          	add    $0x48,%rsp
  80e41f:	5b                   	pop    %rbx
  80e420:	5d                   	pop    %rbp
  80e421:	c3                   	retq   

000000000080e422 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80e422:	55                   	push   %rbp
  80e423:	48 89 e5             	mov    %rsp,%rbp
  80e426:	48 83 ec 30          	sub    $0x30,%rsp
  80e42a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80e42e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80e432:	48 b8 79 82 81 00 00 	movabs $0x818279,%rax
  80e439:	00 00 00 
  80e43c:	ff d0                	callq  *%rax
  80e43e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80e442:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e447:	75 35                	jne    80e47e <sys_untimeout+0x5c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80e449:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e44e:	0f 85 f6 00 00 00    	jne    80e54a <sys_untimeout+0x128>
  80e454:	48 ba 58 1d 82 00 00 	movabs $0x821d58,%rdx
  80e45b:	00 00 00 
  80e45e:	be 00 01 00 00       	mov    $0x100,%esi
  80e463:	48 bf 25 1d 82 00 00 	movabs $0x821d25,%rdi
  80e46a:	00 00 00 
  80e46d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e472:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80e479:	00 00 00 
  80e47c:	ff d1                	callq  *%rcx
    return;
  }
  if (timeouts->next == NULL) {
  80e47e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e482:	48 8b 00             	mov    (%rax),%rax
  80e485:	48 85 c0             	test   %rax,%rax
  80e488:	0f 84 bf 00 00 00    	je     80e54d <sys_untimeout+0x12b>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e48e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e492:	48 8b 00             	mov    (%rax),%rax
  80e495:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e499:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80e4a0:	00 
  80e4a1:	e9 97 00 00 00       	jmpq   80e53d <sys_untimeout+0x11b>
    if ((t->h == h) && (t->arg == arg)) {
  80e4a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4aa:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e4ae:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80e4b2:	75 76                	jne    80e52a <sys_untimeout+0x108>
  80e4b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4b8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e4bc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80e4c0:	75 68                	jne    80e52a <sys_untimeout+0x108>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80e4c2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e4c7:	75 10                	jne    80e4d9 <sys_untimeout+0xb7>
        timeouts->next = t->next;
  80e4c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4cd:	48 8b 10             	mov    (%rax),%rdx
  80e4d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e4d4:	48 89 10             	mov    %rdx,(%rax)
  80e4d7:	eb 0e                	jmp    80e4e7 <sys_untimeout+0xc5>
      else
        prev_t->next = t->next;
  80e4d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4dd:	48 8b 10             	mov    (%rax),%rdx
  80e4e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e4e4:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80e4e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4eb:	48 8b 00             	mov    (%rax),%rax
  80e4ee:	48 85 c0             	test   %rax,%rax
  80e4f1:	74 1d                	je     80e510 <sys_untimeout+0xee>
        t->next->time += t->time;
  80e4f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e4f7:	48 8b 00             	mov    (%rax),%rax
  80e4fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e4fe:	48 8b 12             	mov    (%rdx),%rdx
  80e501:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e504:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e508:	8b 52 08             	mov    0x8(%rdx),%edx
  80e50b:	01 ca                	add    %ecx,%edx
  80e50d:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80e510:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e514:	48 89 c6             	mov    %rax,%rsi
  80e517:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e51c:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e523:	00 00 00 
  80e526:	ff d0                	callq  *%rax
      return;
  80e528:	eb 24                	jmp    80e54e <sys_untimeout+0x12c>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e52a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e52e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e532:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e536:	48 8b 00             	mov    (%rax),%rax
  80e539:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e53d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e542:	0f 85 5e ff ff ff    	jne    80e4a6 <sys_untimeout+0x84>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80e548:	eb 04                	jmp    80e54e <sys_untimeout+0x12c>

  timeouts = sys_arch_timeouts();

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
  80e54a:	90                   	nop
  80e54b:	eb 01                	jmp    80e54e <sys_untimeout+0x12c>
  }
  if (timeouts->next == NULL) {
    return;
  80e54d:	90                   	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80e54e:	c9                   	leaveq 
  80e54f:	c3                   	retq   

000000000080e550 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80e550:	55                   	push   %rbp
  80e551:	48 89 e5             	mov    %rsp,%rbp
  80e554:	48 83 ec 20          	sub    $0x20,%rsp
  80e558:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80e55c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e560:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80e564:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e568:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80e56d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e571:	48 8b 40 08          	mov    0x8(%rax),%rax
  80e575:	8b 00                	mov    (%rax),%eax
  80e577:	89 c7                	mov    %eax,%edi
  80e579:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  80e580:	00 00 00 
  80e583:	ff d0                	callq  *%rax
}
  80e585:	c9                   	leaveq 
  80e586:	c3                   	retq   

000000000080e587 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80e587:	55                   	push   %rbp
  80e588:	48 89 e5             	mov    %rsp,%rbp
  80e58b:	48 83 ec 20          	sub    $0x20,%rsp
  80e58f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80e592:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80e595:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80e599:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80e59d:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80e5a3:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80e5a7:	74 1f                	je     80e5c8 <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80e5a9:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80e5ad:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80e5b0:	48 be 50 e5 80 00 00 	movabs $0x80e550,%rsi
  80e5b7:	00 00 00 
  80e5ba:	89 c7                	mov    %eax,%edi
  80e5bc:	48 b8 31 e2 80 00 00 	movabs $0x80e231,%rax
  80e5c3:	00 00 00 
  80e5c6:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80e5c8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80e5cb:	89 c7                	mov    %eax,%edi
  80e5cd:	48 b8 08 e1 80 00 00 	movabs $0x80e108,%rax
  80e5d4:	00 00 00 
  80e5d7:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80e5d9:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80e5dd:	66 85 c0             	test   %ax,%ax
  80e5e0:	74 07                	je     80e5e9 <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80e5e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80e5e7:	eb 22                	jmp    80e60b <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80e5e9:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80e5ed:	48 89 c6             	mov    %rax,%rsi
  80e5f0:	48 bf 50 e5 80 00 00 	movabs $0x80e550,%rdi
  80e5f7:	00 00 00 
  80e5fa:	48 b8 22 e4 80 00 00 	movabs $0x80e422,%rax
  80e601:	00 00 00 
  80e604:	ff d0                	callq  *%rax
    return 1;
  80e606:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80e60b:	c9                   	leaveq 
  80e60c:	c3                   	retq   

000000000080e60d <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80e60d:	55                   	push   %rbp
  80e60e:	48 89 e5             	mov    %rsp,%rbp
  80e611:	48 83 ec 20          	sub    $0x20,%rsp
  80e615:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80e618:	bf 00 00 00 00       	mov    $0x0,%edi
  80e61d:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  80e624:	00 00 00 
  80e627:	ff d0                	callq  *%rax
  80e629:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80e62c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80e62f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e632:	89 d6                	mov    %edx,%esi
  80e634:	89 c7                	mov    %eax,%edi
  80e636:	48 b8 87 e5 80 00 00 	movabs $0x80e587,%rax
  80e63d:	00 00 00 
  80e640:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80e642:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e645:	89 c7                	mov    %eax,%edi
  80e647:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  80e64e:	00 00 00 
  80e651:	ff d0                	callq  *%rax
}
  80e653:	c9                   	leaveq 
  80e654:	c3                   	retq   
  80e655:	00 00                	add    %al,(%rax)
	...

000000000080e658 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80e658:	55                   	push   %rbp
  80e659:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80e65c:	48 b8 6e fd 80 00 00 	movabs $0x80fd6e,%rax
  80e663:	00 00 00 
  80e666:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80e668:	48 b8 50 b0 b4 00 00 	movabs $0xb4b050,%rax
  80e66f:	00 00 00 
  80e672:	0f b6 00             	movzbl (%rax),%eax
  80e675:	8d 50 01             	lea    0x1(%rax),%edx
  80e678:	48 b8 50 b0 b4 00 00 	movabs $0xb4b050,%rax
  80e67f:	00 00 00 
  80e682:	88 10                	mov    %dl,(%rax)
  80e684:	48 b8 50 b0 b4 00 00 	movabs $0xb4b050,%rax
  80e68b:	00 00 00 
  80e68e:	0f b6 00             	movzbl (%rax),%eax
  80e691:	0f b6 c0             	movzbl %al,%eax
  80e694:	83 e0 01             	and    $0x1,%eax
  80e697:	84 c0                	test   %al,%al
  80e699:	74 0c                	je     80e6a7 <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80e69b:	48 b8 0e f5 80 00 00 	movabs $0x80f50e,%rax
  80e6a2:	00 00 00 
  80e6a5:	ff d0                	callq  *%rax
  }
}
  80e6a7:	5d                   	pop    %rbp
  80e6a8:	c3                   	retq   

000000000080e6a9 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80e6a9:	55                   	push   %rbp
  80e6aa:	48 89 e5             	mov    %rsp,%rbp
  80e6ad:	48 83 ec 20          	sub    $0x20,%rsp
  80e6b1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80e6b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6b9:	8b 40 18             	mov    0x18(%rax),%eax
  80e6bc:	83 f8 07             	cmp    $0x7,%eax
  80e6bf:	0f 87 31 02 00 00    	ja     80e8f6 <tcp_close+0x24d>
  80e6c5:	89 c0                	mov    %eax,%eax
  80e6c7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80e6ce:	00 
  80e6cf:	48 b8 90 1d 82 00 00 	movabs $0x821d90,%rax
  80e6d6:	00 00 00 
  80e6d9:	48 01 d0             	add    %rdx,%rax
  80e6dc:	48 8b 00             	mov    (%rax),%rax
  80e6df:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80e6e1:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80e6e5:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e6ec:	00 00 00 
  80e6ef:	48 8b 00             	mov    (%rax),%rax
  80e6f2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e6f6:	75 23                	jne    80e71b <tcp_close+0x72>
  80e6f8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e6ff:	00 00 00 
  80e702:	48 8b 00             	mov    (%rax),%rax
  80e705:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e709:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e710:	00 00 00 
  80e713:	48 89 10             	mov    %rdx,(%rax)
  80e716:	e9 94 00 00 00       	jmpq   80e7af <tcp_close+0x106>
  80e71b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e722:	00 00 00 
  80e725:	48 8b 10             	mov    (%rax),%rdx
  80e728:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e72f:	00 00 00 
  80e732:	48 89 10             	mov    %rdx,(%rax)
  80e735:	eb 66                	jmp    80e79d <tcp_close+0xf4>
  80e737:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e73e:	00 00 00 
  80e741:	48 8b 00             	mov    (%rax),%rax
  80e744:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e748:	48 85 c0             	test   %rax,%rax
  80e74b:	74 32                	je     80e77f <tcp_close+0xd6>
  80e74d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e754:	00 00 00 
  80e757:	48 8b 00             	mov    (%rax),%rax
  80e75a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e75e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e762:	75 1b                	jne    80e77f <tcp_close+0xd6>
  80e764:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e76b:	00 00 00 
  80e76e:	48 8b 00             	mov    (%rax),%rax
  80e771:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e775:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80e779:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80e77d:	eb 30                	jmp    80e7af <tcp_close+0x106>
  80e77f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e786:	00 00 00 
  80e789:	48 8b 00             	mov    (%rax),%rax
  80e78c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e790:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e797:	00 00 00 
  80e79a:	48 89 10             	mov    %rdx,(%rax)
  80e79d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e7a4:	00 00 00 
  80e7a7:	48 8b 00             	mov    (%rax),%rax
  80e7aa:	48 85 c0             	test   %rax,%rax
  80e7ad:	75 88                	jne    80e737 <tcp_close+0x8e>
  80e7af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7b3:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80e7ba:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80e7bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7bf:	48 89 c6             	mov    %rax,%rsi
  80e7c2:	bf 02 00 00 00       	mov    $0x2,%edi
  80e7c7:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e7ce:	00 00 00 
  80e7d1:	ff d0                	callq  *%rax
    pcb = NULL;
  80e7d3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e7da:	00 
    break;
  80e7db:	e9 2b 01 00 00       	jmpq   80e90b <tcp_close+0x262>
  case LISTEN:
    err = ERR_OK;
  80e7e0:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80e7e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e7e8:	48 89 c6             	mov    %rax,%rsi
  80e7eb:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80e7f2:	00 00 00 
  80e7f5:	48 b8 08 05 81 00 00 	movabs $0x810508,%rax
  80e7fc:	00 00 00 
  80e7ff:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80e801:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e805:	48 89 c6             	mov    %rax,%rsi
  80e808:	bf 03 00 00 00       	mov    $0x3,%edi
  80e80d:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e814:	00 00 00 
  80e817:	ff d0                	callq  *%rax
    pcb = NULL;
  80e819:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e820:	00 
    break;
  80e821:	e9 e5 00 00 00       	jmpq   80e90b <tcp_close+0x262>
  case SYN_SENT:
    err = ERR_OK;
  80e826:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e82a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e82e:	48 89 c6             	mov    %rax,%rsi
  80e831:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80e838:	00 00 00 
  80e83b:	48 b8 08 05 81 00 00 	movabs $0x810508,%rax
  80e842:	00 00 00 
  80e845:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80e847:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e84b:	48 89 c6             	mov    %rax,%rsi
  80e84e:	bf 02 00 00 00       	mov    $0x2,%edi
  80e853:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e85a:	00 00 00 
  80e85d:	ff d0                	callq  *%rax
    pcb = NULL;
  80e85f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e866:	00 
    snmp_inc_tcpattemptfails();
    break;
  80e867:	e9 9f 00 00 00       	jmpq   80e90b <tcp_close+0x262>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80e86c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e870:	be 01 00 00 00       	mov    $0x1,%esi
  80e875:	48 89 c7             	mov    %rax,%rdi
  80e878:	48 b8 40 2b 81 00 00 	movabs $0x812b40,%rax
  80e87f:	00 00 00 
  80e882:	ff d0                	callq  *%rax
  80e884:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80e887:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e88b:	75 77                	jne    80e904 <tcp_close+0x25b>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80e88d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e891:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80e898:	eb 6a                	jmp    80e904 <tcp_close+0x25b>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80e89a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e89e:	be 01 00 00 00       	mov    $0x1,%esi
  80e8a3:	48 89 c7             	mov    %rax,%rdi
  80e8a6:	48 b8 40 2b 81 00 00 	movabs $0x812b40,%rax
  80e8ad:	00 00 00 
  80e8b0:	ff d0                	callq  *%rax
  80e8b2:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80e8b5:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e8b9:	75 4c                	jne    80e907 <tcp_close+0x25e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80e8bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e8bf:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80e8c6:	eb 3f                	jmp    80e907 <tcp_close+0x25e>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80e8c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e8cc:	be 01 00 00 00       	mov    $0x1,%esi
  80e8d1:	48 89 c7             	mov    %rax,%rdi
  80e8d4:	48 b8 40 2b 81 00 00 	movabs $0x812b40,%rax
  80e8db:	00 00 00 
  80e8de:	ff d0                	callq  *%rax
  80e8e0:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80e8e3:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e8e7:	75 21                	jne    80e90a <tcp_close+0x261>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80e8e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e8ed:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80e8f4:	eb 14                	jmp    80e90a <tcp_close+0x261>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80e8f6:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80e8fa:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e901:	00 
    break;
  80e902:	eb 07                	jmp    80e90b <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80e904:	90                   	nop
  80e905:	eb 04                	jmp    80e90b <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80e907:	90                   	nop
  80e908:	eb 01                	jmp    80e90b <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
  80e90a:	90                   	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80e90b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e910:	74 19                	je     80e92b <tcp_close+0x282>
  80e912:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80e916:	75 13                	jne    80e92b <tcp_close+0x282>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80e918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e91c:	48 89 c7             	mov    %rax,%rdi
  80e91f:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  80e926:	00 00 00 
  80e929:	ff d0                	callq  *%rax
  }
  return err;
  80e92b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80e92f:	c9                   	leaveq 
  80e930:	c3                   	retq   

000000000080e931 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80e931:	55                   	push   %rbp
  80e932:	48 89 e5             	mov    %rsp,%rbp
  80e935:	48 83 ec 50          	sub    $0x50,%rsp
  80e939:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80e93d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e941:	8b 40 18             	mov    0x18(%rax),%eax
  80e944:	83 f8 0a             	cmp    $0xa,%eax
  80e947:	75 3a                	jne    80e983 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80e949:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e94d:	48 89 c6             	mov    %rax,%rsi
  80e950:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80e957:	00 00 00 
  80e95a:	48 b8 08 05 81 00 00 	movabs $0x810508,%rax
  80e961:	00 00 00 
  80e964:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80e966:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e96a:	48 89 c6             	mov    %rax,%rsi
  80e96d:	bf 02 00 00 00       	mov    $0x2,%edi
  80e972:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80e979:	00 00 00 
  80e97c:	ff d0                	callq  *%rax
  80e97e:	e9 75 01 00 00       	jmpq   80eaf8 <tcp_abort+0x1c7>
  } else {
    seqno = pcb->snd_nxt;
  80e983:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e987:	8b 40 60             	mov    0x60(%rax),%eax
  80e98a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80e98d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e991:	8b 40 30             	mov    0x30(%rax),%eax
  80e994:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80e997:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e99b:	48 85 c0             	test   %rax,%rax
  80e99e:	74 08                	je     80e9a8 <tcp_abort+0x77>
  80e9a0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9a4:	8b 00                	mov    (%rax),%eax
  80e9a6:	eb 05                	jmp    80e9ad <tcp_abort+0x7c>
  80e9a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9ad:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80e9b0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9b4:	48 83 c0 04          	add    $0x4,%rax
  80e9b8:	48 85 c0             	test   %rax,%rax
  80e9bb:	74 09                	je     80e9c6 <tcp_abort+0x95>
  80e9bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9c1:	8b 40 04             	mov    0x4(%rax),%eax
  80e9c4:	eb 05                	jmp    80e9cb <tcp_abort+0x9a>
  80e9c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9cb:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80e9ce:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9d2:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80e9d6:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80e9da:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9de:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80e9e2:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80e9e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9ea:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80e9f1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80e9f5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80e9f9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80e9fd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ea01:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea05:	48 89 c6             	mov    %rax,%rsi
  80ea08:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ea0f:	00 00 00 
  80ea12:	48 b8 08 05 81 00 00 	movabs $0x810508,%rax
  80ea19:	00 00 00 
  80ea1c:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80ea1e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea22:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80ea29:	48 85 c0             	test   %rax,%rax
  80ea2c:	74 1a                	je     80ea48 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80ea2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea32:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80ea39:	48 89 c7             	mov    %rax,%rdi
  80ea3c:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  80ea43:	00 00 00 
  80ea46:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80ea48:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea4c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ea53:	48 85 c0             	test   %rax,%rax
  80ea56:	74 1a                	je     80ea72 <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80ea58:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea5c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ea63:	48 89 c7             	mov    %rax,%rdi
  80ea66:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  80ea6d:	00 00 00 
  80ea70:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80ea72:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea76:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ea7d:	48 85 c0             	test   %rax,%rax
  80ea80:	74 1a                	je     80ea9c <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80ea82:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ea86:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ea8d:	48 89 c7             	mov    %rax,%rdi
  80ea90:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  80ea97:	00 00 00 
  80ea9a:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80ea9c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eaa0:	48 89 c6             	mov    %rax,%rsi
  80eaa3:	bf 02 00 00 00       	mov    $0x2,%edi
  80eaa8:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80eaaf:	00 00 00 
  80eab2:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80eab4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80eab9:	74 12                	je     80eacd <tcp_abort+0x19c>
  80eabb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eabf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80eac3:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80eac8:	48 89 c7             	mov    %rax,%rdi
  80eacb:	ff d2                	callq  *%rdx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80eacd:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80ead2:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80ead6:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80eada:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80eade:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80eae1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80eae4:	45 89 c1             	mov    %r8d,%r9d
  80eae7:	41 89 f8             	mov    %edi,%r8d
  80eaea:	89 c7                	mov    %eax,%edi
  80eaec:	48 b8 f9 3f 81 00 00 	movabs $0x813ff9,%rax
  80eaf3:	00 00 00 
  80eaf6:	ff d0                	callq  *%rax
  }
}
  80eaf8:	c9                   	leaveq 
  80eaf9:	c3                   	retq   

000000000080eafa <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80eafa:	55                   	push   %rbp
  80eafb:	48 89 e5             	mov    %rsp,%rbp
  80eafe:	48 83 ec 30          	sub    $0x30,%rsp
  80eb02:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80eb06:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80eb0a:	89 d0                	mov    %edx,%eax
  80eb0c:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80eb10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eb14:	8b 40 18             	mov    0x18(%rax),%eax
  80eb17:	85 c0                	test   %eax,%eax
  80eb19:	74 2a                	je     80eb45 <tcp_bind+0x4b>
  80eb1b:	48 ba d0 1d 82 00 00 	movabs $0x821dd0,%rdx
  80eb22:	00 00 00 
  80eb25:	be 05 01 00 00       	mov    $0x105,%esi
  80eb2a:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80eb31:	00 00 00 
  80eb34:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb39:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80eb40:	00 00 00 
  80eb43:	ff d1                	callq  *%rcx

  if (port == 0) {
  80eb45:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80eb4a:	75 10                	jne    80eb5c <tcp_bind+0x62>
    port = tcp_new_port();
  80eb4c:	48 b8 0b f1 80 00 00 	movabs $0x80f10b,%rax
  80eb53:	00 00 00 
  80eb56:	ff d0                	callq  *%rax
  80eb58:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80eb5c:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80eb63:	00 00 00 
  80eb66:	48 8b 00             	mov    (%rax),%rax
  80eb69:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eb6d:	eb 58                	jmp    80ebc7 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80eb6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb73:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80eb77:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80eb7b:	75 3e                	jne    80ebbb <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80eb7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb81:	48 85 c0             	test   %rax,%rax
  80eb84:	74 2b                	je     80ebb1 <tcp_bind+0xb7>
  80eb86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eb8a:	8b 00                	mov    (%rax),%eax
  80eb8c:	85 c0                	test   %eax,%eax
  80eb8e:	74 21                	je     80ebb1 <tcp_bind+0xb7>
  80eb90:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80eb95:	74 1a                	je     80ebb1 <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80eb97:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eb9b:	8b 00                	mov    (%rax),%eax
  80eb9d:	85 c0                	test   %eax,%eax
  80eb9f:	74 10                	je     80ebb1 <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80eba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eba5:	8b 10                	mov    (%rax),%edx
  80eba7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ebab:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ebad:	39 c2                	cmp    %eax,%edx
  80ebaf:	75 0a                	jne    80ebbb <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ebb1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ebb6:	e9 a2 01 00 00       	jmpq   80ed5d <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80ebbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebbf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ebc3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80ebc7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ebcc:	75 a1                	jne    80eb6f <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80ebce:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80ebd5:	00 00 00 
  80ebd8:	48 8b 00             	mov    (%rax),%rax
  80ebdb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ebdf:	eb 58                	jmp    80ec39 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80ebe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebe5:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ebe9:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ebed:	75 3e                	jne    80ec2d <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80ebef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebf3:	48 85 c0             	test   %rax,%rax
  80ebf6:	74 2b                	je     80ec23 <tcp_bind+0x129>
  80ebf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ebfc:	8b 00                	mov    (%rax),%eax
  80ebfe:	85 c0                	test   %eax,%eax
  80ec00:	74 21                	je     80ec23 <tcp_bind+0x129>
  80ec02:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ec07:	74 1a                	je     80ec23 <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80ec09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ec0d:	8b 00                	mov    (%rax),%eax
  80ec0f:	85 c0                	test   %eax,%eax
  80ec11:	74 10                	je     80ec23 <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ec13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ec17:	8b 10                	mov    (%rax),%edx
  80ec19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ec1d:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ec1f:	39 c2                	cmp    %eax,%edx
  80ec21:	75 0a                	jne    80ec2d <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ec23:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ec28:	e9 30 01 00 00       	jmpq   80ed5d <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80ec2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ec31:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ec35:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80ec39:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ec3e:	75 a1                	jne    80ebe1 <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ec40:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ec47:	00 00 00 
  80ec4a:	48 8b 00             	mov    (%rax),%rax
  80ec4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ec51:	eb 58                	jmp    80ecab <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80ec53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ec57:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ec5b:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ec5f:	75 3e                	jne    80ec9f <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80ec61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ec65:	48 85 c0             	test   %rax,%rax
  80ec68:	74 2b                	je     80ec95 <tcp_bind+0x19b>
  80ec6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ec6e:	8b 00                	mov    (%rax),%eax
  80ec70:	85 c0                	test   %eax,%eax
  80ec72:	74 21                	je     80ec95 <tcp_bind+0x19b>
  80ec74:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ec79:	74 1a                	je     80ec95 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80ec7b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ec7f:	8b 00                	mov    (%rax),%eax
  80ec81:	85 c0                	test   %eax,%eax
  80ec83:	74 10                	je     80ec95 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ec85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ec89:	8b 10                	mov    (%rax),%edx
  80ec8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ec8f:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ec91:	39 c2                	cmp    %eax,%edx
  80ec93:	75 0a                	jne    80ec9f <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ec95:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ec9a:	e9 be 00 00 00       	jmpq   80ed5d <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ec9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eca3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eca7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ecab:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ecb0:	75 a1                	jne    80ec53 <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ecb2:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80ecb9:	00 00 00 
  80ecbc:	48 8b 00             	mov    (%rax),%rax
  80ecbf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ecc3:	eb 31                	jmp    80ecf6 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80ecc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ecc9:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80eccd:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ecd1:	75 17                	jne    80ecea <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ecd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ecd7:	8b 10                	mov    (%rax),%edx
  80ecd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ecdd:	8b 00                	mov    (%rax),%eax
  80ecdf:	39 c2                	cmp    %eax,%edx
  80ece1:	75 07                	jne    80ecea <tcp_bind+0x1f0>
        return ERR_USE;
  80ece3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ece8:	eb 73                	jmp    80ed5d <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ecea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ecee:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ecf2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ecf6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ecfb:	75 c8                	jne    80ecc5 <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80ecfd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ed02:	74 16                	je     80ed1a <tcp_bind+0x220>
  80ed04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ed08:	8b 00                	mov    (%rax),%eax
  80ed0a:	85 c0                	test   %eax,%eax
  80ed0c:	74 0c                	je     80ed1a <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80ed0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed12:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ed16:	8b 12                	mov    (%rdx),%edx
  80ed18:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80ed1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed1e:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80ed22:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80ed26:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed2d:	00 00 00 
  80ed30:	48 8b 10             	mov    (%rax),%rdx
  80ed33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed37:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ed3b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ed42:	00 00 00 
  80ed45:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ed49:	48 89 10             	mov    %rdx,(%rax)
  80ed4c:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  80ed53:	00 00 00 
  80ed56:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80ed58:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ed5d:	c9                   	leaveq 
  80ed5e:	c3                   	retq   

000000000080ed5f <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80ed5f:	55                   	push   %rbp
  80ed60:	48 89 e5             	mov    %rsp,%rbp
  80ed63:	48 83 ec 18          	sub    $0x18,%rsp
  80ed67:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ed6b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80ed6f:	89 d0                	mov    %edx,%eax
  80ed71:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80ed74:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80ed79:	c9                   	leaveq 
  80ed7a:	c3                   	retq   

000000000080ed7b <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80ed7b:	55                   	push   %rbp
  80ed7c:	48 89 e5             	mov    %rsp,%rbp
  80ed7f:	48 83 ec 20          	sub    $0x20,%rsp
  80ed83:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80ed87:	89 f0                	mov    %esi,%eax
  80ed89:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80ed8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ed90:	8b 40 18             	mov    0x18(%rax),%eax
  80ed93:	85 c0                	test   %eax,%eax
  80ed95:	74 2a                	je     80edc1 <tcp_listen_with_backlog+0x46>
  80ed97:	48 ba 10 1e 82 00 00 	movabs $0x821e10,%rdx
  80ed9e:	00 00 00 
  80eda1:	be 60 01 00 00       	mov    $0x160,%esi
  80eda6:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80edad:	00 00 00 
  80edb0:	b8 00 00 00 00       	mov    $0x0,%eax
  80edb5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80edbc:	00 00 00 
  80edbf:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80edc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edc5:	8b 40 18             	mov    0x18(%rax),%eax
  80edc8:	83 f8 01             	cmp    $0x1,%eax
  80edcb:	75 09                	jne    80edd6 <tcp_listen_with_backlog+0x5b>
    return pcb;
  80edcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80edd1:	e9 e6 01 00 00       	jmpq   80efbc <tcp_listen_with_backlog+0x241>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80edd6:	bf 03 00 00 00       	mov    $0x3,%edi
  80eddb:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80ede2:	00 00 00 
  80ede5:	ff d0                	callq  *%rax
  80ede7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (lpcb == NULL) {
  80edeb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80edf0:	75 0a                	jne    80edfc <tcp_listen_with_backlog+0x81>
    return NULL;
  80edf2:	b8 00 00 00 00       	mov    $0x0,%eax
  80edf7:	e9 c0 01 00 00       	jmpq   80efbc <tcp_listen_with_backlog+0x241>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80edfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee00:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80ee04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee08:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80ee0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee10:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80ee14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee18:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80ee1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee20:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80ee27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee2b:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80ee2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee33:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80ee37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee3b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80ee3f:	89 c2                	mov    %eax,%edx
  80ee41:	83 ca 02             	or     $0x2,%edx
  80ee44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee48:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80ee4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee50:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80ee54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee58:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80ee5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee5f:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80ee63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee67:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80ee6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee6e:	48 85 c0             	test   %rax,%rax
  80ee71:	74 08                	je     80ee7b <tcp_listen_with_backlog+0x100>
  80ee73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ee77:	8b 00                	mov    (%rax),%eax
  80ee79:	eb 05                	jmp    80ee80 <tcp_listen_with_backlog+0x105>
  80ee7b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ee80:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80ee84:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80ee86:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ee8d:	00 00 00 
  80ee90:	48 8b 00             	mov    (%rax),%rax
  80ee93:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ee97:	75 23                	jne    80eebc <tcp_listen_with_backlog+0x141>
  80ee99:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80eea0:	00 00 00 
  80eea3:	48 8b 00             	mov    (%rax),%rax
  80eea6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80eeaa:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80eeb1:	00 00 00 
  80eeb4:	48 89 10             	mov    %rdx,(%rax)
  80eeb7:	e9 94 00 00 00       	jmpq   80ef50 <tcp_listen_with_backlog+0x1d5>
  80eebc:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80eec3:	00 00 00 
  80eec6:	48 8b 10             	mov    (%rax),%rdx
  80eec9:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80eed0:	00 00 00 
  80eed3:	48 89 10             	mov    %rdx,(%rax)
  80eed6:	eb 66                	jmp    80ef3e <tcp_listen_with_backlog+0x1c3>
  80eed8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80eedf:	00 00 00 
  80eee2:	48 8b 00             	mov    (%rax),%rax
  80eee5:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eee9:	48 85 c0             	test   %rax,%rax
  80eeec:	74 32                	je     80ef20 <tcp_listen_with_backlog+0x1a5>
  80eeee:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80eef5:	00 00 00 
  80eef8:	48 8b 00             	mov    (%rax),%rax
  80eefb:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eeff:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ef03:	75 1b                	jne    80ef20 <tcp_listen_with_backlog+0x1a5>
  80ef05:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ef0c:	00 00 00 
  80ef0f:	48 8b 00             	mov    (%rax),%rax
  80ef12:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ef16:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80ef1a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ef1e:	eb 30                	jmp    80ef50 <tcp_listen_with_backlog+0x1d5>
  80ef20:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ef27:	00 00 00 
  80ef2a:	48 8b 00             	mov    (%rax),%rax
  80ef2d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80ef31:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ef38:	00 00 00 
  80ef3b:	48 89 10             	mov    %rdx,(%rax)
  80ef3e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80ef45:	00 00 00 
  80ef48:	48 8b 00             	mov    (%rax),%rax
  80ef4b:	48 85 c0             	test   %rax,%rax
  80ef4e:	75 88                	jne    80eed8 <tcp_listen_with_backlog+0x15d>
  80ef50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef54:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ef5b:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80ef5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef60:	48 89 c6             	mov    %rax,%rsi
  80ef63:	bf 02 00 00 00       	mov    $0x2,%edi
  80ef68:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80ef6f:	00 00 00 
  80ef72:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80ef74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef78:	48 ba 5f ed 80 00 00 	movabs $0x80ed5f,%rdx
  80ef7f:	00 00 00 
  80ef82:	48 89 50 30          	mov    %rdx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80ef86:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80ef8d:	00 00 00 
  80ef90:	48 8b 10             	mov    (%rax),%rdx
  80ef93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ef97:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ef9b:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80efa2:	00 00 00 
  80efa5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80efa9:	48 89 10             	mov    %rdx,(%rax)
  80efac:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  80efb3:	00 00 00 
  80efb6:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80efb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80efbc:	c9                   	leaveq 
  80efbd:	c3                   	retq   

000000000080efbe <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80efbe:	55                   	push   %rbp
  80efbf:	48 89 e5             	mov    %rsp,%rbp
  80efc2:	48 83 ec 10          	sub    $0x10,%rsp
  80efc6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80efca:	89 f0                	mov    %esi,%eax
  80efcc:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80efd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80efd4:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80efd8:	0f b7 d0             	movzwl %ax,%edx
  80efdb:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80efdf:	01 d0                	add    %edx,%eax
  80efe1:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80efe6:	76 16                	jbe    80effe <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80efe8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80efec:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80eff2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eff6:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80effc:	eb 3b                	jmp    80f039 <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80effe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f002:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f006:	89 c2                	mov    %eax,%edx
  80f008:	66 03 55 f4          	add    -0xc(%rbp),%dx
  80f00c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f010:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f014:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f018:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f01c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f020:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f024:	66 39 c2             	cmp    %ax,%dx
  80f027:	72 10                	jb     80f039 <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f029:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f02d:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f031:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f035:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f039:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f03d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f041:	0f b6 c0             	movzbl %al,%eax
  80f044:	83 e0 01             	and    $0x1,%eax
  80f047:	85 c0                	test   %eax,%eax
  80f049:	75 77                	jne    80f0c2 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f04b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f04f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f053:	0f b6 c0             	movzbl %al,%eax
  80f056:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f059:	85 c0                	test   %eax,%eax
  80f05b:	75 65                	jne    80f0c2 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f05d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f061:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f065:	0f b6 c0             	movzbl %al,%eax
  80f068:	83 e0 01             	and    $0x1,%eax
  80f06b:	84 c0                	test   %al,%al
  80f06d:	74 3d                	je     80f0ac <tcp_recved+0xee>
  80f06f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f073:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f077:	89 c2                	mov    %eax,%edx
  80f079:	83 e2 fe             	and    $0xfffffffe,%edx
  80f07c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f080:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f083:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f087:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f08b:	89 c2                	mov    %eax,%edx
  80f08d:	83 ca 02             	or     $0x2,%edx
  80f090:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f094:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f097:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f09b:	48 89 c7             	mov    %rax,%rdi
  80f09e:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  80f0a5:	00 00 00 
  80f0a8:	ff d0                	callq  *%rax
  80f0aa:	eb 5d                	jmp    80f109 <tcp_recved+0x14b>
  80f0ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0b0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f0b4:	89 c2                	mov    %eax,%edx
  80f0b6:	83 ca 01             	or     $0x1,%edx
  80f0b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0bd:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f0c0:	eb 47                	jmp    80f109 <tcp_recved+0x14b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f0c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0c6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f0ca:	0f b6 c0             	movzbl %al,%eax
  80f0cd:	83 e0 01             	and    $0x1,%eax
  80f0d0:	84 c0                	test   %al,%al
  80f0d2:	74 35                	je     80f109 <tcp_recved+0x14b>
  80f0d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0d8:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f0dc:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f0e0:	76 27                	jbe    80f109 <tcp_recved+0x14b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f0e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0e6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f0ea:	89 c2                	mov    %eax,%edx
  80f0ec:	83 ca 02             	or     $0x2,%edx
  80f0ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0f3:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f0f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f0fa:	48 89 c7             	mov    %rax,%rdi
  80f0fd:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  80f104:	00 00 00 
  80f107:	ff d0                	callq  *%rax
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f109:	c9                   	leaveq 
  80f10a:	c3                   	retq   

000000000080f10b <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f10b:	55                   	push   %rbp
  80f10c:	48 89 e5             	mov    %rsp,%rbp
  80f10f:	48 83 ec 10          	sub    $0x10,%rsp
  80f113:	eb 07                	jmp    80f11c <tcp_new_port+0x11>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
  80f115:	90                   	nop
  80f116:	eb 04                	jmp    80f11c <tcp_new_port+0x11>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
  80f118:	90                   	nop
  80f119:	eb 01                	jmp    80f11c <tcp_new_port+0x11>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
  80f11b:	90                   	nop
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f11c:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f123:	00 00 00 
  80f126:	0f b7 00             	movzwl (%rax),%eax
  80f129:	8d 50 01             	lea    0x1(%rax),%edx
  80f12c:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f133:	00 00 00 
  80f136:	66 89 10             	mov    %dx,(%rax)
  80f139:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f140:	00 00 00 
  80f143:	0f b7 00             	movzwl (%rax),%eax
  80f146:	66 85 c0             	test   %ax,%ax
  80f149:	79 0f                	jns    80f15a <tcp_new_port+0x4f>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f14b:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f152:	00 00 00 
  80f155:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f15a:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f161:	00 00 00 
  80f164:	48 8b 00             	mov    (%rax),%rax
  80f167:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f16b:	eb 26                	jmp    80f193 <tcp_new_port+0x88>
    if (pcb->local_port == port) {
  80f16d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f171:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f175:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f17c:	00 00 00 
  80f17f:	0f b7 00             	movzwl (%rax),%eax
  80f182:	66 39 c2             	cmp    %ax,%dx
  80f185:	74 8e                	je     80f115 <tcp_new_port+0xa>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f187:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f18b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f18f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f193:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f198:	75 d3                	jne    80f16d <tcp_new_port+0x62>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f19a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f1a1:	00 00 00 
  80f1a4:	48 8b 00             	mov    (%rax),%rax
  80f1a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1ab:	eb 2a                	jmp    80f1d7 <tcp_new_port+0xcc>
    if (pcb->local_port == port) {
  80f1ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1b1:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f1b5:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f1bc:	00 00 00 
  80f1bf:	0f b7 00             	movzwl (%rax),%eax
  80f1c2:	66 39 c2             	cmp    %ax,%dx
  80f1c5:	0f 84 4d ff ff ff    	je     80f118 <tcp_new_port+0xd>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f1cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1cf:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f1d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f1dc:	75 cf                	jne    80f1ad <tcp_new_port+0xa2>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f1de:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f1e5:	00 00 00 
  80f1e8:	48 8b 00             	mov    (%rax),%rax
  80f1eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f1ef:	eb 2a                	jmp    80f21b <tcp_new_port+0x110>
    if (pcb->local_port == port) {
  80f1f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1f5:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f1f9:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f200:	00 00 00 
  80f203:	0f b7 00             	movzwl (%rax),%eax
  80f206:	66 39 c2             	cmp    %ax,%dx
  80f209:	0f 84 0c ff ff ff    	je     80f11b <tcp_new_port+0x10>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f20f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f213:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f217:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f21b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f220:	75 cf                	jne    80f1f1 <tcp_new_port+0xe6>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f222:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f229:	00 00 00 
  80f22c:	0f b7 00             	movzwl (%rax),%eax
}
  80f22f:	c9                   	leaveq 
  80f230:	c3                   	retq   

000000000080f231 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f231:	55                   	push   %rbp
  80f232:	48 89 e5             	mov    %rsp,%rbp
  80f235:	48 83 ec 40          	sub    $0x40,%rsp
  80f239:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f23d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f241:	89 d0                	mov    %edx,%eax
  80f243:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f247:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f24b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f24f:	8b 40 18             	mov    0x18(%rax),%eax
  80f252:	85 c0                	test   %eax,%eax
  80f254:	74 2a                	je     80f280 <tcp_connect+0x4f>
  80f256:	48 ba 38 1e 82 00 00 	movabs $0x821e38,%rdx
  80f25d:	00 00 00 
  80f260:	be ec 01 00 00       	mov    $0x1ec,%esi
  80f265:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80f26c:	00 00 00 
  80f26f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f274:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80f27b:	00 00 00 
  80f27e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f280:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f285:	74 28                	je     80f2af <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f287:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f28b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f28f:	8b 12                	mov    (%rdx),%edx
  80f291:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f294:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f298:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f29c:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f2a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2a4:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f2a8:	66 85 c0             	test   %ax,%ax
  80f2ab:	74 0c                	je     80f2b9 <tcp_connect+0x88>
  80f2ad:	eb 1e                	jmp    80f2cd <tcp_connect+0x9c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f2af:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f2b4:	e9 53 02 00 00       	jmpq   80f50c <tcp_connect+0x2db>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f2b9:	48 b8 0b f1 80 00 00 	movabs $0x80f10b,%rax
  80f2c0:	00 00 00 
  80f2c3:	ff d0                	callq  *%rax
  80f2c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f2c9:	66 89 42 28          	mov    %ax,0x28(%rdx)
  }
  iss = tcp_next_iss();
  80f2cd:	48 b8 05 07 81 00 00 	movabs $0x810705,%rax
  80f2d4:	00 00 00 
  80f2d7:	ff d0                	callq  *%rax
  80f2d9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f2dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2e0:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f2e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2eb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f2ee:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f2f1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f2f4:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f2f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f2fb:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f2fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f301:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f304:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f308:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f30b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f30f:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f315:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f319:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f31f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f323:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f329:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f32d:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f333:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f337:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f33b:	0f b7 c0             	movzwl %ax,%eax
  80f33e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f342:	48 89 d6             	mov    %rdx,%rsi
  80f345:	89 c7                	mov    %eax,%edi
  80f347:	48 b8 3d 07 81 00 00 	movabs $0x81073d,%rax
  80f34e:	00 00 00 
  80f351:	ff d0                	callq  *%rax
  80f353:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f357:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f35b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f35f:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f365:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f369:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f36d:	89 d0                	mov    %edx,%eax
  80f36f:	c1 e0 02             	shl    $0x2,%eax
  80f372:	01 d0                	add    %edx,%eax
  80f374:	01 c0                	add    %eax,%eax
  80f376:	89 c2                	mov    %eax,%edx
  80f378:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f37c:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f380:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f384:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f38b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f38f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f393:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f39a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f3a1:	00 00 00 
  80f3a4:	48 8b 00             	mov    (%rax),%rax
  80f3a7:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f3ab:	75 23                	jne    80f3d0 <tcp_connect+0x19f>
  80f3ad:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f3b4:	00 00 00 
  80f3b7:	48 8b 00             	mov    (%rax),%rax
  80f3ba:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f3be:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f3c5:	00 00 00 
  80f3c8:	48 89 10             	mov    %rdx,(%rax)
  80f3cb:	e9 94 00 00 00       	jmpq   80f464 <tcp_connect+0x233>
  80f3d0:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f3d7:	00 00 00 
  80f3da:	48 8b 10             	mov    (%rax),%rdx
  80f3dd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3e4:	00 00 00 
  80f3e7:	48 89 10             	mov    %rdx,(%rax)
  80f3ea:	eb 66                	jmp    80f452 <tcp_connect+0x221>
  80f3ec:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f3f3:	00 00 00 
  80f3f6:	48 8b 00             	mov    (%rax),%rax
  80f3f9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f3fd:	48 85 c0             	test   %rax,%rax
  80f400:	74 32                	je     80f434 <tcp_connect+0x203>
  80f402:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f409:	00 00 00 
  80f40c:	48 8b 00             	mov    (%rax),%rax
  80f40f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f413:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f417:	75 1b                	jne    80f434 <tcp_connect+0x203>
  80f419:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f420:	00 00 00 
  80f423:	48 8b 00             	mov    (%rax),%rax
  80f426:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f42a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f42e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f432:	eb 30                	jmp    80f464 <tcp_connect+0x233>
  80f434:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f43b:	00 00 00 
  80f43e:	48 8b 00             	mov    (%rax),%rax
  80f441:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f445:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f44c:	00 00 00 
  80f44f:	48 89 10             	mov    %rdx,(%rax)
  80f452:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f459:	00 00 00 
  80f45c:	48 8b 00             	mov    (%rax),%rax
  80f45f:	48 85 c0             	test   %rax,%rax
  80f462:	75 88                	jne    80f3ec <tcp_connect+0x1bb>
  80f464:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f468:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f46f:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80f470:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f477:	00 00 00 
  80f47a:	48 8b 10             	mov    (%rax),%rdx
  80f47d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f481:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f485:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f48c:	00 00 00 
  80f48f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f493:	48 89 10             	mov    %rdx,(%rax)
  80f496:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  80f49d:	00 00 00 
  80f4a0:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80f4a2:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80f4a7:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  80f4ae:	00 00 00 
  80f4b1:	ff d0                	callq  *%rax
  80f4b3:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80f4b6:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80f4ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4be:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  80f4c5:	49 89 d1             	mov    %rdx,%r9
  80f4c8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80f4ce:	b9 02 00 00 00       	mov    $0x2,%ecx
  80f4d3:	ba 00 00 00 00       	mov    $0x0,%edx
  80f4d8:	be 00 00 00 00       	mov    $0x0,%esi
  80f4dd:	48 89 c7             	mov    %rax,%rdi
  80f4e0:	48 b8 1d 2c 81 00 00 	movabs $0x812c1d,%rax
  80f4e7:	00 00 00 
  80f4ea:	ff d0                	callq  *%rax
  80f4ec:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80f4ef:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80f4f3:	75 13                	jne    80f508 <tcp_connect+0x2d7>
    tcp_output(pcb);
  80f4f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4f9:	48 89 c7             	mov    %rax,%rdi
  80f4fc:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  80f503:	00 00 00 
  80f506:	ff d0                	callq  *%rax
  }
  return ret;
  80f508:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80f50c:	c9                   	leaveq 
  80f50d:	c3                   	retq   

000000000080f50e <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80f50e:	55                   	push   %rbp
  80f50f:	48 89 e5             	mov    %rsp,%rbp
  80f512:	48 83 ec 30          	sub    $0x30,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80f516:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80f51a:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f521:	00 00 00 
  80f524:	8b 00                	mov    (%rax),%eax
  80f526:	8d 50 01             	lea    0x1(%rax),%edx
  80f529:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f530:	00 00 00 
  80f533:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80f535:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80f53c:	00 
  pcb = tcp_active_pcbs;
  80f53d:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f544:	00 00 00 
  80f547:	48 8b 00             	mov    (%rax),%rax
  80f54a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80f54e:	e9 80 06 00 00       	jmpq   80fbd3 <tcp_slowtmr+0x6c5>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80f553:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f557:	8b 40 18             	mov    0x18(%rax),%eax
  80f55a:	85 c0                	test   %eax,%eax
  80f55c:	75 2a                	jne    80f588 <tcp_slowtmr+0x7a>
  80f55e:	48 ba 70 1e 82 00 00 	movabs $0x821e70,%rdx
  80f565:	00 00 00 
  80f568:	be 36 02 00 00       	mov    $0x236,%esi
  80f56d:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80f574:	00 00 00 
  80f577:	b8 00 00 00 00       	mov    $0x0,%eax
  80f57c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80f583:	00 00 00 
  80f586:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80f588:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f58c:	8b 40 18             	mov    0x18(%rax),%eax
  80f58f:	83 f8 01             	cmp    $0x1,%eax
  80f592:	75 2a                	jne    80f5be <tcp_slowtmr+0xb0>
  80f594:	48 ba a0 1e 82 00 00 	movabs $0x821ea0,%rdx
  80f59b:	00 00 00 
  80f59e:	be 37 02 00 00       	mov    $0x237,%esi
  80f5a3:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80f5aa:	00 00 00 
  80f5ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5b2:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80f5b9:	00 00 00 
  80f5bc:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80f5be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5c2:	8b 40 18             	mov    0x18(%rax),%eax
  80f5c5:	83 f8 0a             	cmp    $0xa,%eax
  80f5c8:	75 2a                	jne    80f5f4 <tcp_slowtmr+0xe6>
  80f5ca:	48 ba d0 1e 82 00 00 	movabs $0x821ed0,%rdx
  80f5d1:	00 00 00 
  80f5d4:	be 38 02 00 00       	mov    $0x238,%esi
  80f5d9:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80f5e0:	00 00 00 
  80f5e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80f5e8:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80f5ef:	00 00 00 
  80f5f2:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80f5f4:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80f5f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f5fc:	8b 40 18             	mov    0x18(%rax),%eax
  80f5ff:	83 f8 02             	cmp    $0x2,%eax
  80f602:	75 15                	jne    80f619 <tcp_slowtmr+0x10b>
  80f604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f608:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f60c:	3c 06                	cmp    $0x6,%al
  80f60e:	75 09                	jne    80f619 <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80f610:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80f614:	e9 e6 01 00 00       	jmpq   80f7ff <tcp_slowtmr+0x2f1>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80f619:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f61d:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f621:	3c 0c                	cmp    $0xc,%al
  80f623:	75 09                	jne    80f62e <tcp_slowtmr+0x120>
      ++pcb_remove;
  80f625:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80f629:	e9 d1 01 00 00       	jmpq   80f7ff <tcp_slowtmr+0x2f1>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80f62e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f632:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f639:	84 c0                	test   %al,%al
  80f63b:	0f 84 9a 00 00 00    	je     80f6db <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80f641:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f645:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80f64b:	8d 50 01             	lea    0x1(%rax),%edx
  80f64e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f652:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80f658:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f65c:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80f662:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f666:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f66d:	0f b6 c0             	movzbl %al,%eax
  80f670:	83 e8 01             	sub    $0x1,%eax
  80f673:	48 ba 85 1d 82 00 00 	movabs $0x821d85,%rdx
  80f67a:	00 00 00 
  80f67d:	48 98                	cltq   
  80f67f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f683:	0f b6 c0             	movzbl %al,%eax
  80f686:	39 c1                	cmp    %eax,%ecx
  80f688:	0f 82 71 01 00 00    	jb     80f7ff <tcp_slowtmr+0x2f1>
          pcb->persist_cnt = 0;
  80f68e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f692:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80f699:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80f69c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6a0:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f6a7:	3c 06                	cmp    $0x6,%al
  80f6a9:	77 18                	ja     80f6c3 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80f6ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6af:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f6b6:	8d 50 01             	lea    0x1(%rax),%edx
  80f6b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6bd:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80f6c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6c7:	48 89 c7             	mov    %rax,%rdi
  80f6ca:	48 b8 d3 45 81 00 00 	movabs $0x8145d3,%rax
  80f6d1:	00 00 00 
  80f6d4:	ff d0                	callq  *%rax
  80f6d6:	e9 24 01 00 00       	jmpq   80f7ff <tcp_slowtmr+0x2f1>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80f6db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6df:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f6e3:	66 85 c0             	test   %ax,%ax
  80f6e6:	78 13                	js     80f6fb <tcp_slowtmr+0x1ed>
          ++pcb->rtime;
  80f6e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6ec:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f6f0:	8d 50 01             	lea    0x1(%rax),%edx
  80f6f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6f7:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80f6fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f6ff:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f706:	48 85 c0             	test   %rax,%rax
  80f709:	0f 84 f0 00 00 00    	je     80f7ff <tcp_slowtmr+0x2f1>
  80f70f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f713:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80f717:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f71b:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80f71f:	66 39 c2             	cmp    %ax,%dx
  80f722:	0f 8c d7 00 00 00    	jl     80f7ff <tcp_slowtmr+0x2f1>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80f728:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f72c:	8b 40 18             	mov    0x18(%rax),%eax
  80f72f:	83 f8 02             	cmp    $0x2,%eax
  80f732:	74 4b                	je     80f77f <tcp_slowtmr+0x271>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80f734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f738:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80f73c:	66 c1 f8 03          	sar    $0x3,%ax
  80f740:	0f bf d0             	movswl %ax,%edx
  80f743:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f747:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80f74b:	98                   	cwtl   
  80f74c:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80f74f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f753:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f757:	0f b6 c0             	movzbl %al,%eax
  80f75a:	48 ba 78 1d 82 00 00 	movabs $0x821d78,%rdx
  80f761:	00 00 00 
  80f764:	48 98                	cltq   
  80f766:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f76a:	0f b6 c0             	movzbl %al,%eax
  80f76d:	89 f2                	mov    %esi,%edx
  80f76f:	89 c1                	mov    %eax,%ecx
  80f771:	d3 e2                	shl    %cl,%edx
  80f773:	89 d0                	mov    %edx,%eax
  80f775:	89 c2                	mov    %eax,%edx
  80f777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f77b:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80f77f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f783:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80f789:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f78d:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80f791:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f795:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80f799:	66 39 c2             	cmp    %ax,%dx
  80f79c:	0f 46 c2             	cmovbe %edx,%eax
  80f79f:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80f7a3:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80f7a7:	89 c2                	mov    %eax,%edx
  80f7a9:	66 d1 ea             	shr    %dx
  80f7ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7b0:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80f7b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7b8:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80f7bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7c0:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f7c4:	66 39 c2             	cmp    %ax,%dx
  80f7c7:	73 13                	jae    80f7dc <tcp_slowtmr+0x2ce>
            pcb->ssthresh = pcb->mss * 2;
  80f7c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7cd:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f7d1:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80f7d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7d8:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80f7dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7e0:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f7e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7e8:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80f7ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7f0:	48 89 c7             	mov    %rax,%rdi
  80f7f3:	48 b8 05 42 81 00 00 	movabs $0x814205,%rax
  80f7fa:	00 00 00 
  80f7fd:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80f7ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f803:	8b 40 18             	mov    0x18(%rax),%eax
  80f806:	83 f8 06             	cmp    $0x6,%eax
  80f809:	75 22                	jne    80f82d <tcp_slowtmr+0x31f>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80f80b:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f812:	00 00 00 
  80f815:	8b 10                	mov    (%rax),%edx
  80f817:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f81b:	8b 40 38             	mov    0x38(%rax),%eax
  80f81e:	89 d1                	mov    %edx,%ecx
  80f820:	29 c1                	sub    %eax,%ecx
  80f822:	89 c8                	mov    %ecx,%eax
  80f824:	83 f8 28             	cmp    $0x28,%eax
  80f827:	76 04                	jbe    80f82d <tcp_slowtmr+0x31f>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80f829:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80f82d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f831:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f835:	0f b7 c0             	movzwl %ax,%eax
  80f838:	83 e0 08             	and    $0x8,%eax
  80f83b:	85 c0                	test   %eax,%eax
  80f83d:	0f 84 1b 01 00 00    	je     80f95e <tcp_slowtmr+0x450>
       ((pcb->state == ESTABLISHED) || 
  80f843:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f847:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80f84a:	83 f8 04             	cmp    $0x4,%eax
  80f84d:	74 10                	je     80f85f <tcp_slowtmr+0x351>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80f84f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f853:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80f856:	83 f8 07             	cmp    $0x7,%eax
  80f859:	0f 85 ff 00 00 00    	jne    80f95e <tcp_slowtmr+0x450>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f85f:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f866:	00 00 00 
  80f869:	8b 10                	mov    (%rax),%edx
  80f86b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f86f:	8b 40 38             	mov    0x38(%rax),%eax
  80f872:	89 d1                	mov    %edx,%ecx
  80f874:	29 c1                	sub    %eax,%ecx
  80f876:	89 c8                	mov    %ecx,%eax
  80f878:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80f87a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f87e:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80f884:	89 c0                	mov    %eax,%eax
  80f886:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80f88c:	48 89 c2             	mov    %rax,%rdx
  80f88f:	48 c1 ea 02          	shr    $0x2,%rdx
  80f893:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80f897:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80f89e:	9b c4 20 
  80f8a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f8a5:	48 f7 e2             	mul    %rdx
  80f8a8:	48 89 d0             	mov    %rdx,%rax
  80f8ab:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f8af:	48 39 c1             	cmp    %rax,%rcx
  80f8b2:	76 18                	jbe    80f8cc <tcp_slowtmr+0x3be>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80f8b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8b8:	48 89 c7             	mov    %rax,%rdi
  80f8bb:	48 b8 31 e9 80 00 00 	movabs $0x80e931,%rax
  80f8c2:	00 00 00 
  80f8c5:	ff d0                	callq  *%rax
  80f8c7:	e9 92 00 00 00       	jmpq   80f95e <tcp_slowtmr+0x450>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f8cc:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f8d3:	00 00 00 
  80f8d6:	8b 10                	mov    (%rax),%edx
  80f8d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8dc:	8b 40 38             	mov    0x38(%rax),%eax
  80f8df:	89 d1                	mov    %edx,%ecx
  80f8e1:	29 c1                	sub    %eax,%ecx
  80f8e3:	89 c8                	mov    %ecx,%eax
  80f8e5:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80f8e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8eb:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80f8f1:	89 c2                	mov    %eax,%edx
  80f8f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8f7:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80f8fe:	0f b6 c0             	movzbl %al,%eax
  80f901:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80f908:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80f90b:	48 89 c2             	mov    %rax,%rdx
  80f90e:	48 c1 ea 02          	shr    $0x2,%rdx
  80f912:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80f916:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80f91d:	9b c4 20 
  80f920:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80f924:	48 f7 e2             	mul    %rdx
  80f927:	48 89 d0             	mov    %rdx,%rax
  80f92a:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80f92e:	48 39 c1             	cmp    %rax,%rcx
  80f931:	76 2b                	jbe    80f95e <tcp_slowtmr+0x450>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80f933:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f937:	48 89 c7             	mov    %rax,%rdi
  80f93a:	48 b8 ac 43 81 00 00 	movabs $0x8143ac,%rax
  80f941:	00 00 00 
  80f944:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80f946:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f94a:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80f951:	8d 50 01             	lea    0x1(%rax),%edx
  80f954:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f958:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80f95e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f962:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f969:	48 85 c0             	test   %rax,%rax
  80f96c:	74 57                	je     80f9c5 <tcp_slowtmr+0x4b7>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80f96e:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f975:	00 00 00 
  80f978:	8b 10                	mov    (%rax),%edx
  80f97a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f97e:	8b 40 38             	mov    0x38(%rax),%eax
  80f981:	89 d1                	mov    %edx,%ecx
  80f983:	29 c1                	sub    %eax,%ecx
  80f985:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f989:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80f98d:	0f bf d0             	movswl %ax,%edx
  80f990:	89 d0                	mov    %edx,%eax
  80f992:	01 c0                	add    %eax,%eax
  80f994:	01 d0                	add    %edx,%eax
  80f996:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80f998:	39 c1                	cmp    %eax,%ecx
  80f99a:	72 29                	jb     80f9c5 <tcp_slowtmr+0x4b7>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80f99c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9a0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80f9a7:	48 89 c7             	mov    %rax,%rdi
  80f9aa:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  80f9b1:	00 00 00 
  80f9b4:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80f9b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9ba:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80f9c1:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80f9c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9c9:	8b 40 18             	mov    0x18(%rax),%eax
  80f9cc:	83 f8 03             	cmp    $0x3,%eax
  80f9cf:	75 22                	jne    80f9f3 <tcp_slowtmr+0x4e5>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80f9d1:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f9d8:	00 00 00 
  80f9db:	8b 10                	mov    (%rax),%edx
  80f9dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9e1:	8b 40 38             	mov    0x38(%rax),%eax
  80f9e4:	89 d1                	mov    %edx,%ecx
  80f9e6:	29 c1                	sub    %eax,%ecx
  80f9e8:	89 c8                	mov    %ecx,%eax
  80f9ea:	83 f8 28             	cmp    $0x28,%eax
  80f9ed:	76 04                	jbe    80f9f3 <tcp_slowtmr+0x4e5>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80f9ef:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80f9f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9f7:	8b 40 18             	mov    0x18(%rax),%eax
  80f9fa:	83 f8 09             	cmp    $0x9,%eax
  80f9fd:	75 24                	jne    80fa23 <tcp_slowtmr+0x515>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80f9ff:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fa06:	00 00 00 
  80fa09:	8b 10                	mov    (%rax),%edx
  80fa0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa0f:	8b 40 38             	mov    0x38(%rax),%eax
  80fa12:	89 d1                	mov    %edx,%ecx
  80fa14:	29 c1                	sub    %eax,%ecx
  80fa16:	89 c8                	mov    %ecx,%eax
  80fa18:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80fa1d:	76 04                	jbe    80fa23 <tcp_slowtmr+0x515>
        ++pcb_remove;
  80fa1f:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fa23:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80fa27:	0f 84 19 01 00 00    	je     80fb46 <tcp_slowtmr+0x638>
      tcp_pcb_purge(pcb);      
  80fa2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa31:	48 89 c7             	mov    %rax,%rdi
  80fa34:	48 b8 06 04 81 00 00 	movabs $0x810406,%rax
  80fa3b:	00 00 00 
  80fa3e:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80fa40:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fa45:	74 4f                	je     80fa96 <tcp_slowtmr+0x588>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80fa47:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fa4e:	00 00 00 
  80fa51:	48 8b 00             	mov    (%rax),%rax
  80fa54:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80fa58:	75 2a                	jne    80fa84 <tcp_slowtmr+0x576>
  80fa5a:	48 ba 00 1f 82 00 00 	movabs $0x821f00,%rdx
  80fa61:	00 00 00 
  80fa64:	be c1 02 00 00       	mov    $0x2c1,%esi
  80fa69:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80fa70:	00 00 00 
  80fa73:	b8 00 00 00 00       	mov    $0x0,%eax
  80fa78:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80fa7f:	00 00 00 
  80fa82:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80fa84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa88:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fa8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fa90:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fa94:	eb 52                	jmp    80fae8 <tcp_slowtmr+0x5da>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80fa96:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fa9d:	00 00 00 
  80faa0:	48 8b 00             	mov    (%rax),%rax
  80faa3:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80faa7:	74 2a                	je     80fad3 <tcp_slowtmr+0x5c5>
  80faa9:	48 ba 30 1f 82 00 00 	movabs $0x821f30,%rdx
  80fab0:	00 00 00 
  80fab3:	be c5 02 00 00       	mov    $0x2c5,%esi
  80fab8:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80fabf:	00 00 00 
  80fac2:	b8 00 00 00 00       	mov    $0x0,%eax
  80fac7:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80face:	00 00 00 
  80fad1:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  80fad3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fad7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fadb:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fae2:	00 00 00 
  80fae5:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80fae8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80faec:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80faf3:	48 85 c0             	test   %rax,%rax
  80faf6:	74 1d                	je     80fb15 <tcp_slowtmr+0x607>
  80faf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fafc:	48 8b 90 c8 00 00 00 	mov    0xc8(%rax),%rdx
  80fb03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb07:	48 8b 40 20          	mov    0x20(%rax),%rax
  80fb0b:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80fb10:	48 89 c7             	mov    %rax,%rdi
  80fb13:	ff d2                	callq  *%rdx

      pcb2 = pcb->next;
  80fb15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb19:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fb1d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80fb21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb25:	48 89 c6             	mov    %rax,%rsi
  80fb28:	bf 02 00 00 00       	mov    $0x2,%edi
  80fb2d:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80fb34:	00 00 00 
  80fb37:	ff d0                	callq  *%rax
      pcb = pcb2;
  80fb39:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80fb3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fb41:	e9 8d 00 00 00       	jmpq   80fbd3 <tcp_slowtmr+0x6c5>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80fb46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb4a:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  80fb4e:	8d 50 01             	lea    0x1(%rax),%edx
  80fb51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb55:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  80fb58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb5c:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  80fb60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb64:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  80fb68:	38 c2                	cmp    %al,%dl
  80fb6a:	72 53                	jb     80fbbf <tcp_slowtmr+0x6b1>
        pcb->polltmr = 0;
  80fb6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb70:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80fb74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb78:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80fb7f:	48 85 c0             	test   %rax,%rax
  80fb82:	74 22                	je     80fba6 <tcp_slowtmr+0x698>
  80fb84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb88:	48 8b 88 c0 00 00 00 	mov    0xc0(%rax),%rcx
  80fb8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb93:	48 8b 40 20          	mov    0x20(%rax),%rax
  80fb97:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80fb9b:	48 89 d6             	mov    %rdx,%rsi
  80fb9e:	48 89 c7             	mov    %rax,%rdi
  80fba1:	ff d1                	callq  *%rcx
  80fba3:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  80fba6:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  80fbaa:	75 13                	jne    80fbbf <tcp_slowtmr+0x6b1>
          tcp_output(pcb);
  80fbac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbb0:	48 89 c7             	mov    %rax,%rdi
  80fbb3:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  80fbba:	00 00 00 
  80fbbd:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  80fbbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbc3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80fbc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbcb:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fbcf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80fbd3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fbd8:	0f 85 75 f9 ff ff    	jne    80f553 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  80fbde:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80fbe5:	00 
  pcb = tcp_tw_pcbs;
  80fbe6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fbed:	00 00 00 
  80fbf0:	48 8b 00             	mov    (%rax),%rax
  80fbf3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  80fbf7:	e9 65 01 00 00       	jmpq   80fd61 <tcp_slowtmr+0x853>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80fbfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc00:	8b 40 18             	mov    0x18(%rax),%eax
  80fc03:	83 f8 0a             	cmp    $0xa,%eax
  80fc06:	74 2a                	je     80fc32 <tcp_slowtmr+0x724>
  80fc08:	48 ba 60 1f 82 00 00 	movabs $0x821f60,%rdx
  80fc0f:	00 00 00 
  80fc12:	be e5 02 00 00       	mov    $0x2e5,%esi
  80fc17:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80fc1e:	00 00 00 
  80fc21:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc26:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80fc2d:	00 00 00 
  80fc30:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  80fc32:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80fc36:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fc3d:	00 00 00 
  80fc40:	8b 10                	mov    (%rax),%edx
  80fc42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc46:	8b 40 38             	mov    0x38(%rax),%eax
  80fc49:	89 d1                	mov    %edx,%ecx
  80fc4b:	29 c1                	sub    %eax,%ecx
  80fc4d:	89 c8                	mov    %ecx,%eax
  80fc4f:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80fc54:	76 04                	jbe    80fc5a <tcp_slowtmr+0x74c>
      ++pcb_remove;
  80fc56:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fc5a:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80fc5e:	0f 84 e9 00 00 00    	je     80fd4d <tcp_slowtmr+0x83f>
      tcp_pcb_purge(pcb);      
  80fc64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc68:	48 89 c7             	mov    %rax,%rdi
  80fc6b:	48 b8 06 04 81 00 00 	movabs $0x810406,%rax
  80fc72:	00 00 00 
  80fc75:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80fc77:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fc7c:	74 4f                	je     80fccd <tcp_slowtmr+0x7bf>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80fc7e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fc85:	00 00 00 
  80fc88:	48 8b 00             	mov    (%rax),%rax
  80fc8b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80fc8f:	75 2a                	jne    80fcbb <tcp_slowtmr+0x7ad>
  80fc91:	48 ba 90 1f 82 00 00 	movabs $0x821f90,%rdx
  80fc98:	00 00 00 
  80fc9b:	be f4 02 00 00       	mov    $0x2f4,%esi
  80fca0:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80fca7:	00 00 00 
  80fcaa:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcaf:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80fcb6:	00 00 00 
  80fcb9:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80fcbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcbf:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fcc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fcc7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fccb:	eb 52                	jmp    80fd1f <tcp_slowtmr+0x811>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80fccd:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fcd4:	00 00 00 
  80fcd7:	48 8b 00             	mov    (%rax),%rax
  80fcda:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80fcde:	74 2a                	je     80fd0a <tcp_slowtmr+0x7fc>
  80fce0:	48 ba b8 1f 82 00 00 	movabs $0x821fb8,%rdx
  80fce7:	00 00 00 
  80fcea:	be f8 02 00 00       	mov    $0x2f8,%esi
  80fcef:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  80fcf6:	00 00 00 
  80fcf9:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcfe:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  80fd05:	00 00 00 
  80fd08:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  80fd0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd0e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fd12:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fd19:	00 00 00 
  80fd1c:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  80fd1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd23:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fd27:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80fd2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd2f:	48 89 c6             	mov    %rax,%rsi
  80fd32:	bf 02 00 00 00       	mov    $0x2,%edi
  80fd37:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80fd3e:	00 00 00 
  80fd41:	ff d0                	callq  *%rax
      pcb = pcb2;
  80fd43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80fd47:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fd4b:	eb 14                	jmp    80fd61 <tcp_slowtmr+0x853>
    } else {
      prev = pcb;
  80fd4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd51:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80fd55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd59:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fd5d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80fd61:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fd66:	0f 85 90 fe ff ff    	jne    80fbfc <tcp_slowtmr+0x6ee>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  80fd6c:	c9                   	leaveq 
  80fd6d:	c3                   	retq   

000000000080fd6e <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80fd6e:	55                   	push   %rbp
  80fd6f:	48 89 e5             	mov    %rsp,%rbp
  80fd72:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80fd76:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fd7d:	00 00 00 
  80fd80:	48 8b 00             	mov    (%rax),%rax
  80fd83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fd87:	e9 f2 00 00 00       	jmpq   80fe7e <tcp_fasttmr+0x110>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80fd8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd90:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80fd97:	48 85 c0             	test   %rax,%rax
  80fd9a:	0f 84 85 00 00 00    	je     80fe25 <tcp_fasttmr+0xb7>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80fda0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda4:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80fdab:	48 85 c0             	test   %rax,%rax
  80fdae:	74 32                	je     80fde2 <tcp_fasttmr+0x74>
  80fdb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdb4:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  80fdbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdbf:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  80fdc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdca:	48 8b 40 20          	mov    0x20(%rax),%rax
  80fdce:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  80fdd2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fdd7:	48 89 c7             	mov    %rax,%rdi
  80fdda:	41 ff d0             	callq  *%r8
  80fddd:	88 45 f7             	mov    %al,-0x9(%rbp)
  80fde0:	eb 2e                	jmp    80fe10 <tcp_fasttmr+0xa2>
  80fde2:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  80fde6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdea:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80fdf1:	48 85 c0             	test   %rax,%rax
  80fdf4:	74 1a                	je     80fe10 <tcp_fasttmr+0xa2>
  80fdf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdfa:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80fe01:	48 89 c7             	mov    %rax,%rdi
  80fe04:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80fe0b:	00 00 00 
  80fe0e:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  80fe10:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80fe14:	75 0f                	jne    80fe25 <tcp_fasttmr+0xb7>
        pcb->refused_data = NULL;
  80fe16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe1a:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  80fe21:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80fe25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe29:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80fe2d:	0f b6 c0             	movzbl %al,%eax
  80fe30:	83 e0 01             	and    $0x1,%eax
  80fe33:	84 c0                	test   %al,%al
  80fe35:	74 3b                	je     80fe72 <tcp_fasttmr+0x104>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80fe37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe3b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80fe3f:	89 c2                	mov    %eax,%edx
  80fe41:	83 ca 02             	or     $0x2,%edx
  80fe44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe48:	88 50 2c             	mov    %dl,0x2c(%rax)
  80fe4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe4f:	48 89 c7             	mov    %rax,%rdi
  80fe52:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  80fe59:	00 00 00 
  80fe5c:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80fe5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe62:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80fe66:	89 c2                	mov    %eax,%edx
  80fe68:	83 e2 fc             	and    $0xfffffffc,%edx
  80fe6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe6f:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80fe72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe76:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fe7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fe7e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fe83:	0f 85 03 ff ff ff    	jne    80fd8c <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  80fe89:	c9                   	leaveq 
  80fe8a:	c3                   	retq   

000000000080fe8b <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  80fe8b:	55                   	push   %rbp
  80fe8c:	48 89 e5             	mov    %rsp,%rbp
  80fe8f:	48 83 ec 20          	sub    $0x20,%rsp
  80fe93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  80fe97:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  80fe9b:	eb 29                	jmp    80fec6 <tcp_segs_free+0x3b>
    next = seg->next;
  80fe9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fea1:	48 8b 00             	mov    (%rax),%rax
  80fea4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  80fea8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80feac:	48 89 c7             	mov    %rax,%rdi
  80feaf:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  80feb6:	00 00 00 
  80feb9:	ff d0                	callq  *%rax
  80febb:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  80febe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fec2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  80fec6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80fecb:	75 d0                	jne    80fe9d <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  80fecd:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80fed1:	c9                   	leaveq 
  80fed2:	c3                   	retq   

000000000080fed3 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80fed3:	55                   	push   %rbp
  80fed4:	48 89 e5             	mov    %rsp,%rbp
  80fed7:	48 83 ec 20          	sub    $0x20,%rsp
  80fedb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  80fedf:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  80fee3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80fee8:	74 3f                	je     80ff29 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  80feea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80feee:	48 8b 40 08          	mov    0x8(%rax),%rax
  80fef2:	48 85 c0             	test   %rax,%rax
  80fef5:	74 1a                	je     80ff11 <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  80fef7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80fefb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80feff:	48 89 c7             	mov    %rax,%rdi
  80ff02:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80ff09:	00 00 00 
  80ff0c:	ff d0                	callq  *%rax
  80ff0e:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80ff11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ff15:	48 89 c6             	mov    %rax,%rsi
  80ff18:	bf 04 00 00 00       	mov    $0x4,%edi
  80ff1d:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  80ff24:	00 00 00 
  80ff27:	ff d0                	callq  *%rax
  }
  return count;
  80ff29:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80ff2d:	c9                   	leaveq 
  80ff2e:	c3                   	retq   

000000000080ff2f <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80ff2f:	55                   	push   %rbp
  80ff30:	48 89 e5             	mov    %rsp,%rbp
  80ff33:	48 83 ec 10          	sub    $0x10,%rsp
  80ff37:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ff3b:	89 f0                	mov    %esi,%eax
  80ff3d:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  80ff40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff44:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80ff48:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  80ff4b:	c9                   	leaveq 
  80ff4c:	c3                   	retq   

000000000080ff4d <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  80ff4d:	55                   	push   %rbp
  80ff4e:	48 89 e5             	mov    %rsp,%rbp
  80ff51:	48 83 ec 20          	sub    $0x20,%rsp
  80ff55:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80ff59:	bf 04 00 00 00       	mov    $0x4,%edi
  80ff5e:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  80ff65:	00 00 00 
  80ff68:	ff d0                	callq  *%rax
  80ff6a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  80ff6e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ff73:	75 07                	jne    80ff7c <tcp_seg_copy+0x2f>
    return NULL;
  80ff75:	b8 00 00 00 00       	mov    $0x0,%eax
  80ff7a:	eb 3a                	jmp    80ffb6 <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80ff7c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80ff80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff84:	ba 28 00 00 00       	mov    $0x28,%edx
  80ff89:	48 89 ce             	mov    %rcx,%rsi
  80ff8c:	48 89 c7             	mov    %rax,%rdi
  80ff8f:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  80ff96:	00 00 00 
  80ff99:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  80ff9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ffa3:	48 89 c7             	mov    %rax,%rdi
  80ffa6:	48 b8 2f d9 80 00 00 	movabs $0x80d92f,%rax
  80ffad:	00 00 00 
  80ffb0:	ff d0                	callq  *%rax
  return cseg;
  80ffb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80ffb6:	c9                   	leaveq 
  80ffb7:	c3                   	retq   

000000000080ffb8 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80ffb8:	55                   	push   %rbp
  80ffb9:	48 89 e5             	mov    %rsp,%rbp
  80ffbc:	48 83 ec 20          	sub    $0x20,%rsp
  80ffc0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ffc4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80ffc8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80ffcc:	89 c8                	mov    %ecx,%eax
  80ffce:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  80ffd1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ffd6:	74 15                	je     80ffed <tcp_recv_null+0x35>
    pbuf_free(p);
  80ffd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ffdc:	48 89 c7             	mov    %rax,%rdi
  80ffdf:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  80ffe6:	00 00 00 
  80ffe9:	ff d0                	callq  *%rax
  80ffeb:	eb 1b                	jmp    810008 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  80ffed:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  80fff1:	75 15                	jne    810008 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  80fff3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fff7:	48 89 c7             	mov    %rax,%rdi
  80fffa:	48 b8 a9 e6 80 00 00 	movabs $0x80e6a9,%rax
  810001:	00 00 00 
  810004:	ff d0                	callq  *%rax
  810006:	eb 05                	jmp    81000d <tcp_recv_null+0x55>
  }
  return ERR_OK;
  810008:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81000d:	c9                   	leaveq 
  81000e:	c3                   	retq   

000000000081000f <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  81000f:	55                   	push   %rbp
  810010:	48 89 e5             	mov    %rsp,%rbp
  810013:	48 83 ec 30          	sub    $0x30,%rsp
  810017:	89 f8                	mov    %edi,%eax
  810019:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  81001c:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  810020:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  810027:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81002e:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81002f:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  810036:	00 00 00 
  810039:	48 8b 00             	mov    (%rax),%rax
  81003c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810040:	eb 73                	jmp    8100b5 <tcp_kill_prio+0xa6>
    if (pcb->prio <= prio &&
  810042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810046:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81004a:	3a 45 dc             	cmp    -0x24(%rbp),%al
  81004d:	77 5a                	ja     8100a9 <tcp_kill_prio+0x9a>
       pcb->prio <= mprio &&
  81004f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810053:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  810057:	3a 45 eb             	cmp    -0x15(%rbp),%al
  81005a:	77 4d                	ja     8100a9 <tcp_kill_prio+0x9a>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  81005c:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810063:	00 00 00 
  810066:	8b 10                	mov    (%rax),%edx
  810068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81006c:	8b 40 38             	mov    0x38(%rax),%eax
  81006f:	89 d1                	mov    %edx,%ecx
  810071:	29 c1                	sub    %eax,%ecx
  810073:	89 c8                	mov    %ecx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  810075:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  810078:	72 2f                	jb     8100a9 <tcp_kill_prio+0x9a>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  81007a:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810081:	00 00 00 
  810084:	8b 10                	mov    (%rax),%edx
  810086:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81008a:	8b 40 38             	mov    0x38(%rax),%eax
  81008d:	89 d1                	mov    %edx,%ecx
  81008f:	29 c1                	sub    %eax,%ecx
  810091:	89 c8                	mov    %ecx,%eax
  810093:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  810096:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81009a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  81009e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100a2:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8100a6:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8100a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8100ad:	48 8b 40 10          	mov    0x10(%rax),%rax
  8100b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8100b5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8100ba:	75 86                	jne    810042 <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  8100bc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8100c1:	74 13                	je     8100d6 <tcp_kill_prio+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8100c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8100c7:	48 89 c7             	mov    %rax,%rdi
  8100ca:	48 b8 31 e9 80 00 00 	movabs $0x80e931,%rax
  8100d1:	00 00 00 
  8100d4:	ff d0                	callq  *%rax
  }      
}
  8100d6:	c9                   	leaveq 
  8100d7:	c3                   	retq   

00000000008100d8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  8100d8:	55                   	push   %rbp
  8100d9:	48 89 e5             	mov    %rsp,%rbp
  8100dc:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8100e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  8100e7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8100ee:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8100ef:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8100f6:	00 00 00 
  8100f9:	48 8b 00             	mov    (%rax),%rax
  8100fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810100:	eb 4e                	jmp    810150 <tcp_kill_timewait+0x78>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  810102:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810109:	00 00 00 
  81010c:	8b 10                	mov    (%rax),%edx
  81010e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810112:	8b 40 38             	mov    0x38(%rax),%eax
  810115:	89 d1                	mov    %edx,%ecx
  810117:	29 c1                	sub    %eax,%ecx
  810119:	89 c8                	mov    %ecx,%eax
  81011b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81011e:	72 24                	jb     810144 <tcp_kill_timewait+0x6c>
      inactivity = tcp_ticks - pcb->tmr;
  810120:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810127:	00 00 00 
  81012a:	8b 10                	mov    (%rax),%edx
  81012c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810130:	8b 40 38             	mov    0x38(%rax),%eax
  810133:	89 d1                	mov    %edx,%ecx
  810135:	29 c1                	sub    %eax,%ecx
  810137:	89 c8                	mov    %ecx,%eax
  810139:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  81013c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810140:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810144:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810148:	48 8b 40 10          	mov    0x10(%rax),%rax
  81014c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810150:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810155:	75 ab                	jne    810102 <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  810157:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81015c:	74 13                	je     810171 <tcp_kill_timewait+0x99>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  81015e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810162:	48 89 c7             	mov    %rax,%rdi
  810165:	48 b8 31 e9 80 00 00 	movabs $0x80e931,%rax
  81016c:	00 00 00 
  81016f:	ff d0                	callq  *%rax
  }      
}
  810171:	c9                   	leaveq 
  810172:	c3                   	retq   

0000000000810173 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  810173:	55                   	push   %rbp
  810174:	48 89 e5             	mov    %rsp,%rbp
  810177:	48 83 ec 20          	sub    $0x20,%rsp
  81017b:	89 f8                	mov    %edi,%eax
  81017d:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  810180:	bf 02 00 00 00       	mov    $0x2,%edi
  810185:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  81018c:	00 00 00 
  81018f:	ff d0                	callq  *%rax
  810191:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  810195:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81019a:	75 4f                	jne    8101eb <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  81019c:	48 b8 d8 00 81 00 00 	movabs $0x8100d8,%rax
  8101a3:	00 00 00 
  8101a6:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8101a8:	bf 02 00 00 00       	mov    $0x2,%edi
  8101ad:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  8101b4:	00 00 00 
  8101b7:	ff d0                	callq  *%rax
  8101b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  8101bd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8101c2:	75 27                	jne    8101eb <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  8101c4:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  8101c8:	89 c7                	mov    %eax,%edi
  8101ca:	48 b8 0f 00 81 00 00 	movabs $0x81000f,%rax
  8101d1:	00 00 00 
  8101d4:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  8101d6:	bf 02 00 00 00       	mov    $0x2,%edi
  8101db:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  8101e2:	00 00 00 
  8101e5:	ff d0                	callq  *%rax
  8101e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  8101eb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8101f0:	0f 84 23 01 00 00    	je     810319 <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8101f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8101fa:	ba e0 00 00 00       	mov    $0xe0,%edx
  8101ff:	be 00 00 00 00       	mov    $0x0,%esi
  810204:	48 89 c7             	mov    %rax,%rdi
  810207:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  81020e:	00 00 00 
  810211:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  810213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810217:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  81021b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81021f:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  810225:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810229:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  81022f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810233:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  810239:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81023d:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  810243:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810247:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  81024b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81024f:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  810253:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810257:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  81025d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810261:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  810267:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81026b:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  810271:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810275:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  81027b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81027f:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  810285:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810289:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  81028f:	48 b8 05 07 81 00 00 	movabs $0x810705,%rax
  810296:	00 00 00 
  810299:	ff d0                	callq  *%rax
  81029b:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  81029e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102a2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8102a5:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  8102a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102ac:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8102af:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  8102b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102b6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8102b9:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  8102bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102c0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8102c3:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  8102c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102ca:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8102cd:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  8102d0:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8102d7:	00 00 00 
  8102da:	8b 10                	mov    (%rax),%edx
  8102dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102e0:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  8102e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102e7:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8102eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102ef:	48 ba b8 ff 80 00 00 	movabs $0x80ffb8,%rdx
  8102f6:	00 00 00 
  8102f9:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  810300:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810304:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  81030b:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  81030e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810312:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  810319:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81031d:	c9                   	leaveq 
  81031e:	c3                   	retq   

000000000081031f <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  81031f:	55                   	push   %rbp
  810320:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  810323:	bf 40 00 00 00       	mov    $0x40,%edi
  810328:	48 b8 73 01 81 00 00 	movabs $0x810173,%rax
  81032f:	00 00 00 
  810332:	ff d0                	callq  *%rax
}
  810334:	5d                   	pop    %rbp
  810335:	c3                   	retq   

0000000000810336 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  810336:	55                   	push   %rbp
  810337:	48 89 e5             	mov    %rsp,%rbp
  81033a:	48 83 ec 10          	sub    $0x10,%rsp
  81033e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810342:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  810346:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81034a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81034e:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  810352:	c9                   	leaveq 
  810353:	c3                   	retq   

0000000000810354 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  810354:	55                   	push   %rbp
  810355:	48 89 e5             	mov    %rsp,%rbp
  810358:	48 83 ec 10          	sub    $0x10,%rsp
  81035c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810360:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  810364:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810368:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81036c:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  810373:	c9                   	leaveq 
  810374:	c3                   	retq   

0000000000810375 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  810375:	55                   	push   %rbp
  810376:	48 89 e5             	mov    %rsp,%rbp
  810379:	48 83 ec 10          	sub    $0x10,%rsp
  81037d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810381:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  810385:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810389:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81038d:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  810394:	c9                   	leaveq 
  810395:	c3                   	retq   

0000000000810396 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  810396:	55                   	push   %rbp
  810397:	48 89 e5             	mov    %rsp,%rbp
  81039a:	48 83 ec 10          	sub    $0x10,%rsp
  81039e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8103a2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  8103a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103aa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8103ae:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  8103b5:	c9                   	leaveq 
  8103b6:	c3                   	retq   

00000000008103b7 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  8103b7:	55                   	push   %rbp
  8103b8:	48 89 e5             	mov    %rsp,%rbp
  8103bb:	48 83 ec 10          	sub    $0x10,%rsp
  8103bf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8103c3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  8103c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103cb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8103cf:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  8103d3:	c9                   	leaveq 
  8103d4:	c3                   	retq   

00000000008103d5 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8103d5:	55                   	push   %rbp
  8103d6:	48 89 e5             	mov    %rsp,%rbp
  8103d9:	48 83 ec 18          	sub    $0x18,%rsp
  8103dd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8103e1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8103e5:	89 d0                	mov    %edx,%eax
  8103e7:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8103ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103ee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8103f2:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8103f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103fd:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  810401:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  810404:	c9                   	leaveq 
  810405:	c3                   	retq   

0000000000810406 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  810406:	55                   	push   %rbp
  810407:	48 89 e5             	mov    %rsp,%rbp
  81040a:	48 83 ec 10          	sub    $0x10,%rsp
  81040e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  810412:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810416:	8b 40 18             	mov    0x18(%rax),%eax
  810419:	85 c0                	test   %eax,%eax
  81041b:	0f 84 e5 00 00 00    	je     810506 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  810421:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810425:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  810428:	83 f8 0a             	cmp    $0xa,%eax
  81042b:	0f 84 d5 00 00 00    	je     810506 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  810431:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810435:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  810438:	83 f8 01             	cmp    $0x1,%eax
  81043b:	0f 84 c5 00 00 00    	je     810506 <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  810441:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810445:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81044c:	48 85 c0             	test   %rax,%rax
  81044f:	74 29                	je     81047a <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  810451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810455:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81045c:	48 89 c7             	mov    %rax,%rdi
  81045f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  810466:	00 00 00 
  810469:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  81046b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81046f:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810476:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  81047a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81047e:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  810484:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810488:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81048f:	48 89 c7             	mov    %rax,%rdi
  810492:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  810499:	00 00 00 
  81049c:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  81049e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104a2:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  8104a9:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8104ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104b1:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8104b8:	48 89 c7             	mov    %rax,%rdi
  8104bb:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  8104c2:	00 00 00 
  8104c5:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  8104c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104cb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8104d2:	48 89 c7             	mov    %rax,%rdi
  8104d5:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  8104dc:	00 00 00 
  8104df:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  8104e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104e5:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  8104ec:	00 00 00 00 
  8104f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104f4:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  8104fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104ff:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  810506:	c9                   	leaveq 
  810507:	c3                   	retq   

0000000000810508 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  810508:	55                   	push   %rbp
  810509:	48 89 e5             	mov    %rsp,%rbp
  81050c:	48 83 ec 10          	sub    $0x10,%rsp
  810510:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810514:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  810518:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81051c:	48 8b 00             	mov    (%rax),%rax
  81051f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810523:	75 17                	jne    81053c <tcp_pcb_remove+0x34>
  810525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810529:	48 8b 00             	mov    (%rax),%rax
  81052c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810530:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810534:	48 89 10             	mov    %rdx,(%rax)
  810537:	e9 8e 00 00 00       	jmpq   8105ca <tcp_pcb_remove+0xc2>
  81053c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810540:	48 8b 10             	mov    (%rax),%rdx
  810543:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81054a:	00 00 00 
  81054d:	48 89 10             	mov    %rdx,(%rax)
  810550:	eb 66                	jmp    8105b8 <tcp_pcb_remove+0xb0>
  810552:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810559:	00 00 00 
  81055c:	48 8b 00             	mov    (%rax),%rax
  81055f:	48 8b 40 10          	mov    0x10(%rax),%rax
  810563:	48 85 c0             	test   %rax,%rax
  810566:	74 32                	je     81059a <tcp_pcb_remove+0x92>
  810568:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81056f:	00 00 00 
  810572:	48 8b 00             	mov    (%rax),%rax
  810575:	48 8b 40 10          	mov    0x10(%rax),%rax
  810579:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  81057d:	75 1b                	jne    81059a <tcp_pcb_remove+0x92>
  81057f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810586:	00 00 00 
  810589:	48 8b 00             	mov    (%rax),%rax
  81058c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810590:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810594:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810598:	eb 30                	jmp    8105ca <tcp_pcb_remove+0xc2>
  81059a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8105a1:	00 00 00 
  8105a4:	48 8b 00             	mov    (%rax),%rax
  8105a7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8105ab:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8105b2:	00 00 00 
  8105b5:	48 89 10             	mov    %rdx,(%rax)
  8105b8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  8105bf:	00 00 00 
  8105c2:	48 8b 00             	mov    (%rax),%rax
  8105c5:	48 85 c0             	test   %rax,%rax
  8105c8:	75 88                	jne    810552 <tcp_pcb_remove+0x4a>
  8105ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105ce:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8105d5:	00 

  tcp_pcb_purge(pcb);
  8105d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105da:	48 89 c7             	mov    %rax,%rdi
  8105dd:	48 b8 06 04 81 00 00 	movabs $0x810406,%rax
  8105e4:	00 00 00 
  8105e7:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8105e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105ed:	8b 40 18             	mov    0x18(%rax),%eax
  8105f0:	83 f8 0a             	cmp    $0xa,%eax
  8105f3:	74 45                	je     81063a <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  8105f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8105f9:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8105fc:	83 f8 01             	cmp    $0x1,%eax
  8105ff:	74 39                	je     81063a <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  810601:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810605:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  810609:	0f b6 c0             	movzbl %al,%eax
  81060c:	83 e0 01             	and    $0x1,%eax
  81060f:	84 c0                	test   %al,%al
  810611:	74 27                	je     81063a <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  810613:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810617:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81061b:	89 c2                	mov    %eax,%edx
  81061d:	83 ca 02             	or     $0x2,%edx
  810620:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810624:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810627:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81062b:	48 89 c7             	mov    %rax,%rdi
  81062e:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  810635:	00 00 00 
  810638:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  81063a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81063e:	8b 40 18             	mov    0x18(%rax),%eax
  810641:	83 f8 01             	cmp    $0x1,%eax
  810644:	0f 84 ae 00 00 00    	je     8106f8 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  81064a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81064e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810655:	48 85 c0             	test   %rax,%rax
  810658:	74 2a                	je     810684 <tcp_pcb_remove+0x17c>
  81065a:	48 ba de 1f 82 00 00 	movabs $0x821fde,%rdx
  810661:	00 00 00 
  810664:	be b4 04 00 00       	mov    $0x4b4,%esi
  810669:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  810670:	00 00 00 
  810673:	b8 00 00 00 00       	mov    $0x0,%eax
  810678:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81067f:	00 00 00 
  810682:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  810684:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810688:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81068f:	48 85 c0             	test   %rax,%rax
  810692:	74 2a                	je     8106be <tcp_pcb_remove+0x1b6>
  810694:	48 ba f6 1f 82 00 00 	movabs $0x821ff6,%rdx
  81069b:	00 00 00 
  81069e:	be b5 04 00 00       	mov    $0x4b5,%esi
  8106a3:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  8106aa:	00 00 00 
  8106ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8106b2:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8106b9:	00 00 00 
  8106bc:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8106be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8106c2:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8106c9:	48 85 c0             	test   %rax,%rax
  8106cc:	74 2a                	je     8106f8 <tcp_pcb_remove+0x1f0>
  8106ce:	48 ba 0f 20 82 00 00 	movabs $0x82200f,%rdx
  8106d5:	00 00 00 
  8106d8:	be b7 04 00 00       	mov    $0x4b7,%esi
  8106dd:	48 bf fb 1d 82 00 00 	movabs $0x821dfb,%rdi
  8106e4:	00 00 00 
  8106e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8106ec:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8106f3:	00 00 00 
  8106f6:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8106f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8106fc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  810703:	c9                   	leaveq 
  810704:	c3                   	retq   

0000000000810705 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  810705:	55                   	push   %rbp
  810706:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  810709:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  810710:	00 00 00 
  810713:	8b 10                	mov    (%rax),%edx
  810715:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81071c:	00 00 00 
  81071f:	8b 00                	mov    (%rax),%eax
  810721:	01 c2                	add    %eax,%edx
  810723:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  81072a:	00 00 00 
  81072d:	89 10                	mov    %edx,(%rax)
  return iss;
  81072f:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  810736:	00 00 00 
  810739:	8b 00                	mov    (%rax),%eax
}
  81073b:	5d                   	pop    %rbp
  81073c:	c3                   	retq   

000000000081073d <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  81073d:	55                   	push   %rbp
  81073e:	48 89 e5             	mov    %rsp,%rbp
  810741:	48 83 ec 20          	sub    $0x20,%rsp
  810745:	89 f8                	mov    %edi,%eax
  810747:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81074b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  81074f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810753:	48 89 c7             	mov    %rax,%rdi
  810756:	48 b8 40 08 81 00 00 	movabs $0x810840,%rax
  81075d:	00 00 00 
  810760:	ff d0                	callq  *%rax
  810762:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  810766:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81076b:	74 2d                	je     81079a <tcp_eff_send_mss+0x5d>
  81076d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810771:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810775:	66 85 c0             	test   %ax,%ax
  810778:	74 20                	je     81079a <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  81077a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81077e:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810782:	83 e8 28             	sub    $0x28,%eax
  810785:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810789:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  81078d:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810791:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810796:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  81079a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  81079e:	c9                   	leaveq 
  81079f:	c3                   	retq   

00000000008107a0 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8107a0:	55                   	push   %rbp
  8107a1:	48 89 e5             	mov    %rsp,%rbp
  8107a4:	48 83 ec 20          	sub    $0x20,%rsp
  8107a8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8107ac:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  8107b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8107b4:	8b 00                	mov    (%rax),%eax
  8107b6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8107b9:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8107bd:	74 06                	je     8107c5 <ip_addr_isbroadcast+0x25>
  8107bf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8107c3:	75 07                	jne    8107cc <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8107c5:	b8 01 00 00 00       	mov    $0x1,%eax
  8107ca:	eb 6f                	jmp    81083b <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8107cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8107d0:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  8107d4:	0f b6 c0             	movzbl %al,%eax
  8107d7:	83 e0 02             	and    $0x2,%eax
  8107da:	85 c0                	test   %eax,%eax
  8107dc:	75 07                	jne    8107e5 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  8107de:	b8 00 00 00 00       	mov    $0x0,%eax
  8107e3:	eb 56                	jmp    81083b <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8107e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8107e9:	8b 40 08             	mov    0x8(%rax),%eax
  8107ec:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8107ef:	75 07                	jne    8107f8 <ip_addr_isbroadcast+0x58>
    return 0;
  8107f1:	b8 00 00 00 00       	mov    $0x0,%eax
  8107f6:	eb 43                	jmp    81083b <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8107f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8107fc:	8b 10                	mov    (%rax),%edx
  8107fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810802:	8b 40 08             	mov    0x8(%rax),%eax
  810805:	31 c2                	xor    %eax,%edx
  810807:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81080b:	8b 40 0c             	mov    0xc(%rax),%eax
  81080e:	21 d0                	and    %edx,%eax
  810810:	85 c0                	test   %eax,%eax
  810812:	75 22                	jne    810836 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810814:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810818:	8b 40 0c             	mov    0xc(%rax),%eax
  81081b:	f7 d0                	not    %eax
  81081d:	89 c2                	mov    %eax,%edx
  81081f:	23 55 fc             	and    -0x4(%rbp),%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810822:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810826:	8b 40 0c             	mov    0xc(%rax),%eax
  810829:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  81082b:	39 c2                	cmp    %eax,%edx
  81082d:	75 07                	jne    810836 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  81082f:	b8 01 00 00 00       	mov    $0x1,%eax
  810834:	eb 05                	jmp    81083b <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810836:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81083b:	c9                   	leaveq 
  81083c:	c3                   	retq   
  81083d:	00 00                	add    %al,(%rax)
	...

0000000000810840 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810840:	55                   	push   %rbp
  810841:	48 89 e5             	mov    %rsp,%rbp
  810844:	48 83 ec 20          	sub    $0x20,%rsp
  810848:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  81084c:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810853:	00 00 00 
  810856:	48 8b 00             	mov    (%rax),%rax
  810859:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81085d:	eb 44                	jmp    8108a3 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  81085f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810863:	48 89 c7             	mov    %rax,%rdi
  810866:	48 b8 53 ce 80 00 00 	movabs $0x80ce53,%rax
  81086d:	00 00 00 
  810870:	ff d0                	callq  *%rax
  810872:	84 c0                	test   %al,%al
  810874:	74 22                	je     810898 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810876:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81087a:	8b 10                	mov    (%rax),%edx
  81087c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810880:	8b 40 08             	mov    0x8(%rax),%eax
  810883:	31 c2                	xor    %eax,%edx
  810885:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810889:	8b 40 0c             	mov    0xc(%rax),%eax
  81088c:	21 d0                	and    %edx,%eax
  81088e:	85 c0                	test   %eax,%eax
  810890:	75 06                	jne    810898 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810892:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810896:	eb 58                	jmp    8108f0 <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810898:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81089c:	48 8b 00             	mov    (%rax),%rax
  81089f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8108a3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8108a8:	75 b5                	jne    81085f <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8108aa:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  8108b1:	00 00 00 
  8108b4:	48 8b 00             	mov    (%rax),%rax
  8108b7:	48 85 c0             	test   %rax,%rax
  8108ba:	74 20                	je     8108dc <ip_route+0x9c>
  8108bc:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  8108c3:	00 00 00 
  8108c6:	48 8b 00             	mov    (%rax),%rax
  8108c9:	48 89 c7             	mov    %rax,%rdi
  8108cc:	48 b8 53 ce 80 00 00 	movabs $0x80ce53,%rax
  8108d3:	00 00 00 
  8108d6:	ff d0                	callq  *%rax
  8108d8:	84 c0                	test   %al,%al
  8108da:	75 07                	jne    8108e3 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  8108dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8108e1:	eb 0d                	jmp    8108f0 <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8108e3:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  8108ea:	00 00 00 
  8108ed:	48 8b 00             	mov    (%rax),%rax
}
  8108f0:	c9                   	leaveq 
  8108f1:	c3                   	retq   

00000000008108f2 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8108f2:	55                   	push   %rbp
  8108f3:	48 89 e5             	mov    %rsp,%rbp
  8108f6:	53                   	push   %rbx
  8108f7:	48 83 ec 38          	sub    $0x38,%rsp
  8108fb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8108ff:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810903:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  81090a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81090e:	48 8b 40 08          	mov    0x8(%rax),%rax
  810912:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810916:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81091a:	0f b7 00             	movzwl (%rax),%eax
  81091d:	0f b7 c0             	movzwl %ax,%eax
  810920:	89 c7                	mov    %eax,%edi
  810922:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810929:	00 00 00 
  81092c:	ff d0                	callq  *%rax
  81092e:	66 c1 e8 0c          	shr    $0xc,%ax
  810932:	66 83 f8 04          	cmp    $0x4,%ax
  810936:	74 1d                	je     810955 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810938:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81093c:	48 89 c7             	mov    %rax,%rdi
  81093f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  810946:	00 00 00 
  810949:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  81094b:	b8 00 00 00 00       	mov    $0x0,%eax
  810950:	e9 1b 04 00 00       	jmpq   810d70 <ip_input+0x47e>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810955:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810959:	0f b7 00             	movzwl (%rax),%eax
  81095c:	0f b7 c0             	movzwl %ax,%eax
  81095f:	89 c7                	mov    %eax,%edi
  810961:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810968:	00 00 00 
  81096b:	ff d0                	callq  *%rax
  81096d:	66 c1 e8 08          	shr    $0x8,%ax
  810971:	83 e0 0f             	and    $0xf,%eax
  810974:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810978:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  81097d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810981:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810985:	0f b7 c0             	movzwl %ax,%eax
  810988:	89 c7                	mov    %eax,%edi
  81098a:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810991:	00 00 00 
  810994:	ff d0                	callq  *%rax
  810996:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  81099a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81099e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8109a2:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  8109a6:	72 0e                	jb     8109b6 <ip_input+0xc4>
  8109a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8109ac:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8109b0:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  8109b4:	73 1d                	jae    8109d3 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8109b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8109ba:	48 89 c7             	mov    %rax,%rdi
  8109bd:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8109c4:	00 00 00 
  8109c7:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8109c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8109ce:	e9 9d 03 00 00       	jmpq   810d70 <ip_input+0x47e>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8109d3:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  8109d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8109db:	89 d6                	mov    %edx,%esi
  8109dd:	48 89 c7             	mov    %rax,%rdi
  8109e0:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  8109e7:	00 00 00 
  8109ea:	ff d0                	callq  *%rax
  8109ec:	66 85 c0             	test   %ax,%ax
  8109ef:	74 1d                	je     810a0e <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  8109f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8109f5:	48 89 c7             	mov    %rax,%rdi
  8109f8:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8109ff:	00 00 00 
  810a02:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810a04:	b8 00 00 00 00       	mov    $0x0,%eax
  810a09:	e9 62 03 00 00       	jmpq   810d70 <ip_input+0x47e>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  810a0e:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  810a12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810a16:	89 d6                	mov    %edx,%esi
  810a18:	48 89 c7             	mov    %rax,%rdi
  810a1b:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  810a22:	00 00 00 
  810a25:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  810a27:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  810a2e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810a32:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  810a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a3a:	48 89 c7             	mov    %rax,%rdi
  810a3d:	48 b8 53 ce 80 00 00 	movabs $0x80ce53,%rax
  810a44:	00 00 00 
  810a47:	ff d0                	callq  *%rax
  810a49:	84 c0                	test   %al,%al
  810a4b:	74 4c                	je     810a99 <ip_input+0x1a7>
  810a4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a51:	48 83 c0 08          	add    $0x8,%rax
  810a55:	48 85 c0             	test   %rax,%rax
  810a58:	74 3f                	je     810a99 <ip_input+0x1a7>
  810a5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a5e:	8b 40 08             	mov    0x8(%rax),%eax
  810a61:	85 c0                	test   %eax,%eax
  810a63:	74 34                	je     810a99 <ip_input+0x1a7>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810a65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810a69:	8b 50 10             	mov    0x10(%rax),%edx
  810a6c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a70:	8b 40 08             	mov    0x8(%rax),%eax
  810a73:	39 c2                	cmp    %eax,%edx
  810a75:	74 6f                	je     810ae6 <ip_input+0x1f4>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  810a77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810a7b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810a7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a83:	48 89 c6             	mov    %rax,%rsi
  810a86:	48 89 d7             	mov    %rdx,%rdi
  810a89:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  810a90:	00 00 00 
  810a93:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810a95:	84 c0                	test   %al,%al
  810a97:	75 4d                	jne    810ae6 <ip_input+0x1f4>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  810a99:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  810a9d:	74 1a                	je     810ab9 <ip_input+0x1c7>
        first = 0;
  810a9f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  810aa6:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810aad:	00 00 00 
  810ab0:	48 8b 00             	mov    (%rax),%rax
  810ab3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  810ab7:	eb 0b                	jmp    810ac4 <ip_input+0x1d2>
      } else {
        netif = netif->next;
  810ab9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810abd:	48 8b 00             	mov    (%rax),%rax
  810ac0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  810ac4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ac8:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  810acc:	75 0b                	jne    810ad9 <ip_input+0x1e7>
        netif = netif->next;
  810ace:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ad2:	48 8b 00             	mov    (%rax),%rax
  810ad5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  810ad9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810ade:	0f 85 52 ff ff ff    	jne    810a36 <ip_input+0x144>
  810ae4:	eb 01                	jmp    810ae7 <ip_input+0x1f5>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  810ae6:	90                   	nop
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  810ae7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810aec:	75 58                	jne    810b46 <ip_input+0x254>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  810aee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810af2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810af6:	0f b7 c0             	movzwl %ax,%eax
  810af9:	89 c7                	mov    %eax,%edi
  810afb:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810b02:	00 00 00 
  810b05:	ff d0                	callq  *%rax
  810b07:	0f b7 c0             	movzwl %ax,%eax
  810b0a:	25 ff 00 00 00       	and    $0xff,%eax
  810b0f:	83 f8 11             	cmp    $0x11,%eax
  810b12:	75 32                	jne    810b46 <ip_input+0x254>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  810b14:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  810b18:	48 03 45 e8          	add    -0x18(%rbp),%rax
  810b1c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810b20:	0f b7 c0             	movzwl %ax,%eax
  810b23:	89 c7                	mov    %eax,%edi
  810b25:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810b2c:	00 00 00 
  810b2f:	ff d0                	callq  *%rax
  810b31:	66 83 f8 44          	cmp    $0x44,%ax
  810b35:	75 0f                	jne    810b46 <ip_input+0x254>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  810b37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810b3b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  810b3f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  810b46:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  810b4a:	74 6e                	je     810bba <ip_input+0x2c8>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810b4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810b50:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  810b54:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810b58:	48 89 c6             	mov    %rax,%rsi
  810b5b:	48 89 d7             	mov    %rdx,%rdi
  810b5e:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  810b65:	00 00 00 
  810b68:	ff d0                	callq  *%rax
  810b6a:	84 c0                	test   %al,%al
  810b6c:	75 2f                	jne    810b9d <ip_input+0x2ab>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  810b6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810b72:	8b 58 0c             	mov    0xc(%rax),%ebx
  810b75:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810b7a:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  810b81:	00 00 00 
  810b84:	ff d0                	callq  *%rax
  810b86:	21 c3                	and    %eax,%ebx
  810b88:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810b8d:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  810b94:	00 00 00 
  810b97:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810b99:	39 c3                	cmp    %eax,%ebx
  810b9b:	75 1d                	jne    810bba <ip_input+0x2c8>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  810b9d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810ba1:	48 89 c7             	mov    %rax,%rdi
  810ba4:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  810bab:	00 00 00 
  810bae:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  810bb0:	b8 00 00 00 00       	mov    $0x0,%eax
  810bb5:	e9 b6 01 00 00       	jmpq   810d70 <ip_input+0x47e>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  810bba:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810bbf:	75 1d                	jne    810bde <ip_input+0x2ec>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  810bc1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810bc5:	48 89 c7             	mov    %rax,%rdi
  810bc8:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  810bcf:	00 00 00 
  810bd2:	ff d0                	callq  *%rax
    return ERR_OK;
  810bd4:	b8 00 00 00 00       	mov    $0x0,%eax
  810bd9:	e9 92 01 00 00       	jmpq   810d70 <ip_input+0x47e>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  810bde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810be2:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  810be6:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  810beb:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  810bf2:	00 00 00 
  810bf5:	ff d0                	callq  *%rax
  810bf7:	21 d8                	and    %ebx,%eax
  810bf9:	66 85 c0             	test   %ax,%ax
  810bfc:	74 34                	je     810c32 <ip_input+0x340>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  810bfe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c02:	48 89 c7             	mov    %rax,%rdi
  810c05:	48 b8 54 1a 81 00 00 	movabs $0x811a54,%rax
  810c0c:	00 00 00 
  810c0f:	ff d0                	callq  *%rax
  810c11:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  810c15:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810c1a:	75 0a                	jne    810c26 <ip_input+0x334>
      return ERR_OK;
  810c1c:	b8 00 00 00 00       	mov    $0x0,%eax
  810c21:	e9 4a 01 00 00       	jmpq   810d70 <ip_input+0x47e>
    }
    iphdr = p->payload;
  810c26:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c2a:	48 8b 40 08          	mov    0x8(%rax),%rax
  810c2e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  810c32:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810c36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c3a:	48 89 d6             	mov    %rdx,%rsi
  810c3d:	48 89 c7             	mov    %rax,%rdi
  810c40:	48 b8 fc f7 81 00 00 	movabs $0x81f7fc,%rax
  810c47:	00 00 00 
  810c4a:	ff d0                	callq  *%rax
  810c4c:	84 c0                	test   %al,%al
  810c4e:	0f 85 17 01 00 00    	jne    810d6b <ip_input+0x479>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  810c54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c58:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810c5c:	0f b7 c0             	movzwl %ax,%eax
  810c5f:	89 c7                	mov    %eax,%edi
  810c61:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810c68:	00 00 00 
  810c6b:	ff d0                	callq  *%rax
  810c6d:	0f b7 c0             	movzwl %ax,%eax
  810c70:	25 ff 00 00 00       	and    $0xff,%eax
  810c75:	83 f8 06             	cmp    $0x6,%eax
  810c78:	74 2b                	je     810ca5 <ip_input+0x3b3>
  810c7a:	83 f8 11             	cmp    $0x11,%eax
  810c7d:	74 07                	je     810c86 <ip_input+0x394>
  810c7f:	83 f8 01             	cmp    $0x1,%eax
  810c82:	74 40                	je     810cc4 <ip_input+0x3d2>
  810c84:	eb 5d                	jmp    810ce3 <ip_input+0x3f1>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  810c86:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810c8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810c8e:	48 89 d6             	mov    %rdx,%rsi
  810c91:	48 89 c7             	mov    %rax,%rdi
  810c94:	48 b8 3c 48 81 00 00 	movabs $0x81483c,%rax
  810c9b:	00 00 00 
  810c9e:	ff d0                	callq  *%rax
      break;
  810ca0:	e9 c6 00 00 00       	jmpq   810d6b <ip_input+0x479>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  810ca5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810ca9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810cad:	48 89 d6             	mov    %rdx,%rsi
  810cb0:	48 89 c7             	mov    %rax,%rdi
  810cb3:	48 b8 50 be 81 00 00 	movabs $0x81be50,%rax
  810cba:	00 00 00 
  810cbd:	ff d0                	callq  *%rax
      break;
  810cbf:	e9 a7 00 00 00       	jmpq   810d6b <ip_input+0x479>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  810cc4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810cc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810ccc:	48 89 d6             	mov    %rdx,%rsi
  810ccf:	48 89 c7             	mov    %rax,%rdi
  810cd2:	48 b8 b8 fc 81 00 00 	movabs $0x81fcb8,%rax
  810cd9:	00 00 00 
  810cdc:	ff d0                	callq  *%rax
      break;
  810cde:	e9 88 00 00 00       	jmpq   810d6b <ip_input+0x479>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810ce3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ce7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810ceb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810cef:	48 89 c6             	mov    %rax,%rsi
  810cf2:	48 89 d7             	mov    %rdx,%rdi
  810cf5:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  810cfc:	00 00 00 
  810cff:	ff d0                	callq  *%rax
  810d01:	84 c0                	test   %al,%al
  810d03:	75 53                	jne    810d58 <ip_input+0x466>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  810d05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d09:	8b 58 10             	mov    0x10(%rax),%ebx
  810d0c:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810d11:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  810d18:	00 00 00 
  810d1b:	ff d0                	callq  *%rax
  810d1d:	21 c3                	and    %eax,%ebx
  810d1f:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810d24:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  810d2b:	00 00 00 
  810d2e:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810d30:	39 c3                	cmp    %eax,%ebx
  810d32:	74 24                	je     810d58 <ip_input+0x466>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  810d34:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d38:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810d3c:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  810d40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d44:	be 02 00 00 00       	mov    $0x2,%esi
  810d49:	48 89 c7             	mov    %rax,%rdi
  810d4c:	48 b8 e2 01 82 00 00 	movabs $0x8201e2,%rax
  810d53:	00 00 00 
  810d56:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  810d58:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d5c:	48 89 c7             	mov    %rax,%rdi
  810d5f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  810d66:	00 00 00 
  810d69:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  810d6b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810d70:	48 83 c4 38          	add    $0x38,%rsp
  810d74:	5b                   	pop    %rbx
  810d75:	5d                   	pop    %rbp
  810d76:	c3                   	retq   

0000000000810d77 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  810d77:	55                   	push   %rbp
  810d78:	48 89 e5             	mov    %rsp,%rbp
  810d7b:	53                   	push   %rbx
  810d7c:	48 83 ec 48          	sub    $0x48,%rsp
  810d80:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  810d84:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  810d88:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  810d8c:	89 c8                	mov    %ecx,%eax
  810d8e:	44 89 c1             	mov    %r8d,%ecx
  810d91:	44 89 ca             	mov    %r9d,%edx
  810d94:	88 45 c4             	mov    %al,-0x3c(%rbp)
  810d97:	88 4d c0             	mov    %cl,-0x40(%rbp)
  810d9a:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  810d9d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810da2:	0f 84 0e 02 00 00    	je     810fb6 <ip_output_if+0x23f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  810da8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810dac:	be 14 00 00 00       	mov    $0x14,%esi
  810db1:	48 89 c7             	mov    %rax,%rdi
  810db4:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  810dbb:	00 00 00 
  810dbe:	ff d0                	callq  *%rax
  810dc0:	84 c0                	test   %al,%al
  810dc2:	74 0a                	je     810dce <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  810dc4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  810dc9:	e9 58 02 00 00       	jmpq   811026 <ip_output_if+0x2af>
    }

    iphdr = p->payload;
  810dce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810dd2:	48 8b 40 08          	mov    0x8(%rax),%rax
  810dd6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  810dda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810dde:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810de2:	66 83 f8 13          	cmp    $0x13,%ax
  810de6:	77 2a                	ja     810e12 <ip_output_if+0x9b>
  810de8:	48 ba 30 20 82 00 00 	movabs $0x822030,%rdx
  810def:	00 00 00 
  810df2:	be ee 01 00 00       	mov    $0x1ee,%esi
  810df7:	48 bf 5d 20 82 00 00 	movabs $0x82205d,%rdi
  810dfe:	00 00 00 
  810e01:	b8 00 00 00 00       	mov    $0x0,%eax
  810e06:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  810e0d:	00 00 00 
  810e10:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  810e12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e16:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810e1a:	0f b7 c0             	movzwl %ax,%eax
  810e1d:	89 c7                	mov    %eax,%edi
  810e1f:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810e26:	00 00 00 
  810e29:	ff d0                	callq  *%rax
  810e2b:	0f b6 d0             	movzbl %al,%edx
  810e2e:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  810e32:	c1 e0 08             	shl    $0x8,%eax
  810e35:	09 d0                	or     %edx,%eax
  810e37:	0f b7 c0             	movzwl %ax,%eax
  810e3a:	89 c7                	mov    %eax,%edi
  810e3c:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  810e43:	00 00 00 
  810e46:	ff d0                	callq  *%rax
  810e48:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810e4c:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_PROTO_SET(iphdr, proto);
  810e50:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  810e54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e58:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810e5c:	0f b7 c0             	movzwl %ax,%eax
  810e5f:	89 c7                	mov    %eax,%edi
  810e61:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  810e68:	00 00 00 
  810e6b:	ff d0                	callq  *%rax
  810e6d:	66 c1 e8 08          	shr    $0x8,%ax
  810e71:	0f b7 c0             	movzwl %ax,%eax
  810e74:	c1 e0 08             	shl    $0x8,%eax
  810e77:	09 d8                	or     %ebx,%eax
  810e79:	0f b7 c0             	movzwl %ax,%eax
  810e7c:	89 c7                	mov    %eax,%edi
  810e7e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  810e85:	00 00 00 
  810e88:	ff d0                	callq  *%rax
  810e8a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810e8e:	66 89 42 08          	mov    %ax,0x8(%rdx)

    ip_addr_set(&(iphdr->dest), dest);
  810e92:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810e97:	74 08                	je     810ea1 <ip_output_if+0x12a>
  810e99:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e9d:	8b 00                	mov    (%rax),%eax
  810e9f:	eb 05                	jmp    810ea6 <ip_output_if+0x12f>
  810ea1:	b8 00 00 00 00       	mov    $0x0,%eax
  810ea6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810eaa:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  810ead:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  810eb1:	80 cc 45             	or     $0x45,%ah
  810eb4:	0f b7 c0             	movzwl %ax,%eax
  810eb7:	89 c7                	mov    %eax,%edi
  810eb9:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  810ec0:	00 00 00 
  810ec3:	ff d0                	callq  *%rax
  810ec5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810ec9:	66 89 02             	mov    %ax,(%rdx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  810ecc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810ed0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810ed4:	0f b7 c0             	movzwl %ax,%eax
  810ed7:	89 c7                	mov    %eax,%edi
  810ed9:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  810ee0:	00 00 00 
  810ee3:	ff d0                	callq  *%rax
  810ee5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810ee9:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(iphdr, 0);
  810eed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ef1:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  810ef7:	48 b8 54 b0 b4 00 00 	movabs $0xb4b054,%rax
  810efe:	00 00 00 
  810f01:	0f b7 00             	movzwl (%rax),%eax
  810f04:	0f b7 c0             	movzwl %ax,%eax
  810f07:	89 c7                	mov    %eax,%edi
  810f09:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  810f10:	00 00 00 
  810f13:	ff d0                	callq  *%rax
  810f15:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810f19:	66 89 42 04          	mov    %ax,0x4(%rdx)
    ++ip_id;
  810f1d:	48 b8 54 b0 b4 00 00 	movabs $0xb4b054,%rax
  810f24:	00 00 00 
  810f27:	0f b7 00             	movzwl (%rax),%eax
  810f2a:	8d 50 01             	lea    0x1(%rax),%edx
  810f2d:	48 b8 54 b0 b4 00 00 	movabs $0xb4b054,%rax
  810f34:	00 00 00 
  810f37:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  810f3a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  810f3f:	74 0a                	je     810f4b <ip_output_if+0x1d4>
  810f41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  810f45:	8b 00                	mov    (%rax),%eax
  810f47:	85 c0                	test   %eax,%eax
  810f49:	75 24                	jne    810f6f <ip_output_if+0x1f8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  810f4b:	48 8b 45 10          	mov    0x10(%rbp),%rax
  810f4f:	48 83 c0 08          	add    $0x8,%rax
  810f53:	48 85 c0             	test   %rax,%rax
  810f56:	74 09                	je     810f61 <ip_output_if+0x1ea>
  810f58:	48 8b 45 10          	mov    0x10(%rbp),%rax
  810f5c:	8b 40 08             	mov    0x8(%rax),%eax
  810f5f:	eb 05                	jmp    810f66 <ip_output_if+0x1ef>
  810f61:	b8 00 00 00 00       	mov    $0x0,%eax
  810f66:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810f6a:	89 42 0c             	mov    %eax,0xc(%rdx)
  810f6d:	eb 1b                	jmp    810f8a <ip_output_if+0x213>
    } else {
      ip_addr_set(&(iphdr->src), src);
  810f6f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  810f74:	74 08                	je     810f7e <ip_output_if+0x207>
  810f76:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  810f7a:	8b 00                	mov    (%rax),%eax
  810f7c:	eb 05                	jmp    810f83 <ip_output_if+0x20c>
  810f7e:	b8 00 00 00 00       	mov    $0x0,%eax
  810f83:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810f87:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  810f8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f8e:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  810f94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810f98:	be 14 00 00 00       	mov    $0x14,%esi
  810f9d:	48 89 c7             	mov    %rax,%rdi
  810fa0:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  810fa7:	00 00 00 
  810faa:	ff d0                	callq  *%rax
  810fac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810fb0:	66 89 42 0a          	mov    %ax,0xa(%rdx)
  810fb4:	eb 18                	jmp    810fce <ip_output_if+0x257>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  810fb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810fba:	48 8b 40 08          	mov    0x8(%rax),%rax
  810fbe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  810fc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810fc6:	48 83 c0 10          	add    $0x10,%rax
  810fca:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  810fce:	48 8b 45 10          	mov    0x10(%rbp),%rax
  810fd2:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810fd6:	66 85 c0             	test   %ax,%ax
  810fd9:	74 32                	je     81100d <ip_output_if+0x296>
  810fdb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810fdf:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  810fe3:	48 8b 45 10          	mov    0x10(%rbp),%rax
  810fe7:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810feb:	66 39 c2             	cmp    %ax,%dx
  810fee:	76 1d                	jbe    81100d <ip_output_if+0x296>
    return ip_frag(p,netif,dest);
  810ff0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  810ff4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810ff8:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  810ffc:	48 89 c7             	mov    %rax,%rdi
  810fff:	48 b8 a3 1e 81 00 00 	movabs $0x811ea3,%rax
  811006:	00 00 00 
  811009:	ff d0                	callq  *%rax
  81100b:	eb 19                	jmp    811026 <ip_output_if+0x2af>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  81100d:	48 8b 45 10          	mov    0x10(%rbp),%rax
  811011:	48 8b 48 20          	mov    0x20(%rax),%rcx
  811015:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  811019:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81101d:	48 89 c6             	mov    %rax,%rsi
  811020:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  811024:	ff d1                	callq  *%rcx
  }
}
  811026:	48 83 c4 48          	add    $0x48,%rsp
  81102a:	5b                   	pop    %rbx
  81102b:	5d                   	pop    %rbp
  81102c:	c3                   	retq   

000000000081102d <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  81102d:	55                   	push   %rbp
  81102e:	48 89 e5             	mov    %rsp,%rbp
  811031:	48 83 ec 50          	sub    $0x50,%rsp
  811035:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  811039:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81103d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  811041:	89 c8                	mov    %ecx,%eax
  811043:	44 89 c1             	mov    %r8d,%ecx
  811046:	44 89 ca             	mov    %r9d,%edx
  811049:	88 45 d4             	mov    %al,-0x2c(%rbp)
  81104c:	88 4d d0             	mov    %cl,-0x30(%rbp)
  81104f:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  811052:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811056:	48 89 c7             	mov    %rax,%rdi
  811059:	48 b8 40 08 81 00 00 	movabs $0x810840,%rax
  811060:	00 00 00 
  811063:	ff d0                	callq  *%rax
  811065:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811069:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81106e:	75 07                	jne    811077 <ip_output+0x4a>
    return ERR_RTE;
  811070:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  811075:	eb 31                	jmp    8110a8 <ip_output+0x7b>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  811077:	44 0f b6 4d cc       	movzbl -0x34(%rbp),%r9d
  81107c:	44 0f b6 45 d0       	movzbl -0x30(%rbp),%r8d
  811081:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  811085:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811089:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  81108d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811091:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  811095:	48 89 3c 24          	mov    %rdi,(%rsp)
  811099:	48 89 c7             	mov    %rax,%rdi
  81109c:	48 b8 77 0d 81 00 00 	movabs $0x810d77,%rax
  8110a3:	00 00 00 
  8110a6:	ff d0                	callq  *%rax
}
  8110a8:	c9                   	leaveq 
  8110a9:	c3                   	retq   
	...

00000000008110ac <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  8110ac:	55                   	push   %rbp
  8110ad:	48 89 e5             	mov    %rsp,%rbp
  8110b0:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  8110b4:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8110bb:	00 

  r = reassdatagrams;
  8110bc:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8110c3:	00 00 00 
  8110c6:	48 8b 00             	mov    (%rax),%rax
  8110c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  8110cd:	eb 60                	jmp    81112f <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  8110cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8110d3:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8110d7:	84 c0                	test   %al,%al
  8110d9:	74 27                	je     811102 <ip_reass_tmr+0x56>
      r->timer--;
  8110db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8110df:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8110e3:	8d 50 ff             	lea    -0x1(%rax),%edx
  8110e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8110ea:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  8110ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8110f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  8110f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8110f9:	48 8b 00             	mov    (%rax),%rax
  8110fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811100:	eb 2d                	jmp    81112f <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  811102:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811106:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  81110a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81110e:	48 8b 00             	mov    (%rax),%rax
  811111:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  811115:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  811119:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81111d:	48 89 d6             	mov    %rdx,%rsi
  811120:	48 89 c7             	mov    %rax,%rdi
  811123:	48 b8 38 11 81 00 00 	movabs $0x811138,%rax
  81112a:	00 00 00 
  81112d:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  81112f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811134:	75 99                	jne    8110cf <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  811136:	c9                   	leaveq 
  811137:	c3                   	retq   

0000000000811138 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811138:	55                   	push   %rbp
  811139:	48 89 e5             	mov    %rsp,%rbp
  81113c:	48 83 ec 30          	sub    $0x30,%rsp
  811140:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811144:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  811148:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  81114f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811153:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  811157:	75 2a                	jne    811183 <ip_reass_free_complete_datagram+0x4b>
  811159:	48 ba 78 20 82 00 00 	movabs $0x822078,%rdx
  811160:	00 00 00 
  811163:	be 99 00 00 00       	mov    $0x99,%esi
  811168:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  81116f:	00 00 00 
  811172:	b8 00 00 00 00       	mov    $0x0,%eax
  811177:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81117e:	00 00 00 
  811181:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  811183:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811188:	74 37                	je     8111c1 <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  81118a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81118e:	48 8b 00             	mov    (%rax),%rax
  811191:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  811195:	74 2a                	je     8111c1 <ip_reass_free_complete_datagram+0x89>
  811197:	48 ba a1 20 82 00 00 	movabs $0x8220a1,%rdx
  81119e:	00 00 00 
  8111a1:	be 9b 00 00 00       	mov    $0x9b,%esi
  8111a6:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  8111ad:	00 00 00 
  8111b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8111b5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8111bc:	00 00 00 
  8111bf:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8111c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8111c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8111c9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8111cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  8111d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111d5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8111d9:	66 85 c0             	test   %ax,%ax
  8111dc:	0f 85 86 00 00 00    	jne    811268 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  8111e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8111e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8111ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  8111ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111f2:	48 8b 10             	mov    (%rax),%rdx
  8111f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8111f9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  8111fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811201:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811205:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811209:	48 8b 40 08          	mov    0x8(%rax),%rax
  81120d:	ba 14 00 00 00       	mov    $0x14,%edx
  811212:	48 89 ce             	mov    %rcx,%rsi
  811215:	48 89 c7             	mov    %rax,%rdi
  811218:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  81121f:	00 00 00 
  811222:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  811224:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811228:	be 01 00 00 00       	mov    $0x1,%esi
  81122d:	48 89 c7             	mov    %rax,%rdi
  811230:	48 b8 81 03 82 00 00 	movabs $0x820381,%rax
  811237:	00 00 00 
  81123a:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  81123c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811240:	48 89 c7             	mov    %rax,%rdi
  811243:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  81124a:	00 00 00 
  81124d:	ff d0                	callq  *%rax
  81124f:	0f b6 c0             	movzbl %al,%eax
  811252:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  811255:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811259:	48 89 c7             	mov    %rax,%rdi
  81125c:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  811263:	00 00 00 
  811266:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  811268:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81126c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811270:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  811274:	eb 4b                	jmp    8112c1 <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  811276:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81127a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81127e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  811282:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811286:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  81128a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81128e:	48 8b 00             	mov    (%rax),%rax
  811291:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  811295:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811299:	48 89 c7             	mov    %rax,%rdi
  81129c:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  8112a3:	00 00 00 
  8112a6:	ff d0                	callq  *%rax
  8112a8:	0f b6 c0             	movzbl %al,%eax
  8112ab:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  8112ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8112b2:	48 89 c7             	mov    %rax,%rdi
  8112b5:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8112bc:	00 00 00 
  8112bf:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  8112c1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8112c6:	75 ae                	jne    811276 <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  8112c8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8112cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8112d0:	48 89 d6             	mov    %rdx,%rsi
  8112d3:	48 89 c7             	mov    %rax,%rdi
  8112d6:	48 b8 3c 15 81 00 00 	movabs $0x81153c,%rax
  8112dd:	00 00 00 
  8112e0:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  8112e2:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  8112e9:	00 00 00 
  8112ec:	0f b7 00             	movzwl (%rax),%eax
  8112ef:	0f b7 c0             	movzwl %ax,%eax
  8112f2:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8112f5:	7d 2a                	jge    811321 <ip_reass_free_complete_datagram+0x1e9>
  8112f7:	48 ba b3 20 82 00 00 	movabs $0x8220b3,%rdx
  8112fe:	00 00 00 
  811301:	be bc 00 00 00       	mov    $0xbc,%esi
  811306:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  81130d:	00 00 00 
  811310:	b8 00 00 00 00       	mov    $0x0,%eax
  811315:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81131c:	00 00 00 
  81131f:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  811321:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811328:	00 00 00 
  81132b:	0f b7 10             	movzwl (%rax),%edx
  81132e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811331:	66 29 c2             	sub    %ax,%dx
  811334:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  81133b:	00 00 00 
  81133e:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  811341:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  811344:	c9                   	leaveq 
  811345:	c3                   	retq   

0000000000811346 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  811346:	55                   	push   %rbp
  811347:	48 89 e5             	mov    %rsp,%rbp
  81134a:	48 83 ec 40          	sub    $0x40,%rsp
  81134e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  811352:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  811355:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  81135c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811363:	00 
    prev = NULL;
  811364:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81136b:	00 
    other_datagrams = 0;
  81136c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  811373:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81137a:	00 00 00 
  81137d:	48 8b 00             	mov    (%rax),%rax
  811380:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  811384:	e9 89 00 00 00       	jmpq   811412 <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  811389:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81138d:	8b 50 1c             	mov    0x1c(%rax),%edx
  811390:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811394:	8b 40 0c             	mov    0xc(%rax),%eax
  811397:	39 c2                	cmp    %eax,%edx
  811399:	75 27                	jne    8113c2 <ip_reass_remove_oldest_datagram+0x7c>
  81139b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81139f:	8b 50 20             	mov    0x20(%rax),%edx
  8113a2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8113a6:	8b 40 10             	mov    0x10(%rax),%eax
  8113a9:	39 c2                	cmp    %eax,%edx
  8113ab:	75 15                	jne    8113c2 <ip_reass_remove_oldest_datagram+0x7c>
  8113ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8113b1:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  8113b5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8113b9:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8113bd:	66 39 c2             	cmp    %ax,%dx
  8113c0:	74 31                	je     8113f3 <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  8113c2:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  8113c6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8113cb:	75 0a                	jne    8113d7 <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  8113cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8113d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8113d5:	eb 1c                	jmp    8113f3 <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  8113d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8113db:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  8113df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8113e3:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8113e7:	38 c2                	cmp    %al,%dl
  8113e9:	77 08                	ja     8113f3 <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  8113eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8113ef:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  8113f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8113f7:	48 8b 00             	mov    (%rax),%rax
  8113fa:	48 85 c0             	test   %rax,%rax
  8113fd:	74 08                	je     811407 <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  8113ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811403:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  811407:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81140b:	48 8b 00             	mov    (%rax),%rax
  81140e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  811412:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811417:	0f 85 6c ff ff ff    	jne    811389 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  81141d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811422:	74 23                	je     811447 <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  811424:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811428:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81142c:	48 89 d6             	mov    %rdx,%rsi
  81142f:	48 89 c7             	mov    %rax,%rdi
  811432:	48 b8 38 11 81 00 00 	movabs $0x811138,%rax
  811439:	00 00 00 
  81143c:	ff d0                	callq  *%rax
  81143e:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  811441:	8b 45 dc             	mov    -0x24(%rbp),%eax
  811444:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  811447:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81144a:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81144d:	7d 0a                	jge    811459 <ip_reass_remove_oldest_datagram+0x113>
  81144f:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  811453:	0f 8f 03 ff ff ff    	jg     81135c <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  811459:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  81145c:	c9                   	leaveq 
  81145d:	c3                   	retq   

000000000081145e <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  81145e:	55                   	push   %rbp
  81145f:	48 89 e5             	mov    %rsp,%rbp
  811462:	48 83 ec 20          	sub    $0x20,%rsp
  811466:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81146a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  81146d:	bf 05 00 00 00       	mov    $0x5,%edi
  811472:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  811479:	00 00 00 
  81147c:	ff d0                	callq  *%rax
  81147e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  811482:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811487:	75 40                	jne    8114c9 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  811489:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  81148c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811490:	89 d6                	mov    %edx,%esi
  811492:	48 89 c7             	mov    %rax,%rdi
  811495:	48 b8 46 13 81 00 00 	movabs $0x811346,%rax
  81149c:	00 00 00 
  81149f:	ff d0                	callq  *%rax
  8114a1:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8114a4:	7c 15                	jl     8114bb <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  8114a6:	bf 05 00 00 00       	mov    $0x5,%edi
  8114ab:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  8114b2:	00 00 00 
  8114b5:	ff d0                	callq  *%rax
  8114b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  8114bb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8114c0:	75 07                	jne    8114c9 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  8114c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8114c7:	eb 71                	jmp    81153a <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  8114c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8114cd:	ba 28 00 00 00       	mov    $0x28,%edx
  8114d2:	be 00 00 00 00       	mov    $0x0,%esi
  8114d7:	48 89 c7             	mov    %rax,%rdi
  8114da:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  8114e1:	00 00 00 
  8114e4:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  8114e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8114ea:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  8114ee:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  8114f5:	00 00 00 
  8114f8:	48 8b 10             	mov    (%rax),%rdx
  8114fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8114ff:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  811502:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811509:	00 00 00 
  81150c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  811510:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  811513:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811517:	48 8d 48 10          	lea    0x10(%rax),%rcx
  81151b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81151f:	ba 14 00 00 00       	mov    $0x14,%edx
  811524:	48 89 c6             	mov    %rax,%rsi
  811527:	48 89 cf             	mov    %rcx,%rdi
  81152a:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  811531:	00 00 00 
  811534:	ff d0                	callq  *%rax
  return ipr;
  811536:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81153a:	c9                   	leaveq 
  81153b:	c3                   	retq   

000000000081153c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  81153c:	55                   	push   %rbp
  81153d:	48 89 e5             	mov    %rsp,%rbp
  811540:	48 83 ec 10          	sub    $0x10,%rsp
  811544:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  811548:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  81154c:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811553:	00 00 00 
  811556:	48 8b 00             	mov    (%rax),%rax
  811559:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81155d:	75 16                	jne    811575 <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  81155f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811563:	48 8b 10             	mov    (%rax),%rdx
  811566:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  81156d:	00 00 00 
  811570:	48 89 10             	mov    %rdx,(%rax)
  811573:	eb 3f                	jmp    8115b4 <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  811575:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81157a:	75 2a                	jne    8115a6 <ip_reass_dequeue_datagram+0x6a>
  81157c:	48 ba ce 20 82 00 00 	movabs $0x8220ce,%rdx
  811583:	00 00 00 
  811586:	be 29 01 00 00       	mov    $0x129,%esi
  81158b:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  811592:	00 00 00 
  811595:	b8 00 00 00 00       	mov    $0x0,%eax
  81159a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8115a1:	00 00 00 
  8115a4:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  8115a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115aa:	48 8b 10             	mov    (%rax),%rdx
  8115ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8115b1:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  8115b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115b8:	48 89 c6             	mov    %rax,%rsi
  8115bb:	bf 05 00 00 00       	mov    $0x5,%edi
  8115c0:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  8115c7:	00 00 00 
  8115ca:	ff d0                	callq  *%rax
}
  8115cc:	c9                   	leaveq 
  8115cd:	c3                   	retq   

00000000008115ce <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  8115ce:	55                   	push   %rbp
  8115cf:	48 89 e5             	mov    %rsp,%rbp
  8115d2:	53                   	push   %rbx
  8115d3:	48 83 ec 58          	sub    $0x58,%rsp
  8115d7:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8115db:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  8115df:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8115e6:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  8115e7:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  8115ee:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8115f2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8115f6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8115fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8115fe:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811602:	0f b7 c0             	movzwl %ax,%eax
  811605:	89 c7                	mov    %eax,%edi
  811607:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81160e:	00 00 00 
  811611:	ff d0                	callq  *%rax
  811613:	89 c3                	mov    %eax,%ebx
  811615:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811619:	0f b7 00             	movzwl (%rax),%eax
  81161c:	0f b7 c0             	movzwl %ax,%eax
  81161f:	89 c7                	mov    %eax,%edi
  811621:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811628:	00 00 00 
  81162b:	ff d0                	callq  *%rax
  81162d:	66 c1 e8 08          	shr    $0x8,%ax
  811631:	89 c2                	mov    %eax,%edx
  811633:	83 e2 0f             	and    $0xf,%edx
  811636:	b8 00 00 00 00       	mov    $0x0,%eax
  81163b:	66 29 d0             	sub    %dx,%ax
  81163e:	c1 e0 02             	shl    $0x2,%eax
  811641:	01 d8                	add    %ebx,%eax
  811643:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811647:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81164b:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81164f:	0f b7 c0             	movzwl %ax,%eax
  811652:	89 c7                	mov    %eax,%edi
  811654:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81165b:	00 00 00 
  81165e:	ff d0                	callq  *%rax
  811660:	66 25 ff 1f          	and    $0x1fff,%ax
  811664:	c1 e0 03             	shl    $0x3,%eax
  811667:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  81166b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81166f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811673:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  811677:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81167b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811682:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811686:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  81168a:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  81168e:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  811692:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811696:	01 c2                	add    %eax,%edx
  811698:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81169c:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8116a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8116a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8116a8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8116ac:	e9 eb 00 00 00       	jmpq   81179c <ip_reass_chain_frag_into_datagram_and_validate+0x1ce>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  8116b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8116b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8116b9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  8116bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116c1:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8116c5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8116c9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8116cd:	66 39 c2             	cmp    %ax,%dx
  8116d0:	73 62                	jae    811734 <ip_reass_chain_frag_into_datagram_and_validate+0x166>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  8116d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116d6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8116da:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  8116dd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8116e2:	74 42                	je     811726 <ip_reass_chain_frag_into_datagram_and_validate+0x158>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  8116e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116e8:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8116ec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8116f0:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  8116f4:	66 39 c2             	cmp    %ax,%dx
  8116f7:	0f 82 03 03 00 00    	jb     811a00 <ip_reass_chain_frag_into_datagram_and_validate+0x432>
  8116fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811701:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811705:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811709:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81170d:	66 39 c2             	cmp    %ax,%dx
  811710:	0f 87 ea 02 00 00    	ja     811a00 <ip_reass_chain_frag_into_datagram_and_validate+0x432>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  811716:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81171a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  81171e:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811721:	e9 81 00 00 00       	jmpq   8117a7 <ip_reass_chain_frag_into_datagram_and_validate+0x1d9>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  811726:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81172a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  81172e:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811732:	eb 73                	jmp    8117a7 <ip_reass_chain_frag_into_datagram_and_validate+0x1d9>
    } else if(iprh->start == iprh_tmp->start) {
  811734:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811738:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  81173c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811740:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811744:	66 39 c2             	cmp    %ax,%dx
  811747:	0f 84 af 02 00 00    	je     8119fc <ip_reass_chain_frag_into_datagram_and_validate+0x42e>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  81174d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811751:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811755:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811759:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  81175d:	66 39 c2             	cmp    %ax,%dx
  811760:	0f 82 99 02 00 00    	jb     8119ff <ip_reass_chain_frag_into_datagram_and_validate+0x431>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  811766:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81176b:	74 1c                	je     811789 <ip_reass_chain_frag_into_datagram_and_validate+0x1bb>
        if (iprh_prev->end != iprh_tmp->start) {
  81176d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811771:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811775:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811779:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81177d:	66 39 c2             	cmp    %ax,%dx
  811780:	74 07                	je     811789 <ip_reass_chain_frag_into_datagram_and_validate+0x1bb>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811782:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  811789:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81178d:	48 8b 00             	mov    (%rax),%rax
  811790:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  811794:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811798:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  81179c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8117a1:	0f 85 0a ff ff ff    	jne    8116b1 <ip_reass_chain_frag_into_datagram_and_validate+0xe3>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  8117a7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8117ac:	0f 85 b2 00 00 00    	jne    811864 <ip_reass_chain_frag_into_datagram_and_validate+0x296>
    if (iprh_prev != NULL) {
  8117b2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8117b7:	74 68                	je     811821 <ip_reass_chain_frag_into_datagram_and_validate+0x253>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8117b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8117bd:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8117c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8117c5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8117c9:	66 39 c2             	cmp    %ax,%dx
  8117cc:	76 2a                	jbe    8117f8 <ip_reass_chain_frag_into_datagram_and_validate+0x22a>
  8117ce:	48 ba e7 20 82 00 00 	movabs $0x8220e7,%rdx
  8117d5:	00 00 00 
  8117d8:	be 83 01 00 00       	mov    $0x183,%esi
  8117dd:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  8117e4:	00 00 00 
  8117e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8117ec:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8117f3:	00 00 00 
  8117f6:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  8117f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8117fc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811800:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  811803:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811807:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  81180b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81180f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811813:	66 39 c2             	cmp    %ax,%dx
  811816:	74 4c                	je     811864 <ip_reass_chain_frag_into_datagram_and_validate+0x296>
        valid = 0;
  811818:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  81181f:	eb 43                	jmp    811864 <ip_reass_chain_frag_into_datagram_and_validate+0x296>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811821:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811825:	48 8b 40 08          	mov    0x8(%rax),%rax
  811829:	48 85 c0             	test   %rax,%rax
  81182c:	74 2a                	je     811858 <ip_reass_chain_frag_into_datagram_and_validate+0x28a>
  81182e:	48 ba 08 21 82 00 00 	movabs $0x822108,%rdx
  811835:	00 00 00 
  811838:	be 8c 01 00 00       	mov    $0x18c,%esi
  81183d:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  811844:	00 00 00 
  811847:	b8 00 00 00 00       	mov    $0x0,%eax
  81184c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  811853:	00 00 00 
  811856:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811858:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81185c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811860:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811864:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811868:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  81186c:	0f b6 c0             	movzbl %al,%eax
  81186f:	83 e0 01             	and    $0x1,%eax
  811872:	84 c0                	test   %al,%al
  811874:	0f 84 7b 01 00 00    	je     8119f5 <ip_reass_chain_frag_into_datagram_and_validate+0x427>
    /* and had no wholes so far */
    if (valid) {
  81187a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  81187e:	0f 84 6c 01 00 00    	je     8119f0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811884:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811888:	48 8b 40 08          	mov    0x8(%rax),%rax
  81188c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811890:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811894:	66 85 c0             	test   %ax,%ax
  811897:	74 0c                	je     8118a5 <ip_reass_chain_frag_into_datagram_and_validate+0x2d7>
        valid = 0;
  811899:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8118a0:	e9 4b 01 00 00       	jmpq   8119f0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  8118a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118a9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  8118ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118b1:	48 8b 00             	mov    (%rax),%rax
  8118b4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  8118b8:	eb 3d                	jmp    8118f7 <ip_reass_chain_frag_into_datagram_and_validate+0x329>
          iprh = (struct ip_reass_helper*)q->payload;
  8118ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8118be:	48 8b 40 08          	mov    0x8(%rax),%rax
  8118c2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  8118c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8118ca:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8118ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118d2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8118d6:	66 39 c2             	cmp    %ax,%dx
  8118d9:	74 09                	je     8118e4 <ip_reass_chain_frag_into_datagram_and_validate+0x316>
            valid = 0;
  8118db:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  8118e2:	eb 1a                	jmp    8118fe <ip_reass_chain_frag_into_datagram_and_validate+0x330>
          }
          iprh_prev = iprh;
  8118e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118e8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  8118ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118f0:	48 8b 00             	mov    (%rax),%rax
  8118f3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  8118f7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8118fc:	75 bc                	jne    8118ba <ip_reass_chain_frag_into_datagram_and_validate+0x2ec>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  8118fe:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811902:	0f 84 e8 00 00 00    	je     8119f0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811908:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81190c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811910:	48 85 c0             	test   %rax,%rax
  811913:	75 2a                	jne    81193f <ip_reass_chain_frag_into_datagram_and_validate+0x371>
  811915:	48 ba 3f 21 82 00 00 	movabs $0x82213f,%rdx
  81191c:	00 00 00 
  81191f:	be ac 01 00 00       	mov    $0x1ac,%esi
  811924:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  81192b:	00 00 00 
  81192e:	b8 00 00 00 00       	mov    $0x0,%eax
  811933:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81193a:	00 00 00 
  81193d:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  81193f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811943:	48 8b 40 08          	mov    0x8(%rax),%rax
  811947:	48 8b 40 08          	mov    0x8(%rax),%rax
  81194b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81194f:	75 2a                	jne    81197b <ip_reass_chain_frag_into_datagram_and_validate+0x3ad>
  811951:	48 ba 3f 21 82 00 00 	movabs $0x82213f,%rdx
  811958:	00 00 00 
  81195b:	be ae 01 00 00       	mov    $0x1ae,%esi
  811960:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  811967:	00 00 00 
  81196a:	b8 00 00 00 00       	mov    $0x0,%eax
  81196f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  811976:	00 00 00 
  811979:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  81197b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81197f:	48 8b 00             	mov    (%rax),%rax
  811982:	48 85 c0             	test   %rax,%rax
  811985:	74 2a                	je     8119b1 <ip_reass_chain_frag_into_datagram_and_validate+0x3e3>
  811987:	48 ba 50 21 82 00 00 	movabs $0x822150,%rdx
  81198e:	00 00 00 
  811991:	be b0 01 00 00       	mov    $0x1b0,%esi
  811996:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  81199d:	00 00 00 
  8119a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8119a5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8119ac:	00 00 00 
  8119af:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8119b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8119b5:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8119b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8119bd:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  8119c1:	66 39 c2             	cmp    %ax,%dx
  8119c4:	74 2a                	je     8119f0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
  8119c6:	48 ba 78 21 82 00 00 	movabs $0x822178,%rdx
  8119cd:	00 00 00 
  8119d0:	be b2 01 00 00       	mov    $0x1b2,%esi
  8119d5:	48 bf 84 20 82 00 00 	movabs $0x822084,%rdi
  8119dc:	00 00 00 
  8119df:	b8 00 00 00 00       	mov    $0x0,%eax
  8119e4:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8119eb:	00 00 00 
  8119ee:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  8119f0:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8119f3:	eb 58                	jmp    811a4d <ip_reass_chain_frag_into_datagram_and_validate+0x47f>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  8119f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8119fa:	eb 51                	jmp    811a4d <ip_reass_chain_frag_into_datagram_and_validate+0x47f>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  8119fc:	90                   	nop
  8119fd:	eb 01                	jmp    811a00 <ip_reass_chain_frag_into_datagram_and_validate+0x432>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  8119ff:	90                   	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  811a00:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811a07:	00 00 00 
  811a0a:	0f b7 18             	movzwl (%rax),%ebx
  811a0d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811a11:	48 89 c7             	mov    %rax,%rdi
  811a14:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  811a1b:	00 00 00 
  811a1e:	ff d0                	callq  *%rax
  811a20:	0f b6 c0             	movzbl %al,%eax
  811a23:	89 da                	mov    %ebx,%edx
  811a25:	66 29 c2             	sub    %ax,%dx
  811a28:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811a2f:	00 00 00 
  811a32:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  811a35:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811a39:	48 89 c7             	mov    %rax,%rdi
  811a3c:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  811a43:	00 00 00 
  811a46:	ff d0                	callq  *%rax
  return 0;
  811a48:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  811a4d:	48 83 c4 58          	add    $0x58,%rsp
  811a51:	5b                   	pop    %rbx
  811a52:	5d                   	pop    %rbp
  811a53:	c3                   	retq   

0000000000811a54 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  811a54:	55                   	push   %rbp
  811a55:	48 89 e5             	mov    %rsp,%rbp
  811a58:	53                   	push   %rbx
  811a59:	48 83 ec 48          	sub    $0x48,%rsp
  811a5d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  811a61:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  811a68:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  811a69:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811a6d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811a71:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  811a75:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811a79:	0f b7 00             	movzwl (%rax),%eax
  811a7c:	0f b7 c0             	movzwl %ax,%eax
  811a7f:	89 c7                	mov    %eax,%edi
  811a81:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811a88:	00 00 00 
  811a8b:	ff d0                	callq  *%rax
  811a8d:	66 c1 e8 08          	shr    $0x8,%ax
  811a91:	0f b7 c0             	movzwl %ax,%eax
  811a94:	83 e0 0f             	and    $0xf,%eax
  811a97:	c1 e0 02             	shl    $0x2,%eax
  811a9a:	83 f8 14             	cmp    $0x14,%eax
  811a9d:	0f 85 dd 03 00 00    	jne    811e80 <ip_reass+0x42c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811aa3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811aa7:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811aab:	0f b7 c0             	movzwl %ax,%eax
  811aae:	89 c7                	mov    %eax,%edi
  811ab0:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811ab7:	00 00 00 
  811aba:	ff d0                	callq  *%rax
  811abc:	66 25 ff 1f          	and    $0x1fff,%ax
  811ac0:	c1 e0 03             	shl    $0x3,%eax
  811ac3:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811ac7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811acb:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811acf:	0f b7 c0             	movzwl %ax,%eax
  811ad2:	89 c7                	mov    %eax,%edi
  811ad4:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811adb:	00 00 00 
  811ade:	ff d0                	callq  *%rax
  811ae0:	89 c3                	mov    %eax,%ebx
  811ae2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811ae6:	0f b7 00             	movzwl (%rax),%eax
  811ae9:	0f b7 c0             	movzwl %ax,%eax
  811aec:	89 c7                	mov    %eax,%edi
  811aee:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811af5:	00 00 00 
  811af8:	ff d0                	callq  *%rax
  811afa:	66 c1 e8 08          	shr    $0x8,%ax
  811afe:	89 c2                	mov    %eax,%edx
  811b00:	83 e2 0f             	and    $0xf,%edx
  811b03:	b8 00 00 00 00       	mov    $0x0,%eax
  811b08:	66 29 d0             	sub    %dx,%ax
  811b0b:	c1 e0 02             	shl    $0x2,%eax
  811b0e:	01 d8                	add    %ebx,%eax
  811b10:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  811b14:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811b18:	48 89 c7             	mov    %rax,%rdi
  811b1b:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  811b22:	00 00 00 
  811b25:	ff d0                	callq  *%rax
  811b27:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  811b2a:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811b31:	00 00 00 
  811b34:	0f b7 00             	movzwl (%rax),%eax
  811b37:	0f b7 d0             	movzwl %ax,%edx
  811b3a:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811b3e:	01 d0                	add    %edx,%eax
  811b40:	83 f8 0a             	cmp    $0xa,%eax
  811b43:	7e 40                	jle    811b85 <ip_reass+0x131>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811b45:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811b49:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811b4d:	89 d6                	mov    %edx,%esi
  811b4f:	48 89 c7             	mov    %rax,%rdi
  811b52:	48 b8 46 13 81 00 00 	movabs $0x811346,%rax
  811b59:	00 00 00 
  811b5c:	ff d0                	callq  *%rax
  811b5e:	85 c0                	test   %eax,%eax
  811b60:	0f 84 1d 03 00 00    	je     811e83 <ip_reass+0x42f>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  811b66:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811b6d:	00 00 00 
  811b70:	0f b7 00             	movzwl (%rax),%eax
  811b73:	0f b7 d0             	movzwl %ax,%edx
  811b76:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811b7a:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811b7c:	83 f8 0a             	cmp    $0xa,%eax
  811b7f:	0f 8f fe 02 00 00    	jg     811e83 <ip_reass+0x42f>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811b85:	48 b8 60 b0 b4 00 00 	movabs $0xb4b060,%rax
  811b8c:	00 00 00 
  811b8f:	48 8b 00             	mov    (%rax),%rax
  811b92:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811b96:	eb 4c                	jmp    811be4 <ip_reass+0x190>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  811b98:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811b9c:	8b 50 1c             	mov    0x1c(%rax),%edx
  811b9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811ba3:	8b 40 0c             	mov    0xc(%rax),%eax
  811ba6:	39 c2                	cmp    %eax,%edx
  811ba8:	75 27                	jne    811bd1 <ip_reass+0x17d>
  811baa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811bae:	8b 50 20             	mov    0x20(%rax),%edx
  811bb1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811bb5:	8b 40 10             	mov    0x10(%rax),%eax
  811bb8:	39 c2                	cmp    %eax,%edx
  811bba:	75 15                	jne    811bd1 <ip_reass+0x17d>
  811bbc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811bc0:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811bc4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811bc8:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811bcc:	66 39 c2             	cmp    %ax,%dx
  811bcf:	74 1c                	je     811bed <ip_reass+0x199>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
  811bd1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811bd5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811bd9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811bdd:	48 8b 00             	mov    (%rax),%rax
  811be0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811be4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811be9:	75 ad                	jne    811b98 <ip_reass+0x144>
  811beb:	eb 01                	jmp    811bee <ip_reass+0x19a>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  811bed:	90                   	nop
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  811bee:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811bf3:	75 29                	jne    811c1e <ip_reass+0x1ca>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  811bf5:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811bf9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811bfd:	89 d6                	mov    %edx,%esi
  811bff:	48 89 c7             	mov    %rax,%rdi
  811c02:	48 b8 5e 14 81 00 00 	movabs $0x81145e,%rax
  811c09:	00 00 00 
  811c0c:	ff d0                	callq  *%rax
  811c0e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  811c12:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811c17:	75 72                	jne    811c8b <ip_reass+0x237>
      goto nullreturn;
  811c19:	e9 66 02 00 00       	jmpq   811e84 <ip_reass+0x430>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811c1e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811c22:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811c26:	0f b7 c0             	movzwl %ax,%eax
  811c29:	89 c7                	mov    %eax,%edi
  811c2b:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811c32:	00 00 00 
  811c35:	ff d0                	callq  *%rax
  811c37:	0f b7 c0             	movzwl %ax,%eax
  811c3a:	25 ff 1f 00 00       	and    $0x1fff,%eax
  811c3f:	85 c0                	test   %eax,%eax
  811c41:	75 48                	jne    811c8b <ip_reass+0x237>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  811c43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811c47:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  811c4b:	0f b7 c0             	movzwl %ax,%eax
  811c4e:	89 c7                	mov    %eax,%edi
  811c50:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811c57:	00 00 00 
  811c5a:	ff d0                	callq  *%rax
  811c5c:	0f b7 c0             	movzwl %ax,%eax
  811c5f:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811c64:	85 c0                	test   %eax,%eax
  811c66:	74 23                	je     811c8b <ip_reass+0x237>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  811c68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811c6c:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811c70:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811c74:	ba 14 00 00 00       	mov    $0x14,%edx
  811c79:	48 89 c6             	mov    %rax,%rsi
  811c7c:	48 89 cf             	mov    %rcx,%rdi
  811c7f:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  811c86:	00 00 00 
  811c89:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  811c8b:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811c8f:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811c96:	00 00 00 
  811c99:	0f b7 00             	movzwl (%rax),%eax
  811c9c:	01 c2                	add    %eax,%edx
  811c9e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811ca5:	00 00 00 
  811ca8:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  811cab:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811caf:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811cb3:	0f b7 c0             	movzwl %ax,%eax
  811cb6:	89 c7                	mov    %eax,%edi
  811cb8:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811cbf:	00 00 00 
  811cc2:	ff d0                	callq  *%rax
  811cc4:	0f b7 c0             	movzwl %ax,%eax
  811cc7:	25 00 20 00 00       	and    $0x2000,%eax
  811ccc:	85 c0                	test   %eax,%eax
  811cce:	75 26                	jne    811cf6 <ip_reass+0x2a2>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  811cd0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811cd4:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811cd8:	89 c2                	mov    %eax,%edx
  811cda:	83 ca 01             	or     $0x1,%edx
  811cdd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ce1:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  811ce4:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  811ce8:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  811cec:	01 c2                	add    %eax,%edx
  811cee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811cf2:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  811cf6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  811cfa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811cfe:	48 89 d6             	mov    %rdx,%rsi
  811d01:	48 89 c7             	mov    %rax,%rdi
  811d04:	48 b8 ce 15 81 00 00 	movabs $0x8115ce,%rax
  811d0b:	00 00 00 
  811d0e:	ff d0                	callq  *%rax
  811d10:	85 c0                	test   %eax,%eax
  811d12:	0f 84 61 01 00 00    	je     811e79 <ip_reass+0x425>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  811d18:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d1c:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811d20:	8d 50 14             	lea    0x14(%rax),%edx
  811d23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d27:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  811d2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d2f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d33:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d37:	48 8b 00             	mov    (%rax),%rax
  811d3a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  811d3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d42:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d46:	48 8b 40 08          	mov    0x8(%rax),%rax
  811d4a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  811d4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d52:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811d56:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d5a:	ba 14 00 00 00       	mov    $0x14,%edx
  811d5f:	48 89 ce             	mov    %rcx,%rsi
  811d62:	48 89 c7             	mov    %rax,%rdi
  811d65:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  811d6c:	00 00 00 
  811d6f:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  811d71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d75:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811d79:	0f b7 c0             	movzwl %ax,%eax
  811d7c:	89 c7                	mov    %eax,%edi
  811d7e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  811d85:	00 00 00 
  811d88:	ff d0                	callq  *%rax
  811d8a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811d8e:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(fraghdr, 0);
  811d92:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d96:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  811d9c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811da0:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  811da6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811daa:	be 14 00 00 00       	mov    $0x14,%esi
  811daf:	48 89 c7             	mov    %rax,%rdi
  811db2:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  811db9:	00 00 00 
  811dbc:	ff d0                	callq  *%rax
  811dbe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811dc2:	66 89 42 0a          	mov    %ax,0xa(%rdx)

    p = ipr->p;
  811dc6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811dca:	48 8b 40 08          	mov    0x8(%rax),%rax
  811dce:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  811dd2:	eb 49                	jmp    811e1d <ip_reass+0x3c9>
      iprh = (struct ip_reass_helper*)r->payload;
  811dd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811dd8:	48 8b 40 08          	mov    0x8(%rax),%rax
  811ddc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  811de0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811de4:	be ec ff ff ff       	mov    $0xffffffec,%esi
  811de9:	48 89 c7             	mov    %rax,%rdi
  811dec:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  811df3:	00 00 00 
  811df6:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  811df8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811dfc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811e00:	48 89 d6             	mov    %rdx,%rsi
  811e03:	48 89 c7             	mov    %rax,%rdi
  811e06:	48 b8 57 d9 80 00 00 	movabs $0x80d957,%rax
  811e0d:	00 00 00 
  811e10:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  811e12:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811e16:	48 8b 00             	mov    (%rax),%rax
  811e19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  811e1d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  811e22:	75 b0                	jne    811dd4 <ip_reass+0x380>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  811e24:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811e28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e2c:	48 89 d6             	mov    %rdx,%rsi
  811e2f:	48 89 c7             	mov    %rax,%rdi
  811e32:	48 b8 3c 15 81 00 00 	movabs $0x81153c,%rax
  811e39:	00 00 00 
  811e3c:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  811e3e:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811e45:	00 00 00 
  811e48:	0f b7 18             	movzwl (%rax),%ebx
  811e4b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811e4f:	48 89 c7             	mov    %rax,%rdi
  811e52:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  811e59:	00 00 00 
  811e5c:	ff d0                	callq  *%rax
  811e5e:	0f b6 c0             	movzbl %al,%eax
  811e61:	89 da                	mov    %ebx,%edx
  811e63:	66 29 c2             	sub    %ax,%dx
  811e66:	48 b8 68 b0 b4 00 00 	movabs $0xb4b068,%rax
  811e6d:	00 00 00 
  811e70:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  811e73:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811e77:	eb 23                	jmp    811e9c <ip_reass+0x448>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  811e79:	b8 00 00 00 00       	mov    $0x0,%eax
  811e7e:	eb 1c                	jmp    811e9c <ip_reass+0x448>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  811e80:	90                   	nop
  811e81:	eb 01                	jmp    811e84 <ip_reass+0x430>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  811e83:	90                   	nop
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  811e84:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811e88:	48 89 c7             	mov    %rax,%rdi
  811e8b:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  811e92:	00 00 00 
  811e95:	ff d0                	callq  *%rax
  return NULL;
  811e97:	b8 00 00 00 00       	mov    $0x0,%eax
}
  811e9c:	48 83 c4 48          	add    $0x48,%rsp
  811ea0:	5b                   	pop    %rbx
  811ea1:	5d                   	pop    %rbp
  811ea2:	c3                   	retq   

0000000000811ea3 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  811ea3:	55                   	push   %rbp
  811ea4:	48 89 e5             	mov    %rsp,%rbp
  811ea7:	48 83 ec 50          	sub    $0x50,%rsp
  811eab:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  811eaf:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  811eb3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  811eb7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811ebb:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  811ebf:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  811ec3:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  811ec9:	ba 02 00 00 00       	mov    $0x2,%edx
  811ece:	be 00 00 00 00       	mov    $0x0,%esi
  811ed3:	bf 02 00 00 00       	mov    $0x2,%edi
  811ed8:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  811edf:	00 00 00 
  811ee2:	ff d0                	callq  *%rax
  811ee4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  811ee8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  811eed:	75 0a                	jne    811ef9 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  811eef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  811ef4:	e9 83 02 00 00       	jmpq   81217c <ip_frag+0x2d9>
  }
  rambuf->tot_len = rambuf->len = mtu;
  811ef9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811efd:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  811f01:	66 89 50 12          	mov    %dx,0x12(%rax)
  811f05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f09:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  811f0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f11:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  811f15:	48 b8 80 b0 b4 00 00 	movabs $0xb4b080,%rax
  811f1c:	00 00 00 
  811f1f:	48 83 c0 03          	add    $0x3,%rax
  811f23:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  811f27:	48 89 c2             	mov    %rax,%rdx
  811f2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f2e:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  811f32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811f36:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f3a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  811f3e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811f42:	48 8b 48 08          	mov    0x8(%rax),%rcx
  811f46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f4a:	ba 14 00 00 00       	mov    $0x14,%edx
  811f4f:	48 89 ce             	mov    %rcx,%rsi
  811f52:	48 89 c7             	mov    %rax,%rdi
  811f55:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  811f5c:	00 00 00 
  811f5f:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  811f61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f65:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811f69:	0f b7 c0             	movzwl %ax,%eax
  811f6c:	89 c7                	mov    %eax,%edi
  811f6e:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  811f75:	00 00 00 
  811f78:	ff d0                	callq  *%rax
  811f7a:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  811f7e:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  811f82:	66 25 ff 1f          	and    $0x1fff,%ax
  811f86:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  811f8a:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  811f8e:	66 25 00 20          	and    $0x2000,%ax
  811f92:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  811f96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811f9a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  811f9e:	83 e8 14             	sub    $0x14,%eax
  811fa1:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  811fa5:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  811fa9:	83 e8 14             	sub    $0x14,%eax
  811fac:	8d 50 07             	lea    0x7(%rax),%edx
  811faf:	85 c0                	test   %eax,%eax
  811fb1:	0f 48 c2             	cmovs  %edx,%eax
  811fb4:	c1 f8 03             	sar    $0x3,%eax
  811fb7:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  811fbb:	e9 99 01 00 00       	jmpq   812159 <ip_frag+0x2b6>
    last = (left <= mtu - IP_HLEN);
  811fc0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  811fc4:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  811fc8:	83 ea 14             	sub    $0x14,%edx
  811fcb:	39 d0                	cmp    %edx,%eax
  811fcd:	0f 9e c0             	setle  %al
  811fd0:	0f b6 c0             	movzbl %al,%eax
  811fd3:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  811fd7:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  811fdb:	66 25 ff 1f          	and    $0x1fff,%ax
  811fdf:	66 0b 45 de          	or     -0x22(%rbp),%ax
  811fe3:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  811fe7:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  811fec:	75 06                	jne    811ff4 <ip_frag+0x151>
      tmp = tmp | IP_MF;
  811fee:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  811ff4:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  811ff9:	75 09                	jne    812004 <ip_frag+0x161>
  811ffb:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  811fff:	c1 e0 03             	shl    $0x3,%eax
  812002:	eb 04                	jmp    812008 <ip_frag+0x165>
  812004:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812008:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  81200c:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  812010:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  812014:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812018:	48 8d 70 14          	lea    0x14(%rax),%rsi
  81201c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812020:	48 89 c7             	mov    %rax,%rdi
  812023:	48 b8 6b de 80 00 00 	movabs $0x80de6b,%rax
  81202a:	00 00 00 
  81202d:	ff d0                	callq  *%rax
  81202f:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  812033:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812037:	89 c7                	mov    %eax,%edi
  812039:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  812040:	00 00 00 
  812043:	ff d0                	callq  *%rax
  812045:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  812049:	66 89 42 06          	mov    %ax,0x6(%rdx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  81204d:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812051:	83 c0 14             	add    $0x14,%eax
  812054:	0f b7 c0             	movzwl %ax,%eax
  812057:	89 c7                	mov    %eax,%edi
  812059:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  812060:	00 00 00 
  812063:	ff d0                	callq  *%rax
  812065:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  812069:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  81206d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812071:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  812077:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81207b:	be 14 00 00 00       	mov    $0x14,%esi
  812080:	48 89 c7             	mov    %rax,%rdi
  812083:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  81208a:	00 00 00 
  81208d:	ff d0                	callq  *%rax
  81208f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  812093:	66 89 42 0a          	mov    %ax,0xa(%rdx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  812097:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  81209c:	74 1f                	je     8120bd <ip_frag+0x21a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  81209e:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8120a2:	83 c0 14             	add    $0x14,%eax
  8120a5:	0f b7 d0             	movzwl %ax,%edx
  8120a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8120ac:	89 d6                	mov    %edx,%esi
  8120ae:	48 89 c7             	mov    %rax,%rdi
  8120b1:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  8120b8:	00 00 00 
  8120bb:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8120bd:	ba 00 00 00 00       	mov    $0x0,%edx
  8120c2:	be 00 00 00 00       	mov    $0x0,%esi
  8120c7:	bf 02 00 00 00       	mov    $0x2,%edi
  8120cc:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  8120d3:	00 00 00 
  8120d6:	ff d0                	callq  *%rax
  8120d8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  8120dc:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8120e1:	74 5c                	je     81213f <ip_frag+0x29c>
      pbuf_chain(header, rambuf);
  8120e3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8120e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8120eb:	48 89 d6             	mov    %rdx,%rsi
  8120ee:	48 89 c7             	mov    %rax,%rdi
  8120f1:	48 b8 76 da 80 00 00 	movabs $0x80da76,%rax
  8120f8:	00 00 00 
  8120fb:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  8120fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812101:	4c 8b 40 20          	mov    0x20(%rax),%r8
  812105:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  812109:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  81210d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  812111:	48 89 ce             	mov    %rcx,%rsi
  812114:	48 89 c7             	mov    %rax,%rdi
  812117:	41 ff d0             	callq  *%r8
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  81211a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81211e:	48 89 c7             	mov    %rax,%rdi
  812121:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  812128:	00 00 00 
  81212b:	ff d0                	callq  *%rax
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  81212d:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812131:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  812135:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  812139:	66 01 45 fc          	add    %ax,-0x4(%rbp)
  81213d:	eb 1a                	jmp    812159 <ip_frag+0x2b6>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  81213f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812143:	48 89 c7             	mov    %rax,%rdi
  812146:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81214d:	00 00 00 
  812150:	ff d0                	callq  *%rax
      return ERR_MEM;
  812152:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812157:	eb 23                	jmp    81217c <ip_frag+0x2d9>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  812159:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  81215e:	0f 85 5c fe ff ff    	jne    811fc0 <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  812164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812168:	48 89 c7             	mov    %rax,%rdi
  81216b:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  812172:	00 00 00 
  812175:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  812177:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81217c:	c9                   	leaveq 
  81217d:	c3                   	retq   
	...

0000000000812180 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  812180:	55                   	push   %rbp
  812181:	48 89 e5             	mov    %rsp,%rbp
  812184:	48 83 ec 30          	sub    $0x30,%rsp
  812188:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81218c:	89 f0                	mov    %esi,%eax
  81218e:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  812192:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  812199:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81219d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  8121a1:	eb 35                	jmp    8121d8 <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8121a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8121a7:	0f b6 00             	movzbl (%rax),%eax
  8121aa:	0f b6 c0             	movzbl %al,%eax
  8121ad:	c1 e0 08             	shl    $0x8,%eax
  8121b0:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  8121b4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  8121b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8121bd:	0f b6 00             	movzbl (%rax),%eax
  8121c0:	0f b6 c0             	movzbl %al,%eax
  8121c3:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  8121c7:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  8121cc:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8121d0:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  8121d3:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8121d8:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  8121dd:	77 c4                	ja     8121a3 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8121df:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  8121e4:	74 18                	je     8121fe <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8121e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8121ea:	0f b6 00             	movzbl (%rax),%eax
  8121ed:	0f b6 c0             	movzbl %al,%eax
  8121f0:	c1 e0 08             	shl    $0x8,%eax
  8121f3:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  8121f7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8121fb:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8121fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812201:	89 c2                	mov    %eax,%edx
  812203:	c1 ea 10             	shr    $0x10,%edx
  812206:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812209:	25 ff ff 00 00       	and    $0xffff,%eax
  81220e:	01 d0                	add    %edx,%eax
  812210:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  812213:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812216:	66 b8 00 00          	mov    $0x0,%ax
  81221a:	85 c0                	test   %eax,%eax
  81221c:	74 15                	je     812233 <lwip_standard_chksum+0xb3>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  81221e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812221:	89 c2                	mov    %eax,%edx
  812223:	c1 ea 10             	shr    $0x10,%edx
  812226:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812229:	25 ff ff 00 00       	and    $0xffff,%eax
  81222e:	01 d0                	add    %edx,%eax
  812230:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  812233:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812236:	0f b7 c0             	movzwl %ax,%eax
  812239:	89 c7                	mov    %eax,%edi
  81223b:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  812242:	00 00 00 
  812245:	ff d0                	callq  *%rax
}
  812247:	c9                   	leaveq 
  812248:	c3                   	retq   

0000000000812249 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  812249:	55                   	push   %rbp
  81224a:	48 89 e5             	mov    %rsp,%rbp
  81224d:	48 83 ec 40          	sub    $0x40,%rsp
  812251:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812255:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812259:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81225d:	89 c8                	mov    %ecx,%eax
  81225f:	44 89 c2             	mov    %r8d,%edx
  812262:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812265:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812269:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812270:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  812274:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812278:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81227c:	e9 80 00 00 00       	jmpq   812301 <inet_chksum_pseudo+0xb8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  812281:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812285:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812289:	0f b7 d0             	movzwl %ax,%edx
  81228c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812290:	48 8b 40 08          	mov    0x8(%rax),%rax
  812294:	89 d6                	mov    %edx,%esi
  812296:	48 89 c7             	mov    %rax,%rdi
  812299:	48 b8 80 21 81 00 00 	movabs $0x812180,%rax
  8122a0:	00 00 00 
  8122a3:	ff d0                	callq  *%rax
  8122a5:	0f b7 c0             	movzwl %ax,%eax
  8122a8:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8122ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8122ae:	89 c2                	mov    %eax,%edx
  8122b0:	c1 ea 10             	shr    $0x10,%edx
  8122b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8122b6:	25 ff ff 00 00       	and    $0xffff,%eax
  8122bb:	01 d0                	add    %edx,%eax
  8122bd:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  8122c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8122c4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8122c8:	0f b7 c0             	movzwl %ax,%eax
  8122cb:	83 e0 01             	and    $0x1,%eax
  8122ce:	84 c0                	test   %al,%al
  8122d0:	74 24                	je     8122f6 <inet_chksum_pseudo+0xad>
      swapped = 1 - swapped;
  8122d2:	b8 01 00 00 00       	mov    $0x1,%eax
  8122d7:	2a 45 ef             	sub    -0x11(%rbp),%al
  8122da:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8122dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8122e0:	c1 e0 08             	shl    $0x8,%eax
  8122e3:	0f b7 d0             	movzwl %ax,%edx
  8122e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8122e9:	25 00 ff 00 00       	and    $0xff00,%eax
  8122ee:	c1 e8 08             	shr    $0x8,%eax
  8122f1:	09 d0                	or     %edx,%eax
  8122f3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8122f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8122fa:	48 8b 00             	mov    (%rax),%rax
  8122fd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812301:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  812306:	0f 85 75 ff ff ff    	jne    812281 <inet_chksum_pseudo+0x38>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  81230c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812310:	74 19                	je     81232b <inet_chksum_pseudo+0xe2>
    acc = SWAP_BYTES_IN_WORD(acc);
  812312:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812315:	c1 e0 08             	shl    $0x8,%eax
  812318:	0f b7 d0             	movzwl %ax,%edx
  81231b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81231e:	25 00 ff 00 00       	and    $0xff00,%eax
  812323:	c1 e8 08             	shr    $0x8,%eax
  812326:	09 d0                	or     %edx,%eax
  812328:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  81232b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81232f:	8b 00                	mov    (%rax),%eax
  812331:	25 ff ff 00 00       	and    $0xffff,%eax
  812336:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812339:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81233d:	8b 00                	mov    (%rax),%eax
  81233f:	c1 e8 10             	shr    $0x10,%eax
  812342:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  812345:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812349:	8b 00                	mov    (%rax),%eax
  81234b:	25 ff ff 00 00       	and    $0xffff,%eax
  812350:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812353:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812357:	8b 00                	mov    (%rax),%eax
  812359:	c1 e8 10             	shr    $0x10,%eax
  81235c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  81235f:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812363:	89 c7                	mov    %eax,%edi
  812365:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81236c:	00 00 00 
  81236f:	ff d0                	callq  *%rax
  812371:	0f b7 c0             	movzwl %ax,%eax
  812374:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  812377:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  81237b:	89 c7                	mov    %eax,%edi
  81237d:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  812384:	00 00 00 
  812387:	ff d0                	callq  *%rax
  812389:	0f b7 c0             	movzwl %ax,%eax
  81238c:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  81238f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812392:	89 c2                	mov    %eax,%edx
  812394:	c1 ea 10             	shr    $0x10,%edx
  812397:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81239a:	25 ff ff 00 00       	and    $0xffff,%eax
  81239f:	01 d0                	add    %edx,%eax
  8123a1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  8123a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8123a7:	89 c2                	mov    %eax,%edx
  8123a9:	c1 ea 10             	shr    $0x10,%edx
  8123ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8123af:	25 ff ff 00 00       	and    $0xffff,%eax
  8123b4:	01 d0                	add    %edx,%eax
  8123b6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8123b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8123bc:	f7 d0                	not    %eax
}
  8123be:	c9                   	leaveq 
  8123bf:	c3                   	retq   

00000000008123c0 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  8123c0:	55                   	push   %rbp
  8123c1:	48 89 e5             	mov    %rsp,%rbp
  8123c4:	48 83 ec 50          	sub    $0x50,%rsp
  8123c8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8123cc:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8123d0:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8123d4:	89 c8                	mov    %ecx,%eax
  8123d6:	44 89 c1             	mov    %r8d,%ecx
  8123d9:	44 89 ca             	mov    %r9d,%edx
  8123dc:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8123df:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  8123e3:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8123e7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8123ee:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8123f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8123f6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8123fa:	e9 d1 00 00 00       	jmpq   8124d0 <inet_chksum_pseudo_partial+0x110>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  8123ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812403:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812407:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  81240b:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  81240f:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  812413:	76 08                	jbe    81241d <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  812415:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  812419:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  81241d:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812421:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812425:	48 8b 40 08          	mov    0x8(%rax),%rax
  812429:	89 d6                	mov    %edx,%esi
  81242b:	48 89 c7             	mov    %rax,%rdi
  81242e:	48 b8 80 21 81 00 00 	movabs $0x812180,%rax
  812435:	00 00 00 
  812438:	ff d0                	callq  *%rax
  81243a:	0f b7 c0             	movzwl %ax,%eax
  81243d:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  812440:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812444:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  812448:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  81244e:	76 2a                	jbe    81247a <inet_chksum_pseudo_partial+0xba>
  812450:	48 ba a8 21 82 00 00 	movabs $0x8221a8,%rdx
  812457:	00 00 00 
  81245a:	be 60 01 00 00       	mov    $0x160,%esi
  81245f:	48 bf b8 21 82 00 00 	movabs $0x8221b8,%rdi
  812466:	00 00 00 
  812469:	b8 00 00 00 00       	mov    $0x0,%eax
  81246e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812475:	00 00 00 
  812478:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  81247a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81247d:	89 c2                	mov    %eax,%edx
  81247f:	c1 ea 10             	shr    $0x10,%edx
  812482:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812485:	25 ff ff 00 00       	and    $0xffff,%eax
  81248a:	01 d0                	add    %edx,%eax
  81248c:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81248f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812493:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812497:	0f b7 c0             	movzwl %ax,%eax
  81249a:	83 e0 01             	and    $0x1,%eax
  81249d:	84 c0                	test   %al,%al
  81249f:	74 24                	je     8124c5 <inet_chksum_pseudo_partial+0x105>
      swapped = 1 - swapped;
  8124a1:	b8 01 00 00 00       	mov    $0x1,%eax
  8124a6:	2a 45 ef             	sub    -0x11(%rbp),%al
  8124a9:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8124ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124af:	c1 e0 08             	shl    $0x8,%eax
  8124b2:	0f b7 d0             	movzwl %ax,%edx
  8124b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124b8:	25 00 ff 00 00       	and    $0xff00,%eax
  8124bd:	c1 e8 08             	shr    $0x8,%eax
  8124c0:	09 d0                	or     %edx,%eax
  8124c2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8124c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8124c9:	48 8b 00             	mov    (%rax),%rax
  8124cc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8124d0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8124d5:	74 0b                	je     8124e2 <inet_chksum_pseudo_partial+0x122>
  8124d7:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  8124dc:	0f 85 1d ff ff ff    	jne    8123ff <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8124e2:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8124e6:	74 19                	je     812501 <inet_chksum_pseudo_partial+0x141>
    acc = SWAP_BYTES_IN_WORD(acc);
  8124e8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124eb:	c1 e0 08             	shl    $0x8,%eax
  8124ee:	0f b7 d0             	movzwl %ax,%edx
  8124f1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124f4:	25 00 ff 00 00       	and    $0xff00,%eax
  8124f9:	c1 e8 08             	shr    $0x8,%eax
  8124fc:	09 d0                	or     %edx,%eax
  8124fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  812501:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812505:	8b 00                	mov    (%rax),%eax
  812507:	25 ff ff 00 00       	and    $0xffff,%eax
  81250c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  81250f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  812513:	8b 00                	mov    (%rax),%eax
  812515:	c1 e8 10             	shr    $0x10,%eax
  812518:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  81251b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81251f:	8b 00                	mov    (%rax),%eax
  812521:	25 ff ff 00 00       	and    $0xffff,%eax
  812526:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812529:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81252d:	8b 00                	mov    (%rax),%eax
  81252f:	c1 e8 10             	shr    $0x10,%eax
  812532:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812535:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812539:	89 c7                	mov    %eax,%edi
  81253b:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  812542:	00 00 00 
  812545:	ff d0                	callq  *%rax
  812547:	0f b7 c0             	movzwl %ax,%eax
  81254a:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  81254d:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  812551:	89 c7                	mov    %eax,%edi
  812553:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81255a:	00 00 00 
  81255d:	ff d0                	callq  *%rax
  81255f:	0f b7 c0             	movzwl %ax,%eax
  812562:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812565:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812568:	89 c2                	mov    %eax,%edx
  81256a:	c1 ea 10             	shr    $0x10,%edx
  81256d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812570:	25 ff ff 00 00       	and    $0xffff,%eax
  812575:	01 d0                	add    %edx,%eax
  812577:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  81257a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81257d:	89 c2                	mov    %eax,%edx
  81257f:	c1 ea 10             	shr    $0x10,%edx
  812582:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812585:	25 ff ff 00 00       	and    $0xffff,%eax
  81258a:	01 d0                	add    %edx,%eax
  81258c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  81258f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812592:	f7 d0                	not    %eax
}
  812594:	c9                   	leaveq 
  812595:	c3                   	retq   

0000000000812596 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  812596:	55                   	push   %rbp
  812597:	48 89 e5             	mov    %rsp,%rbp
  81259a:	48 83 ec 10          	sub    $0x10,%rsp
  81259e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8125a2:	89 f0                	mov    %esi,%eax
  8125a4:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  8125a8:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  8125ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8125b0:	89 d6                	mov    %edx,%esi
  8125b2:	48 89 c7             	mov    %rax,%rdi
  8125b5:	48 b8 80 21 81 00 00 	movabs $0x812180,%rax
  8125bc:	00 00 00 
  8125bf:	ff d0                	callq  *%rax
  8125c1:	f7 d0                	not    %eax
}
  8125c3:	c9                   	leaveq 
  8125c4:	c3                   	retq   

00000000008125c5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8125c5:	55                   	push   %rbp
  8125c6:	48 89 e5             	mov    %rsp,%rbp
  8125c9:	48 83 ec 30          	sub    $0x30,%rsp
  8125cd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8125d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8125d8:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  8125dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8125e0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8125e4:	e9 80 00 00 00       	jmpq   812669 <inet_chksum_pbuf+0xa4>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8125e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8125ed:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8125f1:	0f b7 d0             	movzwl %ax,%edx
  8125f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8125f8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8125fc:	89 d6                	mov    %edx,%esi
  8125fe:	48 89 c7             	mov    %rax,%rdi
  812601:	48 b8 80 21 81 00 00 	movabs $0x812180,%rax
  812608:	00 00 00 
  81260b:	ff d0                	callq  *%rax
  81260d:	0f b7 c0             	movzwl %ax,%eax
  812610:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  812613:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812616:	89 c2                	mov    %eax,%edx
  812618:	c1 ea 10             	shr    $0x10,%edx
  81261b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81261e:	25 ff ff 00 00       	and    $0xffff,%eax
  812623:	01 d0                	add    %edx,%eax
  812625:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812628:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81262c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812630:	0f b7 c0             	movzwl %ax,%eax
  812633:	83 e0 01             	and    $0x1,%eax
  812636:	84 c0                	test   %al,%al
  812638:	74 24                	je     81265e <inet_chksum_pbuf+0x99>
      swapped = 1 - swapped;
  81263a:	b8 01 00 00 00       	mov    $0x1,%eax
  81263f:	2a 45 ef             	sub    -0x11(%rbp),%al
  812642:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812645:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812648:	c1 e0 08             	shl    $0x8,%eax
  81264b:	0f b7 d0             	movzwl %ax,%edx
  81264e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812651:	25 00 ff 00 00       	and    $0xff00,%eax
  812656:	c1 e8 08             	shr    $0x8,%eax
  812659:	09 d0                	or     %edx,%eax
  81265b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  81265e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812662:	48 8b 00             	mov    (%rax),%rax
  812665:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812669:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81266e:	0f 85 75 ff ff ff    	jne    8125e9 <inet_chksum_pbuf+0x24>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  812674:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812678:	74 19                	je     812693 <inet_chksum_pbuf+0xce>
    acc = SWAP_BYTES_IN_WORD(acc);
  81267a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81267d:	c1 e0 08             	shl    $0x8,%eax
  812680:	0f b7 d0             	movzwl %ax,%edx
  812683:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812686:	25 00 ff 00 00       	and    $0xff00,%eax
  81268b:	c1 e8 08             	shr    $0x8,%eax
  81268e:	09 d0                	or     %edx,%eax
  812690:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  812693:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812696:	f7 d0                	not    %eax
}
  812698:	c9                   	leaveq 
  812699:	c3                   	retq   
	...

000000000081269c <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  81269c:	55                   	push   %rbp
  81269d:	48 89 e5             	mov    %rsp,%rbp
  8126a0:	48 83 ec 20          	sub    $0x20,%rsp
  8126a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  8126a8:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8126ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8126b0:	48 89 d6             	mov    %rdx,%rsi
  8126b3:	48 89 c7             	mov    %rax,%rdi
  8126b6:	48 b8 d2 26 81 00 00 	movabs $0x8126d2,%rax
  8126bd:	00 00 00 
  8126c0:	ff d0                	callq  *%rax
  8126c2:	85 c0                	test   %eax,%eax
  8126c4:	74 05                	je     8126cb <inet_addr+0x2f>
    return (val.s_addr);
  8126c6:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8126c9:	eb 05                	jmp    8126d0 <inet_addr+0x34>
  }
  return (INADDR_NONE);
  8126cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8126d0:	c9                   	leaveq 
  8126d1:	c3                   	retq   

00000000008126d2 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  8126d2:	55                   	push   %rbp
  8126d3:	48 89 e5             	mov    %rsp,%rbp
  8126d6:	53                   	push   %rbx
  8126d7:	48 83 ec 48          	sub    $0x48,%rsp
  8126db:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8126df:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  8126e3:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8126e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  c = *cp;
  8126eb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8126ef:	0f b6 00             	movzbl (%rax),%eax
  8126f2:	0f be c0             	movsbl %al,%eax
  8126f5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  8126f8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8126fb:	3c 2f                	cmp    $0x2f,%al
  8126fd:	76 07                	jbe    812706 <inet_aton+0x34>
  8126ff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812702:	3c 39                	cmp    $0x39,%al
  812704:	76 0a                	jbe    812710 <inet_aton+0x3e>
      return (0);
  812706:	b8 00 00 00 00       	mov    $0x0,%eax
  81270b:	e9 6a 02 00 00       	jmpq   81297a <inet_aton+0x2a8>
    val = 0;
  812710:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    base = 10;
  812717:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%rbp)
    if (c == '0') {
  81271e:	83 7d e4 30          	cmpl   $0x30,-0x1c(%rbp)
  812722:	75 40                	jne    812764 <inet_aton+0x92>
      c = *++cp;
  812724:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  812729:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81272d:	0f b6 00             	movzbl (%rax),%eax
  812730:	0f be c0             	movsbl %al,%eax
  812733:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      if (c == 'x' || c == 'X') {
  812736:	83 7d e4 78          	cmpl   $0x78,-0x1c(%rbp)
  81273a:	74 06                	je     812742 <inet_aton+0x70>
  81273c:	83 7d e4 58          	cmpl   $0x58,-0x1c(%rbp)
  812740:	75 1b                	jne    81275d <inet_aton+0x8b>
        base = 16;
  812742:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%rbp)
        c = *++cp;
  812749:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  81274e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812752:	0f b6 00             	movzbl (%rax),%eax
  812755:	0f be c0             	movsbl %al,%eax
  812758:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  81275b:	eb 07                	jmp    812764 <inet_aton+0x92>
      } else
        base = 8;
  81275d:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812764:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812767:	3c 2f                	cmp    $0x2f,%al
  812769:	76 2f                	jbe    81279a <inet_aton+0xc8>
  81276b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81276e:	3c 39                	cmp    $0x39,%al
  812770:	77 28                	ja     81279a <inet_aton+0xc8>
        val = (val * base) + (int)(c - '0');
  812772:	8b 45 e8             	mov    -0x18(%rbp),%eax
  812775:	89 c2                	mov    %eax,%edx
  812777:	0f af 55 ec          	imul   -0x14(%rbp),%edx
  81277b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81277e:	01 d0                	add    %edx,%eax
  812780:	83 e8 30             	sub    $0x30,%eax
  812783:	89 45 ec             	mov    %eax,-0x14(%rbp)
        c = *++cp;
  812786:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  81278b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81278f:	0f b6 00             	movzbl (%rax),%eax
  812792:	0f be c0             	movsbl %al,%eax
  812795:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
  812798:	eb ca                	jmp    812764 <inet_aton+0x92>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  81279a:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  81279e:	75 74                	jne    812814 <inet_aton+0x142>
  8127a0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127a3:	3c 2f                	cmp    $0x2f,%al
  8127a5:	76 07                	jbe    8127ae <inet_aton+0xdc>
  8127a7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127aa:	3c 39                	cmp    $0x39,%al
  8127ac:	76 1c                	jbe    8127ca <inet_aton+0xf8>
  8127ae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127b1:	3c 60                	cmp    $0x60,%al
  8127b3:	76 07                	jbe    8127bc <inet_aton+0xea>
  8127b5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127b8:	3c 66                	cmp    $0x66,%al
  8127ba:	76 0e                	jbe    8127ca <inet_aton+0xf8>
  8127bc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127bf:	3c 40                	cmp    $0x40,%al
  8127c1:	76 51                	jbe    812814 <inet_aton+0x142>
  8127c3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127c6:	3c 46                	cmp    $0x46,%al
  8127c8:	77 4a                	ja     812814 <inet_aton+0x142>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  8127ca:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8127cd:	89 c2                	mov    %eax,%edx
  8127cf:	c1 e2 04             	shl    $0x4,%edx
  8127d2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127d5:	8d 48 0a             	lea    0xa(%rax),%ecx
  8127d8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127db:	3c 60                	cmp    $0x60,%al
  8127dd:	76 0e                	jbe    8127ed <inet_aton+0x11b>
  8127df:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8127e2:	3c 7a                	cmp    $0x7a,%al
  8127e4:	77 07                	ja     8127ed <inet_aton+0x11b>
  8127e6:	b8 61 00 00 00       	mov    $0x61,%eax
  8127eb:	eb 05                	jmp    8127f2 <inet_aton+0x120>
  8127ed:	b8 41 00 00 00       	mov    $0x41,%eax
  8127f2:	89 cb                	mov    %ecx,%ebx
  8127f4:	29 c3                	sub    %eax,%ebx
  8127f6:	89 d8                	mov    %ebx,%eax
  8127f8:	09 d0                	or     %edx,%eax
  8127fa:	89 45 ec             	mov    %eax,-0x14(%rbp)
        c = *++cp;
  8127fd:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  812802:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812806:	0f b6 00             	movzbl (%rax),%eax
  812809:	0f be c0             	movsbl %al,%eax
  81280c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      } else
        break;
    }
  81280f:	e9 50 ff ff ff       	jmpq   812764 <inet_aton+0x92>
    if (c == '.') {
  812814:	83 7d e4 2e          	cmpl   $0x2e,-0x1c(%rbp)
  812818:	75 3d                	jne    812857 <inet_aton+0x185>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  81281a:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  81281e:	48 83 c0 0c          	add    $0xc,%rax
  812822:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  812826:	72 0a                	jb     812832 <inet_aton+0x160>
        return (0);
  812828:	b8 00 00 00 00       	mov    $0x0,%eax
  81282d:	e9 48 01 00 00       	jmpq   81297a <inet_aton+0x2a8>
      *pp++ = val;
  812832:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812836:	8b 55 ec             	mov    -0x14(%rbp),%edx
  812839:	89 10                	mov    %edx,(%rax)
  81283b:	48 83 45 d8 04       	addq   $0x4,-0x28(%rbp)
      c = *++cp;
  812840:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  812845:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812849:	0f b6 00             	movzbl (%rax),%eax
  81284c:	0f be c0             	movsbl %al,%eax
  81284f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    } else
      break;
  }
  812852:	e9 a1 fe ff ff       	jmpq   8126f8 <inet_aton+0x26>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812857:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812858:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  81285c:	74 3c                	je     81289a <inet_aton+0x1c8>
  81285e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812861:	3c 1f                	cmp    $0x1f,%al
  812863:	76 2b                	jbe    812890 <inet_aton+0x1be>
  812865:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812868:	84 c0                	test   %al,%al
  81286a:	78 24                	js     812890 <inet_aton+0x1be>
  81286c:	83 7d e4 20          	cmpl   $0x20,-0x1c(%rbp)
  812870:	74 28                	je     81289a <inet_aton+0x1c8>
  812872:	83 7d e4 0c          	cmpl   $0xc,-0x1c(%rbp)
  812876:	74 22                	je     81289a <inet_aton+0x1c8>
  812878:	83 7d e4 0a          	cmpl   $0xa,-0x1c(%rbp)
  81287c:	74 1c                	je     81289a <inet_aton+0x1c8>
  81287e:	83 7d e4 0d          	cmpl   $0xd,-0x1c(%rbp)
  812882:	74 16                	je     81289a <inet_aton+0x1c8>
  812884:	83 7d e4 09          	cmpl   $0x9,-0x1c(%rbp)
  812888:	74 10                	je     81289a <inet_aton+0x1c8>
  81288a:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%rbp)
  81288e:	74 0a                	je     81289a <inet_aton+0x1c8>
    return (0);
  812890:	b8 00 00 00 00       	mov    $0x0,%eax
  812895:	e9 e0 00 00 00       	jmpq   81297a <inet_aton+0x2a8>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  81289a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81289e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8128a2:	48 89 d1             	mov    %rdx,%rcx
  8128a5:	48 29 c1             	sub    %rax,%rcx
  8128a8:	48 89 c8             	mov    %rcx,%rax
  8128ab:	48 c1 f8 02          	sar    $0x2,%rax
  8128af:	83 c0 01             	add    $0x1,%eax
  8128b2:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  switch (n) {
  8128b5:	83 7d d4 04          	cmpl   $0x4,-0x2c(%rbp)
  8128b9:	0f 87 98 00 00 00    	ja     812957 <inet_aton+0x285>
  8128bf:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8128c2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8128c9:	00 
  8128ca:	48 b8 e0 21 82 00 00 	movabs $0x8221e0,%rax
  8128d1:	00 00 00 
  8128d4:	48 01 d0             	add    %rdx,%rax
  8128d7:	48 8b 00             	mov    (%rax),%rax
  8128da:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  8128dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8128e1:	e9 94 00 00 00       	jmpq   81297a <inet_aton+0x2a8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  8128e6:	81 7d ec ff ff ff 00 	cmpl   $0xffffff,-0x14(%rbp)
  8128ed:	76 0a                	jbe    8128f9 <inet_aton+0x227>
      return (0);
  8128ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8128f4:	e9 81 00 00 00       	jmpq   81297a <inet_aton+0x2a8>
    val |= parts[0] << 24;
  8128f9:	8b 45 c0             	mov    -0x40(%rbp),%eax
  8128fc:	c1 e0 18             	shl    $0x18,%eax
  8128ff:	09 45 ec             	or     %eax,-0x14(%rbp)
    break;
  812902:	eb 53                	jmp    812957 <inet_aton+0x285>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812904:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  81290b:	76 07                	jbe    812914 <inet_aton+0x242>
      return (0);
  81290d:	b8 00 00 00 00       	mov    $0x0,%eax
  812912:	eb 66                	jmp    81297a <inet_aton+0x2a8>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812914:	8b 45 c0             	mov    -0x40(%rbp),%eax
  812917:	89 c2                	mov    %eax,%edx
  812919:	c1 e2 18             	shl    $0x18,%edx
  81291c:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81291f:	c1 e0 10             	shl    $0x10,%eax
  812922:	09 d0                	or     %edx,%eax
  812924:	09 45 ec             	or     %eax,-0x14(%rbp)
    break;
  812927:	eb 2e                	jmp    812957 <inet_aton+0x285>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812929:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  812930:	76 07                	jbe    812939 <inet_aton+0x267>
      return (0);
  812932:	b8 00 00 00 00       	mov    $0x0,%eax
  812937:	eb 41                	jmp    81297a <inet_aton+0x2a8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812939:	8b 45 c0             	mov    -0x40(%rbp),%eax
  81293c:	89 c2                	mov    %eax,%edx
  81293e:	c1 e2 18             	shl    $0x18,%edx
  812941:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  812944:	c1 e0 10             	shl    $0x10,%eax
  812947:	09 c2                	or     %eax,%edx
  812949:	8b 45 c8             	mov    -0x38(%rbp),%eax
  81294c:	c1 e0 08             	shl    $0x8,%eax
  81294f:	09 d0                	or     %edx,%eax
  812951:	09 45 ec             	or     %eax,-0x14(%rbp)
    break;
  812954:	eb 01                	jmp    812957 <inet_aton+0x285>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812956:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812957:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  81295c:	74 17                	je     812975 <inet_aton+0x2a3>
    addr->s_addr = htonl(val);
  81295e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  812961:	89 c7                	mov    %eax,%edi
  812963:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  81296a:	00 00 00 
  81296d:	ff d0                	callq  *%rax
  81296f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  812973:	89 02                	mov    %eax,(%rdx)
  return (1);
  812975:	b8 01 00 00 00       	mov    $0x1,%eax
}
  81297a:	48 83 c4 48          	add    $0x48,%rsp
  81297e:	5b                   	pop    %rbx
  81297f:	5d                   	pop    %rbp
  812980:	c3                   	retq   

0000000000812981 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812981:	55                   	push   %rbp
  812982:	48 89 e5             	mov    %rsp,%rbp
  812985:	48 83 ec 30          	sub    $0x30,%rsp
  812989:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  81298c:	8b 45 d0             	mov    -0x30(%rbp),%eax
  81298f:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812992:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812999:	00 00 00 
  81299c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  8129a0:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  8129a4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  8129a8:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  8129ac:	e9 d1 00 00 00       	jmpq   812a82 <inet_ntoa+0x101>
    i = 0;
  8129b1:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  8129b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8129b9:	0f b6 08             	movzbl (%rax),%ecx
  8129bc:	0f b6 d1             	movzbl %cl,%edx
  8129bf:	89 d0                	mov    %edx,%eax
  8129c1:	c1 e0 02             	shl    $0x2,%eax
  8129c4:	01 d0                	add    %edx,%eax
  8129c6:	c1 e0 03             	shl    $0x3,%eax
  8129c9:	01 d0                	add    %edx,%eax
  8129cb:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  8129d2:	01 d0                	add    %edx,%eax
  8129d4:	66 c1 e8 08          	shr    $0x8,%ax
  8129d8:	c0 e8 03             	shr    $0x3,%al
  8129db:	88 45 ed             	mov    %al,-0x13(%rbp)
  8129de:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  8129e2:	89 d0                	mov    %edx,%eax
  8129e4:	c1 e0 02             	shl    $0x2,%eax
  8129e7:	01 d0                	add    %edx,%eax
  8129e9:	01 c0                	add    %eax,%eax
  8129eb:	89 ca                	mov    %ecx,%edx
  8129ed:	28 c2                	sub    %al,%dl
  8129ef:	89 d0                	mov    %edx,%eax
  8129f1:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  8129f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8129f8:	0f b6 00             	movzbl (%rax),%eax
  8129fb:	0f b6 d0             	movzbl %al,%edx
  8129fe:	89 d0                	mov    %edx,%eax
  812a00:	c1 e0 02             	shl    $0x2,%eax
  812a03:	01 d0                	add    %edx,%eax
  812a05:	c1 e0 03             	shl    $0x3,%eax
  812a08:	01 d0                	add    %edx,%eax
  812a0a:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812a11:	01 d0                	add    %edx,%eax
  812a13:	66 c1 e8 08          	shr    $0x8,%ax
  812a17:	89 c2                	mov    %eax,%edx
  812a19:	c0 ea 03             	shr    $0x3,%dl
  812a1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a20:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  812a22:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812a26:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812a2a:	83 c2 30             	add    $0x30,%edx
  812a2d:	48 98                	cltq   
  812a2f:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
  812a33:	80 45 ee 01          	addb   $0x1,-0x12(%rbp)
    } while(*ap);
  812a37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812a3b:	0f b6 00             	movzbl (%rax),%eax
  812a3e:	84 c0                	test   %al,%al
  812a40:	0f 85 6f ff ff ff    	jne    8129b5 <inet_ntoa+0x34>
    while(i--)
  812a46:	eb 16                	jmp    812a5e <inet_ntoa+0xdd>
      *rp++ = inv[i];
  812a48:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812a4c:	48 98                	cltq   
  812a4e:	0f b6 54 05 e0       	movzbl -0x20(%rbp,%rax,1),%edx
  812a53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812a57:	88 10                	mov    %dl,(%rax)
  812a59:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  812a5e:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  812a62:	0f 95 c0             	setne  %al
  812a65:	80 6d ee 01          	subb   $0x1,-0x12(%rbp)
  812a69:	84 c0                	test   %al,%al
  812a6b:	75 db                	jne    812a48 <inet_ntoa+0xc7>
      *rp++ = inv[i];
    *rp++ = '.';
  812a6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812a71:	c6 00 2e             	movb   $0x2e,(%rax)
  812a74:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
    ap++;
  812a79:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  812a7e:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  812a82:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  812a86:	0f 86 25 ff ff ff    	jbe    8129b1 <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  812a8c:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  812a91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812a95:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  812a98:	48 b8 60 b6 b4 00 00 	movabs $0xb4b660,%rax
  812a9f:	00 00 00 
}
  812aa2:	c9                   	leaveq 
  812aa3:	c3                   	retq   

0000000000812aa4 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  812aa4:	55                   	push   %rbp
  812aa5:	48 89 e5             	mov    %rsp,%rbp
  812aa8:	48 83 ec 08          	sub    $0x8,%rsp
  812aac:	89 f8                	mov    %edi,%eax
  812aae:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  812ab2:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812ab6:	c1 e0 08             	shl    $0x8,%eax
  812ab9:	89 c2                	mov    %eax,%edx
  812abb:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812abf:	66 c1 e8 08          	shr    $0x8,%ax
  812ac3:	09 d0                	or     %edx,%eax
}
  812ac5:	c9                   	leaveq 
  812ac6:	c3                   	retq   

0000000000812ac7 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  812ac7:	55                   	push   %rbp
  812ac8:	48 89 e5             	mov    %rsp,%rbp
  812acb:	48 83 ec 08          	sub    $0x8,%rsp
  812acf:	89 f8                	mov    %edi,%eax
  812ad1:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  812ad5:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812ad9:	89 c7                	mov    %eax,%edi
  812adb:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  812ae2:	00 00 00 
  812ae5:	ff d0                	callq  *%rax
}
  812ae7:	c9                   	leaveq 
  812ae8:	c3                   	retq   

0000000000812ae9 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  812ae9:	55                   	push   %rbp
  812aea:	48 89 e5             	mov    %rsp,%rbp
  812aed:	48 83 ec 08          	sub    $0x8,%rsp
  812af1:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  812af4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812af7:	89 c2                	mov    %eax,%edx
  812af9:	c1 e2 18             	shl    $0x18,%edx
    ((n & 0xff00) << 8) |
  812afc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812aff:	25 00 ff 00 00       	and    $0xff00,%eax
  812b04:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812b07:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  812b09:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b0c:	25 00 00 ff 00       	and    $0xff0000,%eax
  812b11:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812b15:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  812b17:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b1a:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812b1d:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  812b1f:	c9                   	leaveq 
  812b20:	c3                   	retq   

0000000000812b21 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  812b21:	55                   	push   %rbp
  812b22:	48 89 e5             	mov    %rsp,%rbp
  812b25:	48 83 ec 08          	sub    $0x8,%rsp
  812b29:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  812b2c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812b2f:	89 c7                	mov    %eax,%edi
  812b31:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  812b38:	00 00 00 
  812b3b:	ff d0                	callq  *%rax
}
  812b3d:	c9                   	leaveq 
  812b3e:	c3                   	retq   
	...

0000000000812b40 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  812b40:	55                   	push   %rbp
  812b41:	48 89 e5             	mov    %rsp,%rbp
  812b44:	48 83 ec 20          	sub    $0x20,%rsp
  812b48:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812b4c:	89 f0                	mov    %esi,%eax
  812b4e:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  812b51:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  812b55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812b59:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812b60:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812b66:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  812b6c:	89 d1                	mov    %edx,%ecx
  812b6e:	ba 00 00 00 00       	mov    $0x0,%edx
  812b73:	be 00 00 00 00       	mov    $0x0,%esi
  812b78:	48 89 c7             	mov    %rax,%rdi
  812b7b:	48 b8 1d 2c 81 00 00 	movabs $0x812c1d,%rax
  812b82:	00 00 00 
  812b85:	ff d0                	callq  *%rax
}
  812b87:	c9                   	leaveq 
  812b88:	c3                   	retq   

0000000000812b89 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  812b89:	55                   	push   %rbp
  812b8a:	48 89 e5             	mov    %rsp,%rbp
  812b8d:	48 83 ec 30          	sub    $0x30,%rsp
  812b91:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812b95:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  812b99:	89 c8                	mov    %ecx,%eax
  812b9b:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  812b9f:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812ba2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812ba6:	8b 40 18             	mov    0x18(%rax),%eax
  812ba9:	83 f8 04             	cmp    $0x4,%eax
  812bac:	74 24                	je     812bd2 <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  812bae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812bb2:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812bb5:	83 f8 07             	cmp    $0x7,%eax
  812bb8:	74 18                	je     812bd2 <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  812bba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812bbe:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  812bc1:	83 f8 02             	cmp    $0x2,%eax
  812bc4:	74 0c                	je     812bd2 <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  812bc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812bca:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  812bcd:	83 f8 03             	cmp    $0x3,%eax
  812bd0:	75 44                	jne    812c16 <tcp_write+0x8d>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  812bd2:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  812bd7:	74 36                	je     812c0f <tcp_write+0x86>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  812bd9:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  812bdd:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812be1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  812be5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812be9:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812bf0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812bf6:	41 89 c8             	mov    %ecx,%r8d
  812bf9:	b9 00 00 00 00       	mov    $0x0,%ecx
  812bfe:	48 89 c7             	mov    %rax,%rdi
  812c01:	48 b8 1d 2c 81 00 00 	movabs $0x812c1d,%rax
  812c08:	00 00 00 
  812c0b:	ff d0                	callq  *%rax
  812c0d:	eb 0c                	jmp    812c1b <tcp_write+0x92>
    }
    return ERR_OK;
  812c0f:	b8 00 00 00 00       	mov    $0x0,%eax
  812c14:	eb 05                	jmp    812c1b <tcp_write+0x92>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  812c16:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  812c1b:	c9                   	leaveq 
  812c1c:	c3                   	retq   

0000000000812c1d <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  812c1d:	55                   	push   %rbp
  812c1e:	48 89 e5             	mov    %rsp,%rbp
  812c21:	41 54                	push   %r12
  812c23:	53                   	push   %rbx
  812c24:	48 83 ec 70          	sub    $0x70,%rsp
  812c28:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  812c2c:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  812c30:	89 c8                	mov    %ecx,%eax
  812c32:	44 89 c6             	mov    %r8d,%esi
  812c35:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  812c39:	8b 4d 10             	mov    0x10(%rbp),%ecx
  812c3c:	66 89 55 9c          	mov    %dx,-0x64(%rbp)
  812c40:	88 45 98             	mov    %al,-0x68(%rbp)
  812c43:	40 88 75 94          	mov    %sil,-0x6c(%rbp)
  812c47:	88 4d 90             	mov    %cl,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  812c4a:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  812c4f:	74 30                	je     812c81 <tcp_enqueue+0x64>
  812c51:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  812c55:	74 2a                	je     812c81 <tcp_enqueue+0x64>
  812c57:	48 ba 08 22 82 00 00 	movabs $0x822208,%rdx
  812c5e:	00 00 00 
  812c61:	be 90 00 00 00       	mov    $0x90,%esi
  812c66:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812c6d:	00 00 00 
  812c70:	b8 00 00 00 00       	mov    $0x0,%eax
  812c75:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812c7c:	00 00 00 
  812c7f:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  812c81:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  812c86:	74 31                	je     812cb9 <tcp_enqueue+0x9c>
  812c88:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  812c8d:	74 2a                	je     812cb9 <tcp_enqueue+0x9c>
  812c8f:	48 ba 60 22 82 00 00 	movabs $0x822260,%rdx
  812c96:	00 00 00 
  812c99:	be 92 00 00 00       	mov    $0x92,%esi
  812c9e:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812ca5:	00 00 00 
  812ca8:	b8 00 00 00 00       	mov    $0x0,%eax
  812cad:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812cb4:	00 00 00 
  812cb7:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  812cb9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812cbd:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  812cc1:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  812cc5:	73 1e                	jae    812ce5 <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  812cc7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812ccb:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812ccf:	89 c2                	mov    %eax,%edx
  812cd1:	83 ca 80             	or     $0xffffff80,%edx
  812cd4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812cd8:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812cdb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812ce0:	e9 f4 09 00 00       	jmpq   8136d9 <tcp_enqueue+0xabc>
  }
  left = len;
  812ce5:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  812ce9:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  812ced:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  812cf1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  812cf5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812cf9:	8b 40 74             	mov    0x74(%rax),%eax
  812cfc:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  812cff:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812d03:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  812d07:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  812d0b:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  812d10:	77 07                	ja     812d19 <tcp_enqueue+0xfc>
  812d12:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  812d17:	76 1e                	jbe    812d37 <tcp_enqueue+0x11a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  812d19:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812d1d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812d21:	89 c2                	mov    %eax,%edx
  812d23:	83 ca 80             	or     $0xffffff80,%edx
  812d26:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812d2a:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812d2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812d32:	e9 a2 09 00 00       	jmpq   8136d9 <tcp_enqueue+0xabc>
  }
  if (queuelen != 0) {
  812d37:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  812d3c:	74 4e                	je     812d8c <tcp_enqueue+0x16f>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  812d3e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812d42:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812d49:	48 85 c0             	test   %rax,%rax
  812d4c:	0f 85 84 00 00 00    	jne    812dd6 <tcp_enqueue+0x1b9>
  812d52:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812d56:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812d5d:	48 85 c0             	test   %rax,%rax
  812d60:	75 74                	jne    812dd6 <tcp_enqueue+0x1b9>
  812d62:	48 ba a8 22 82 00 00 	movabs $0x8222a8,%rdx
  812d69:	00 00 00 
  812d6c:	be ae 00 00 00       	mov    $0xae,%esi
  812d71:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812d78:	00 00 00 
  812d7b:	b8 00 00 00 00       	mov    $0x0,%eax
  812d80:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812d87:	00 00 00 
  812d8a:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  812d8c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812d90:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812d97:	48 85 c0             	test   %rax,%rax
  812d9a:	75 10                	jne    812dac <tcp_enqueue+0x18f>
  812d9c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812da0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812da7:	48 85 c0             	test   %rax,%rax
  812daa:	74 2a                	je     812dd6 <tcp_enqueue+0x1b9>
  812dac:	48 ba e8 22 82 00 00 	movabs $0x8222e8,%rdx
  812db3:	00 00 00 
  812db6:	be b1 00 00 00       	mov    $0xb1,%esi
  812dbb:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812dc2:	00 00 00 
  812dc5:	b8 00 00 00 00       	mov    $0x0,%eax
  812dca:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812dd1:	00 00 00 
  812dd4:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  812dd6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  812ddd:	00 
  812dde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812de2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  812de6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812dea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  812dee:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  812df4:	e9 f8 04 00 00       	jmpq   8132f1 <tcp_enqueue+0x6d4>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  812df9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812dfd:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  812e01:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  812e05:	66 39 c2             	cmp    %ax,%dx
  812e08:	0f 46 c2             	cmovbe %edx,%eax
  812e0b:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  812e0f:	bf 04 00 00 00       	mov    $0x4,%edi
  812e14:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  812e1b:	00 00 00 
  812e1e:	ff d0                	callq  *%rax
  812e20:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  812e24:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812e29:	0f 84 10 08 00 00    	je     81363f <tcp_enqueue+0xa22>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  812e2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e33:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  812e3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e3e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  812e45:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  812e46:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  812e4b:	75 0a                	jne    812e57 <tcp_enqueue+0x23a>
      queue = seg;
  812e4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e51:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  812e55:	eb 3c                	jmp    812e93 <tcp_enqueue+0x276>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  812e57:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  812e5c:	75 2a                	jne    812e88 <tcp_enqueue+0x26b>
  812e5e:	48 ba 1c 23 82 00 00 	movabs $0x82231c,%rdx
  812e65:	00 00 00 
  812e68:	be ce 00 00 00       	mov    $0xce,%esi
  812e6d:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812e74:	00 00 00 
  812e77:	b8 00 00 00 00       	mov    $0x0,%eax
  812e7c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812e83:	00 00 00 
  812e86:	ff d1                	callq  *%rcx
      useg->next = seg;
  812e88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812e8c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812e90:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  812e93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812e97:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  812e9b:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  812ea0:	0f 84 ab 00 00 00    	je     812f51 <tcp_enqueue+0x334>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  812ea6:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  812eaa:	ba 00 00 00 00       	mov    $0x0,%edx
  812eaf:	89 c6                	mov    %eax,%esi
  812eb1:	bf 00 00 00 00       	mov    $0x0,%edi
  812eb6:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  812ebd:	00 00 00 
  812ec0:	ff d0                	callq  *%rax
  812ec2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812ec6:	48 89 42 08          	mov    %rax,0x8(%rdx)
  812eca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812ece:	48 8b 40 08          	mov    0x8(%rax),%rax
  812ed2:	48 85 c0             	test   %rax,%rax
  812ed5:	0f 84 67 07 00 00    	je     813642 <tcp_enqueue+0xa25>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  812edb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812edf:	48 8b 40 08          	mov    0x8(%rax),%rax
  812ee3:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  812ee7:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  812eeb:	66 39 c2             	cmp    %ax,%dx
  812eee:	73 2a                	jae    812f1a <tcp_enqueue+0x2fd>
  812ef0:	48 ba 30 23 82 00 00 	movabs $0x822330,%rdx
  812ef7:	00 00 00 
  812efa:	be df 00 00 00       	mov    $0xdf,%esi
  812eff:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812f06:	00 00 00 
  812f09:	b8 00 00 00 00       	mov    $0x0,%eax
  812f0e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812f15:	00 00 00 
  812f18:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  812f1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812f1e:	48 8b 40 08          	mov    0x8(%rax),%rax
  812f22:	48 89 c7             	mov    %rax,%rdi
  812f25:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  812f2c:	00 00 00 
  812f2f:	ff d0                	callq  *%rax
  812f31:	0f b6 c0             	movzbl %al,%eax
  812f34:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  812f38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812f3c:	48 8b 40 08          	mov    0x8(%rax),%rax
  812f40:	48 8b 50 08          	mov    0x8(%rax),%rdx
  812f44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812f48:	48 89 50 10          	mov    %rdx,0x10(%rax)
  812f4c:	e9 b8 01 00 00       	jmpq   813109 <tcp_enqueue+0x4ec>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  812f51:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  812f55:	83 e0 01             	and    $0x1,%eax
  812f58:	84 c0                	test   %al,%al
  812f5a:	0f 84 d5 00 00 00    	je     813035 <tcp_enqueue+0x418>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  812f60:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  812f64:	ba 00 00 00 00       	mov    $0x0,%edx
  812f69:	89 c6                	mov    %eax,%esi
  812f6b:	bf 00 00 00 00       	mov    $0x0,%edi
  812f70:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  812f77:	00 00 00 
  812f7a:	ff d0                	callq  *%rax
  812f7c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  812f80:	48 89 42 08          	mov    %rax,0x8(%rdx)
  812f84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812f88:	48 8b 40 08          	mov    0x8(%rax),%rax
  812f8c:	48 85 c0             	test   %rax,%rax
  812f8f:	0f 84 b0 06 00 00    	je     813645 <tcp_enqueue+0xa28>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  812f95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812f99:	48 8b 40 08          	mov    0x8(%rax),%rax
  812f9d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812fa1:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  812fa5:	73 2a                	jae    812fd1 <tcp_enqueue+0x3b4>
  812fa7:	48 ba 58 23 82 00 00 	movabs $0x822358,%rdx
  812fae:	00 00 00 
  812fb1:	be ea 00 00 00       	mov    $0xea,%esi
  812fb6:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  812fbd:	00 00 00 
  812fc0:	b8 00 00 00 00       	mov    $0x0,%eax
  812fc5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  812fcc:	00 00 00 
  812fcf:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  812fd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812fd5:	48 8b 40 08          	mov    0x8(%rax),%rax
  812fd9:	48 89 c7             	mov    %rax,%rdi
  812fdc:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  812fe3:	00 00 00 
  812fe6:	ff d0                	callq  *%rax
  812fe8:	0f b6 c0             	movzbl %al,%eax
  812feb:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  812fef:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  812ff4:	74 26                	je     81301c <tcp_enqueue+0x3ff>
        MEMCPY(seg->p->payload, ptr, seglen);
  812ff6:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  812ffa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812ffe:	48 8b 40 08          	mov    0x8(%rax),%rax
  813002:	48 8b 40 08          	mov    0x8(%rax),%rax
  813006:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  81300a:	48 89 ce             	mov    %rcx,%rsi
  81300d:	48 89 c7             	mov    %rax,%rdi
  813010:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  813017:	00 00 00 
  81301a:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  81301c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813020:	48 8b 40 08          	mov    0x8(%rax),%rax
  813024:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813028:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81302c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  813030:	e9 d4 00 00 00       	jmpq   813109 <tcp_enqueue+0x4ec>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  813035:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813039:	ba 01 00 00 00       	mov    $0x1,%edx
  81303e:	89 c6                	mov    %eax,%esi
  813040:	bf 00 00 00 00       	mov    $0x0,%edi
  813045:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  81304c:	00 00 00 
  81304f:	ff d0                	callq  *%rax
  813051:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  813055:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81305a:	0f 84 e8 05 00 00    	je     813648 <tcp_enqueue+0xa2b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  813060:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  813065:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813069:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81306d:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  813071:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813075:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813079:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  81307d:	ba 00 00 00 00       	mov    $0x0,%edx
  813082:	be 00 00 00 00       	mov    $0x0,%esi
  813087:	bf 00 00 00 00       	mov    $0x0,%edi
  81308c:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  813093:	00 00 00 
  813096:	ff d0                	callq  *%rax
  813098:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81309c:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8130a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8130a8:	48 85 c0             	test   %rax,%rax
  8130ab:	75 18                	jne    8130c5 <tcp_enqueue+0x4a8>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  8130ad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8130b1:	48 89 c7             	mov    %rax,%rdi
  8130b4:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8130bb:	00 00 00 
  8130be:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8130c0:	e9 8a 05 00 00       	jmpq   81364f <tcp_enqueue+0xa32>
      }
      queuelen += pbuf_clen(seg->p);
  8130c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130c9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8130cd:	48 89 c7             	mov    %rax,%rdi
  8130d0:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  8130d7:	00 00 00 
  8130da:	ff d0                	callq  *%rax
  8130dc:	0f b6 c0             	movzbl %al,%eax
  8130df:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8130e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8130eb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8130ef:	48 89 d6             	mov    %rdx,%rsi
  8130f2:	48 89 c7             	mov    %rax,%rdi
  8130f5:	48 b8 57 d9 80 00 00 	movabs $0x80d957,%rax
  8130fc:	00 00 00 
  8130ff:	ff d0                	callq  *%rax
      p = NULL;
  813101:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  813108:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  813109:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  81310e:	0f 87 37 05 00 00    	ja     81364b <tcp_enqueue+0xa2e>
  813114:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  813119:	0f 87 2c 05 00 00    	ja     81364b <tcp_enqueue+0xa2e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  81311f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813123:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813127:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  81312b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81312f:	48 8b 40 08          	mov    0x8(%rax),%rax
  813133:	be 14 00 00 00       	mov    $0x14,%esi
  813138:	48 89 c7             	mov    %rax,%rdi
  81313b:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  813142:	00 00 00 
  813145:	ff d0                	callq  *%rax
  813147:	84 c0                	test   %al,%al
  813149:	0f 85 ff 04 00 00    	jne    81364e <tcp_enqueue+0xa31>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  81314f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813153:	48 8b 40 08          	mov    0x8(%rax),%rax
  813157:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81315b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81315f:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  813163:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813167:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81316b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81316f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813173:	0f b7 c0             	movzwl %ax,%eax
  813176:	89 c7                	mov    %eax,%edi
  813178:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81317f:	00 00 00 
  813182:	ff d0                	callq  *%rax
  813184:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  813187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81318b:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81318f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813193:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813197:	0f b7 c0             	movzwl %ax,%eax
  81319a:	89 c7                	mov    %eax,%edi
  81319c:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8131a3:	00 00 00 
  8131a6:	ff d0                	callq  *%rax
  8131a8:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  8131ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131b0:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8131b4:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8131b7:	89 c7                	mov    %eax,%edi
  8131b9:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  8131c0:	00 00 00 
  8131c3:	ff d0                	callq  *%rax
  8131c5:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  8131c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131cc:	48 8b 40 20          	mov    0x20(%rax),%rax
  8131d0:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  8131d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131da:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8131de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131e2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8131e6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8131ea:	0f b7 c0             	movzwl %ax,%eax
  8131ed:	89 c7                	mov    %eax,%edi
  8131ef:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8131f6:	00 00 00 
  8131f9:	ff d0                	callq  *%rax
  8131fb:	89 c2                	mov    %eax,%edx
  8131fd:	83 e2 c0             	and    $0xffffffc0,%edx
  813200:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  813204:	09 d0                	or     %edx,%eax
  813206:	0f b7 c0             	movzwl %ax,%eax
  813209:	89 c7                	mov    %eax,%edi
  81320b:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813212:	00 00 00 
  813215:	ff d0                	callq  *%rax
  813217:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  81321b:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  813220:	75 42                	jne    813264 <tcp_enqueue+0x647>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  813222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813226:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81322a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81322e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813232:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813236:	0f b7 c0             	movzwl %ax,%eax
  813239:	89 c7                	mov    %eax,%edi
  81323b:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813242:	00 00 00 
  813245:	ff d0                	callq  *%rax
  813247:	83 e0 3f             	and    $0x3f,%eax
  81324a:	80 cc 50             	or     $0x50,%ah
  81324d:	0f b7 c0             	movzwl %ax,%eax
  813250:	89 c7                	mov    %eax,%edi
  813252:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813259:	00 00 00 
  81325c:	ff d0                	callq  *%rax
  81325e:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  813262:	eb 76                	jmp    8132da <tcp_enqueue+0x6bd>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  813264:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813268:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81326c:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813270:	c0 e8 02             	shr    $0x2,%al
  813273:	0f b6 c0             	movzbl %al,%eax
  813276:	83 c0 05             	add    $0x5,%eax
  813279:	41 89 c4             	mov    %eax,%r12d
  81327c:	41 c1 e4 0c          	shl    $0xc,%r12d
  813280:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813284:	48 8b 40 20          	mov    0x20(%rax),%rax
  813288:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81328c:	0f b7 c0             	movzwl %ax,%eax
  81328f:	89 c7                	mov    %eax,%edi
  813291:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813298:	00 00 00 
  81329b:	ff d0                	callq  *%rax
  81329d:	83 e0 3f             	and    $0x3f,%eax
  8132a0:	44 09 e0             	or     %r12d,%eax
  8132a3:	0f b7 c0             	movzwl %ax,%eax
  8132a6:	89 c7                	mov    %eax,%edi
  8132a8:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8132af:	00 00 00 
  8132b2:	ff d0                	callq  *%rax
  8132b4:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  8132b8:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  8132bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8132c0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8132c4:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8132c8:	48 89 ce             	mov    %rcx,%rsi
  8132cb:	48 89 c7             	mov    %rax,%rdi
  8132ce:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  8132d5:	00 00 00 
  8132d8:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  8132da:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8132de:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  8132e2:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8132e6:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  8132e9:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8132ed:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  8132f1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8132f6:	0f 84 fd fa ff ff    	je     812df9 <tcp_enqueue+0x1dc>
  8132fc:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  813301:	0f 85 f2 fa ff ff    	jne    812df9 <tcp_enqueue+0x1dc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  813307:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81330b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813312:	48 85 c0             	test   %rax,%rax
  813315:	75 0a                	jne    813321 <tcp_enqueue+0x704>
    useg = NULL;
  813317:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81331e:	00 
  81331f:	eb 28                	jmp    813349 <tcp_enqueue+0x72c>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  813321:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813325:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81332c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813330:	eb 0b                	jmp    81333d <tcp_enqueue+0x720>
  813332:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813336:	48 8b 00             	mov    (%rax),%rax
  813339:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81333d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813341:	48 8b 00             	mov    (%rax),%rax
  813344:	48 85 c0             	test   %rax,%rax
  813347:	75 e9                	jne    813332 <tcp_enqueue+0x715>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813349:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81334e:	0f 84 94 01 00 00    	je     8134e8 <tcp_enqueue+0x8cb>
    TCP_TCPLEN(useg) != 0 &&
  813354:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813358:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81335c:	0f b7 d8             	movzwl %ax,%ebx
  81335f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813363:	48 8b 40 20          	mov    0x20(%rax),%rax
  813367:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81336b:	0f b7 c0             	movzwl %ax,%eax
  81336e:	89 c7                	mov    %eax,%edi
  813370:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813377:	00 00 00 
  81337a:	ff d0                	callq  *%rax
  81337c:	0f b7 c0             	movzwl %ax,%eax
  81337f:	83 e0 01             	and    $0x1,%eax
  813382:	84 c0                	test   %al,%al
  813384:	75 27                	jne    8133ad <tcp_enqueue+0x790>
  813386:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81338a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81338e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813392:	0f b7 c0             	movzwl %ax,%eax
  813395:	89 c7                	mov    %eax,%edi
  813397:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81339e:	00 00 00 
  8133a1:	ff d0                	callq  *%rax
  8133a3:	0f b7 c0             	movzwl %ax,%eax
  8133a6:	83 e0 02             	and    $0x2,%eax
  8133a9:	85 c0                	test   %eax,%eax
  8133ab:	74 07                	je     8133b4 <tcp_enqueue+0x797>
  8133ad:	b8 01 00 00 00       	mov    $0x1,%eax
  8133b2:	eb 05                	jmp    8133b9 <tcp_enqueue+0x79c>
  8133b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8133b9:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  8133bb:	85 c0                	test   %eax,%eax
  8133bd:	0f 84 25 01 00 00    	je     8134e8 <tcp_enqueue+0x8cb>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8133c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8133c7:	48 8b 40 20          	mov    0x20(%rax),%rax
  8133cb:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8133cf:	0f b7 c0             	movzwl %ax,%eax
  8133d2:	89 c7                	mov    %eax,%edi
  8133d4:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8133db:	00 00 00 
  8133de:	ff d0                	callq  *%rax
  8133e0:	0f b7 c0             	movzwl %ax,%eax
  8133e3:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  8133e6:	85 c0                	test   %eax,%eax
  8133e8:	0f 85 fa 00 00 00    	jne    8134e8 <tcp_enqueue+0x8cb>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8133ee:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  8133f2:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8133f5:	85 c0                	test   %eax,%eax
  8133f7:	0f 85 eb 00 00 00    	jne    8134e8 <tcp_enqueue+0x8cb>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  8133fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813401:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813405:	0f b7 d0             	movzwl %ax,%edx
  813408:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81340c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813410:	0f b7 c0             	movzwl %ax,%eax
  813413:	01 c2                	add    %eax,%edx
  813415:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813419:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81341d:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813420:	39 c2                	cmp    %eax,%edx
  813422:	0f 8f c0 00 00 00    	jg     8134e8 <tcp_enqueue+0x8cb>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813428:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81342c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813430:	be ec ff ff ff       	mov    $0xffffffec,%esi
  813435:	48 89 c7             	mov    %rax,%rdi
  813438:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81343f:	00 00 00 
  813442:	ff d0                	callq  *%rax
  813444:	84 c0                	test   %al,%al
  813446:	74 2a                	je     813472 <tcp_enqueue+0x855>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  813448:	48 ba 8b 23 82 00 00 	movabs $0x82238b,%rdx
  81344f:	00 00 00 
  813452:	be 52 01 00 00       	mov    $0x152,%esi
  813457:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  81345e:	00 00 00 
  813461:	b8 00 00 00 00       	mov    $0x0,%eax
  813466:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81346d:	00 00 00 
  813470:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  813472:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813476:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81347a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81347e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813482:	48 89 d6             	mov    %rdx,%rsi
  813485:	48 89 c7             	mov    %rax,%rdi
  813488:	48 b8 57 d9 80 00 00 	movabs $0x80d957,%rax
  81348f:	00 00 00 
  813492:	ff d0                	callq  *%rax
    useg->len += queue->len;
  813494:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813498:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81349c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8134a0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8134a4:	01 c2                	add    %eax,%edx
  8134a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8134aa:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  8134ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8134b2:	48 8b 10             	mov    (%rax),%rdx
  8134b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8134b9:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  8134bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134c0:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8134c4:	75 08                	jne    8134ce <tcp_enqueue+0x8b1>
      seg = NULL;
  8134c6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8134cd:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  8134ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8134d2:	48 89 c6             	mov    %rax,%rsi
  8134d5:	bf 04 00 00 00       	mov    $0x4,%edi
  8134da:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  8134e1:	00 00 00 
  8134e4:	ff d0                	callq  *%rax
  8134e6:	eb 23                	jmp    81350b <tcp_enqueue+0x8ee>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  8134e8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8134ed:	75 11                	jne    813500 <tcp_enqueue+0x8e3>
      /* initialize list with this segment */
      pcb->unsent = queue;
  8134ef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8134f3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8134f7:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  8134fe:	eb 0b                	jmp    81350b <tcp_enqueue+0x8ee>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  813500:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813504:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813508:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  81350b:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81350f:	83 e0 02             	and    $0x2,%eax
  813512:	85 c0                	test   %eax,%eax
  813514:	75 0b                	jne    813521 <tcp_enqueue+0x904>
  813516:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81351a:	83 e0 01             	and    $0x1,%eax
  81351d:	84 c0                	test   %al,%al
  81351f:	74 05                	je     813526 <tcp_enqueue+0x909>
    ++len;
  813521:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813526:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81352a:	83 e0 01             	and    $0x1,%eax
  81352d:	84 c0                	test   %al,%al
  81352f:	74 14                	je     813545 <tcp_enqueue+0x928>
    pcb->flags |= TF_FIN;
  813531:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813535:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813539:	89 c2                	mov    %eax,%edx
  81353b:	83 ca 20             	or     $0x20,%edx
  81353e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813542:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  813545:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813549:	8b 50 74             	mov    0x74(%rax),%edx
  81354c:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813550:	01 c2                	add    %eax,%edx
  813552:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813556:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  813559:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81355d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  813561:	89 c2                	mov    %eax,%edx
  813563:	66 2b 55 9c          	sub    -0x64(%rbp),%dx
  813567:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81356b:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  81356f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813573:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  813577:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  81357b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81357f:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813583:	66 85 c0             	test   %ax,%ax
  813586:	74 4a                	je     8135d2 <tcp_enqueue+0x9b5>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  813588:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81358c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813593:	48 85 c0             	test   %rax,%rax
  813596:	75 3a                	jne    8135d2 <tcp_enqueue+0x9b5>
  813598:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81359c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8135a3:	48 85 c0             	test   %rax,%rax
  8135a6:	75 2a                	jne    8135d2 <tcp_enqueue+0x9b5>
  8135a8:	48 ba a0 23 82 00 00 	movabs $0x8223a0,%rdx
  8135af:	00 00 00 
  8135b2:	be 7a 01 00 00       	mov    $0x17a,%esi
  8135b7:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  8135be:	00 00 00 
  8135c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8135c6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8135cd:	00 00 00 
  8135d0:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8135d2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8135d7:	74 5c                	je     813635 <tcp_enqueue+0xa18>
  8135d9:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  8135de:	74 55                	je     813635 <tcp_enqueue+0xa18>
  8135e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135e4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8135e8:	48 85 c0             	test   %rax,%rax
  8135eb:	74 48                	je     813635 <tcp_enqueue+0xa18>
  8135ed:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  8135f1:	83 e0 02             	and    $0x2,%eax
  8135f4:	85 c0                	test   %eax,%eax
  8135f6:	75 3d                	jne    813635 <tcp_enqueue+0xa18>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8135f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8135fc:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813600:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813604:	48 8b 40 20          	mov    0x20(%rax),%rax
  813608:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81360c:	0f b7 c0             	movzwl %ax,%eax
  81360f:	89 c7                	mov    %eax,%edi
  813611:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813618:	00 00 00 
  81361b:	ff d0                	callq  *%rax
  81361d:	83 c8 08             	or     $0x8,%eax
  813620:	0f b7 c0             	movzwl %ax,%eax
  813623:	89 c7                	mov    %eax,%edi
  813625:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81362c:	00 00 00 
  81362f:	ff d0                	callq  *%rax
  813631:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  813635:	b8 00 00 00 00       	mov    $0x0,%eax
  81363a:	e9 9a 00 00 00       	jmpq   8136d9 <tcp_enqueue+0xabc>

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  81363f:	90                   	nop
  813640:	eb 0d                	jmp    81364f <tcp_enqueue+0xa32>
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        goto memerr;
  813642:	90                   	nop
  813643:	eb 0a                	jmp    81364f <tcp_enqueue+0xa32>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  813645:	90                   	nop
  813646:	eb 07                	jmp    81364f <tcp_enqueue+0xa32>
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  813648:	90                   	nop
  813649:	eb 04                	jmp    81364f <tcp_enqueue+0xa32>

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  81364b:	90                   	nop
  81364c:	eb 01                	jmp    81364f <tcp_enqueue+0xa32>

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  81364e:	90                   	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  81364f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813653:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813657:	89 c2                	mov    %eax,%edx
  813659:	83 ca 80             	or     $0xffffff80,%edx
  81365c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813660:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  813663:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813668:	74 13                	je     81367d <tcp_enqueue+0xa60>
    tcp_segs_free(queue);
  81366a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81366e:	48 89 c7             	mov    %rax,%rdi
  813671:	48 b8 8b fe 80 00 00 	movabs $0x80fe8b,%rax
  813678:	00 00 00 
  81367b:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  81367d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813681:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813685:	66 85 c0             	test   %ax,%ax
  813688:	74 4a                	je     8136d4 <tcp_enqueue+0xab7>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  81368a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81368e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813695:	48 85 c0             	test   %rax,%rax
  813698:	75 3a                	jne    8136d4 <tcp_enqueue+0xab7>
  81369a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81369e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8136a5:	48 85 c0             	test   %rax,%rax
  8136a8:	75 2a                	jne    8136d4 <tcp_enqueue+0xab7>
  8136aa:	48 ba a0 23 82 00 00 	movabs $0x8223a0,%rdx
  8136b1:	00 00 00 
  8136b4:	be 8d 01 00 00       	mov    $0x18d,%esi
  8136b9:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  8136c0:	00 00 00 
  8136c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8136c8:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8136cf:	00 00 00 
  8136d2:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  8136d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8136d9:	48 83 c4 70          	add    $0x70,%rsp
  8136dd:	5b                   	pop    %rbx
  8136de:	41 5c                	pop    %r12
  8136e0:	5d                   	pop    %rbp
  8136e1:	c3                   	retq   

00000000008136e2 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8136e2:	55                   	push   %rbp
  8136e3:	48 89 e5             	mov    %rsp,%rbp
  8136e6:	41 54                	push   %r12
  8136e8:	53                   	push   %rbx
  8136e9:	48 83 ec 40          	sub    $0x40,%rsp
  8136ed:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8136f1:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  8136f8:	00 00 00 
  8136fb:	48 8b 00             	mov    (%rax),%rax
  8136fe:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  813702:	75 0a                	jne    81370e <tcp_output+0x2c>
    return ERR_OK;
  813704:	b8 00 00 00 00       	mov    $0x0,%eax
  813709:	e9 c7 06 00 00       	jmpq   813dd5 <tcp_output+0x6f3>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  81370e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813712:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  813716:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81371a:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81371e:	66 39 c2             	cmp    %ax,%dx
  813721:	0f 46 c2             	cmovbe %edx,%eax
  813724:	0f b7 c0             	movzwl %ax,%eax
  813727:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  81372a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81372e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813735:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813739:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81373d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813744:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813748:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81374d:	74 19                	je     813768 <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  81374f:	eb 0b                	jmp    81375c <tcp_output+0x7a>
  813751:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813755:	48 8b 00             	mov    (%rax),%rax
  813758:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81375c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813760:	48 8b 00             	mov    (%rax),%rax
  813763:	48 85 c0             	test   %rax,%rax
  813766:	75 e9                	jne    813751 <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813768:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81376c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813770:	0f b6 c0             	movzbl %al,%eax
  813773:	83 e0 02             	and    $0x2,%eax
  813776:	85 c0                	test   %eax,%eax
  813778:	0f 84 87 05 00 00    	je     813d05 <tcp_output+0x623>
  81377e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813783:	74 3c                	je     8137c1 <tcp_output+0xdf>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  813785:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813789:	48 8b 40 20          	mov    0x20(%rax),%rax
  81378d:	8b 40 04             	mov    0x4(%rax),%eax
  813790:	89 c7                	mov    %eax,%edi
  813792:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813799:	00 00 00 
  81379c:	ff d0                	callq  *%rax
  81379e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8137a2:	8b 52 54             	mov    0x54(%rdx),%edx
  8137a5:	89 c1                	mov    %eax,%ecx
  8137a7:	29 d1                	sub    %edx,%ecx
  8137a9:	89 ca                	mov    %ecx,%edx
  8137ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137af:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8137b3:	0f b7 c0             	movzwl %ax,%eax
  8137b6:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  8137b8:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8137bb:	0f 86 44 05 00 00    	jbe    813d05 <tcp_output+0x623>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8137c1:	ba 00 00 00 00       	mov    $0x0,%edx
  8137c6:	be 14 00 00 00       	mov    $0x14,%esi
  8137cb:	bf 01 00 00 00       	mov    $0x1,%edi
  8137d0:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  8137d7:	00 00 00 
  8137da:	ff d0                	callq  *%rax
  8137dc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  8137e0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8137e5:	75 0a                	jne    8137f1 <tcp_output+0x10f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  8137e7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8137ec:	e9 e4 05 00 00       	jmpq   813dd5 <tcp_output+0x6f3>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8137f1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8137f5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8137f9:	89 c2                	mov    %eax,%edx
  8137fb:	83 e2 fc             	and    $0xfffffffc,%edx
  8137fe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813802:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  813805:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813809:	48 8b 40 08          	mov    0x8(%rax),%rax
  81380d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  813811:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813815:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813819:	0f b7 c0             	movzwl %ax,%eax
  81381c:	89 c7                	mov    %eax,%edi
  81381e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813825:	00 00 00 
  813828:	ff d0                	callq  *%rax
  81382a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81382e:	66 89 02             	mov    %ax,(%rdx)
    tcphdr->dest = htons(pcb->remote_port);
  813831:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813835:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813839:	0f b7 c0             	movzwl %ax,%eax
  81383c:	89 c7                	mov    %eax,%edi
  81383e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813845:	00 00 00 
  813848:	ff d0                	callq  *%rax
  81384a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81384e:	66 89 42 02          	mov    %ax,0x2(%rdx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813852:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813856:	8b 40 60             	mov    0x60(%rax),%eax
  813859:	89 c7                	mov    %eax,%edi
  81385b:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  813862:	00 00 00 
  813865:	ff d0                	callq  *%rax
  813867:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81386b:	89 42 04             	mov    %eax,0x4(%rdx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  81386e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813872:	8b 40 30             	mov    0x30(%rax),%eax
  813875:	89 c7                	mov    %eax,%edi
  813877:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  81387e:	00 00 00 
  813881:	ff d0                	callq  *%rax
  813883:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813887:	89 42 08             	mov    %eax,0x8(%rdx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  81388a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81388e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813892:	0f b7 c0             	movzwl %ax,%eax
  813895:	89 c7                	mov    %eax,%edi
  813897:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81389e:	00 00 00 
  8138a1:	ff d0                	callq  *%rax
  8138a3:	83 e0 c0             	and    $0xffffffc0,%eax
  8138a6:	83 c8 10             	or     $0x10,%eax
  8138a9:	0f b7 c0             	movzwl %ax,%eax
  8138ac:	89 c7                	mov    %eax,%edi
  8138ae:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8138b5:	00 00 00 
  8138b8:	ff d0                	callq  *%rax
  8138ba:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8138be:	66 89 42 0c          	mov    %ax,0xc(%rdx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8138c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8138c6:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8138ca:	0f b7 c0             	movzwl %ax,%eax
  8138cd:	89 c7                	mov    %eax,%edi
  8138cf:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8138d6:	00 00 00 
  8138d9:	ff d0                	callq  *%rax
  8138db:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8138df:	66 89 42 0e          	mov    %ax,0xe(%rdx)
    tcphdr->urgp = 0;
  8138e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8138e7:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8138ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8138f1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8138f5:	0f b7 c0             	movzwl %ax,%eax
  8138f8:	89 c7                	mov    %eax,%edi
  8138fa:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813901:	00 00 00 
  813904:	ff d0                	callq  *%rax
  813906:	83 e0 3f             	and    $0x3f,%eax
  813909:	80 cc 50             	or     $0x50,%ah
  81390c:	0f b7 c0             	movzwl %ax,%eax
  81390f:	89 c7                	mov    %eax,%edi
  813911:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813918:	00 00 00 
  81391b:	ff d0                	callq  *%rax
  81391d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813921:	66 89 42 0c          	mov    %ax,0xc(%rdx)

    tcphdr->chksum = 0;
  813925:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813929:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  81392f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813933:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813937:	0f b7 c8             	movzwl %ax,%ecx
  81393a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81393e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813942:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813946:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81394a:	41 89 c8             	mov    %ecx,%r8d
  81394d:	b9 06 00 00 00       	mov    $0x6,%ecx
  813952:	48 89 c7             	mov    %rax,%rdi
  813955:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  81395c:	00 00 00 
  81395f:	ff d0                	callq  *%rax
  813961:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813965:	66 89 42 10          	mov    %ax,0x10(%rdx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813969:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81396d:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813971:	0f b6 c8             	movzbl %al,%ecx
  813974:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813978:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81397c:	0f b6 d0             	movzbl %al,%edx
  81397f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813983:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813987:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  81398b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81398f:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813995:	41 89 c8             	mov    %ecx,%r8d
  813998:	89 d1                	mov    %edx,%ecx
  81399a:	48 89 fa             	mov    %rdi,%rdx
  81399d:	48 89 c7             	mov    %rax,%rdi
  8139a0:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  8139a7:	00 00 00 
  8139aa:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8139ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8139b0:	48 89 c7             	mov    %rax,%rdi
  8139b3:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8139ba:	00 00 00 
  8139bd:	ff d0                	callq  *%rax

    return ERR_OK;
  8139bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8139c4:	e9 0c 04 00 00       	jmpq   813dd5 <tcp_output+0x6f3>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8139c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8139cd:	48 8b 40 20          	mov    0x20(%rax),%rax
  8139d1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8139d5:	0f b7 c0             	movzwl %ax,%eax
  8139d8:	89 c7                	mov    %eax,%edi
  8139da:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8139e1:	00 00 00 
  8139e4:	ff d0                	callq  *%rax
  8139e6:	0f b7 c0             	movzwl %ax,%eax
  8139e9:	83 e0 04             	and    $0x4,%eax
  8139ec:	85 c0                	test   %eax,%eax
  8139ee:	74 2a                	je     813a1a <tcp_output+0x338>
  8139f0:	48 ba c0 23 82 00 00 	movabs $0x8223c0,%rdx
  8139f7:	00 00 00 
  8139fa:	be 05 02 00 00       	mov    $0x205,%esi
  8139ff:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  813a06:	00 00 00 
  813a09:	b8 00 00 00 00       	mov    $0x0,%eax
  813a0e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  813a15:	00 00 00 
  813a18:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813a1a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a1e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813a25:	48 85 c0             	test   %rax,%rax
  813a28:	74 35                	je     813a5f <tcp_output+0x37d>
  813a2a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a2e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813a32:	0f b6 c0             	movzbl %al,%eax
  813a35:	83 e0 40             	and    $0x40,%eax
  813a38:	85 c0                	test   %eax,%eax
  813a3a:	75 23                	jne    813a5f <tcp_output+0x37d>
  813a3c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a40:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813a47:	48 85 c0             	test   %rax,%rax
  813a4a:	74 1a                	je     813a66 <tcp_output+0x384>
  813a4c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a50:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813a57:	48 8b 00             	mov    (%rax),%rax
  813a5a:	48 85 c0             	test   %rax,%rax
  813a5d:	74 07                	je     813a66 <tcp_output+0x384>
  813a5f:	b8 01 00 00 00       	mov    $0x1,%eax
  813a64:	eb 05                	jmp    813a6b <tcp_output+0x389>
  813a66:	b8 00 00 00 00       	mov    $0x0,%eax
  813a6b:	85 c0                	test   %eax,%eax
  813a6d:	75 18                	jne    813a87 <tcp_output+0x3a5>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  813a6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a73:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813a77:	0f b6 c0             	movzbl %al,%eax
  813a7a:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813a7f:	85 c0                	test   %eax,%eax
  813a81:	0f 84 c3 02 00 00    	je     813d4a <tcp_output+0x668>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  813a87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813a8b:	48 8b 10             	mov    (%rax),%rdx
  813a8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a92:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  813a99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a9d:	8b 40 18             	mov    0x18(%rax),%eax
  813aa0:	83 f8 02             	cmp    $0x2,%eax
  813aa3:	74 51                	je     813af6 <tcp_output+0x414>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  813aa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813aa9:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813aad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ab1:	48 8b 40 20          	mov    0x20(%rax),%rax
  813ab5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813ab9:	0f b7 c0             	movzwl %ax,%eax
  813abc:	89 c7                	mov    %eax,%edi
  813abe:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813ac5:	00 00 00 
  813ac8:	ff d0                	callq  *%rax
  813aca:	83 c8 10             	or     $0x10,%eax
  813acd:	0f b7 c0             	movzwl %ax,%eax
  813ad0:	89 c7                	mov    %eax,%edi
  813ad2:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813ad9:	00 00 00 
  813adc:	ff d0                	callq  *%rax
  813ade:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813ae2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ae6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813aea:	89 c2                	mov    %eax,%edx
  813aec:	83 e2 fc             	and    $0xfffffffc,%edx
  813aef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813af3:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  813af6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813afa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813afe:	48 89 d6             	mov    %rdx,%rsi
  813b01:	48 89 c7             	mov    %rax,%rdi
  813b04:	48 b8 de 3d 81 00 00 	movabs $0x813dde,%rax
  813b0b:	00 00 00 
  813b0e:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  813b10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b14:	48 8b 40 20          	mov    0x20(%rax),%rax
  813b18:	8b 40 04             	mov    0x4(%rax),%eax
  813b1b:	89 c7                	mov    %eax,%edi
  813b1d:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813b24:	00 00 00 
  813b27:	ff d0                	callq  *%rax
  813b29:	89 c3                	mov    %eax,%ebx
  813b2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b2f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813b33:	44 0f b7 e0          	movzwl %ax,%r12d
  813b37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b3b:	48 8b 40 20          	mov    0x20(%rax),%rax
  813b3f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813b43:	0f b7 c0             	movzwl %ax,%eax
  813b46:	89 c7                	mov    %eax,%edi
  813b48:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813b4f:	00 00 00 
  813b52:	ff d0                	callq  *%rax
  813b54:	0f b7 c0             	movzwl %ax,%eax
  813b57:	83 e0 01             	and    $0x1,%eax
  813b5a:	84 c0                	test   %al,%al
  813b5c:	75 27                	jne    813b85 <tcp_output+0x4a3>
  813b5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813b62:	48 8b 40 20          	mov    0x20(%rax),%rax
  813b66:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813b6a:	0f b7 c0             	movzwl %ax,%eax
  813b6d:	89 c7                	mov    %eax,%edi
  813b6f:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813b76:	00 00 00 
  813b79:	ff d0                	callq  *%rax
  813b7b:	0f b7 c0             	movzwl %ax,%eax
  813b7e:	83 e0 02             	and    $0x2,%eax
  813b81:	85 c0                	test   %eax,%eax
  813b83:	74 07                	je     813b8c <tcp_output+0x4aa>
  813b85:	b8 01 00 00 00       	mov    $0x1,%eax
  813b8a:	eb 05                	jmp    813b91 <tcp_output+0x4af>
  813b8c:	b8 00 00 00 00       	mov    $0x0,%eax
  813b91:	44 01 e0             	add    %r12d,%eax
  813b94:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  813b97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b9b:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  813b9e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ba2:	8b 50 64             	mov    0x64(%rax),%edx
  813ba5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813ba9:	8b 40 60             	mov    0x60(%rax),%eax
  813bac:	89 d1                	mov    %edx,%ecx
  813bae:	29 c1                	sub    %eax,%ecx
  813bb0:	89 c8                	mov    %ecx,%eax
  813bb2:	85 c0                	test   %eax,%eax
  813bb4:	79 0e                	jns    813bc4 <tcp_output+0x4e2>
      pcb->snd_max = pcb->snd_nxt;
  813bb6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813bba:	8b 50 60             	mov    0x60(%rax),%edx
  813bbd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813bc1:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  813bc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bc8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813bcc:	0f b7 d8             	movzwl %ax,%ebx
  813bcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bd3:	48 8b 40 20          	mov    0x20(%rax),%rax
  813bd7:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813bdb:	0f b7 c0             	movzwl %ax,%eax
  813bde:	89 c7                	mov    %eax,%edi
  813be0:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813be7:	00 00 00 
  813bea:	ff d0                	callq  *%rax
  813bec:	0f b7 c0             	movzwl %ax,%eax
  813bef:	83 e0 01             	and    $0x1,%eax
  813bf2:	84 c0                	test   %al,%al
  813bf4:	75 27                	jne    813c1d <tcp_output+0x53b>
  813bf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bfa:	48 8b 40 20          	mov    0x20(%rax),%rax
  813bfe:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813c02:	0f b7 c0             	movzwl %ax,%eax
  813c05:	89 c7                	mov    %eax,%edi
  813c07:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  813c0e:	00 00 00 
  813c11:	ff d0                	callq  *%rax
  813c13:	0f b7 c0             	movzwl %ax,%eax
  813c16:	83 e0 02             	and    $0x2,%eax
  813c19:	85 c0                	test   %eax,%eax
  813c1b:	74 07                	je     813c24 <tcp_output+0x542>
  813c1d:	b8 01 00 00 00       	mov    $0x1,%eax
  813c22:	eb 05                	jmp    813c29 <tcp_output+0x547>
  813c24:	b8 00 00 00 00       	mov    $0x0,%eax
  813c29:	01 d8                	add    %ebx,%eax
  813c2b:	85 c0                	test   %eax,%eax
  813c2d:	0f 8e b0 00 00 00    	jle    813ce3 <tcp_output+0x601>
      seg->next = NULL;
  813c33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c37:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  813c3e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c42:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813c49:	48 85 c0             	test   %rax,%rax
  813c4c:	75 1c                	jne    813c6a <tcp_output+0x588>
        pcb->unacked = seg;
  813c4e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c52:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813c56:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  813c5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c61:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813c65:	e9 8c 00 00 00       	jmpq   813cf6 <tcp_output+0x614>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  813c6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c6e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c72:	8b 40 04             	mov    0x4(%rax),%eax
  813c75:	89 c7                	mov    %eax,%edi
  813c77:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813c7e:	00 00 00 
  813c81:	ff d0                	callq  *%rax
  813c83:	89 c3                	mov    %eax,%ebx
  813c85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813c89:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c8d:	8b 40 04             	mov    0x4(%rax),%eax
  813c90:	89 c7                	mov    %eax,%edi
  813c92:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813c99:	00 00 00 
  813c9c:	ff d0                	callq  *%rax
  813c9e:	89 da                	mov    %ebx,%edx
  813ca0:	29 c2                	sub    %eax,%edx
  813ca2:	89 d0                	mov    %edx,%eax
  813ca4:	85 c0                	test   %eax,%eax
  813ca6:	79 23                	jns    813ccb <tcp_output+0x5e9>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  813ca8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cac:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  813cb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cb7:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  813cba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cbe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813cc2:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  813cc9:	eb 2b                	jmp    813cf6 <tcp_output+0x614>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  813ccb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813ccf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813cd3:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  813cd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813cda:	48 8b 00             	mov    (%rax),%rax
  813cdd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813ce1:	eb 13                	jmp    813cf6 <tcp_output+0x614>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  813ce3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ce7:	48 89 c7             	mov    %rax,%rdi
  813cea:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  813cf1:	00 00 00 
  813cf4:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  813cf6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cfa:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813d01:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813d05:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813d0a:	74 3f                	je     813d4b <tcp_output+0x669>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  813d0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d10:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d14:	8b 40 04             	mov    0x4(%rax),%eax
  813d17:	89 c7                	mov    %eax,%edi
  813d19:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813d20:	00 00 00 
  813d23:	ff d0                	callq  *%rax
  813d25:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813d29:	8b 52 54             	mov    0x54(%rdx),%edx
  813d2c:	89 c1                	mov    %eax,%ecx
  813d2e:	29 d1                	sub    %edx,%ecx
  813d30:	89 ca                	mov    %ecx,%edx
  813d32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d36:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813d3a:	0f b7 c0             	movzwl %ax,%eax
  813d3d:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813d3f:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813d42:	0f 86 81 fc ff ff    	jbe    8139c9 <tcp_output+0x2e7>
  813d48:	eb 01                	jmp    813d4b <tcp_output+0x669>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  813d4a:	90                   	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  813d4b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813d50:	74 6a                	je     813dbc <tcp_output+0x6da>
  813d52:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d56:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  813d5d:	84 c0                	test   %al,%al
  813d5f:	75 5b                	jne    813dbc <tcp_output+0x6da>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  813d61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d65:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d69:	8b 40 04             	mov    0x4(%rax),%eax
  813d6c:	89 c7                	mov    %eax,%edi
  813d6e:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813d75:	00 00 00 
  813d78:	ff d0                	callq  *%rax
  813d7a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813d7e:	8b 52 54             	mov    0x54(%rdx),%edx
  813d81:	89 c1                	mov    %eax,%ecx
  813d83:	29 d1                	sub    %edx,%ecx
  813d85:	89 ca                	mov    %ecx,%edx
  813d87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d8b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813d8f:	0f b7 c0             	movzwl %ax,%eax
  813d92:	01 c2                	add    %eax,%edx
  813d94:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d98:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813d9c:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  813d9f:	39 c2                	cmp    %eax,%edx
  813da1:	76 19                	jbe    813dbc <tcp_output+0x6da>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  813da3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813da7:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  813dae:	00 00 00 
    pcb->persist_backoff = 1;
  813db1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813db5:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  813dbc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dc0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813dc4:	89 c2                	mov    %eax,%edx
  813dc6:	83 e2 7f             	and    $0x7f,%edx
  813dc9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813dcd:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  813dd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  813dd5:	48 83 c4 40          	add    $0x40,%rsp
  813dd9:	5b                   	pop    %rbx
  813dda:	41 5c                	pop    %r12
  813ddc:	5d                   	pop    %rbp
  813ddd:	c3                   	retq   

0000000000813dde <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  813dde:	55                   	push   %rbp
  813ddf:	48 89 e5             	mov    %rsp,%rbp
  813de2:	53                   	push   %rbx
  813de3:	48 83 ec 28          	sub    $0x28,%rsp
  813de7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  813deb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  813def:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813df3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813df7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813dfb:	8b 40 30             	mov    0x30(%rax),%eax
  813dfe:	89 c7                	mov    %eax,%edi
  813e00:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  813e07:	00 00 00 
  813e0a:	ff d0                	callq  *%rax
  813e0c:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813e0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813e13:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813e17:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e1b:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813e1f:	0f b7 c0             	movzwl %ax,%eax
  813e22:	89 c7                	mov    %eax,%edi
  813e24:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  813e2b:	00 00 00 
  813e2e:	ff d0                	callq  *%rax
  813e30:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  813e34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e38:	48 85 c0             	test   %rax,%rax
  813e3b:	74 0a                	je     813e47 <tcp_output_segment+0x69>
  813e3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e41:	8b 00                	mov    (%rax),%eax
  813e43:	85 c0                	test   %eax,%eax
  813e45:	75 47                	jne    813e8e <tcp_output_segment+0xb0>
    netif = ip_route(&(pcb->remote_ip));
  813e47:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e4b:	48 83 c0 04          	add    $0x4,%rax
  813e4f:	48 89 c7             	mov    %rax,%rdi
  813e52:	48 b8 40 08 81 00 00 	movabs $0x810840,%rax
  813e59:	00 00 00 
  813e5c:	ff d0                	callq  *%rax
  813e5e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  813e62:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813e67:	0f 84 84 01 00 00    	je     813ff1 <tcp_output_segment+0x213>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  813e6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e71:	48 83 c0 08          	add    $0x8,%rax
  813e75:	48 85 c0             	test   %rax,%rax
  813e78:	74 09                	je     813e83 <tcp_output_segment+0xa5>
  813e7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e7e:	8b 40 08             	mov    0x8(%rax),%eax
  813e81:	eb 05                	jmp    813e88 <tcp_output_segment+0xaa>
  813e83:	b8 00 00 00 00       	mov    $0x0,%eax
  813e88:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  813e8c:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  813e8e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813e92:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  813e96:	66 83 f8 ff          	cmp    $0xffff,%ax
  813e9a:	75 0a                	jne    813ea6 <tcp_output_segment+0xc8>
    pcb->rtime = 0;
  813e9c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813ea0:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  813ea6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813eaa:	8b 40 44             	mov    0x44(%rax),%eax
  813ead:	85 c0                	test   %eax,%eax
  813eaf:	75 33                	jne    813ee4 <tcp_output_segment+0x106>
    pcb->rttest = tcp_ticks;
  813eb1:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  813eb8:	00 00 00 
  813ebb:	8b 10                	mov    (%rax),%edx
  813ebd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813ec1:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  813ec4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813ec8:	48 8b 40 20          	mov    0x20(%rax),%rax
  813ecc:	8b 40 04             	mov    0x4(%rax),%eax
  813ecf:	89 c7                	mov    %eax,%edi
  813ed1:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  813ed8:	00 00 00 
  813edb:	ff d0                	callq  *%rax
  813edd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  813ee1:	89 42 48             	mov    %eax,0x48(%rdx)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  813ee4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813ee8:	48 8b 40 20          	mov    0x20(%rax),%rax
  813eec:	48 89 c2             	mov    %rax,%rdx
  813eef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813ef3:	48 8b 40 08          	mov    0x8(%rax),%rax
  813ef7:	48 8b 40 08          	mov    0x8(%rax),%rax
  813efb:	48 89 d1             	mov    %rdx,%rcx
  813efe:	48 29 c1             	sub    %rax,%rcx
  813f01:	48 89 c8             	mov    %rcx,%rax
  813f04:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  813f08:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f0c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813f10:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813f14:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  813f18:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  813f1c:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  813f20:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  813f24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f28:	48 8b 40 08          	mov    0x8(%rax),%rax
  813f2c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813f30:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  813f34:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  813f38:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  813f3c:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  813f40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f44:	48 8b 40 08          	mov    0x8(%rax),%rax
  813f48:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  813f4c:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  813f50:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  813f54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f58:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f5c:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  813f62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f66:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  813f6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f6e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813f72:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  813f76:	0f b7 c8             	movzwl %ax,%ecx
  813f79:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813f7d:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813f81:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  813f85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813f89:	48 8b 40 08          	mov    0x8(%rax),%rax
  813f8d:	41 89 c8             	mov    %ecx,%r8d
  813f90:	b9 06 00 00 00       	mov    $0x6,%ecx
  813f95:	48 89 c7             	mov    %rax,%rdi
  813f98:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  813f9f:	00 00 00 
  813fa2:	ff d0                	callq  *%rax
  813fa4:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813fa8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fac:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813fb0:	0f b6 c8             	movzbl %al,%ecx
  813fb3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fb7:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813fbb:	0f b6 d0             	movzbl %al,%edx
  813fbe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fc2:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813fc6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  813fca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813fce:	48 8b 40 08          	mov    0x8(%rax),%rax
  813fd2:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813fd8:	41 89 c8             	mov    %ecx,%r8d
  813fdb:	89 d1                	mov    %edx,%ecx
  813fdd:	48 89 fa             	mov    %rdi,%rdx
  813fe0:	48 89 c7             	mov    %rax,%rdi
  813fe3:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  813fea:	00 00 00 
  813fed:	ff d0                	callq  *%rax
  813fef:	eb 01                	jmp    813ff2 <tcp_output_segment+0x214>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
  813ff1:	90                   	nop
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  813ff2:	48 83 c4 28          	add    $0x28,%rsp
  813ff6:	5b                   	pop    %rbx
  813ff7:	5d                   	pop    %rbp
  813ff8:	c3                   	retq   

0000000000813ff9 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  813ff9:	55                   	push   %rbp
  813ffa:	48 89 e5             	mov    %rsp,%rbp
  813ffd:	48 83 ec 30          	sub    $0x30,%rsp
  814001:	89 7d ec             	mov    %edi,-0x14(%rbp)
  814004:	89 75 e8             	mov    %esi,-0x18(%rbp)
  814007:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  81400b:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  81400f:	44 89 c2             	mov    %r8d,%edx
  814012:	44 89 c8             	mov    %r9d,%eax
  814015:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  814019:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  81401d:	ba 00 00 00 00       	mov    $0x0,%edx
  814022:	be 14 00 00 00       	mov    $0x14,%esi
  814027:	bf 01 00 00 00       	mov    $0x1,%edi
  81402c:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  814033:	00 00 00 
  814036:	ff d0                	callq  *%rax
  814038:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  81403c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814041:	0f 84 bb 01 00 00    	je     814202 <tcp_rst+0x209>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814047:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81404b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81404f:	66 83 f8 13          	cmp    $0x13,%ax
  814053:	77 2a                	ja     81407f <tcp_rst+0x86>
  814055:	48 ba d8 23 82 00 00 	movabs $0x8223d8,%rdx
  81405c:	00 00 00 
  81405f:	be be 02 00 00       	mov    $0x2be,%esi
  814064:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  81406b:	00 00 00 
  81406e:	b8 00 00 00 00       	mov    $0x0,%eax
  814073:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81407a:	00 00 00 
  81407d:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  81407f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814083:	48 8b 40 08          	mov    0x8(%rax),%rax
  814087:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  81408b:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  81408f:	89 c7                	mov    %eax,%edi
  814091:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814098:	00 00 00 
  81409b:	ff d0                	callq  *%rax
  81409d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8140a1:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(remote_port);
  8140a4:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8140a8:	89 c7                	mov    %eax,%edi
  8140aa:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8140b1:	00 00 00 
  8140b4:	ff d0                	callq  *%rax
  8140b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8140ba:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(seqno);
  8140be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8140c1:	89 c7                	mov    %eax,%edi
  8140c3:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  8140ca:	00 00 00 
  8140cd:	ff d0                	callq  *%rax
  8140cf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8140d3:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(ackno);
  8140d6:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8140d9:	89 c7                	mov    %eax,%edi
  8140db:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  8140e2:	00 00 00 
  8140e5:	ff d0                	callq  *%rax
  8140e7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8140eb:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8140ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8140f2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8140f6:	0f b7 c0             	movzwl %ax,%eax
  8140f9:	89 c7                	mov    %eax,%edi
  8140fb:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814102:	00 00 00 
  814105:	ff d0                	callq  *%rax
  814107:	83 e0 c0             	and    $0xffffffc0,%eax
  81410a:	83 c8 14             	or     $0x14,%eax
  81410d:	0f b7 c0             	movzwl %ax,%eax
  814110:	89 c7                	mov    %eax,%edi
  814112:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814119:	00 00 00 
  81411c:	ff d0                	callq  *%rax
  81411e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814122:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(TCP_WND);
  814126:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  81412b:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814132:	00 00 00 
  814135:	ff d0                	callq  *%rax
  814137:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81413b:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  81413f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814143:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814149:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81414d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814151:	0f b7 c0             	movzwl %ax,%eax
  814154:	89 c7                	mov    %eax,%edi
  814156:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81415d:	00 00 00 
  814160:	ff d0                	callq  *%rax
  814162:	83 e0 3f             	and    $0x3f,%eax
  814165:	80 cc 50             	or     $0x50,%ah
  814168:	0f b7 c0             	movzwl %ax,%eax
  81416b:	89 c7                	mov    %eax,%edi
  81416d:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814174:	00 00 00 
  814177:	ff d0                	callq  *%rax
  814179:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81417d:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  814181:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814185:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  81418b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81418f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  814193:	0f b7 c8             	movzwl %ax,%ecx
  814196:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81419a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  81419e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8141a2:	41 89 c8             	mov    %ecx,%r8d
  8141a5:	b9 06 00 00 00       	mov    $0x6,%ecx
  8141aa:	48 89 c7             	mov    %rax,%rdi
  8141ad:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  8141b4:	00 00 00 
  8141b7:	ff d0                	callq  *%rax
  8141b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8141bd:	66 89 42 10          	mov    %ax,0x10(%rdx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8141c1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8141c5:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8141c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8141cd:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8141d3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8141d9:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8141de:	48 89 c7             	mov    %rax,%rdi
  8141e1:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  8141e8:	00 00 00 
  8141eb:	ff d0                	callq  *%rax
  pbuf_free(p);
  8141ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8141f1:	48 89 c7             	mov    %rax,%rdi
  8141f4:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8141fb:	00 00 00 
  8141fe:	ff d0                	callq  *%rax
  814200:	eb 01                	jmp    814203 <tcp_rst+0x20a>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  814202:	90                   	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  814203:	c9                   	leaveq 
  814204:	c3                   	retq   

0000000000814205 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  814205:	55                   	push   %rbp
  814206:	48 89 e5             	mov    %rsp,%rbp
  814209:	48 83 ec 20          	sub    $0x20,%rsp
  81420d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  814211:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814215:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81421c:	48 85 c0             	test   %rax,%rax
  81421f:	0f 84 b8 00 00 00    	je     8142dd <tcp_rexmit_rto+0xd8>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  814225:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814229:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814230:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814234:	eb 0b                	jmp    814241 <tcp_rexmit_rto+0x3c>
  814236:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81423a:	48 8b 00             	mov    (%rax),%rax
  81423d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814241:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814245:	48 8b 00             	mov    (%rax),%rax
  814248:	48 85 c0             	test   %rax,%rax
  81424b:	75 e9                	jne    814236 <tcp_rexmit_rto+0x31>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  81424d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814251:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  814258:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81425c:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  81425f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814263:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  81426a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81426e:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  814275:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814279:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  814280:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  814284:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814288:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81428f:	48 8b 40 20          	mov    0x20(%rax),%rax
  814293:	8b 40 04             	mov    0x4(%rax),%eax
  814296:	89 c7                	mov    %eax,%edi
  814298:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81429f:	00 00 00 
  8142a2:	ff d0                	callq  *%rax
  8142a4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8142a8:	89 42 60             	mov    %eax,0x60(%rdx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8142ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142af:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  8142b3:	8d 50 01             	lea    0x1(%rax),%edx
  8142b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142ba:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8142bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142c1:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8142c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142cc:	48 89 c7             	mov    %rax,%rdi
  8142cf:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  8142d6:	00 00 00 
  8142d9:	ff d0                	callq  *%rax
  8142db:	eb 01                	jmp    8142de <tcp_rexmit_rto+0xd9>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  8142dd:	90                   	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
  8142de:	c9                   	leaveq 
  8142df:	c3                   	retq   

00000000008142e0 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8142e0:	55                   	push   %rbp
  8142e1:	48 89 e5             	mov    %rsp,%rbp
  8142e4:	48 83 ec 20          	sub    $0x20,%rsp
  8142e8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8142ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8142f0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8142f7:	48 85 c0             	test   %rax,%rax
  8142fa:	0f 84 a9 00 00 00    	je     8143a9 <tcp_rexmit+0xc9>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  814300:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814304:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81430b:	48 8b 00             	mov    (%rax),%rax
  81430e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  814312:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814316:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81431d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814321:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  814328:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  81432b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81432f:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814336:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81433a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  814341:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814345:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  814349:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  814350:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814354:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81435b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81435f:	8b 40 04             	mov    0x4(%rax),%eax
  814362:	89 c7                	mov    %eax,%edi
  814364:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81436b:	00 00 00 
  81436e:	ff d0                	callq  *%rax
  814370:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814374:	89 42 60             	mov    %eax,0x60(%rdx)

  ++pcb->nrtx;
  814377:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81437b:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  81437f:	8d 50 01             	lea    0x1(%rax),%edx
  814382:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814386:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  814389:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81438d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  814394:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814398:	48 89 c7             	mov    %rax,%rdi
  81439b:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  8143a2:	00 00 00 
  8143a5:	ff d0                	callq  *%rax
  8143a7:	eb 01                	jmp    8143aa <tcp_rexmit+0xca>
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  8143a9:	90                   	nop
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
}
  8143aa:	c9                   	leaveq 
  8143ab:	c3                   	retq   

00000000008143ac <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8143ac:	55                   	push   %rbp
  8143ad:	48 89 e5             	mov    %rsp,%rbp
  8143b0:	48 83 ec 20          	sub    $0x20,%rsp
  8143b4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8143b8:	ba 00 00 00 00       	mov    $0x0,%edx
  8143bd:	be 14 00 00 00       	mov    $0x14,%esi
  8143c2:	bf 01 00 00 00       	mov    $0x1,%edi
  8143c7:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  8143ce:	00 00 00 
  8143d1:	ff d0                	callq  *%rax
  8143d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  8143d7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8143dc:	0f 84 ee 01 00 00    	je     8145d0 <tcp_keepalive+0x224>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8143e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8143e6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8143ea:	66 83 f8 13          	cmp    $0x13,%ax
  8143ee:	77 2a                	ja     81441a <tcp_keepalive+0x6e>
  8143f0:	48 ba d8 23 82 00 00 	movabs $0x8223d8,%rdx
  8143f7:	00 00 00 
  8143fa:	be 3a 03 00 00       	mov    $0x33a,%esi
  8143ff:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  814406:	00 00 00 
  814409:	b8 00 00 00 00       	mov    $0x0,%eax
  81440e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  814415:	00 00 00 
  814418:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  81441a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81441e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814422:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814426:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81442a:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81442e:	0f b7 c0             	movzwl %ax,%eax
  814431:	89 c7                	mov    %eax,%edi
  814433:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81443a:	00 00 00 
  81443d:	ff d0                	callq  *%rax
  81443f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814443:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  814446:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81444a:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81444e:	0f b7 c0             	movzwl %ax,%eax
  814451:	89 c7                	mov    %eax,%edi
  814453:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81445a:	00 00 00 
  81445d:	ff d0                	callq  *%rax
  81445f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814463:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  814467:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81446b:	8b 40 60             	mov    0x60(%rax),%eax
  81446e:	83 e8 01             	sub    $0x1,%eax
  814471:	89 c7                	mov    %eax,%edi
  814473:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  81447a:	00 00 00 
  81447d:	ff d0                	callq  *%rax
  81447f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814483:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814486:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81448a:	8b 40 30             	mov    0x30(%rax),%eax
  81448d:	89 c7                	mov    %eax,%edi
  81448f:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  814496:	00 00 00 
  814499:	ff d0                	callq  *%rax
  81449b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81449f:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8144a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8144a6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8144aa:	0f b7 c0             	movzwl %ax,%eax
  8144ad:	89 c7                	mov    %eax,%edi
  8144af:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8144b6:	00 00 00 
  8144b9:	ff d0                	callq  *%rax
  8144bb:	0f b7 c0             	movzwl %ax,%eax
  8144be:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8144c3:	89 c7                	mov    %eax,%edi
  8144c5:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8144cc:	00 00 00 
  8144cf:	ff d0                	callq  *%rax
  8144d1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8144d5:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8144d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144dd:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8144e1:	0f b7 c0             	movzwl %ax,%eax
  8144e4:	89 c7                	mov    %eax,%edi
  8144e6:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8144ed:	00 00 00 
  8144f0:	ff d0                	callq  *%rax
  8144f2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8144f6:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  8144fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8144fe:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814504:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814508:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81450c:	0f b7 c0             	movzwl %ax,%eax
  81450f:	89 c7                	mov    %eax,%edi
  814511:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814518:	00 00 00 
  81451b:	ff d0                	callq  *%rax
  81451d:	83 e0 3f             	and    $0x3f,%eax
  814520:	80 cc 50             	or     $0x50,%ah
  814523:	0f b7 c0             	movzwl %ax,%eax
  814526:	89 c7                	mov    %eax,%edi
  814528:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81452f:	00 00 00 
  814532:	ff d0                	callq  *%rax
  814534:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814538:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  81453c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814540:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814546:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81454a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  81454e:	0f b7 c8             	movzwl %ax,%ecx
  814551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814555:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814559:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81455d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814561:	41 89 c8             	mov    %ecx,%r8d
  814564:	b9 06 00 00 00       	mov    $0x6,%ecx
  814569:	48 89 c7             	mov    %rax,%rdi
  81456c:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  814573:	00 00 00 
  814576:	ff d0                	callq  *%rax
  814578:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81457c:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814580:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814584:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814588:	0f b6 d0             	movzbl %al,%edx
  81458b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81458f:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814593:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814597:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81459b:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8145a1:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8145a7:	89 d1                	mov    %edx,%ecx
  8145a9:	48 89 fa             	mov    %rdi,%rdx
  8145ac:	48 89 c7             	mov    %rax,%rdi
  8145af:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  8145b6:	00 00 00 
  8145b9:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8145bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145bf:	48 89 c7             	mov    %rax,%rdi
  8145c2:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8145c9:	00 00 00 
  8145cc:	ff d0                	callq  *%rax
  8145ce:	eb 01                	jmp    8145d1 <tcp_keepalive+0x225>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  8145d0:	90                   	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8145d1:	c9                   	leaveq 
  8145d2:	c3                   	retq   

00000000008145d3 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8145d3:	55                   	push   %rbp
  8145d4:	48 89 e5             	mov    %rsp,%rbp
  8145d7:	48 83 ec 30          	sub    $0x30,%rsp
  8145db:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8145df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145e3:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8145ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  8145ee:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8145f3:	75 0f                	jne    814604 <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  8145f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8145f9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  814600:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  814604:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814609:	0f 84 24 02 00 00    	je     814833 <tcp_zero_window_probe+0x260>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  81460f:	ba 00 00 00 00       	mov    $0x0,%edx
  814614:	be 15 00 00 00       	mov    $0x15,%esi
  814619:	bf 01 00 00 00       	mov    $0x1,%edi
  81461e:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  814625:	00 00 00 
  814628:	ff d0                	callq  *%rax
  81462a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  81462e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814633:	0f 84 fd 01 00 00    	je     814836 <tcp_zero_window_probe+0x263>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814639:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81463d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814641:	66 83 f8 13          	cmp    $0x13,%ax
  814645:	77 2a                	ja     814671 <tcp_zero_window_probe+0x9e>
  814647:	48 ba d8 23 82 00 00 	movabs $0x8223d8,%rdx
  81464e:	00 00 00 
  814651:	be 8d 03 00 00       	mov    $0x38d,%esi
  814656:	48 bf 47 22 82 00 00 	movabs $0x822247,%rdi
  81465d:	00 00 00 
  814660:	b8 00 00 00 00       	mov    $0x0,%eax
  814665:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81466c:	00 00 00 
  81466f:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814671:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814675:	48 8b 40 08          	mov    0x8(%rax),%rax
  814679:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  81467d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814681:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814685:	0f b7 c0             	movzwl %ax,%eax
  814688:	89 c7                	mov    %eax,%edi
  81468a:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814691:	00 00 00 
  814694:	ff d0                	callq  *%rax
  814696:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81469a:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  81469d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8146a1:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  8146a5:	0f b7 c0             	movzwl %ax,%eax
  8146a8:	89 c7                	mov    %eax,%edi
  8146aa:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8146b1:	00 00 00 
  8146b4:	ff d0                	callq  *%rax
  8146b6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8146ba:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8146be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8146c2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8146c6:	8b 50 04             	mov    0x4(%rax),%edx
  8146c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146cd:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8146d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8146d4:	8b 40 30             	mov    0x30(%rax),%eax
  8146d7:	89 c7                	mov    %eax,%edi
  8146d9:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  8146e0:	00 00 00 
  8146e3:	ff d0                	callq  *%rax
  8146e5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8146e9:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8146ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146f0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8146f4:	0f b7 c0             	movzwl %ax,%eax
  8146f7:	89 c7                	mov    %eax,%edi
  8146f9:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814700:	00 00 00 
  814703:	ff d0                	callq  *%rax
  814705:	0f b7 c0             	movzwl %ax,%eax
  814708:	25 c0 ff 00 00       	and    $0xffc0,%eax
  81470d:	89 c7                	mov    %eax,%edi
  81470f:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814716:	00 00 00 
  814719:	ff d0                	callq  *%rax
  81471b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81471f:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814723:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814727:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81472b:	0f b7 c0             	movzwl %ax,%eax
  81472e:	89 c7                	mov    %eax,%edi
  814730:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814737:	00 00 00 
  81473a:	ff d0                	callq  *%rax
  81473c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814740:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814744:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814748:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  81474e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814752:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814756:	0f b7 c0             	movzwl %ax,%eax
  814759:	89 c7                	mov    %eax,%edi
  81475b:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814762:	00 00 00 
  814765:	ff d0                	callq  *%rax
  814767:	83 e0 3f             	and    $0x3f,%eax
  81476a:	80 cc 50             	or     $0x50,%ah
  81476d:	0f b7 c0             	movzwl %ax,%eax
  814770:	89 c7                	mov    %eax,%edi
  814772:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814779:	00 00 00 
  81477c:	ff d0                	callq  *%rax
  81477e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814782:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  814786:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81478a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81478e:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814792:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814796:	48 8b 40 10          	mov    0x10(%rax),%rax
  81479a:	0f b6 00             	movzbl (%rax),%eax
  81479d:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  81479f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8147a3:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  8147a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147ad:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8147b1:	0f b7 c8             	movzwl %ax,%ecx
  8147b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147b8:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8147bc:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8147c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147c4:	41 89 c8             	mov    %ecx,%r8d
  8147c7:	b9 06 00 00 00       	mov    $0x6,%ecx
  8147cc:	48 89 c7             	mov    %rax,%rdi
  8147cf:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  8147d6:	00 00 00 
  8147d9:	ff d0                	callq  *%rax
  8147db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8147df:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8147e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147e7:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8147eb:	0f b6 d0             	movzbl %al,%edx
  8147ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147f2:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8147f6:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8147fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8147fe:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814804:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81480a:	89 d1                	mov    %edx,%ecx
  81480c:	48 89 fa             	mov    %rdi,%rdx
  81480f:	48 89 c7             	mov    %rax,%rdi
  814812:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  814819:	00 00 00 
  81481c:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  81481e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814822:	48 89 c7             	mov    %rax,%rdi
  814825:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81482c:	00 00 00 
  81482f:	ff d0                	callq  *%rax
  814831:	eb 04                	jmp    814837 <tcp_zero_window_probe+0x264>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
  814833:	90                   	nop
  814834:	eb 01                	jmp    814837 <tcp_zero_window_probe+0x264>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  814836:	90                   	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814837:	c9                   	leaveq 
  814838:	c3                   	retq   
  814839:	00 00                	add    %al,(%rax)
	...

000000000081483c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  81483c:	55                   	push   %rbp
  81483d:	48 89 e5             	mov    %rsp,%rbp
  814840:	53                   	push   %rbx
  814841:	48 83 ec 58          	sub    $0x58,%rsp
  814845:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814849:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  81484d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814851:	48 8b 40 08          	mov    0x8(%rax),%rax
  814855:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814859:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81485d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814861:	0f b7 d8             	movzwl %ax,%ebx
  814864:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814868:	0f b7 00             	movzwl (%rax),%eax
  81486b:	0f b7 c0             	movzwl %ax,%eax
  81486e:	89 c7                	mov    %eax,%edi
  814870:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814877:	00 00 00 
  81487a:	ff d0                	callq  *%rax
  81487c:	66 c1 e8 08          	shr    $0x8,%ax
  814880:	0f b7 c0             	movzwl %ax,%eax
  814883:	83 e0 0f             	and    $0xf,%eax
  814886:	83 c0 02             	add    $0x2,%eax
  814889:	c1 e0 02             	shl    $0x2,%eax
  81488c:	39 c3                	cmp    %eax,%ebx
  81488e:	7c 40                	jl     8148d0 <udp_input+0x94>
  814890:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814894:	0f b7 00             	movzwl (%rax),%eax
  814897:	0f b7 c0             	movzwl %ax,%eax
  81489a:	89 c7                	mov    %eax,%edi
  81489c:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8148a3:	00 00 00 
  8148a6:	ff d0                	callq  *%rax
  8148a8:	66 c1 e8 08          	shr    $0x8,%ax
  8148ac:	83 e0 0f             	and    $0xf,%eax
  8148af:	c1 e0 02             	shl    $0x2,%eax
  8148b2:	f7 d8                	neg    %eax
  8148b4:	0f bf d0             	movswl %ax,%edx
  8148b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8148bb:	89 d6                	mov    %edx,%esi
  8148bd:	48 89 c7             	mov    %rax,%rdi
  8148c0:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  8148c7:	00 00 00 
  8148ca:	ff d0                	callq  *%rax
  8148cc:	84 c0                	test   %al,%al
  8148ce:	74 18                	je     8148e8 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  8148d0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8148d4:	48 89 c7             	mov    %rax,%rdi
  8148d7:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8148de:	00 00 00 
  8148e1:	ff d0                	callq  *%rax
    goto end;
  8148e3:	e9 6b 04 00 00       	jmpq   814d53 <udp_input+0x517>
  }

  udphdr = (struct udp_hdr *)p->payload;
  8148e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8148ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  8148f0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  8148f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8148f8:	0f b7 00             	movzwl (%rax),%eax
  8148fb:	0f b7 c0             	movzwl %ax,%eax
  8148fe:	89 c7                	mov    %eax,%edi
  814900:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814907:	00 00 00 
  81490a:	ff d0                	callq  *%rax
  81490c:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814910:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814914:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814918:	0f b7 c0             	movzwl %ax,%eax
  81491b:	89 c7                	mov    %eax,%edi
  81491d:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814924:	00 00 00 
  814927:	ff d0                	callq  *%rax
  814929:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  81492d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814934:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814935:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  81493a:	0f 85 8c 00 00 00    	jne    8149cc <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814940:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814945:	0f 85 d6 01 00 00    	jne    814b21 <udp_input+0x2e5>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  81494b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81494f:	48 8b 40 38          	mov    0x38(%rax),%rax
  814953:	48 85 c0             	test   %rax,%rax
  814956:	0f 84 c5 01 00 00    	je     814b21 <udp_input+0x2e5>
  81495c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814960:	48 8b 40 38          	mov    0x38(%rax),%rax
  814964:	48 8b 40 08          	mov    0x8(%rax),%rax
  814968:	48 85 c0             	test   %rax,%rax
  81496b:	0f 84 b0 01 00 00    	je     814b21 <udp_input+0x2e5>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814971:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814975:	48 8b 40 38          	mov    0x38(%rax),%rax
  814979:	48 8b 40 08          	mov    0x8(%rax),%rax
  81497d:	48 83 c0 04          	add    $0x4,%rax
  814981:	48 85 c0             	test   %rax,%rax
  814984:	74 31                	je     8149b7 <udp_input+0x17b>
  814986:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81498a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81498e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814992:	8b 40 04             	mov    0x4(%rax),%eax
  814995:	85 c0                	test   %eax,%eax
  814997:	74 1e                	je     8149b7 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814999:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81499d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8149a1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8149a5:	8b 50 04             	mov    0x4(%rax),%edx
  8149a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8149ac:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  8149af:	39 c2                	cmp    %eax,%edx
  8149b1:	0f 85 6a 01 00 00    	jne    814b21 <udp_input+0x2e5>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  8149b7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8149bb:	48 8b 40 38          	mov    0x38(%rax),%rax
  8149bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8149c3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8149c7:	e9 55 01 00 00       	jmpq   814b21 <udp_input+0x2e5>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  8149cc:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8149d3:	00 
    local_match = 0;
  8149d4:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  8149d8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8149df:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8149e0:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8149e7:	00 00 00 
  8149ea:	48 8b 00             	mov    (%rax),%rax
  8149ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8149f1:	e9 0e 01 00 00       	jmpq   814b04 <udp_input+0x2c8>
      local_match = 0;
  8149f6:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  8149fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8149fe:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814a02:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  814a06:	75 6b                	jne    814a73 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  814a08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814a0c:	48 85 c0             	test   %rax,%rax
  814a0f:	74 3d                	je     814a4e <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  814a11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a15:	8b 00                	mov    (%rax),%eax
  814a17:	85 c0                	test   %eax,%eax
  814a19:	74 33                	je     814a4e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814a1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a1f:	8b 10                	mov    (%rax),%edx
  814a21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814a25:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  814a28:	39 c2                	cmp    %eax,%edx
  814a2a:	74 22                	je     814a4e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  814a2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814a30:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814a34:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814a38:	48 89 c6             	mov    %rax,%rsi
  814a3b:	48 89 d7             	mov    %rdx,%rdi
  814a3e:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  814a45:	00 00 00 
  814a48:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814a4a:	84 c0                	test   %al,%al
  814a4c:	74 25                	je     814a73 <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  814a4e:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  814a52:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  814a57:	75 1a                	jne    814a73 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  814a59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a5d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814a61:	0f b6 c0             	movzbl %al,%eax
  814a64:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  814a67:	85 c0                	test   %eax,%eax
  814a69:	75 08                	jne    814a73 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  814a6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a6f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814a73:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  814a77:	74 77                	je     814af0 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  814a79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a7d:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814a81:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  814a85:	75 69                	jne    814af0 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814a87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a8b:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  814a8f:	48 85 c0             	test   %rax,%rax
  814a92:	74 1d                	je     814ab1 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  814a94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814a98:	8b 40 04             	mov    0x4(%rax),%eax
  814a9b:	85 c0                	test   %eax,%eax
  814a9d:	74 12                	je     814ab1 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  814a9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814aa3:	8b 50 04             	mov    0x4(%rax),%edx
  814aa6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814aaa:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814aad:	39 c2                	cmp    %eax,%edx
  814aaf:	75 3f                	jne    814af0 <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  814ab1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814ab6:	74 59                	je     814b11 <udp_input+0x2d5>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  814ab8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814abc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814ac0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814ac4:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  814ac8:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814acf:	00 00 00 
  814ad2:	48 8b 10             	mov    (%rax),%rdx
  814ad5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ad9:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  814add:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814ae4:	00 00 00 
  814ae7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814aeb:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  814aee:	eb 21                	jmp    814b11 <udp_input+0x2d5>
      }
      prev = pcb;
  814af0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814af4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814af8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814afc:	48 8b 40 10          	mov    0x10(%rax),%rax
  814b00:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814b04:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814b09:	0f 85 e7 fe ff ff    	jne    8149f6 <udp_input+0x1ba>
  814b0f:	eb 01                	jmp    814b12 <udp_input+0x2d6>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  814b11:	90                   	nop
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  814b12:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814b17:	75 08                	jne    814b21 <udp_input+0x2e5>
      pcb = uncon_pcb;
  814b19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814b1d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  814b21:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814b26:	75 16                	jne    814b3e <udp_input+0x302>
  814b28:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b2c:	8b 50 08             	mov    0x8(%rax),%edx
  814b2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814b33:	8b 40 10             	mov    0x10(%rax),%eax
  814b36:	39 c2                	cmp    %eax,%edx
  814b38:	0f 85 02 02 00 00    	jne    814d40 <udp_input+0x504>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  814b3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814b42:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  814b46:	66 85 c0             	test   %ax,%ax
  814b49:	74 53                	je     814b9e <udp_input+0x362>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  814b4b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814b4f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  814b53:	0f b7 c8             	movzwl %ax,%ecx
  814b56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814b5a:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814b5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814b62:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  814b66:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814b6a:	41 89 c8             	mov    %ecx,%r8d
  814b6d:	b9 11 00 00 00       	mov    $0x11,%ecx
  814b72:	48 89 c7             	mov    %rax,%rdi
  814b75:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  814b7c:	00 00 00 
  814b7f:	ff d0                	callq  *%rax
  814b81:	66 85 c0             	test   %ax,%ax
  814b84:	74 18                	je     814b9e <udp_input+0x362>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  814b86:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814b8a:	48 89 c7             	mov    %rax,%rdi
  814b8d:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  814b94:	00 00 00 
  814b97:	ff d0                	callq  *%rax
          goto end;
  814b99:	e9 b5 01 00 00       	jmpq   814d53 <udp_input+0x517>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  814b9e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ba2:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  814ba7:	48 89 c7             	mov    %rax,%rdi
  814baa:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  814bb1:	00 00 00 
  814bb4:	ff d0                	callq  *%rax
  814bb6:	84 c0                	test   %al,%al
  814bb8:	74 2a                	je     814be4 <udp_input+0x3a8>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  814bba:	48 ba 08 24 82 00 00 	movabs $0x822408,%rdx
  814bc1:	00 00 00 
  814bc4:	be 0a 01 00 00       	mov    $0x10a,%esi
  814bc9:	48 bf 1c 24 82 00 00 	movabs $0x82241c,%rdi
  814bd0:	00 00 00 
  814bd3:	b8 00 00 00 00       	mov    $0x0,%eax
  814bd8:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  814bdf:	00 00 00 
  814be2:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814be4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814be9:	74 57                	je     814c42 <udp_input+0x406>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  814beb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bef:	48 8b 40 20          	mov    0x20(%rax),%rax
  814bf3:	48 85 c0             	test   %rax,%rax
  814bf6:	74 32                	je     814c2a <udp_input+0x3ee>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  814bf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bfc:	4c 8b 48 20          	mov    0x20(%rax),%r9
  814c00:	0f b7 7d be          	movzwl -0x42(%rbp),%edi
  814c04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c08:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  814c0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c10:	48 8b 40 28          	mov    0x28(%rax),%rax
  814c14:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  814c18:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814c1c:	41 89 f8             	mov    %edi,%r8d
  814c1f:	48 89 c7             	mov    %rax,%rdi
  814c22:	41 ff d1             	callq  *%r9
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814c25:	e9 29 01 00 00       	jmpq   814d53 <udp_input+0x517>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  814c2a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814c2e:	48 89 c7             	mov    %rax,%rdi
  814c31:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  814c38:	00 00 00 
  814c3b:	ff d0                	callq  *%rax
        goto end;
  814c3d:	e9 11 01 00 00       	jmpq   814d53 <udp_input+0x517>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814c42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c46:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814c4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814c4e:	48 89 c6             	mov    %rax,%rsi
  814c51:	48 89 d7             	mov    %rdx,%rdi
  814c54:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  814c5b:	00 00 00 
  814c5e:	ff d0                	callq  *%rax
  814c60:	84 c0                	test   %al,%al
  814c62:	0f 85 c3 00 00 00    	jne    814d2b <udp_input+0x4ef>
          !ip_addr_ismulticast(&iphdr->dest)) {
  814c68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c6c:	8b 58 10             	mov    0x10(%rax),%ebx
  814c6f:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  814c74:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  814c7b:	00 00 00 
  814c7e:	ff d0                	callq  *%rax
  814c80:	21 c3                	and    %eax,%ebx
  814c82:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  814c87:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  814c8e:	00 00 00 
  814c91:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814c93:	39 c3                	cmp    %eax,%ebx
  814c95:	0f 84 90 00 00 00    	je     814d2b <udp_input+0x4ef>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  814c9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c9f:	0f b7 00             	movzwl (%rax),%eax
  814ca2:	0f b7 c0             	movzwl %ax,%eax
  814ca5:	89 c7                	mov    %eax,%edi
  814ca7:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  814cae:	00 00 00 
  814cb1:	ff d0                	callq  *%rax
  814cb3:	66 c1 e8 08          	shr    $0x8,%ax
  814cb7:	0f b7 c0             	movzwl %ax,%eax
  814cba:	83 e0 0f             	and    $0xf,%eax
  814cbd:	83 c0 02             	add    $0x2,%eax
  814cc0:	c1 e0 02             	shl    $0x2,%eax
  814cc3:	0f bf d0             	movswl %ax,%edx
  814cc6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814cca:	89 d6                	mov    %edx,%esi
  814ccc:	48 89 c7             	mov    %rax,%rdi
  814ccf:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  814cd6:	00 00 00 
  814cd9:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  814cdb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814cdf:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ce3:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  814ce7:	74 2a                	je     814d13 <udp_input+0x4d7>
  814ce9:	48 ba 30 24 82 00 00 	movabs $0x822430,%rdx
  814cf0:	00 00 00 
  814cf3:	be 25 01 00 00       	mov    $0x125,%esi
  814cf8:	48 bf 1c 24 82 00 00 	movabs $0x82241c,%rdi
  814cff:	00 00 00 
  814d02:	b8 00 00 00 00       	mov    $0x0,%eax
  814d07:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  814d0e:	00 00 00 
  814d11:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  814d13:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d17:	be 03 00 00 00       	mov    $0x3,%esi
  814d1c:	48 89 c7             	mov    %rax,%rdi
  814d1f:	48 b8 e2 01 82 00 00 	movabs $0x8201e2,%rax
  814d26:	00 00 00 
  814d29:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  814d2b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d2f:	48 89 c7             	mov    %rax,%rdi
  814d32:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  814d39:	00 00 00 
  814d3c:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814d3e:	eb 13                	jmp    814d53 <udp_input+0x517>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  814d40:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d44:	48 89 c7             	mov    %rax,%rdi
  814d47:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  814d4e:	00 00 00 
  814d51:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  814d53:	48 83 c4 58          	add    $0x58,%rsp
  814d57:	5b                   	pop    %rbx
  814d58:	5d                   	pop    %rbp
  814d59:	c3                   	retq   

0000000000814d5a <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  814d5a:	55                   	push   %rbp
  814d5b:	48 89 e5             	mov    %rsp,%rbp
  814d5e:	48 83 ec 10          	sub    $0x10,%rsp
  814d62:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  814d66:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  814d6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d6e:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  814d72:	0f b7 d0             	movzwl %ax,%edx
  814d75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d79:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814d7d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  814d81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814d85:	89 d1                	mov    %edx,%ecx
  814d87:	48 89 fa             	mov    %rdi,%rdx
  814d8a:	48 89 c7             	mov    %rax,%rdi
  814d8d:	48 b8 9b 4d 81 00 00 	movabs $0x814d9b,%rax
  814d94:	00 00 00 
  814d97:	ff d0                	callq  *%rax
}
  814d99:	c9                   	leaveq 
  814d9a:	c3                   	retq   

0000000000814d9b <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  814d9b:	55                   	push   %rbp
  814d9c:	48 89 e5             	mov    %rsp,%rbp
  814d9f:	48 83 ec 30          	sub    $0x30,%rsp
  814da3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  814da7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  814dab:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  814daf:	89 c8                	mov    %ecx,%eax
  814db1:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  814db5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814db9:	48 89 c7             	mov    %rax,%rdi
  814dbc:	48 b8 40 08 81 00 00 	movabs $0x810840,%rax
  814dc3:	00 00 00 
  814dc6:	ff d0                	callq  *%rax
  814dc8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  814dcc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814dd1:	75 07                	jne    814dda <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  814dd3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  814dd8:	eb 26                	jmp    814e00 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  814dda:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  814dde:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  814de2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814de6:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  814dea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dee:	49 89 f8             	mov    %rdi,%r8
  814df1:	48 89 c7             	mov    %rax,%rdi
  814df4:	48 b8 02 4e 81 00 00 	movabs $0x814e02,%rax
  814dfb:	00 00 00 
  814dfe:	ff d0                	callq  *%rax
}
  814e00:	c9                   	leaveq 
  814e01:	c3                   	retq   

0000000000814e02 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  814e02:	55                   	push   %rbp
  814e03:	48 89 e5             	mov    %rsp,%rbp
  814e06:	48 83 ec 60          	sub    $0x60,%rsp
  814e0a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  814e0e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  814e12:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  814e16:	89 c8                	mov    %ecx,%eax
  814e18:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  814e1c:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  814e20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814e24:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814e28:	66 85 c0             	test   %ax,%ax
  814e2b:	75 37                	jne    814e64 <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  814e2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814e31:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814e35:	0f b7 d0             	movzwl %ax,%edx
  814e38:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  814e3c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814e40:	48 89 ce             	mov    %rcx,%rsi
  814e43:	48 89 c7             	mov    %rax,%rdi
  814e46:	48 b8 b3 50 81 00 00 	movabs $0x8150b3,%rax
  814e4d:	00 00 00 
  814e50:	ff d0                	callq  *%rax
  814e52:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  814e55:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  814e59:	74 09                	je     814e64 <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  814e5b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  814e5f:	e9 4d 02 00 00       	jmpq   8150b1 <udp_sendto_if+0x2af>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  814e64:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814e68:	be 08 00 00 00       	mov    $0x8,%esi
  814e6d:	48 89 c7             	mov    %rax,%rdi
  814e70:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  814e77:	00 00 00 
  814e7a:	ff d0                	callq  *%rax
  814e7c:	84 c0                	test   %al,%al
  814e7e:	74 4c                	je     814ecc <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  814e80:	ba 00 00 00 00       	mov    $0x0,%edx
  814e85:	be 08 00 00 00       	mov    $0x8,%esi
  814e8a:	bf 01 00 00 00       	mov    $0x1,%edi
  814e8f:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  814e96:	00 00 00 
  814e99:	ff d0                	callq  *%rax
  814e9b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  814e9f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814ea4:	75 0a                	jne    814eb0 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  814ea6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  814eab:	e9 01 02 00 00       	jmpq   8150b1 <udp_sendto_if+0x2af>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  814eb0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  814eb4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814eb8:	48 89 d6             	mov    %rdx,%rsi
  814ebb:	48 89 c7             	mov    %rax,%rdi
  814ebe:	48 b8 76 da 80 00 00 	movabs $0x80da76,%rax
  814ec5:	00 00 00 
  814ec8:	ff d0                	callq  *%rax
  814eca:	eb 08                	jmp    814ed4 <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  814ecc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814ed0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  814ed4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ed8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814edc:	66 83 f8 07          	cmp    $0x7,%ax
  814ee0:	77 2a                	ja     814f0c <udp_sendto_if+0x10a>
  814ee2:	48 ba 48 24 82 00 00 	movabs $0x822448,%rdx
  814ee9:	00 00 00 
  814eec:	be b2 01 00 00       	mov    $0x1b2,%esi
  814ef1:	48 bf 1c 24 82 00 00 	movabs $0x82241c,%rdi
  814ef8:	00 00 00 
  814efb:	b8 00 00 00 00       	mov    $0x0,%eax
  814f00:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  814f07:	00 00 00 
  814f0a:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  814f0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814f10:	48 8b 40 08          	mov    0x8(%rax),%rax
  814f14:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  814f18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814f1c:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814f20:	0f b7 c0             	movzwl %ax,%eax
  814f23:	89 c7                	mov    %eax,%edi
  814f25:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814f2c:	00 00 00 
  814f2f:	ff d0                	callq  *%rax
  814f31:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  814f35:	66 89 02             	mov    %ax,(%rdx)
  udphdr->dest = htons(dst_port);
  814f38:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  814f3c:	89 c7                	mov    %eax,%edi
  814f3e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814f45:	00 00 00 
  814f48:	ff d0                	callq  *%rax
  814f4a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  814f4e:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  814f52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814f56:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  814f5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814f60:	48 85 c0             	test   %rax,%rax
  814f63:	74 0a                	je     814f6f <udp_sendto_if+0x16d>
  814f65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814f69:	8b 00                	mov    (%rax),%eax
  814f6b:	85 c0                	test   %eax,%eax
  814f6d:	75 0e                	jne    814f7d <udp_sendto_if+0x17b>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  814f6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814f73:	48 83 c0 08          	add    $0x8,%rax
  814f77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814f7b:	eb 48                	jmp    814fc5 <udp_sendto_if+0x1c3>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  814f7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814f81:	8b 10                	mov    (%rax),%edx
  814f83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  814f87:	8b 40 08             	mov    0x8(%rax),%eax
  814f8a:	39 c2                	cmp    %eax,%edx
  814f8c:	74 2f                	je     814fbd <udp_sendto_if+0x1bb>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  814f8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814f92:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  814f96:	74 1b                	je     814fb3 <udp_sendto_if+0x1b1>
        /* free the header pbuf */
        pbuf_free(q);
  814f98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814f9c:	48 89 c7             	mov    %rax,%rdi
  814f9f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  814fa6:	00 00 00 
  814fa9:	ff d0                	callq  *%rax
        q = NULL;
  814fab:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  814fb2:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  814fb3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  814fb8:	e9 f4 00 00 00       	jmpq   8150b1 <udp_sendto_if+0x2af>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  814fbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814fc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  814fc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814fc9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814fcd:	0f b7 c0             	movzwl %ax,%eax
  814fd0:	89 c7                	mov    %eax,%edi
  814fd2:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  814fd9:	00 00 00 
  814fdc:	ff d0                	callq  *%rax
  814fde:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  814fe2:	66 89 42 04          	mov    %ax,0x4(%rdx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  814fe6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814fea:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814fee:	0f b6 c0             	movzbl %al,%eax
  814ff1:	83 e0 01             	and    $0x1,%eax
  814ff4:	85 c0                	test   %eax,%eax
  814ff6:	75 4d                	jne    815045 <udp_sendto_if+0x243>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  814ff8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814ffc:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  815000:	0f b7 c8             	movzwl %ax,%ecx
  815003:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815007:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81500b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81500f:	41 89 c8             	mov    %ecx,%r8d
  815012:	b9 11 00 00 00       	mov    $0x11,%ecx
  815017:	48 89 c7             	mov    %rax,%rdi
  81501a:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  815021:	00 00 00 
  815024:	ff d0                	callq  *%rax
  815026:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81502a:	66 89 42 06          	mov    %ax,0x6(%rdx)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  81502e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815032:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  815036:	66 85 c0             	test   %ax,%ax
  815039:	75 0a                	jne    815045 <udp_sendto_if+0x243>
  81503b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81503f:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  815045:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815049:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81504d:	44 0f b6 c0          	movzbl %al,%r8d
  815051:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815055:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  815059:	0f b6 c8             	movzbl %al,%ecx
  81505c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815060:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  815064:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815068:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  81506c:	48 89 3c 24          	mov    %rdi,(%rsp)
  815070:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  815076:	48 89 c7             	mov    %rax,%rdi
  815079:	48 b8 77 0d 81 00 00 	movabs $0x810d77,%rax
  815080:	00 00 00 
  815083:	ff d0                	callq  *%rax
  815085:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  815088:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81508c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  815090:	74 1b                	je     8150ad <udp_sendto_if+0x2ab>
    /* free the header pbuf */
    pbuf_free(q);
  815092:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815096:	48 89 c7             	mov    %rax,%rdi
  815099:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8150a0:	00 00 00 
  8150a3:	ff d0                	callq  *%rax
    q = NULL;
  8150a5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8150ac:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8150ad:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  8150b1:	c9                   	leaveq 
  8150b2:	c3                   	retq   

00000000008150b3 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8150b3:	55                   	push   %rbp
  8150b4:	48 89 e5             	mov    %rsp,%rbp
  8150b7:	48 83 ec 30          	sub    $0x30,%rsp
  8150bb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8150bf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8150c3:	89 d0                	mov    %edx,%eax
  8150c5:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  8150c9:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8150cd:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8150d4:	00 00 00 
  8150d7:	48 8b 00             	mov    (%rax),%rax
  8150da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8150de:	eb 4a                	jmp    81512a <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  8150e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8150e4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8150e8:	75 34                	jne    81511e <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  8150ea:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8150ee:	74 2a                	je     81511a <udp_bind+0x67>
  8150f0:	48 ba 76 24 82 00 00 	movabs $0x822476,%rdx
  8150f7:	00 00 00 
  8150fa:	be 41 02 00 00       	mov    $0x241,%esi
  8150ff:	48 bf 1c 24 82 00 00 	movabs $0x82241c,%rdi
  815106:	00 00 00 
  815109:	b8 00 00 00 00       	mov    $0x0,%eax
  81510e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815115:	00 00 00 
  815118:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  81511a:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  81511e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815122:	48 8b 40 10          	mov    0x10(%rax),%rax
  815126:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81512a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81512f:	75 af                	jne    8150e0 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  815131:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815136:	74 08                	je     815140 <udp_bind+0x8d>
  815138:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81513c:	8b 00                	mov    (%rax),%eax
  81513e:	eb 05                	jmp    815145 <udp_bind+0x92>
  815140:	b8 00 00 00 00       	mov    $0x0,%eax
  815145:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815149:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  81514b:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  815150:	75 68                	jne    8151ba <udp_bind+0x107>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815152:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  815158:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81515f:	00 00 00 
  815162:	48 8b 00             	mov    (%rax),%rax
  815165:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  815169:	eb 32                	jmp    81519d <udp_bind+0xea>
      if (ipcb->local_port == port) {
  81516b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81516f:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815173:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  815177:	75 18                	jne    815191 <udp_bind+0xde>
        /* port is already used by another udp_pcb */
        port++;
  815179:	66 83 45 dc 01       	addw   $0x1,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  81517e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815185:	00 00 00 
  815188:	48 8b 00             	mov    (%rax),%rax
  81518b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81518f:	eb 0c                	jmp    81519d <udp_bind+0xea>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  815191:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815195:	48 8b 40 10          	mov    0x10(%rax),%rax
  815199:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  81519d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8151a2:	74 08                	je     8151ac <udp_bind+0xf9>
  8151a4:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  8151aa:	75 bf                	jne    81516b <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  8151ac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8151b1:	74 07                	je     8151ba <udp_bind+0x107>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  8151b3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8151b8:	eb 3d                	jmp    8151f7 <udp_bind+0x144>
    }
  }
  pcb->local_port = port;
  8151ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8151be:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8151c2:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8151c6:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8151ca:	75 26                	jne    8151f2 <udp_bind+0x13f>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8151cc:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8151d3:	00 00 00 
  8151d6:	48 8b 10             	mov    (%rax),%rdx
  8151d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8151dd:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  8151e1:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8151e8:	00 00 00 
  8151eb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8151ef:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8151f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8151f7:	c9                   	leaveq 
  8151f8:	c3                   	retq   

00000000008151f9 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8151f9:	55                   	push   %rbp
  8151fa:	48 89 e5             	mov    %rsp,%rbp
  8151fd:	48 83 ec 30          	sub    $0x30,%rsp
  815201:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815205:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815209:	89 d0                	mov    %edx,%eax
  81520b:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  81520f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815213:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815217:	66 85 c0             	test   %ax,%ax
  81521a:	75 37                	jne    815253 <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  81521c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815220:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815224:	0f b7 d0             	movzwl %ax,%edx
  815227:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81522b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81522f:	48 89 ce             	mov    %rcx,%rsi
  815232:	48 89 c7             	mov    %rax,%rdi
  815235:	48 b8 b3 50 81 00 00 	movabs $0x8150b3,%rax
  81523c:	00 00 00 
  81523f:	ff d0                	callq  *%rax
  815241:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  815244:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815248:	74 09                	je     815253 <udp_connect+0x5a>
      return err;
  81524a:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  81524e:	e9 9d 00 00 00       	jmpq   8152f0 <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  815253:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815258:	74 08                	je     815262 <udp_connect+0x69>
  81525a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81525e:	8b 00                	mov    (%rax),%eax
  815260:	eb 05                	jmp    815267 <udp_connect+0x6e>
  815262:	b8 00 00 00 00       	mov    $0x0,%eax
  815267:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81526b:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  81526e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815272:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  815276:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  81527a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81527e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815282:	89 c2                	mov    %eax,%edx
  815284:	83 ca 04             	or     $0x4,%edx
  815287:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81528b:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  81528e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815295:	00 00 00 
  815298:	48 8b 00             	mov    (%rax),%rax
  81529b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81529f:	eb 1d                	jmp    8152be <udp_connect+0xc5>
    if (pcb == ipcb) {
  8152a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8152a5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8152a9:	75 07                	jne    8152b2 <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  8152ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8152b0:	eb 3e                	jmp    8152f0 <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8152b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8152b6:	48 8b 40 10          	mov    0x10(%rax),%rax
  8152ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8152be:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8152c3:	75 dc                	jne    8152a1 <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  8152c5:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8152cc:	00 00 00 
  8152cf:	48 8b 10             	mov    (%rax),%rdx
  8152d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8152d6:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  8152da:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8152e1:	00 00 00 
  8152e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8152e8:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  8152eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8152f0:	c9                   	leaveq 
  8152f1:	c3                   	retq   

00000000008152f2 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8152f2:	55                   	push   %rbp
  8152f3:	48 89 e5             	mov    %rsp,%rbp
  8152f6:	48 83 ec 08          	sub    $0x8,%rsp
  8152fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  8152fe:	48 b8 28 20 82 00 00 	movabs $0x822028,%rax
  815305:	00 00 00 
  815308:	8b 10                	mov    (%rax),%edx
  81530a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81530e:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  815311:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815315:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  81531b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81531f:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815323:	89 c2                	mov    %eax,%edx
  815325:	83 e2 fb             	and    $0xfffffffb,%edx
  815328:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81532c:	88 50 18             	mov    %dl,0x18(%rax)
}
  81532f:	c9                   	leaveq 
  815330:	c3                   	retq   

0000000000815331 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  815331:	55                   	push   %rbp
  815332:	48 89 e5             	mov    %rsp,%rbp
  815335:	48 83 ec 18          	sub    $0x18,%rsp
  815339:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81533d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  815341:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  815345:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815349:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81534d:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  815351:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815355:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815359:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81535d:	c9                   	leaveq 
  81535e:	c3                   	retq   

000000000081535f <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  81535f:	55                   	push   %rbp
  815360:	48 89 e5             	mov    %rsp,%rbp
  815363:	48 83 ec 20          	sub    $0x20,%rsp
  815367:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  81536b:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815372:	00 00 00 
  815375:	48 8b 00             	mov    (%rax),%rax
  815378:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81537c:	75 20                	jne    81539e <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  81537e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815385:	00 00 00 
  815388:	48 8b 00             	mov    (%rax),%rax
  81538b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81538f:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815396:	00 00 00 
  815399:	48 89 10             	mov    %rdx,(%rax)
  81539c:	eb 51                	jmp    8153ef <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81539e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8153a5:	00 00 00 
  8153a8:	48 8b 00             	mov    (%rax),%rax
  8153ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8153af:	eb 37                	jmp    8153e8 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8153b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153b5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8153b9:	48 85 c0             	test   %rax,%rax
  8153bc:	74 1e                	je     8153dc <udp_remove+0x7d>
  8153be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153c2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8153c6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8153ca:	75 10                	jne    8153dc <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8153cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153d0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8153d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153d8:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8153dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8153e0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8153e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8153e8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8153ed:	75 c2                	jne    8153b1 <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8153ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153f3:	48 89 c6             	mov    %rax,%rsi
  8153f6:	bf 01 00 00 00       	mov    $0x1,%edi
  8153fb:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  815402:	00 00 00 
  815405:	ff d0                	callq  *%rax
}
  815407:	c9                   	leaveq 
  815408:	c3                   	retq   

0000000000815409 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  815409:	55                   	push   %rbp
  81540a:	48 89 e5             	mov    %rsp,%rbp
  81540d:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  815411:	bf 01 00 00 00       	mov    $0x1,%edi
  815416:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  81541d:	00 00 00 
  815420:	ff d0                	callq  *%rax
  815422:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815426:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81542b:	74 25                	je     815452 <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  81542d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815431:	ba 30 00 00 00       	mov    $0x30,%edx
  815436:	be 00 00 00 00       	mov    $0x0,%esi
  81543b:	48 89 c7             	mov    %rax,%rdi
  81543e:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  815445:	00 00 00 
  815448:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  81544a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81544e:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  815452:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815456:	c9                   	leaveq 
  815457:	c3                   	retq   

0000000000815458 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815458:	55                   	push   %rbp
  815459:	48 89 e5             	mov    %rsp,%rbp
  81545c:	48 83 ec 20          	sub    $0x20,%rsp
  815460:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  815464:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815469:	75 2a                	jne    815495 <free_etharp_q+0x3d>
  81546b:	48 ba 94 24 82 00 00 	movabs $0x822494,%rdx
  815472:	00 00 00 
  815475:	be 93 00 00 00       	mov    $0x93,%esi
  81547a:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  815481:	00 00 00 
  815484:	b8 00 00 00 00       	mov    $0x0,%eax
  815489:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815490:	00 00 00 
  815493:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  815495:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815499:	48 8b 40 08          	mov    0x8(%rax),%rax
  81549d:	48 85 c0             	test   %rax,%rax
  8154a0:	0f 85 a3 00 00 00    	jne    815549 <free_etharp_q+0xf1>
  8154a6:	48 ba b6 24 82 00 00 	movabs $0x8224b6,%rdx
  8154ad:	00 00 00 
  8154b0:	be 94 00 00 00       	mov    $0x94,%esi
  8154b5:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  8154bc:	00 00 00 
  8154bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8154c4:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8154cb:	00 00 00 
  8154ce:	ff d1                	callq  *%rcx
  while (q) {
    r = q;
  8154d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8154d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  8154d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8154dc:	48 8b 00             	mov    (%rax),%rax
  8154df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8154e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8154e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8154eb:	48 85 c0             	test   %rax,%rax
  8154ee:	75 2a                	jne    81551a <free_etharp_q+0xc2>
  8154f0:	48 ba c3 24 82 00 00 	movabs $0x8224c3,%rdx
  8154f7:	00 00 00 
  8154fa:	be 98 00 00 00       	mov    $0x98,%esi
  8154ff:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  815506:	00 00 00 
  815509:	b8 00 00 00 00       	mov    $0x0,%eax
  81550e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815515:	00 00 00 
  815518:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  81551a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81551e:	48 8b 40 08          	mov    0x8(%rax),%rax
  815522:	48 89 c7             	mov    %rax,%rdi
  815525:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81552c:	00 00 00 
  81552f:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  815531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815535:	48 89 c6             	mov    %rax,%rsi
  815538:	bf 0a 00 00 00       	mov    $0xa,%edi
  81553d:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  815544:	00 00 00 
  815547:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815549:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81554e:	75 80                	jne    8154d0 <free_etharp_q+0x78>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  815550:	c9                   	leaveq 
  815551:	c3                   	retq   

0000000000815552 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  815552:	55                   	push   %rbp
  815553:	48 89 e5             	mov    %rsp,%rbp
  815556:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  81555a:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  81555e:	e9 df 01 00 00       	jmpq   815742 <etharp_tmr+0x1f0>
    arp_table[i].ctime++;
  815563:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815567:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  81556e:	00 00 00 
  815571:	48 63 ca             	movslq %edx,%rcx
  815574:	48 89 c8             	mov    %rcx,%rax
  815577:	48 c1 e0 02          	shl    $0x2,%rax
  81557b:	48 01 c8             	add    %rcx,%rax
  81557e:	48 c1 e0 03          	shl    $0x3,%rax
  815582:	48 01 f0             	add    %rsi,%rax
  815585:	48 83 c0 10          	add    $0x10,%rax
  815589:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81558d:	8d 48 01             	lea    0x1(%rax),%ecx
  815590:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815597:	00 00 00 
  81559a:	48 63 d2             	movslq %edx,%rdx
  81559d:	48 89 d0             	mov    %rdx,%rax
  8155a0:	48 c1 e0 02          	shl    $0x2,%rax
  8155a4:	48 01 d0             	add    %rdx,%rax
  8155a7:	48 c1 e0 03          	shl    $0x3,%rax
  8155ab:	48 01 f0             	add    %rsi,%rax
  8155ae:	48 83 c0 10          	add    $0x10,%rax
  8155b2:	88 48 08             	mov    %cl,0x8(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8155b5:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8155b9:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8155c0:	00 00 00 
  8155c3:	48 63 d0             	movslq %eax,%rdx
  8155c6:	48 89 d0             	mov    %rdx,%rax
  8155c9:	48 c1 e0 02          	shl    $0x2,%rax
  8155cd:	48 01 d0             	add    %rdx,%rax
  8155d0:	48 c1 e0 03          	shl    $0x3,%rax
  8155d4:	48 01 c8             	add    %rcx,%rax
  8155d7:	48 83 c0 10          	add    $0x10,%rax
  8155db:	8b 40 04             	mov    0x4(%rax),%eax
  8155de:	83 f8 02             	cmp    $0x2,%eax
  8155e1:	75 2e                	jne    815611 <etharp_tmr+0xbf>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  8155e3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8155e7:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8155ee:	00 00 00 
  8155f1:	48 63 d0             	movslq %eax,%rdx
  8155f4:	48 89 d0             	mov    %rdx,%rax
  8155f7:	48 c1 e0 02          	shl    $0x2,%rax
  8155fb:	48 01 d0             	add    %rdx,%rax
  8155fe:	48 c1 e0 03          	shl    $0x3,%rax
  815602:	48 01 c8             	add    %rcx,%rax
  815605:	48 83 c0 10          	add    $0x10,%rax
  815609:	0f b6 40 08          	movzbl 0x8(%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  81560d:	3c ef                	cmp    $0xef,%al
  81560f:	77 64                	ja     815675 <etharp_tmr+0x123>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  815611:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815615:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81561c:	00 00 00 
  81561f:	48 63 d0             	movslq %eax,%rdx
  815622:	48 89 d0             	mov    %rdx,%rax
  815625:	48 c1 e0 02          	shl    $0x2,%rax
  815629:	48 01 d0             	add    %rdx,%rax
  81562c:	48 c1 e0 03          	shl    $0x3,%rax
  815630:	48 01 c8             	add    %rcx,%rax
  815633:	48 83 c0 10          	add    $0x10,%rax
  815637:	8b 40 04             	mov    0x4(%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  81563a:	83 f8 01             	cmp    $0x1,%eax
  81563d:	0f 85 e6 00 00 00    	jne    815729 <etharp_tmr+0x1d7>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  815643:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815647:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81564e:	00 00 00 
  815651:	48 63 d0             	movslq %eax,%rdx
  815654:	48 89 d0             	mov    %rdx,%rax
  815657:	48 c1 e0 02          	shl    $0x2,%rax
  81565b:	48 01 d0             	add    %rdx,%rax
  81565e:	48 c1 e0 03          	shl    $0x3,%rax
  815662:	48 01 c8             	add    %rcx,%rax
  815665:	48 83 c0 10          	add    $0x10,%rax
  815669:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  81566d:	3c 01                	cmp    $0x1,%al
  81566f:	0f 86 b4 00 00 00    	jbe    815729 <etharp_tmr+0x1d7>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  815675:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815679:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815680:	00 00 00 
  815683:	48 63 d0             	movslq %eax,%rdx
  815686:	48 89 d0             	mov    %rdx,%rax
  815689:	48 c1 e0 02          	shl    $0x2,%rax
  81568d:	48 01 d0             	add    %rdx,%rax
  815690:	48 c1 e0 03          	shl    $0x3,%rax
  815694:	48 01 c8             	add    %rcx,%rax
  815697:	48 8b 00             	mov    (%rax),%rax
  81569a:	48 85 c0             	test   %rax,%rax
  81569d:	74 5d                	je     8156fc <etharp_tmr+0x1aa>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  81569f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8156a3:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8156aa:	00 00 00 
  8156ad:	48 63 d0             	movslq %eax,%rdx
  8156b0:	48 89 d0             	mov    %rdx,%rax
  8156b3:	48 c1 e0 02          	shl    $0x2,%rax
  8156b7:	48 01 d0             	add    %rdx,%rax
  8156ba:	48 c1 e0 03          	shl    $0x3,%rax
  8156be:	48 01 c8             	add    %rcx,%rax
  8156c1:	48 8b 00             	mov    (%rax),%rax
  8156c4:	48 89 c7             	mov    %rax,%rdi
  8156c7:	48 b8 58 54 81 00 00 	movabs $0x815458,%rax
  8156ce:	00 00 00 
  8156d1:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  8156d3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8156d7:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8156de:	00 00 00 
  8156e1:	48 63 d0             	movslq %eax,%rdx
  8156e4:	48 89 d0             	mov    %rdx,%rax
  8156e7:	48 c1 e0 02          	shl    $0x2,%rax
  8156eb:	48 01 d0             	add    %rdx,%rax
  8156ee:	48 c1 e0 03          	shl    $0x3,%rax
  8156f2:	48 01 c8             	add    %rcx,%rax
  8156f5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8156fc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815700:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815707:	00 00 00 
  81570a:	48 63 d0             	movslq %eax,%rdx
  81570d:	48 89 d0             	mov    %rdx,%rax
  815710:	48 c1 e0 02          	shl    $0x2,%rax
  815714:	48 01 d0             	add    %rdx,%rax
  815717:	48 c1 e0 03          	shl    $0x3,%rax
  81571b:	48 01 c8             	add    %rcx,%rax
  81571e:	48 83 c0 10          	add    $0x10,%rax
  815722:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815729:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81572d:	48 63 d0             	movslq %eax,%rdx
  815730:	48 89 d0             	mov    %rdx,%rax
  815733:	48 c1 e0 02          	shl    $0x2,%rax
  815737:	48 01 d0             	add    %rdx,%rax
  81573a:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  81573e:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  815742:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815746:	0f 86 17 fe ff ff    	jbe    815563 <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  81574c:	c9                   	leaveq 
  81574d:	c3                   	retq   

000000000081574e <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  81574e:	55                   	push   %rbp
  81574f:	48 89 e5             	mov    %rsp,%rbp
  815752:	48 83 ec 20          	sub    $0x20,%rsp
  815756:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81575a:	89 f0                	mov    %esi,%eax
  81575c:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  81575f:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  815763:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815767:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  81576b:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  81576f:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  815773:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815777:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  81577b:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  81577f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815784:	0f 84 87 00 00 00    	je     815811 <find_entry+0xc3>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  81578a:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815791:	00 00 00 
  815794:	0f b6 00             	movzbl (%rax),%eax
  815797:	0f b6 c0             	movzbl %al,%eax
  81579a:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8157a1:	00 00 00 
  8157a4:	48 63 d0             	movslq %eax,%rdx
  8157a7:	48 89 d0             	mov    %rdx,%rax
  8157aa:	48 c1 e0 02          	shl    $0x2,%rax
  8157ae:	48 01 d0             	add    %rdx,%rax
  8157b1:	48 c1 e0 03          	shl    $0x3,%rax
  8157b5:	48 01 c8             	add    %rcx,%rax
  8157b8:	48 83 c0 10          	add    $0x10,%rax
  8157bc:	8b 40 04             	mov    0x4(%rax),%eax
  8157bf:	83 f8 02             	cmp    $0x2,%eax
  8157c2:	75 4d                	jne    815811 <find_entry+0xc3>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8157c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8157c8:	8b 08                	mov    (%rax),%ecx
  8157ca:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  8157d1:	00 00 00 
  8157d4:	0f b6 00             	movzbl (%rax),%eax
  8157d7:	0f b6 c0             	movzbl %al,%eax
  8157da:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8157e1:	00 00 00 
  8157e4:	48 63 d0             	movslq %eax,%rdx
  8157e7:	48 89 d0             	mov    %rdx,%rax
  8157ea:	48 c1 e0 02          	shl    $0x2,%rax
  8157ee:	48 01 d0             	add    %rdx,%rax
  8157f1:	48 c1 e0 03          	shl    $0x3,%rax
  8157f5:	48 01 f0             	add    %rsi,%rax
  8157f8:	8b 40 08             	mov    0x8(%rax),%eax
  8157fb:	39 c1                	cmp    %eax,%ecx
  8157fd:	75 12                	jne    815811 <find_entry+0xc3>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  8157ff:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815806:	00 00 00 
  815809:	0f b6 00             	movzbl (%rax),%eax
  81580c:	e9 cf 04 00 00       	jmpq   815ce0 <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815811:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  815815:	e9 aa 02 00 00       	jmpq   815ac4 <find_entry+0x376>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  81581a:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  81581e:	75 39                	jne    815859 <find_entry+0x10b>
  815820:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815824:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81582b:	00 00 00 
  81582e:	48 63 d0             	movslq %eax,%rdx
  815831:	48 89 d0             	mov    %rdx,%rax
  815834:	48 c1 e0 02          	shl    $0x2,%rax
  815838:	48 01 d0             	add    %rdx,%rax
  81583b:	48 c1 e0 03          	shl    $0x3,%rax
  81583f:	48 01 c8             	add    %rcx,%rax
  815842:	48 83 c0 10          	add    $0x10,%rax
  815846:	8b 40 04             	mov    0x4(%rax),%eax
  815849:	85 c0                	test   %eax,%eax
  81584b:	75 0c                	jne    815859 <find_entry+0x10b>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  81584d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815851:	88 45 fd             	mov    %al,-0x3(%rbp)
  815854:	e9 67 02 00 00       	jmpq   815ac0 <find_entry+0x372>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815859:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81585d:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815864:	00 00 00 
  815867:	48 63 d0             	movslq %eax,%rdx
  81586a:	48 89 d0             	mov    %rdx,%rax
  81586d:	48 c1 e0 02          	shl    $0x2,%rax
  815871:	48 01 d0             	add    %rdx,%rax
  815874:	48 c1 e0 03          	shl    $0x3,%rax
  815878:	48 01 c8             	add    %rcx,%rax
  81587b:	48 83 c0 10          	add    $0x10,%rax
  81587f:	8b 40 04             	mov    0x4(%rax),%eax
  815882:	83 f8 01             	cmp    $0x1,%eax
  815885:	0f 85 51 01 00 00    	jne    8159dc <find_entry+0x28e>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  81588b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815890:	74 48                	je     8158da <find_entry+0x18c>
  815892:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815896:	8b 08                	mov    (%rax),%ecx
  815898:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81589c:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  8158a3:	00 00 00 
  8158a6:	48 63 d0             	movslq %eax,%rdx
  8158a9:	48 89 d0             	mov    %rdx,%rax
  8158ac:	48 c1 e0 02          	shl    $0x2,%rax
  8158b0:	48 01 d0             	add    %rdx,%rax
  8158b3:	48 c1 e0 03          	shl    $0x3,%rax
  8158b7:	48 01 f0             	add    %rsi,%rax
  8158ba:	8b 40 08             	mov    0x8(%rax),%eax
  8158bd:	39 c1                	cmp    %eax,%ecx
  8158bf:	75 19                	jne    8158da <find_entry+0x18c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8158c1:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  8158c8:	00 00 00 
  8158cb:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  8158cf:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8158d1:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8158d5:	e9 06 04 00 00       	jmpq   815ce0 <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8158da:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8158de:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8158e5:	00 00 00 
  8158e8:	48 63 d0             	movslq %eax,%rdx
  8158eb:	48 89 d0             	mov    %rdx,%rax
  8158ee:	48 c1 e0 02          	shl    $0x2,%rax
  8158f2:	48 01 d0             	add    %rdx,%rax
  8158f5:	48 c1 e0 03          	shl    $0x3,%rax
  8158f9:	48 01 c8             	add    %rcx,%rax
  8158fc:	48 8b 00             	mov    (%rax),%rax
  8158ff:	48 85 c0             	test   %rax,%rax
  815902:	74 6c                	je     815970 <find_entry+0x222>
        if (arp_table[i].ctime >= age_queue) {
  815904:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815908:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81590f:	00 00 00 
  815912:	48 63 d0             	movslq %eax,%rdx
  815915:	48 89 d0             	mov    %rdx,%rax
  815918:	48 c1 e0 02          	shl    $0x2,%rax
  81591c:	48 01 d0             	add    %rdx,%rax
  81591f:	48 c1 e0 03          	shl    $0x3,%rax
  815923:	48 01 c8             	add    %rcx,%rax
  815926:	48 83 c0 10          	add    $0x10,%rax
  81592a:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81592e:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815931:	0f 82 89 01 00 00    	jb     815ac0 <find_entry+0x372>
          old_queue = i;
  815937:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  81593b:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  81593e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815942:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815949:	00 00 00 
  81594c:	48 63 d0             	movslq %eax,%rdx
  81594f:	48 89 d0             	mov    %rdx,%rax
  815952:	48 c1 e0 02          	shl    $0x2,%rax
  815956:	48 01 d0             	add    %rdx,%rax
  815959:	48 c1 e0 03          	shl    $0x3,%rax
  81595d:	48 01 c8             	add    %rcx,%rax
  815960:	48 83 c0 10          	add    $0x10,%rax
  815964:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815968:	88 45 f8             	mov    %al,-0x8(%rbp)
  81596b:	e9 50 01 00 00       	jmpq   815ac0 <find_entry+0x372>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815970:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815974:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81597b:	00 00 00 
  81597e:	48 63 d0             	movslq %eax,%rdx
  815981:	48 89 d0             	mov    %rdx,%rax
  815984:	48 c1 e0 02          	shl    $0x2,%rax
  815988:	48 01 d0             	add    %rdx,%rax
  81598b:	48 c1 e0 03          	shl    $0x3,%rax
  81598f:	48 01 c8             	add    %rcx,%rax
  815992:	48 83 c0 10          	add    $0x10,%rax
  815996:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81599a:	3a 45 fb             	cmp    -0x5(%rbp),%al
  81599d:	0f 82 1d 01 00 00    	jb     815ac0 <find_entry+0x372>
          old_pending = i;
  8159a3:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8159a7:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  8159aa:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8159ae:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8159b5:	00 00 00 
  8159b8:	48 63 d0             	movslq %eax,%rdx
  8159bb:	48 89 d0             	mov    %rdx,%rax
  8159be:	48 c1 e0 02          	shl    $0x2,%rax
  8159c2:	48 01 d0             	add    %rdx,%rax
  8159c5:	48 c1 e0 03          	shl    $0x3,%rax
  8159c9:	48 01 c8             	add    %rcx,%rax
  8159cc:	48 83 c0 10          	add    $0x10,%rax
  8159d0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  8159d4:	88 45 fb             	mov    %al,-0x5(%rbp)
  8159d7:	e9 e4 00 00 00       	jmpq   815ac0 <find_entry+0x372>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8159dc:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  8159e0:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8159e7:	00 00 00 
  8159ea:	48 63 d0             	movslq %eax,%rdx
  8159ed:	48 89 d0             	mov    %rdx,%rax
  8159f0:	48 c1 e0 02          	shl    $0x2,%rax
  8159f4:	48 01 d0             	add    %rdx,%rax
  8159f7:	48 c1 e0 03          	shl    $0x3,%rax
  8159fb:	48 01 c8             	add    %rcx,%rax
  8159fe:	48 83 c0 10          	add    $0x10,%rax
  815a02:	8b 40 04             	mov    0x4(%rax),%eax
  815a05:	83 f8 02             	cmp    $0x2,%eax
  815a08:	0f 85 b2 00 00 00    	jne    815ac0 <find_entry+0x372>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815a0e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815a13:	74 48                	je     815a5d <find_entry+0x30f>
  815a15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a19:	8b 08                	mov    (%rax),%ecx
  815a1b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a1f:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815a26:	00 00 00 
  815a29:	48 63 d0             	movslq %eax,%rdx
  815a2c:	48 89 d0             	mov    %rdx,%rax
  815a2f:	48 c1 e0 02          	shl    $0x2,%rax
  815a33:	48 01 d0             	add    %rdx,%rax
  815a36:	48 c1 e0 03          	shl    $0x3,%rax
  815a3a:	48 01 f0             	add    %rsi,%rax
  815a3d:	8b 40 08             	mov    0x8(%rax),%eax
  815a40:	39 c1                	cmp    %eax,%ecx
  815a42:	75 19                	jne    815a5d <find_entry+0x30f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815a44:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815a4b:	00 00 00 
  815a4e:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815a52:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815a54:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a58:	e9 83 02 00 00       	jmpq   815ce0 <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  815a5d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a61:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a68:	00 00 00 
  815a6b:	48 63 d0             	movslq %eax,%rdx
  815a6e:	48 89 d0             	mov    %rdx,%rax
  815a71:	48 c1 e0 02          	shl    $0x2,%rax
  815a75:	48 01 d0             	add    %rdx,%rax
  815a78:	48 c1 e0 03          	shl    $0x3,%rax
  815a7c:	48 01 c8             	add    %rcx,%rax
  815a7f:	48 83 c0 10          	add    $0x10,%rax
  815a83:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815a87:	3a 45 fa             	cmp    -0x6(%rbp),%al
  815a8a:	72 34                	jb     815ac0 <find_entry+0x372>
        old_stable = i;
  815a8c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a90:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  815a93:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a97:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815a9e:	00 00 00 
  815aa1:	48 63 d0             	movslq %eax,%rdx
  815aa4:	48 89 d0             	mov    %rdx,%rax
  815aa7:	48 c1 e0 02          	shl    $0x2,%rax
  815aab:	48 01 d0             	add    %rdx,%rax
  815aae:	48 c1 e0 03          	shl    $0x3,%rax
  815ab2:	48 01 c8             	add    %rcx,%rax
  815ab5:	48 83 c0 10          	add    $0x10,%rax
  815ab9:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815abd:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815ac0:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  815ac4:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815ac8:	0f 86 4c fd ff ff    	jbe    81581a <find_entry+0xcc>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  815ace:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815ad2:	75 0b                	jne    815adf <find_entry+0x391>
  815ad4:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815ad8:	83 e0 01             	and    $0x1,%eax
  815adb:	85 c0                	test   %eax,%eax
  815add:	74 0b                	je     815aea <find_entry+0x39c>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  815adf:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815ae3:	83 e0 02             	and    $0x2,%eax
  815ae6:	85 c0                	test   %eax,%eax
  815ae8:	74 0a                	je     815af4 <find_entry+0x3a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  815aea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815aef:	e9 ec 01 00 00       	jmpq   815ce0 <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  815af4:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  815af8:	7f 0c                	jg     815b06 <find_entry+0x3b8>
    i = empty;
  815afa:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  815afe:	88 45 fc             	mov    %al,-0x4(%rbp)
  815b01:	e9 ea 00 00 00       	jmpq   815bf0 <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  815b06:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  815b0a:	7f 5f                	jg     815b6b <find_entry+0x41d>
    /* recycle oldest stable*/
    i = old_stable;
  815b0c:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  815b10:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  815b13:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b17:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b1e:	00 00 00 
  815b21:	48 63 d0             	movslq %eax,%rdx
  815b24:	48 89 d0             	mov    %rdx,%rax
  815b27:	48 c1 e0 02          	shl    $0x2,%rax
  815b2b:	48 01 d0             	add    %rdx,%rax
  815b2e:	48 c1 e0 03          	shl    $0x3,%rax
  815b32:	48 01 c8             	add    %rcx,%rax
  815b35:	48 8b 00             	mov    (%rax),%rax
  815b38:	48 85 c0             	test   %rax,%rax
  815b3b:	0f 84 af 00 00 00    	je     815bf0 <find_entry+0x4a2>
  815b41:	48 ba d0 24 82 00 00 	movabs $0x8224d0,%rdx
  815b48:	00 00 00 
  815b4b:	be 75 01 00 00       	mov    $0x175,%esi
  815b50:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  815b57:	00 00 00 
  815b5a:	b8 00 00 00 00       	mov    $0x0,%eax
  815b5f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815b66:	00 00 00 
  815b69:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  815b6b:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815b6f:	7f 09                	jg     815b7a <find_entry+0x42c>
    /* recycle oldest pending */
    i = old_pending;
  815b71:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815b75:	88 45 fc             	mov    %al,-0x4(%rbp)
  815b78:	eb 76                	jmp    815bf0 <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  815b7a:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  815b7e:	7f 66                	jg     815be6 <find_entry+0x498>
    /* recycle oldest pending */
    i = old_queue;
  815b80:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  815b84:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  815b87:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b8b:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815b92:	00 00 00 
  815b95:	48 63 d0             	movslq %eax,%rdx
  815b98:	48 89 d0             	mov    %rdx,%rax
  815b9b:	48 c1 e0 02          	shl    $0x2,%rax
  815b9f:	48 01 d0             	add    %rdx,%rax
  815ba2:	48 c1 e0 03          	shl    $0x3,%rax
  815ba6:	48 01 c8             	add    %rcx,%rax
  815ba9:	48 8b 00             	mov    (%rax),%rax
  815bac:	48 89 c7             	mov    %rax,%rdi
  815baf:	48 b8 58 54 81 00 00 	movabs $0x815458,%rax
  815bb6:	00 00 00 
  815bb9:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  815bbb:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815bbf:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815bc6:	00 00 00 
  815bc9:	48 63 d0             	movslq %eax,%rdx
  815bcc:	48 89 d0             	mov    %rdx,%rax
  815bcf:	48 c1 e0 02          	shl    $0x2,%rax
  815bd3:	48 01 d0             	add    %rdx,%rax
  815bd6:	48 c1 e0 03          	shl    $0x3,%rax
  815bda:	48 01 c8             	add    %rcx,%rax
  815bdd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  815be4:	eb 0a                	jmp    815bf0 <find_entry+0x4a2>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  815be6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815beb:	e9 f0 00 00 00       	jmpq   815ce0 <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  815bf0:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815bf4:	76 2a                	jbe    815c20 <find_entry+0x4d2>
  815bf6:	48 ba e7 24 82 00 00 	movabs $0x8224e7,%rdx
  815bfd:	00 00 00 
  815c00:	be 8b 01 00 00       	mov    $0x18b,%esi
  815c05:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  815c0c:	00 00 00 
  815c0f:	b8 00 00 00 00       	mov    $0x0,%eax
  815c14:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815c1b:	00 00 00 
  815c1e:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  815c20:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c24:	48 63 d0             	movslq %eax,%rdx
  815c27:	48 89 d0             	mov    %rdx,%rax
  815c2a:	48 c1 e0 02          	shl    $0x2,%rax
  815c2e:	48 01 d0             	add    %rdx,%rax
  815c31:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  815c35:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c39:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815c40:	00 00 00 
  815c43:	48 63 d0             	movslq %eax,%rdx
  815c46:	48 89 d0             	mov    %rdx,%rax
  815c49:	48 c1 e0 02          	shl    $0x2,%rax
  815c4d:	48 01 d0             	add    %rdx,%rax
  815c50:	48 c1 e0 03          	shl    $0x3,%rax
  815c54:	48 01 c8             	add    %rcx,%rax
  815c57:	48 83 c0 10          	add    $0x10,%rax
  815c5b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  815c62:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815c67:	74 39                	je     815ca2 <find_entry+0x554>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  815c69:	0f b6 4d fc          	movzbl -0x4(%rbp),%ecx
  815c6d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815c72:	74 08                	je     815c7c <find_entry+0x52e>
  815c74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815c78:	8b 10                	mov    (%rax),%edx
  815c7a:	eb 05                	jmp    815c81 <find_entry+0x533>
  815c7c:	ba 00 00 00 00       	mov    $0x0,%edx
  815c81:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815c88:	00 00 00 
  815c8b:	48 63 c9             	movslq %ecx,%rcx
  815c8e:	48 89 c8             	mov    %rcx,%rax
  815c91:	48 c1 e0 02          	shl    $0x2,%rax
  815c95:	48 01 c8             	add    %rcx,%rax
  815c98:	48 c1 e0 03          	shl    $0x3,%rax
  815c9c:	48 01 f0             	add    %rsi,%rax
  815c9f:	89 50 08             	mov    %edx,0x8(%rax)
  }
  arp_table[i].ctime = 0;
  815ca2:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ca6:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815cad:	00 00 00 
  815cb0:	48 63 d0             	movslq %eax,%rdx
  815cb3:	48 89 d0             	mov    %rdx,%rax
  815cb6:	48 c1 e0 02          	shl    $0x2,%rax
  815cba:	48 01 d0             	add    %rdx,%rax
  815cbd:	48 c1 e0 03          	shl    $0x3,%rax
  815cc1:	48 01 c8             	add    %rcx,%rax
  815cc4:	48 83 c0 10          	add    $0x10,%rax
  815cc8:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  815ccc:	48 b8 10 b8 b4 00 00 	movabs $0xb4b810,%rax
  815cd3:	00 00 00 
  815cd6:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815cda:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  815cdc:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  815ce0:	c9                   	leaveq 
  815ce1:	c3                   	retq   

0000000000815ce2 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  815ce2:	55                   	push   %rbp
  815ce3:	48 89 e5             	mov    %rsp,%rbp
  815ce6:	48 83 ec 30          	sub    $0x30,%rsp
  815cea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815cee:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815cf2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  815cf6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  815cfa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815cfe:	48 8b 40 08          	mov    0x8(%rax),%rax
  815d02:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  815d06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815d0a:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815d0e:	3c 06                	cmp    $0x6,%al
  815d10:	74 2a                	je     815d3c <etharp_send_ip+0x5a>
  815d12:	48 ba 00 25 82 00 00 	movabs $0x822500,%rdx
  815d19:	00 00 00 
  815d1c:	be b3 01 00 00       	mov    $0x1b3,%esi
  815d21:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  815d28:	00 00 00 
  815d2b:	b8 00 00 00 00       	mov    $0x0,%eax
  815d30:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815d37:	00 00 00 
  815d3a:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  815d3c:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  815d40:	eb 3d                	jmp    815d7f <etharp_send_ip+0x9d>
    k--;
  815d42:	80 6d ff 01          	subb   $0x1,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  815d46:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815d4a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d4e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  815d52:	48 98                	cltq   
  815d54:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815d58:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815d5c:	48 63 c6             	movslq %esi,%rax
  815d5f:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  815d62:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815d66:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d6a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  815d6e:	48 98                	cltq   
  815d70:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815d74:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815d78:	48 63 c6             	movslq %esi,%rax
  815d7b:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  815d7f:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  815d83:	75 bd                	jne    815d42 <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  815d85:	bf 00 08 00 00       	mov    $0x800,%edi
  815d8a:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  815d91:	00 00 00 
  815d94:	ff d0                	callq  *%rax
  815d96:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815d9a:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  815d9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815da2:	48 8b 48 28          	mov    0x28(%rax),%rcx
  815da6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815daa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815dae:	48 89 d6             	mov    %rdx,%rsi
  815db1:	48 89 c7             	mov    %rax,%rdi
  815db4:	ff d1                	callq  *%rcx
}
  815db6:	c9                   	leaveq 
  815db7:	c3                   	retq   

0000000000815db8 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  815db8:	55                   	push   %rbp
  815db9:	48 89 e5             	mov    %rsp,%rbp
  815dbc:	53                   	push   %rbx
  815dbd:	48 83 ec 48          	sub    $0x48,%rsp
  815dc1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  815dc5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  815dc9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  815dcd:	89 c8                	mov    %ecx,%eax
  815dcf:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  815dd2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815dd6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815dda:	3c 06                	cmp    $0x6,%al
  815ddc:	74 2a                	je     815e08 <update_arp_entry+0x50>
  815dde:	48 ba 48 25 82 00 00 	movabs $0x822548,%rdx
  815de5:	00 00 00 
  815de8:	be d9 01 00 00       	mov    $0x1d9,%esi
  815ded:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  815df4:	00 00 00 
  815df7:	b8 00 00 00 00       	mov    $0x0,%eax
  815dfc:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  815e03:	00 00 00 
  815e06:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  815e08:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  815e0d:	74 56                	je     815e65 <update_arp_entry+0xad>
  815e0f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815e13:	8b 00                	mov    (%rax),%eax
  815e15:	85 c0                	test   %eax,%eax
  815e17:	74 4c                	je     815e65 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  815e19:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815e1d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815e21:	48 89 d6             	mov    %rdx,%rsi
  815e24:	48 89 c7             	mov    %rax,%rdi
  815e27:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  815e2e:	00 00 00 
  815e31:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  815e33:	84 c0                	test   %al,%al
  815e35:	75 2e                	jne    815e65 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  815e37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815e3b:	8b 18                	mov    (%rax),%ebx
  815e3d:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  815e42:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  815e49:	00 00 00 
  815e4c:	ff d0                	callq  *%rax
  815e4e:	21 c3                	and    %eax,%ebx
  815e50:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  815e55:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  815e5c:	00 00 00 
  815e5f:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  815e61:	39 c3                	cmp    %eax,%ebx
  815e63:	75 0a                	jne    815e6f <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  815e65:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  815e6a:	e9 ea 01 00 00       	jmpq   816059 <update_arp_entry+0x2a1>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  815e6f:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  815e73:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815e77:	89 d6                	mov    %edx,%esi
  815e79:	48 89 c7             	mov    %rax,%rdi
  815e7c:	48 b8 4e 57 81 00 00 	movabs $0x81574e,%rax
  815e83:	00 00 00 
  815e86:	ff d0                	callq  *%rax
  815e88:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  815e8b:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  815e8f:	79 09                	jns    815e9a <update_arp_entry+0xe2>
    return (err_t)i;
  815e91:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  815e95:	e9 bf 01 00 00       	jmpq   816059 <update_arp_entry+0x2a1>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  815e9a:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  815e9e:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ea5:	00 00 00 
  815ea8:	48 63 d0             	movslq %eax,%rdx
  815eab:	48 89 d0             	mov    %rdx,%rax
  815eae:	48 c1 e0 02          	shl    $0x2,%rax
  815eb2:	48 01 d0             	add    %rdx,%rax
  815eb5:	48 c1 e0 03          	shl    $0x3,%rax
  815eb9:	48 01 c8             	add    %rcx,%rax
  815ebc:	48 83 c0 10          	add    $0x10,%rax
  815ec0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  815ec7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  815ecb:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815ed2:	00 00 00 
  815ed5:	48 63 d0             	movslq %eax,%rdx
  815ed8:	48 89 d0             	mov    %rdx,%rax
  815edb:	48 c1 e0 02          	shl    $0x2,%rax
  815edf:	48 01 d0             	add    %rdx,%rax
  815ee2:	48 c1 e0 03          	shl    $0x3,%rax
  815ee6:	48 01 c8             	add    %rcx,%rax
  815ee9:	48 8d 50 20          	lea    0x20(%rax),%rdx
  815eed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815ef1:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  815ef4:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  815ef8:	eb 42                	jmp    815f3c <update_arp_entry+0x184>
    k--;
  815efa:	80 6d ef 01          	subb   $0x1,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  815efe:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  815f03:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  815f07:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  815f0b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  815f0f:	48 98                	cltq   
  815f11:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815f15:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815f1c:	00 00 00 
  815f1f:	48 63 ff             	movslq %edi,%rdi
  815f22:	49 63 d0             	movslq %r8d,%rdx
  815f25:	48 89 d0             	mov    %rdx,%rax
  815f28:	48 c1 e0 02          	shl    $0x2,%rax
  815f2c:	48 01 d0             	add    %rdx,%rax
  815f2f:	48 c1 e0 03          	shl    $0x3,%rax
  815f33:	48 01 f8             	add    %rdi,%rax
  815f36:	48 01 f0             	add    %rsi,%rax
  815f39:	88 48 0c             	mov    %cl,0xc(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  815f3c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  815f40:	75 b8                	jne    815efa <update_arp_entry+0x142>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  815f42:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  815f46:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f4d:	00 00 00 
  815f50:	48 63 d0             	movslq %eax,%rdx
  815f53:	48 89 d0             	mov    %rdx,%rax
  815f56:	48 c1 e0 02          	shl    $0x2,%rax
  815f5a:	48 01 d0             	add    %rdx,%rax
  815f5d:	48 c1 e0 03          	shl    $0x3,%rax
  815f61:	48 01 c8             	add    %rcx,%rax
  815f64:	48 83 c0 10          	add    $0x10,%rax
  815f68:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  815f6c:	e9 b5 00 00 00       	jmpq   816026 <update_arp_entry+0x26e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  815f71:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  815f75:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  815f7c:	00 00 00 
  815f7f:	48 63 d0             	movslq %eax,%rdx
  815f82:	48 89 d0             	mov    %rdx,%rax
  815f85:	48 c1 e0 02          	shl    $0x2,%rax
  815f89:	48 01 d0             	add    %rdx,%rax
  815f8c:	48 c1 e0 03          	shl    $0x3,%rax
  815f90:	48 01 c8             	add    %rcx,%rax
  815f93:	48 8b 00             	mov    (%rax),%rax
  815f96:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  815f9a:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  815f9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815fa2:	48 8b 08             	mov    (%rax),%rcx
  815fa5:	48 be 80 b6 b4 00 00 	movabs $0xb4b680,%rsi
  815fac:	00 00 00 
  815faf:	48 63 d2             	movslq %edx,%rdx
  815fb2:	48 89 d0             	mov    %rdx,%rax
  815fb5:	48 c1 e0 02          	shl    $0x2,%rax
  815fb9:	48 01 d0             	add    %rdx,%rax
  815fbc:	48 c1 e0 03          	shl    $0x3,%rax
  815fc0:	48 01 f0             	add    %rsi,%rax
  815fc3:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  815fc6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815fca:	48 8b 40 08          	mov    0x8(%rax),%rax
  815fce:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  815fd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815fd6:	48 89 c6             	mov    %rax,%rsi
  815fd9:	bf 0a 00 00 00       	mov    $0xa,%edi
  815fde:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  815fe5:	00 00 00 
  815fe8:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  815fea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815fee:	48 8d 78 41          	lea    0x41(%rax),%rdi
  815ff2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  815ff6:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  815ffa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815ffe:	48 89 d1             	mov    %rdx,%rcx
  816001:	48 89 fa             	mov    %rdi,%rdx
  816004:	48 89 c7             	mov    %rax,%rdi
  816007:	48 b8 e2 5c 81 00 00 	movabs $0x815ce2,%rax
  81600e:	00 00 00 
  816011:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  816013:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816017:	48 89 c7             	mov    %rax,%rdi
  81601a:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  816021:	00 00 00 
  816024:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  816026:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81602a:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816031:	00 00 00 
  816034:	48 63 d0             	movslq %eax,%rdx
  816037:	48 89 d0             	mov    %rdx,%rax
  81603a:	48 c1 e0 02          	shl    $0x2,%rax
  81603e:	48 01 d0             	add    %rdx,%rax
  816041:	48 c1 e0 03          	shl    $0x3,%rax
  816045:	48 01 c8             	add    %rcx,%rax
  816048:	48 8b 00             	mov    (%rax),%rax
  81604b:	48 85 c0             	test   %rax,%rax
  81604e:	0f 85 1d ff ff ff    	jne    815f71 <update_arp_entry+0x1b9>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  816054:	b8 00 00 00 00       	mov    $0x0,%eax
}
  816059:	48 83 c4 48          	add    $0x48,%rsp
  81605d:	5b                   	pop    %rbx
  81605e:	5d                   	pop    %rbp
  81605f:	c3                   	retq   

0000000000816060 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  816060:	55                   	push   %rbp
  816061:	48 89 e5             	mov    %rsp,%rbp
  816064:	48 83 ec 30          	sub    $0x30,%rsp
  816068:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81606c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  816070:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  816074:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  816078:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81607c:	be 02 00 00 00       	mov    $0x2,%esi
  816081:	48 89 c7             	mov    %rax,%rdi
  816084:	48 b8 4e 57 81 00 00 	movabs $0x81574e,%rax
  81608b:	00 00 00 
  81608e:	ff d0                	callq  *%rax
  816090:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  816093:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  816097:	0f 88 8e 00 00 00    	js     81612b <etharp_find_addr+0xcb>
  81609d:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8160a1:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8160a8:	00 00 00 
  8160ab:	48 63 d0             	movslq %eax,%rdx
  8160ae:	48 89 d0             	mov    %rdx,%rax
  8160b1:	48 c1 e0 02          	shl    $0x2,%rax
  8160b5:	48 01 d0             	add    %rdx,%rax
  8160b8:	48 c1 e0 03          	shl    $0x3,%rax
  8160bc:	48 01 c8             	add    %rcx,%rax
  8160bf:	48 83 c0 10          	add    $0x10,%rax
  8160c3:	8b 40 04             	mov    0x4(%rax),%eax
  8160c6:	83 f8 02             	cmp    $0x2,%eax
  8160c9:	75 60                	jne    81612b <etharp_find_addr+0xcb>
      *eth_ret = &arp_table[i].ethaddr;
  8160cb:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8160cf:	48 63 d0             	movslq %eax,%rdx
  8160d2:	48 89 d0             	mov    %rdx,%rax
  8160d5:	48 c1 e0 02          	shl    $0x2,%rax
  8160d9:	48 01 d0             	add    %rdx,%rax
  8160dc:	48 c1 e0 03          	shl    $0x3,%rax
  8160e0:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  8160e7:	00 00 00 
  8160ea:	48 01 d0             	add    %rdx,%rax
  8160ed:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8160f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8160f5:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  8160f8:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8160fc:	48 63 d0             	movslq %eax,%rdx
  8160ff:	48 89 d0             	mov    %rdx,%rax
  816102:	48 c1 e0 02          	shl    $0x2,%rax
  816106:	48 01 d0             	add    %rdx,%rax
  816109:	48 c1 e0 03          	shl    $0x3,%rax
  81610d:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  816114:	00 00 00 
  816117:	48 01 d0             	add    %rdx,%rax
  81611a:	48 8d 50 08          	lea    0x8(%rax),%rdx
  81611e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816122:	48 89 10             	mov    %rdx,(%rax)
      return i;
  816125:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816129:	eb 05                	jmp    816130 <etharp_find_addr+0xd0>
  }
  return -1;
  81612b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816130:	c9                   	leaveq 
  816131:	c3                   	retq   

0000000000816132 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816132:	55                   	push   %rbp
  816133:	48 89 e5             	mov    %rsp,%rbp
  816136:	48 83 ec 20          	sub    $0x20,%rsp
  81613a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81613e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816142:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816147:	75 2a                	jne    816173 <etharp_ip_input+0x41>
  816149:	48 ba 6f 25 82 00 00 	movabs $0x82256f,%rdx
  816150:	00 00 00 
  816153:	be 48 02 00 00       	mov    $0x248,%esi
  816158:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  81615f:	00 00 00 
  816162:	b8 00 00 00 00       	mov    $0x0,%eax
  816167:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81616e:	00 00 00 
  816171:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  816173:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816177:	48 8b 40 08          	mov    0x8(%rax),%rax
  81617b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  81617f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816183:	8b 50 1c             	mov    0x1c(%rax),%edx
  816186:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81618a:	8b 40 08             	mov    0x8(%rax),%eax
  81618d:	31 c2                	xor    %eax,%edx
  81618f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816193:	8b 40 0c             	mov    0xc(%rax),%eax
  816196:	21 d0                	and    %edx,%eax
  816198:	85 c0                	test   %eax,%eax
  81619a:	75 2a                	jne    8161c6 <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  81619c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8161a0:	48 8d 50 06          	lea    0x6(%rax),%rdx
  8161a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8161a8:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  8161ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8161b0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8161b5:	48 89 c7             	mov    %rax,%rdi
  8161b8:	48 b8 b8 5d 81 00 00 	movabs $0x815db8,%rax
  8161bf:	00 00 00 
  8161c2:	ff d0                	callq  *%rax
  8161c4:	eb 01                	jmp    8161c7 <etharp_ip_input+0x95>
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
  8161c6:	90                   	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  8161c7:	c9                   	leaveq 
  8161c8:	c3                   	retq   

00000000008161c9 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8161c9:	55                   	push   %rbp
  8161ca:	48 89 e5             	mov    %rsp,%rbp
  8161cd:	53                   	push   %rbx
  8161ce:	48 83 ec 58          	sub    $0x58,%rsp
  8161d2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8161d6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8161da:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8161de:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8161e3:	75 2a                	jne    81620f <etharp_arp_input+0x46>
  8161e5:	48 ba 6f 25 82 00 00 	movabs $0x82256f,%rdx
  8161ec:	00 00 00 
  8161ef:	be 75 02 00 00       	mov    $0x275,%esi
  8161f4:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  8161fb:	00 00 00 
  8161fe:	b8 00 00 00 00       	mov    $0x0,%eax
  816203:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81620a:	00 00 00 
  81620d:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  81620f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816213:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  816217:	66 83 f8 29          	cmp    $0x29,%ax
  81621b:	77 18                	ja     816235 <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  81621d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816221:	48 89 c7             	mov    %rax,%rdi
  816224:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81622b:	00 00 00 
  81622e:	ff d0                	callq  *%rax
    return;
  816230:	e9 cd 02 00 00       	jmpq   816502 <etharp_arp_input+0x339>
  }

  hdr = p->payload;
  816235:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816239:	48 8b 40 08          	mov    0x8(%rax),%rax
  81623d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816241:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816245:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  816249:	bf 01 00 00 00       	mov    $0x1,%edi
  81624e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816255:	00 00 00 
  816258:	ff d0                	callq  *%rax
  81625a:	66 39 c3             	cmp    %ax,%bx
  81625d:	75 5a                	jne    8162b9 <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  81625f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816263:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  816267:	bf 04 06 00 00       	mov    $0x604,%edi
  81626c:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816273:	00 00 00 
  816276:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816278:	66 39 c3             	cmp    %ax,%bx
  81627b:	75 3c                	jne    8162b9 <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  81627d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816281:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  816285:	bf 00 08 00 00       	mov    $0x800,%edi
  81628a:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816291:	00 00 00 
  816294:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  816296:	66 39 c3             	cmp    %ax,%bx
  816299:	75 1e                	jne    8162b9 <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  81629b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81629f:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  8162a3:	bf 06 08 00 00       	mov    $0x806,%edi
  8162a8:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8162af:	00 00 00 
  8162b2:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8162b4:	66 39 c3             	cmp    %ax,%bx
  8162b7:	74 18                	je     8162d1 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8162b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8162bd:	48 89 c7             	mov    %rax,%rdi
  8162c0:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8162c7:	00 00 00 
  8162ca:	ff d0                	callq  *%rax
    return;
  8162cc:	e9 31 02 00 00       	jmpq   816502 <etharp_arp_input+0x339>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8162d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8162d5:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  8162d9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8162dd:	ba 04 00 00 00       	mov    $0x4,%edx
  8162e2:	48 89 ce             	mov    %rcx,%rsi
  8162e5:	48 89 c7             	mov    %rax,%rdi
  8162e8:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  8162ef:	00 00 00 
  8162f2:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  8162f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8162f8:	48 8d 48 26          	lea    0x26(%rax),%rcx
  8162fc:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  816300:	ba 04 00 00 00       	mov    $0x4,%edx
  816305:	48 89 ce             	mov    %rcx,%rsi
  816308:	48 89 c7             	mov    %rax,%rdi
  81630b:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  816312:	00 00 00 
  816315:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  816317:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81631b:	8b 40 08             	mov    0x8(%rax),%eax
  81631e:	85 c0                	test   %eax,%eax
  816320:	75 06                	jne    816328 <etharp_arp_input+0x15f>
    for_us = 0;
  816322:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  816326:	eb 12                	jmp    81633a <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  816328:	8b 55 c0             	mov    -0x40(%rbp),%edx
  81632b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81632f:	8b 40 08             	mov    0x8(%rax),%eax
  816332:	39 c2                	cmp    %eax,%edx
  816334:	0f 94 c0             	sete   %al
  816337:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  81633a:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81633e:	74 26                	je     816366 <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816340:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816344:	48 8d 50 16          	lea    0x16(%rax),%rdx
  816348:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  81634c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816350:	b9 01 00 00 00       	mov    $0x1,%ecx
  816355:	48 89 c7             	mov    %rax,%rdi
  816358:	48 b8 b8 5d 81 00 00 	movabs $0x815db8,%rax
  81635f:	00 00 00 
  816362:	ff d0                	callq  *%rax
  816364:	eb 24                	jmp    81638a <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  816366:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81636a:	48 8d 50 16          	lea    0x16(%rax),%rdx
  81636e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816372:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816376:	b9 00 00 00 00       	mov    $0x0,%ecx
  81637b:	48 89 c7             	mov    %rax,%rdi
  81637e:	48 b8 b8 5d 81 00 00 	movabs $0x815db8,%rax
  816385:	00 00 00 
  816388:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  81638a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81638e:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  816392:	0f b7 c0             	movzwl %ax,%eax
  816395:	89 c7                	mov    %eax,%edi
  816397:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  81639e:	00 00 00 
  8163a1:	ff d0                	callq  *%rax
  8163a3:	0f b7 c0             	movzwl %ax,%eax
  8163a6:	83 f8 01             	cmp    $0x1,%eax
  8163a9:	74 0e                	je     8163b9 <etharp_arp_input+0x1f0>
  8163ab:	83 f8 02             	cmp    $0x2,%eax
  8163ae:	0f 84 1c 01 00 00    	je     8164d0 <etharp_arp_input+0x307>
  8163b4:	e9 33 01 00 00       	jmpq   8164ec <etharp_arp_input+0x323>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  8163b9:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  8163bd:	0f 84 2b 01 00 00    	je     8164ee <etharp_arp_input+0x325>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  8163c3:	bf 02 00 00 00       	mov    $0x2,%edi
  8163c8:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8163cf:	00 00 00 
  8163d2:	ff d0                	callq  *%rax
  8163d4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8163d8:	66 89 42 14          	mov    %ax,0x14(%rdx)

      hdr->dipaddr = hdr->sipaddr;
  8163dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163e0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8163e4:	8b 52 1c             	mov    0x1c(%rdx),%edx
  8163e7:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8163ea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8163ee:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8163f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8163f6:	8b 12                	mov    (%rdx),%edx
  8163f8:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8163fb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8163ff:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816403:	3c 06                	cmp    $0x6,%al
  816405:	74 2a                	je     816431 <etharp_arp_input+0x268>
  816407:	48 ba 00 25 82 00 00 	movabs $0x822500,%rdx
  81640e:	00 00 00 
  816411:	be c7 02 00 00       	mov    $0x2c7,%esi
  816416:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  81641d:	00 00 00 
  816420:	b8 00 00 00 00       	mov    $0x0,%eax
  816425:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81642c:	00 00 00 
  81642f:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816431:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816435:	eb 79                	jmp    8164b0 <etharp_arp_input+0x2e7>
        i--;
  816437:	80 6d ef 01          	subb   $0x1,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  81643b:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81643f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816443:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816447:	48 98                	cltq   
  816449:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  81644e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816452:	48 63 c6             	movslq %esi,%rax
  816455:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  816459:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81645d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816461:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816465:	48 98                	cltq   
  816467:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  81646c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816470:	48 63 c6             	movslq %esi,%rax
  816473:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  816476:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81647a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81647e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816482:	48 98                	cltq   
  816484:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816488:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81648c:	48 63 c6             	movslq %esi,%rax
  81648f:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  816493:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816497:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81649b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  81649f:	48 98                	cltq   
  8164a1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8164a5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8164a9:	48 63 c6             	movslq %esi,%rax
  8164ac:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  8164b0:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8164b4:	75 81                	jne    816437 <etharp_arp_input+0x26e>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  8164b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8164ba:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8164be:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8164c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8164c6:	48 89 d6             	mov    %rdx,%rsi
  8164c9:	48 89 c7             	mov    %rax,%rdi
  8164cc:	ff d1                	callq  *%rcx
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  8164ce:	eb 1e                	jmp    8164ee <etharp_arp_input+0x325>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  8164d0:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8164d4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8164d8:	48 89 d6             	mov    %rdx,%rsi
  8164db:	48 89 c7             	mov    %rax,%rdi
  8164de:	48 b8 7a 9d 80 00 00 	movabs $0x809d7a,%rax
  8164e5:	00 00 00 
  8164e8:	ff d0                	callq  *%rax
#endif
    break;
  8164ea:	eb 03                	jmp    8164ef <etharp_arp_input+0x326>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  8164ec:	eb 01                	jmp    8164ef <etharp_arp_input+0x326>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  8164ee:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  8164ef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8164f3:	48 89 c7             	mov    %rax,%rdi
  8164f6:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8164fd:	00 00 00 
  816500:	ff d0                	callq  *%rax
}
  816502:	48 83 c4 58          	add    $0x58,%rsp
  816506:	5b                   	pop    %rbx
  816507:	5d                   	pop    %rbp
  816508:	c3                   	retq   

0000000000816509 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  816509:	55                   	push   %rbp
  81650a:	48 89 e5             	mov    %rsp,%rbp
  81650d:	53                   	push   %rbx
  81650e:	48 83 ec 38          	sub    $0x38,%rsp
  816512:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816516:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81651a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  81651e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816522:	be 0e 00 00 00       	mov    $0xe,%esi
  816527:	48 89 c7             	mov    %rax,%rdi
  81652a:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  816531:	00 00 00 
  816534:	ff d0                	callq  *%rax
  816536:	84 c0                	test   %al,%al
  816538:	74 0a                	je     816544 <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  81653a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  81653f:	e9 50 01 00 00       	jmpq   816694 <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  816544:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81654b:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  81654c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816550:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816554:	48 89 d6             	mov    %rdx,%rsi
  816557:	48 89 c7             	mov    %rax,%rdi
  81655a:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  816561:	00 00 00 
  816564:	ff d0                	callq  *%rax
  816566:	84 c0                	test   %al,%al
  816568:	74 13                	je     81657d <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  81656a:	48 b8 88 24 82 00 00 	movabs $0x822488,%rax
  816571:	00 00 00 
  816574:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816578:	e9 ee 00 00 00       	jmpq   81666b <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  81657d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816581:	8b 18                	mov    (%rax),%ebx
  816583:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816588:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81658f:	00 00 00 
  816592:	ff d0                	callq  *%rax
  816594:	21 c3                	and    %eax,%ebx
  816596:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81659b:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  8165a2:	00 00 00 
  8165a5:	ff d0                	callq  *%rax
  8165a7:	39 c3                	cmp    %eax,%ebx
  8165a9:	75 64                	jne    81660f <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  8165ab:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  8165af:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  8165b3:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  8165b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8165bb:	8b 00                	mov    (%rax),%eax
  8165bd:	89 c7                	mov    %eax,%edi
  8165bf:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  8165c6:	00 00 00 
  8165c9:	ff d0                	callq  *%rax
  8165cb:	c1 e8 10             	shr    $0x10,%eax
  8165ce:	83 e0 7f             	and    $0x7f,%eax
  8165d1:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  8165d4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8165d8:	8b 00                	mov    (%rax),%eax
  8165da:	89 c7                	mov    %eax,%edi
  8165dc:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  8165e3:	00 00 00 
  8165e6:	ff d0                	callq  *%rax
  8165e8:	c1 e8 08             	shr    $0x8,%eax
  8165eb:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  8165ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8165f2:	8b 00                	mov    (%rax),%eax
  8165f4:	89 c7                	mov    %eax,%edi
  8165f6:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  8165fd:	00 00 00 
  816600:	ff d0                	callq  *%rax
  816602:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  816605:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  816609:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81660d:	eb 5c                	jmp    81666b <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  81660f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816613:	8b 10                	mov    (%rax),%edx
  816615:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816619:	8b 40 08             	mov    0x8(%rax),%eax
  81661c:	31 c2                	xor    %eax,%edx
  81661e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816622:	8b 40 0c             	mov    0xc(%rax),%eax
  816625:	21 d0                	and    %edx,%eax
  816627:	85 c0                	test   %eax,%eax
  816629:	74 20                	je     81664b <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  81662b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81662f:	8b 40 10             	mov    0x10(%rax),%eax
  816632:	85 c0                	test   %eax,%eax
  816634:	74 0e                	je     816644 <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816636:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81663a:	48 83 c0 10          	add    $0x10,%rax
  81663e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  816642:	eb 07                	jmp    81664b <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816644:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816649:	eb 49                	jmp    816694 <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  81664b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81664f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816653:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816657:	48 89 ce             	mov    %rcx,%rsi
  81665a:	48 89 c7             	mov    %rax,%rdi
  81665d:	48 b8 9b 66 81 00 00 	movabs $0x81669b,%rax
  816664:	00 00 00 
  816667:	ff d0                	callq  *%rax
  816669:	eb 29                	jmp    816694 <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  81666b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81666f:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816673:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816677:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  81667b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81667f:	48 89 d1             	mov    %rdx,%rcx
  816682:	48 89 fa             	mov    %rdi,%rdx
  816685:	48 89 c7             	mov    %rax,%rdi
  816688:	48 b8 e2 5c 81 00 00 	movabs $0x815ce2,%rax
  81668f:	00 00 00 
  816692:	ff d0                	callq  *%rax
}
  816694:	48 83 c4 38          	add    $0x38,%rsp
  816698:	5b                   	pop    %rbx
  816699:	5d                   	pop    %rbp
  81669a:	c3                   	retq   

000000000081669b <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  81669b:	55                   	push   %rbp
  81669c:	48 89 e5             	mov    %rsp,%rbp
  81669f:	53                   	push   %rbx
  8166a0:	48 83 ec 68          	sub    $0x68,%rsp
  8166a4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8166a8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8166ac:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  8166b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8166b4:	48 83 c0 41          	add    $0x41,%rax
  8166b8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  8166bc:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8166c0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8166c4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8166c8:	48 89 d6             	mov    %rdx,%rsi
  8166cb:	48 89 c7             	mov    %rax,%rdi
  8166ce:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  8166d5:	00 00 00 
  8166d8:	ff d0                	callq  *%rax
  8166da:	84 c0                	test   %al,%al
  8166dc:	75 3f                	jne    81671d <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  8166de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8166e2:	8b 18                	mov    (%rax),%ebx
  8166e4:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8166e9:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  8166f0:	00 00 00 
  8166f3:	ff d0                	callq  *%rax
  8166f5:	21 c3                	and    %eax,%ebx
  8166f7:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8166fc:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  816703:	00 00 00 
  816706:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  816708:	39 c3                	cmp    %eax,%ebx
  81670a:	74 11                	je     81671d <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  81670c:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  816711:	74 0a                	je     81671d <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  816713:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  816717:	8b 00                	mov    (%rax),%eax
  816719:	85 c0                	test   %eax,%eax
  81671b:	75 0a                	jne    816727 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  81671d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816722:	e9 1f 04 00 00       	jmpq   816b46 <etharp_query+0x4ab>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816727:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81672b:	be 01 00 00 00       	mov    $0x1,%esi
  816730:	48 89 c7             	mov    %rax,%rdi
  816733:	48 b8 4e 57 81 00 00 	movabs $0x81574e,%rax
  81673a:	00 00 00 
  81673d:	ff d0                	callq  *%rax
  81673f:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  816742:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816746:	79 09                	jns    816751 <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816748:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  81674c:	e9 f5 03 00 00       	jmpq   816b46 <etharp_query+0x4ab>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  816751:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816755:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81675c:	00 00 00 
  81675f:	48 63 d0             	movslq %eax,%rdx
  816762:	48 89 d0             	mov    %rdx,%rax
  816765:	48 c1 e0 02          	shl    $0x2,%rax
  816769:	48 01 d0             	add    %rdx,%rax
  81676c:	48 c1 e0 03          	shl    $0x3,%rax
  816770:	48 01 c8             	add    %rcx,%rax
  816773:	48 83 c0 10          	add    $0x10,%rax
  816777:	8b 40 04             	mov    0x4(%rax),%eax
  81677a:	85 c0                	test   %eax,%eax
  81677c:	75 2d                	jne    8167ab <etharp_query+0x110>
    arp_table[i].state = ETHARP_STATE_PENDING;
  81677e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816782:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816789:	00 00 00 
  81678c:	48 63 d0             	movslq %eax,%rdx
  81678f:	48 89 d0             	mov    %rdx,%rax
  816792:	48 c1 e0 02          	shl    $0x2,%rax
  816796:	48 01 d0             	add    %rdx,%rax
  816799:	48 c1 e0 03          	shl    $0x3,%rax
  81679d:	48 01 c8             	add    %rcx,%rax
  8167a0:	48 83 c0 10          	add    $0x10,%rax
  8167a4:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  8167ab:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8167af:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8167b6:	00 00 00 
  8167b9:	48 63 d0             	movslq %eax,%rdx
  8167bc:	48 89 d0             	mov    %rdx,%rax
  8167bf:	48 c1 e0 02          	shl    $0x2,%rax
  8167c3:	48 01 d0             	add    %rdx,%rax
  8167c6:	48 c1 e0 03          	shl    $0x3,%rax
  8167ca:	48 01 c8             	add    %rcx,%rax
  8167cd:	48 83 c0 10          	add    $0x10,%rax
  8167d1:	8b 40 04             	mov    0x4(%rax),%eax
  8167d4:	83 f8 01             	cmp    $0x1,%eax
  8167d7:	74 58                	je     816831 <etharp_query+0x196>
  8167d9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8167dd:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  8167e4:	00 00 00 
  8167e7:	48 63 d0             	movslq %eax,%rdx
  8167ea:	48 89 d0             	mov    %rdx,%rax
  8167ed:	48 c1 e0 02          	shl    $0x2,%rax
  8167f1:	48 01 d0             	add    %rdx,%rax
  8167f4:	48 c1 e0 03          	shl    $0x3,%rax
  8167f8:	48 01 c8             	add    %rcx,%rax
  8167fb:	48 83 c0 10          	add    $0x10,%rax
  8167ff:	8b 40 04             	mov    0x4(%rax),%eax
  816802:	83 f8 02             	cmp    $0x2,%eax
  816805:	74 2a                	je     816831 <etharp_query+0x196>
  816807:	48 ba 80 25 82 00 00 	movabs $0x822580,%rdx
  81680e:	00 00 00 
  816811:	be 92 03 00 00       	mov    $0x392,%esi
  816816:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  81681d:	00 00 00 
  816820:	b8 00 00 00 00       	mov    $0x0,%eax
  816825:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81682c:	00 00 00 
  81682f:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816831:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816835:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  81683c:	00 00 00 
  81683f:	48 63 d0             	movslq %eax,%rdx
  816842:	48 89 d0             	mov    %rdx,%rax
  816845:	48 c1 e0 02          	shl    $0x2,%rax
  816849:	48 01 d0             	add    %rdx,%rax
  81684c:	48 c1 e0 03          	shl    $0x3,%rax
  816850:	48 01 c8             	add    %rcx,%rax
  816853:	48 83 c0 10          	add    $0x10,%rax
  816857:	8b 40 04             	mov    0x4(%rax),%eax
  81685a:	83 f8 01             	cmp    $0x1,%eax
  81685d:	74 07                	je     816866 <etharp_query+0x1cb>
  81685f:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816864:	75 1d                	jne    816883 <etharp_query+0x1e8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816866:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  81686a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81686e:	48 89 d6             	mov    %rdx,%rsi
  816871:	48 89 c7             	mov    %rax,%rdi
  816874:	48 b8 79 6d 81 00 00 	movabs $0x816d79,%rax
  81687b:	00 00 00 
  81687e:	ff d0                	callq  *%rax
  816880:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816883:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816888:	0f 84 b4 02 00 00    	je     816b42 <etharp_query+0x4a7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  81688e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816892:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816899:	00 00 00 
  81689c:	48 63 d0             	movslq %eax,%rdx
  81689f:	48 89 d0             	mov    %rdx,%rax
  8168a2:	48 c1 e0 02          	shl    $0x2,%rax
  8168a6:	48 01 d0             	add    %rdx,%rax
  8168a9:	48 c1 e0 03          	shl    $0x3,%rax
  8168ad:	48 01 c8             	add    %rcx,%rax
  8168b0:	48 83 c0 10          	add    $0x10,%rax
  8168b4:	8b 40 04             	mov    0x4(%rax),%eax
  8168b7:	83 f8 02             	cmp    $0x2,%eax
  8168ba:	75 49                	jne    816905 <etharp_query+0x26a>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  8168bc:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8168c0:	48 63 d0             	movslq %eax,%rdx
  8168c3:	48 89 d0             	mov    %rdx,%rax
  8168c6:	48 c1 e0 02          	shl    $0x2,%rax
  8168ca:	48 01 d0             	add    %rdx,%rax
  8168cd:	48 c1 e0 03          	shl    $0x3,%rax
  8168d1:	48 ba 80 b6 b4 00 00 	movabs $0xb4b680,%rdx
  8168d8:	00 00 00 
  8168db:	48 01 d0             	add    %rdx,%rax
  8168de:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  8168e2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8168e6:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  8168ea:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8168ee:	48 89 c7             	mov    %rax,%rdi
  8168f1:	48 b8 e2 5c 81 00 00 	movabs $0x815ce2,%rax
  8168f8:	00 00 00 
  8168fb:	ff d0                	callq  *%rax
  8168fd:	88 45 ef             	mov    %al,-0x11(%rbp)
  816900:	e9 3d 02 00 00       	jmpq   816b42 <etharp_query+0x4a7>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816905:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816909:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816910:	00 00 00 
  816913:	48 63 d0             	movslq %eax,%rdx
  816916:	48 89 d0             	mov    %rdx,%rax
  816919:	48 c1 e0 02          	shl    $0x2,%rax
  81691d:	48 01 d0             	add    %rdx,%rax
  816920:	48 c1 e0 03          	shl    $0x3,%rax
  816924:	48 01 c8             	add    %rcx,%rax
  816927:	48 83 c0 10          	add    $0x10,%rax
  81692b:	8b 40 04             	mov    0x4(%rax),%eax
  81692e:	83 f8 01             	cmp    $0x1,%eax
  816931:	0f 85 0b 02 00 00    	jne    816b42 <etharp_query+0x4a7>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816937:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  81693e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816942:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816946:	eb 6b                	jmp    8169b3 <etharp_query+0x318>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816948:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81694c:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  816950:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816954:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816958:	66 39 c2             	cmp    %ax,%dx
  81695b:	75 36                	jne    816993 <etharp_query+0x2f8>
  81695d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816961:	48 8b 00             	mov    (%rax),%rax
  816964:	48 85 c0             	test   %rax,%rax
  816967:	74 2a                	je     816993 <etharp_query+0x2f8>
  816969:	48 ba a8 25 82 00 00 	movabs $0x8225a8,%rdx
  816970:	00 00 00 
  816973:	be b1 03 00 00       	mov    $0x3b1,%esi
  816978:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  81697f:	00 00 00 
  816982:	b8 00 00 00 00       	mov    $0x0,%eax
  816987:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81698e:	00 00 00 
  816991:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816993:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816997:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81699b:	3c 01                	cmp    $0x1,%al
  81699d:	74 09                	je     8169a8 <etharp_query+0x30d>
          copy_needed = 1;
  81699f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  8169a6:	eb 12                	jmp    8169ba <etharp_query+0x31f>
        }
        p = p->next;
  8169a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169ac:	48 8b 00             	mov    (%rax),%rax
  8169af:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  8169b3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8169b8:	75 8e                	jne    816948 <etharp_query+0x2ad>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  8169ba:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8169be:	74 69                	je     816a29 <etharp_query+0x38e>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  8169c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169c4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8169c8:	0f b7 c0             	movzwl %ax,%eax
  8169cb:	ba 00 00 00 00       	mov    $0x0,%edx
  8169d0:	89 c6                	mov    %eax,%esi
  8169d2:	bf 03 00 00 00       	mov    $0x3,%edi
  8169d7:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  8169de:	00 00 00 
  8169e1:	ff d0                	callq  *%rax
  8169e3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  8169e7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8169ec:	74 56                	je     816a44 <etharp_query+0x3a9>
          if (pbuf_copy(p, q) != ERR_OK) {
  8169ee:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8169f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8169f6:	48 89 d6             	mov    %rdx,%rsi
  8169f9:	48 89 c7             	mov    %rax,%rdi
  8169fc:	48 b8 d4 db 80 00 00 	movabs $0x80dbd4,%rax
  816a03:	00 00 00 
  816a06:	ff d0                	callq  *%rax
  816a08:	84 c0                	test   %al,%al
  816a0a:	74 38                	je     816a44 <etharp_query+0x3a9>
            pbuf_free(p);
  816a0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a10:	48 89 c7             	mov    %rax,%rdi
  816a13:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  816a1a:	00 00 00 
  816a1d:	ff d0                	callq  *%rax
            p = NULL;
  816a1f:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  816a26:	00 
  816a27:	eb 1b                	jmp    816a44 <etharp_query+0x3a9>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  816a29:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816a2d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  816a31:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816a35:	48 89 c7             	mov    %rax,%rdi
  816a38:	48 b8 2f d9 80 00 00 	movabs $0x80d92f,%rax
  816a3f:	00 00 00 
  816a42:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  816a44:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816a49:	0f 84 f3 00 00 00    	je     816b42 <etharp_query+0x4a7>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  816a4f:	bf 0a 00 00 00       	mov    $0xa,%edi
  816a54:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  816a5b:	00 00 00 
  816a5e:	ff d0                	callq  *%rax
  816a60:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  816a64:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816a69:	0f 84 c0 00 00 00    	je     816b2f <etharp_query+0x494>
          new_entry->next = 0;
  816a6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a73:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  816a7a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816a7e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816a82:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  816a86:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816a8a:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816a91:	00 00 00 
  816a94:	48 63 d0             	movslq %eax,%rdx
  816a97:	48 89 d0             	mov    %rdx,%rax
  816a9a:	48 c1 e0 02          	shl    $0x2,%rax
  816a9e:	48 01 d0             	add    %rdx,%rax
  816aa1:	48 c1 e0 03          	shl    $0x3,%rax
  816aa5:	48 01 c8             	add    %rcx,%rax
  816aa8:	48 8b 00             	mov    (%rax),%rax
  816aab:	48 85 c0             	test   %rax,%rax
  816aae:	74 4f                	je     816aff <etharp_query+0x464>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  816ab0:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ab4:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816abb:	00 00 00 
  816abe:	48 63 d0             	movslq %eax,%rdx
  816ac1:	48 89 d0             	mov    %rdx,%rax
  816ac4:	48 c1 e0 02          	shl    $0x2,%rax
  816ac8:	48 01 d0             	add    %rdx,%rax
  816acb:	48 c1 e0 03          	shl    $0x3,%rax
  816acf:	48 01 c8             	add    %rcx,%rax
  816ad2:	48 8b 00             	mov    (%rax),%rax
  816ad5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  816ad9:	eb 0b                	jmp    816ae6 <etharp_query+0x44b>
              r = r->next;
  816adb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816adf:	48 8b 00             	mov    (%rax),%rax
  816ae2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  816ae6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816aea:	48 8b 00             	mov    (%rax),%rax
  816aed:	48 85 c0             	test   %rax,%rax
  816af0:	75 e9                	jne    816adb <etharp_query+0x440>
              r = r->next;
            }
            r->next = new_entry;
  816af2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816af6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816afa:	48 89 10             	mov    %rdx,(%rax)
  816afd:	eb 2a                	jmp    816b29 <etharp_query+0x48e>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  816aff:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816b03:	48 b9 80 b6 b4 00 00 	movabs $0xb4b680,%rcx
  816b0a:	00 00 00 
  816b0d:	48 63 d0             	movslq %eax,%rdx
  816b10:	48 89 d0             	mov    %rdx,%rax
  816b13:	48 c1 e0 02          	shl    $0x2,%rax
  816b17:	48 01 d0             	add    %rdx,%rax
  816b1a:	48 c1 e0 03          	shl    $0x3,%rax
  816b1e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  816b22:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816b26:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  816b29:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  816b2d:	eb 13                	jmp    816b42 <etharp_query+0x4a7>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  816b2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b33:	48 89 c7             	mov    %rax,%rdi
  816b36:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  816b3d:	00 00 00 
  816b40:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  816b42:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  816b46:	48 83 c4 68          	add    $0x68,%rsp
  816b4a:	5b                   	pop    %rbx
  816b4b:	5d                   	pop    %rbp
  816b4c:	c3                   	retq   

0000000000816b4d <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  816b4d:	55                   	push   %rbp
  816b4e:	48 89 e5             	mov    %rsp,%rbp
  816b51:	48 83 ec 60          	sub    $0x60,%rsp
  816b55:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816b59:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816b5d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  816b61:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  816b65:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  816b69:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  816b6d:	8b 45 18             	mov    0x18(%rbp),%eax
  816b70:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  816b74:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  816b78:	ba 00 00 00 00       	mov    $0x0,%edx
  816b7d:	be 2a 00 00 00       	mov    $0x2a,%esi
  816b82:	bf 02 00 00 00       	mov    $0x2,%edi
  816b87:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  816b8e:	00 00 00 
  816b91:	ff d0                	callq  *%rax
  816b93:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  816b97:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  816b9c:	75 0a                	jne    816ba8 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  816b9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816ba3:	e9 cf 01 00 00       	jmpq   816d77 <etharp_raw+0x22a>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  816ba8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816bac:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  816bb0:	66 83 f8 29          	cmp    $0x29,%ax
  816bb4:	77 2a                	ja     816be0 <etharp_raw+0x93>
  816bb6:	48 ba c8 25 82 00 00 	movabs $0x8225c8,%rdx
  816bbd:	00 00 00 
  816bc0:	be 1c 04 00 00       	mov    $0x41c,%esi
  816bc5:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  816bcc:	00 00 00 
  816bcf:	b8 00 00 00 00       	mov    $0x0,%eax
  816bd4:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  816bdb:	00 00 00 
  816bde:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  816be0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816be4:	48 8b 40 08          	mov    0x8(%rax),%rax
  816be8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  816bec:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  816bf0:	89 c7                	mov    %eax,%edi
  816bf2:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816bf9:	00 00 00 
  816bfc:	ff d0                	callq  *%rax
  816bfe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816c02:	66 89 42 14          	mov    %ax,0x14(%rdx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816c06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816c0a:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816c0e:	3c 06                	cmp    $0x6,%al
  816c10:	74 2a                	je     816c3c <etharp_raw+0xef>
  816c12:	48 ba 00 25 82 00 00 	movabs $0x822500,%rdx
  816c19:	00 00 00 
  816c1c:	be 23 04 00 00       	mov    $0x423,%esi
  816c21:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  816c28:	00 00 00 
  816c2b:	b8 00 00 00 00       	mov    $0x0,%eax
  816c30:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  816c37:	00 00 00 
  816c3a:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  816c3c:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  816c40:	eb 77                	jmp    816cb9 <etharp_raw+0x16c>
    k--;
  816c42:	80 6d ff 01          	subb   $0x1,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  816c46:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816c4a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816c4e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  816c52:	48 98                	cltq   
  816c54:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816c58:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816c5c:	48 63 c6             	movslq %esi,%rax
  816c5f:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  816c63:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816c67:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816c6b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816c6f:	48 98                	cltq   
  816c71:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816c75:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816c79:	48 63 c6             	movslq %esi,%rax
  816c7c:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  816c80:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816c84:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816c88:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816c8c:	48 98                	cltq   
  816c8e:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816c92:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816c96:	48 63 c6             	movslq %esi,%rax
  816c99:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  816c9c:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816ca0:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816ca4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816ca8:	48 98                	cltq   
  816caa:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816cae:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816cb2:	48 63 c6             	movslq %esi,%rax
  816cb5:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  816cb9:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  816cbd:	75 83                	jne    816c42 <etharp_raw+0xf5>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  816cbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816cc3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816cc7:	8b 12                	mov    (%rdx),%edx
  816cc9:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  816ccc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816cd0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  816cd4:	8b 12                	mov    (%rdx),%edx
  816cd6:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  816cd9:	bf 01 00 00 00       	mov    $0x1,%edi
  816cde:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816ce5:	00 00 00 
  816ce8:	ff d0                	callq  *%rax
  816cea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816cee:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  hdr->proto = htons(ETHTYPE_IP);
  816cf2:	bf 00 08 00 00       	mov    $0x800,%edi
  816cf7:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816cfe:	00 00 00 
  816d01:	ff d0                	callq  *%rax
  816d03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816d07:	66 89 42 10          	mov    %ax,0x10(%rdx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  816d0b:	bf 04 06 00 00       	mov    $0x604,%edi
  816d10:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816d17:	00 00 00 
  816d1a:	ff d0                	callq  *%rax
  816d1c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816d20:	66 89 42 12          	mov    %ax,0x12(%rdx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  816d24:	bf 06 08 00 00       	mov    $0x806,%edi
  816d29:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816d30:	00 00 00 
  816d33:	ff d0                	callq  *%rax
  816d35:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816d39:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  816d3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d41:	48 8b 48 28          	mov    0x28(%rax),%rcx
  816d45:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816d49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816d4d:	48 89 d6             	mov    %rdx,%rsi
  816d50:	48 89 c7             	mov    %rax,%rdi
  816d53:	ff d1                	callq  *%rcx
  816d55:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  816d58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816d5c:	48 89 c7             	mov    %rax,%rdi
  816d5f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  816d66:	00 00 00 
  816d69:	ff d0                	callq  *%rax
  p = NULL;
  816d6b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  816d72:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  816d73:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  816d77:	c9                   	leaveq 
  816d78:	c3                   	retq   

0000000000816d79 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  816d79:	55                   	push   %rbp
  816d7a:	48 89 e5             	mov    %rsp,%rbp
  816d7d:	48 83 ec 20          	sub    $0x20,%rsp
  816d81:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  816d85:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  816d89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816d8d:	48 8d 78 08          	lea    0x8(%rax),%rdi
  816d91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816d95:	48 8d 48 41          	lea    0x41(%rax),%rcx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  816d99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816d9d:	48 8d 70 41          	lea    0x41(%rax),%rsi
  816da1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816da5:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
  816dac:	00 
  816dad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816db1:	48 89 14 24          	mov    %rdx,(%rsp)
  816db5:	49 b9 8e 24 82 00 00 	movabs $0x82248e,%r9
  816dbc:	00 00 00 
  816dbf:	49 89 f8             	mov    %rdi,%r8
  816dc2:	48 ba 88 24 82 00 00 	movabs $0x822488,%rdx
  816dc9:	00 00 00 
  816dcc:	48 89 c7             	mov    %rax,%rdi
  816dcf:	48 b8 4d 6b 81 00 00 	movabs $0x816b4d,%rax
  816dd6:	00 00 00 
  816dd9:	ff d0                	callq  *%rax
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  816ddb:	c9                   	leaveq 
  816ddc:	c3                   	retq   

0000000000816ddd <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  816ddd:	55                   	push   %rbp
  816dde:	48 89 e5             	mov    %rsp,%rbp
  816de1:	48 83 ec 20          	sub    $0x20,%rsp
  816de5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816de9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  816ded:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816df1:	48 8b 40 08          	mov    0x8(%rax),%rax
  816df5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  816df9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816dfd:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  816e01:	0f b7 c0             	movzwl %ax,%eax
  816e04:	89 c7                	mov    %eax,%edi
  816e06:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  816e0d:	00 00 00 
  816e10:	ff d0                	callq  *%rax
  816e12:	0f b7 c0             	movzwl %ax,%eax
  816e15:	3d 00 08 00 00       	cmp    $0x800,%eax
  816e1a:	74 10                	je     816e2c <ethernet_input+0x4f>
  816e1c:	3d 06 08 00 00       	cmp    $0x806,%eax
  816e21:	0f 84 81 00 00 00    	je     816ea8 <ethernet_input+0xcb>
  816e27:	e9 a0 00 00 00       	jmpq   816ecc <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  816e2c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816e34:	48 89 d6             	mov    %rdx,%rsi
  816e37:	48 89 c7             	mov    %rax,%rdi
  816e3a:	48 b8 32 61 81 00 00 	movabs $0x816132,%rax
  816e41:	00 00 00 
  816e44:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  816e46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816e4a:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  816e4f:	48 89 c7             	mov    %rax,%rdi
  816e52:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  816e59:	00 00 00 
  816e5c:	ff d0                	callq  *%rax
  816e5e:	84 c0                	test   %al,%al
  816e60:	74 2a                	je     816e8c <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  816e62:	48 ba 00 26 82 00 00 	movabs $0x822600,%rdx
  816e69:	00 00 00 
  816e6c:	be 7e 04 00 00       	mov    $0x47e,%esi
  816e71:	48 bf 9e 24 82 00 00 	movabs $0x82249e,%rdi
  816e78:	00 00 00 
  816e7b:	b8 00 00 00 00       	mov    $0x0,%eax
  816e80:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  816e87:	00 00 00 
  816e8a:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  816e8c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816e90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816e94:	48 89 d6             	mov    %rdx,%rsi
  816e97:	48 89 c7             	mov    %rax,%rdi
  816e9a:	48 b8 f2 08 81 00 00 	movabs $0x8108f2,%rax
  816ea1:	00 00 00 
  816ea4:	ff d0                	callq  *%rax
      }
      break;
  816ea6:	eb 40                	jmp    816ee8 <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  816ea8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816eac:	48 8d 48 41          	lea    0x41(%rax),%rcx
  816eb0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816eb4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816eb8:	48 89 ce             	mov    %rcx,%rsi
  816ebb:	48 89 c7             	mov    %rax,%rdi
  816ebe:	48 b8 c9 61 81 00 00 	movabs $0x8161c9,%rax
  816ec5:	00 00 00 
  816ec8:	ff d0                	callq  *%rax
      break;
  816eca:	eb 1c                	jmp    816ee8 <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  816ecc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816ed0:	48 89 c7             	mov    %rax,%rdi
  816ed3:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  816eda:	00 00 00 
  816edd:	ff d0                	callq  *%rax
      p = NULL;
  816edf:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  816ee6:	00 
      break;
  816ee7:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  816ee8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  816eed:	c9                   	leaveq 
  816eee:	c3                   	retq   
	...

0000000000816ef0 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  816ef0:	55                   	push   %rbp
  816ef1:	48 89 e5             	mov    %rsp,%rbp
  816ef4:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  816ef8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    for (i = 0; i < NSEM; i++) {
  816eff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  816f06:	e9 d0 00 00 00       	jmpq   816fdb <sys_init+0xeb>
	sems[i].freed = 1;
  816f0b:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  816f12:	00 00 00 
  816f15:	8b 55 fc             	mov    -0x4(%rbp),%edx
  816f18:	48 63 d2             	movslq %edx,%rdx
  816f1b:	48 c1 e2 05          	shl    $0x5,%rdx
  816f1f:	48 01 d0             	add    %rdx,%rax
  816f22:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  816f28:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816f2b:	48 98                	cltq   
  816f2d:	48 89 c2             	mov    %rax,%rdx
  816f30:	48 c1 e2 05          	shl    $0x5,%rdx
  816f34:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  816f3b:	00 00 00 
  816f3e:	48 01 d0             	add    %rdx,%rax
  816f41:	48 ba 20 d8 b4 00 00 	movabs $0xb4d820,%rdx
  816f48:	00 00 00 
  816f4b:	48 8b 12             	mov    (%rdx),%rdx
  816f4e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  816f52:	48 8b 40 10          	mov    0x10(%rax),%rax
  816f56:	48 85 c0             	test   %rax,%rax
  816f59:	74 2f                	je     816f8a <sys_init+0x9a>
  816f5b:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  816f62:	00 00 00 
  816f65:	48 8b 00             	mov    (%rax),%rax
  816f68:	8b 55 fc             	mov    -0x4(%rbp),%edx
  816f6b:	48 63 d2             	movslq %edx,%rdx
  816f6e:	48 89 d1             	mov    %rdx,%rcx
  816f71:	48 c1 e1 05          	shl    $0x5,%rcx
  816f75:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  816f7c:	00 00 00 
  816f7f:	48 01 ca             	add    %rcx,%rdx
  816f82:	48 83 c2 10          	add    $0x10,%rdx
  816f86:	48 89 50 18          	mov    %rdx,0x18(%rax)
  816f8a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816f8d:	48 98                	cltq   
  816f8f:	48 89 c2             	mov    %rax,%rdx
  816f92:	48 c1 e2 05          	shl    $0x5,%rdx
  816f96:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  816f9d:	00 00 00 
  816fa0:	48 01 c2             	add    %rax,%rdx
  816fa3:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  816faa:	00 00 00 
  816fad:	48 89 10             	mov    %rdx,(%rax)
  816fb0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  816fb3:	48 98                	cltq   
  816fb5:	48 89 c2             	mov    %rax,%rdx
  816fb8:	48 c1 e2 05          	shl    $0x5,%rdx
  816fbc:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  816fc3:	00 00 00 
  816fc6:	48 01 d0             	add    %rdx,%rax
  816fc9:	48 ba 20 d8 b4 00 00 	movabs $0xb4d820,%rdx
  816fd0:	00 00 00 
  816fd3:	48 89 50 18          	mov    %rdx,0x18(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  816fd7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  816fdb:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  816fe2:	0f 8e 23 ff ff ff    	jle    816f0b <sys_init+0x1b>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  816fe8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  816fef:	e9 36 01 00 00       	jmpq   81712a <sys_init+0x23a>
	mboxes[i].freed = 1;
  816ff4:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  816ffb:	00 00 00 
  816ffe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817001:	48 63 d0             	movslq %eax,%rdx
  817004:	48 89 d0             	mov    %rdx,%rax
  817007:	48 c1 e0 03          	shl    $0x3,%rax
  81700b:	48 01 d0             	add    %rdx,%rax
  81700e:	48 c1 e0 02          	shl    $0x2,%rax
  817012:	48 01 d0             	add    %rdx,%rax
  817015:	48 c1 e0 03          	shl    $0x3,%rax
  817019:	48 01 c8             	add    %rcx,%rax
  81701c:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  817022:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817025:	48 63 d0             	movslq %eax,%rdx
  817028:	48 89 d0             	mov    %rdx,%rax
  81702b:	48 c1 e0 03          	shl    $0x3,%rax
  81702f:	48 01 d0             	add    %rdx,%rax
  817032:	48 c1 e0 02          	shl    $0x2,%rax
  817036:	48 01 d0             	add    %rdx,%rax
  817039:	48 c1 e0 03          	shl    $0x3,%rax
  81703d:	48 89 c2             	mov    %rax,%rdx
  817040:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817047:	00 00 00 
  81704a:	48 01 d0             	add    %rdx,%rax
  81704d:	48 ba 40 6c b5 00 00 	movabs $0xb56c40,%rdx
  817054:	00 00 00 
  817057:	48 8b 12             	mov    (%rdx),%rdx
  81705a:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
  817061:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817068:	48 85 c0             	test   %rax,%rax
  81706b:	74 45                	je     8170b2 <sys_init+0x1c2>
  81706d:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817074:	00 00 00 
  817077:	48 8b 08             	mov    (%rax),%rcx
  81707a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81707d:	48 63 d0             	movslq %eax,%rdx
  817080:	48 89 d0             	mov    %rdx,%rax
  817083:	48 c1 e0 03          	shl    $0x3,%rax
  817087:	48 01 d0             	add    %rdx,%rax
  81708a:	48 c1 e0 02          	shl    $0x2,%rax
  81708e:	48 01 d0             	add    %rdx,%rax
  817091:	48 c1 e0 03          	shl    $0x3,%rax
  817095:	48 89 c2             	mov    %rax,%rdx
  817098:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81709f:	00 00 00 
  8170a2:	48 01 d0             	add    %rdx,%rax
  8170a5:	48 05 18 01 00 00    	add    $0x118,%rax
  8170ab:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  8170b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8170b5:	48 63 d0             	movslq %eax,%rdx
  8170b8:	48 89 d0             	mov    %rdx,%rax
  8170bb:	48 c1 e0 03          	shl    $0x3,%rax
  8170bf:	48 01 d0             	add    %rdx,%rax
  8170c2:	48 c1 e0 02          	shl    $0x2,%rax
  8170c6:	48 01 d0             	add    %rdx,%rax
  8170c9:	48 c1 e0 03          	shl    $0x3,%rax
  8170cd:	48 89 c2             	mov    %rax,%rdx
  8170d0:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8170d7:	00 00 00 
  8170da:	48 01 c2             	add    %rax,%rdx
  8170dd:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8170e4:	00 00 00 
  8170e7:	48 89 10             	mov    %rdx,(%rax)
  8170ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8170ed:	48 63 d0             	movslq %eax,%rdx
  8170f0:	48 89 d0             	mov    %rdx,%rax
  8170f3:	48 c1 e0 03          	shl    $0x3,%rax
  8170f7:	48 01 d0             	add    %rdx,%rax
  8170fa:	48 c1 e0 02          	shl    $0x2,%rax
  8170fe:	48 01 d0             	add    %rdx,%rax
  817101:	48 c1 e0 03          	shl    $0x3,%rax
  817105:	48 89 c2             	mov    %rax,%rdx
  817108:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  81710f:	00 00 00 
  817112:	48 01 d0             	add    %rdx,%rax
  817115:	48 ba 40 6c b5 00 00 	movabs $0xb56c40,%rdx
  81711c:	00 00 00 
  81711f:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817126:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  81712a:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  81712e:	0f 8e c0 fe ff ff    	jle    816ff4 <sys_init+0x104>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  817134:	c9                   	leaveq 
  817135:	c3                   	retq   

0000000000817136 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  817136:	55                   	push   %rbp
  817137:	48 89 e5             	mov    %rsp,%rbp
  81713a:	48 83 ec 20          	sub    $0x20,%rsp
  81713e:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  817141:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  817145:	7e 35                	jle    81717c <sys_mbox_new+0x46>
  817147:	48 b9 28 26 82 00 00 	movabs $0x822628,%rcx
  81714e:	00 00 00 
  817151:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  817158:	00 00 00 
  81715b:	be 45 00 00 00       	mov    $0x45,%esi
  817160:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817167:	00 00 00 
  81716a:	b8 00 00 00 00       	mov    $0x0,%eax
  81716f:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817176:	00 00 00 
  817179:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  81717c:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817183:	00 00 00 
  817186:	48 8b 00             	mov    (%rax),%rax
  817189:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  81718d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817192:	75 25                	jne    8171b9 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  817194:	48 bf 70 26 82 00 00 	movabs $0x822670,%rdi
  81719b:	00 00 00 
  81719e:	b8 00 00 00 00       	mov    $0x0,%eax
  8171a3:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  8171aa:	00 00 00 
  8171ad:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  8171af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8171b4:	e9 5e 01 00 00       	jmpq   817317 <sys_mbox_new+0x1e1>
    }
    LIST_REMOVE(mbe, link);
  8171b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171bd:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  8171c4:	48 85 c0             	test   %rax,%rax
  8171c7:	74 1d                	je     8171e6 <sys_mbox_new+0xb0>
  8171c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171cd:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  8171d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8171d8:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  8171df:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  8171e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8171ea:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  8171f1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8171f5:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  8171fc:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  8171ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817203:	8b 00                	mov    (%rax),%eax
  817205:	85 c0                	test   %eax,%eax
  817207:	75 35                	jne    81723e <sys_mbox_new+0x108>
  817209:	48 b9 96 26 82 00 00 	movabs $0x822696,%rcx
  817210:	00 00 00 
  817213:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  81721a:	00 00 00 
  81721d:	be 4c 00 00 00       	mov    $0x4c,%esi
  817222:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817229:	00 00 00 
  81722c:	b8 00 00 00 00       	mov    $0x0,%eax
  817231:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817238:	00 00 00 
  81723b:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  81723e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817242:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  817248:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81724c:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817253:	00 00 00 
  817256:	48 89 d1             	mov    %rdx,%rcx
  817259:	48 29 c1             	sub    %rax,%rcx
  81725c:	48 89 c8             	mov    %rcx,%rax
  81725f:	48 89 c2             	mov    %rax,%rdx
  817262:	48 c1 fa 03          	sar    $0x3,%rdx
  817266:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  81726d:	ba c1 14 
  817270:	48 0f af c2          	imul   %rdx,%rax
  817274:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  817277:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81727b:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  817282:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817286:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  81728d:	bf 00 00 00 00       	mov    $0x0,%edi
  817292:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  817299:	00 00 00 
  81729c:	ff d0                	callq  *%rax
  81729e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8172a2:	89 82 10 01 00 00    	mov    %eax,0x110(%rdx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  8172a8:	bf 20 00 00 00       	mov    $0x20,%edi
  8172ad:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  8172b4:	00 00 00 
  8172b7:	ff d0                	callq  *%rax
  8172b9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8172bd:	89 82 14 01 00 00    	mov    %eax,0x114(%rdx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  8172c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172c7:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  8172cd:	83 f8 ff             	cmp    $0xffffffff,%eax
  8172d0:	74 0f                	je     8172e1 <sys_mbox_new+0x1ab>
	mbe->free_msg == SYS_SEM_NULL)
  8172d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8172d6:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  8172dc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8172df:	75 33                	jne    817314 <sys_mbox_new+0x1de>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  8172e1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8172e4:	89 c7                	mov    %eax,%edi
  8172e6:	48 b8 19 73 81 00 00 	movabs $0x817319,%rax
  8172ed:	00 00 00 
  8172f0:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  8172f2:	48 bf a8 26 82 00 00 	movabs $0x8226a8,%rdi
  8172f9:	00 00 00 
  8172fc:	b8 00 00 00 00       	mov    $0x0,%eax
  817301:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  817308:	00 00 00 
  81730b:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  81730d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817312:	eb 03                	jmp    817317 <sys_mbox_new+0x1e1>
    }
    return i;
  817314:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  817317:	c9                   	leaveq 
  817318:	c3                   	retq   

0000000000817319 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  817319:	55                   	push   %rbp
  81731a:	48 89 e5             	mov    %rsp,%rbp
  81731d:	48 83 ec 10          	sub    $0x10,%rsp
  817321:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!mboxes[mbox].freed);
  817324:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81732b:	00 00 00 
  81732e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817331:	48 63 d0             	movslq %eax,%rdx
  817334:	48 89 d0             	mov    %rdx,%rax
  817337:	48 c1 e0 03          	shl    $0x3,%rax
  81733b:	48 01 d0             	add    %rdx,%rax
  81733e:	48 c1 e0 02          	shl    $0x2,%rax
  817342:	48 01 d0             	add    %rdx,%rax
  817345:	48 c1 e0 03          	shl    $0x3,%rax
  817349:	48 01 c8             	add    %rcx,%rax
  81734c:	8b 00                	mov    (%rax),%eax
  81734e:	85 c0                	test   %eax,%eax
  817350:	74 35                	je     817387 <sys_mbox_free+0x6e>
  817352:	48 b9 d1 26 82 00 00 	movabs $0x8226d1,%rcx
  817359:	00 00 00 
  81735c:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  817363:	00 00 00 
  817366:	be 62 00 00 00       	mov    $0x62,%esi
  81736b:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817372:	00 00 00 
  817375:	b8 00 00 00 00       	mov    $0x0,%eax
  81737a:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817381:	00 00 00 
  817384:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  817387:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81738e:	00 00 00 
  817391:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817394:	48 63 d0             	movslq %eax,%rdx
  817397:	48 89 d0             	mov    %rdx,%rax
  81739a:	48 c1 e0 03          	shl    $0x3,%rax
  81739e:	48 01 d0             	add    %rdx,%rax
  8173a1:	48 c1 e0 02          	shl    $0x2,%rax
  8173a5:	48 01 d0             	add    %rdx,%rax
  8173a8:	48 c1 e0 03          	shl    $0x3,%rax
  8173ac:	48 01 c8             	add    %rcx,%rax
  8173af:	48 05 10 01 00 00    	add    $0x110,%rax
  8173b5:	8b 00                	mov    (%rax),%eax
  8173b7:	89 c7                	mov    %eax,%edi
  8173b9:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  8173c0:	00 00 00 
  8173c3:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  8173c5:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8173cc:	00 00 00 
  8173cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8173d2:	48 63 d0             	movslq %eax,%rdx
  8173d5:	48 89 d0             	mov    %rdx,%rax
  8173d8:	48 c1 e0 03          	shl    $0x3,%rax
  8173dc:	48 01 d0             	add    %rdx,%rax
  8173df:	48 c1 e0 02          	shl    $0x2,%rax
  8173e3:	48 01 d0             	add    %rdx,%rax
  8173e6:	48 c1 e0 03          	shl    $0x3,%rax
  8173ea:	48 01 c8             	add    %rcx,%rax
  8173ed:	48 05 10 01 00 00    	add    $0x110,%rax
  8173f3:	8b 40 04             	mov    0x4(%rax),%eax
  8173f6:	89 c7                	mov    %eax,%edi
  8173f8:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  8173ff:	00 00 00 
  817402:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  817404:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817407:	48 63 d0             	movslq %eax,%rdx
  81740a:	48 89 d0             	mov    %rdx,%rax
  81740d:	48 c1 e0 03          	shl    $0x3,%rax
  817411:	48 01 d0             	add    %rdx,%rax
  817414:	48 c1 e0 02          	shl    $0x2,%rax
  817418:	48 01 d0             	add    %rdx,%rax
  81741b:	48 c1 e0 03          	shl    $0x3,%rax
  81741f:	48 89 c2             	mov    %rax,%rdx
  817422:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817429:	00 00 00 
  81742c:	48 01 d0             	add    %rdx,%rax
  81742f:	48 ba 40 6c b5 00 00 	movabs $0xb56c40,%rdx
  817436:	00 00 00 
  817439:	48 8b 12             	mov    (%rdx),%rdx
  81743c:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
  817443:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  81744a:	48 85 c0             	test   %rax,%rax
  81744d:	74 45                	je     817494 <sys_mbox_free+0x17b>
  81744f:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  817456:	00 00 00 
  817459:	48 8b 08             	mov    (%rax),%rcx
  81745c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81745f:	48 63 d0             	movslq %eax,%rdx
  817462:	48 89 d0             	mov    %rdx,%rax
  817465:	48 c1 e0 03          	shl    $0x3,%rax
  817469:	48 01 d0             	add    %rdx,%rax
  81746c:	48 c1 e0 02          	shl    $0x2,%rax
  817470:	48 01 d0             	add    %rdx,%rax
  817473:	48 c1 e0 03          	shl    $0x3,%rax
  817477:	48 89 c2             	mov    %rax,%rdx
  81747a:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  817481:	00 00 00 
  817484:	48 01 d0             	add    %rdx,%rax
  817487:	48 05 18 01 00 00    	add    $0x118,%rax
  81748d:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  817494:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817497:	48 63 d0             	movslq %eax,%rdx
  81749a:	48 89 d0             	mov    %rdx,%rax
  81749d:	48 c1 e0 03          	shl    $0x3,%rax
  8174a1:	48 01 d0             	add    %rdx,%rax
  8174a4:	48 c1 e0 02          	shl    $0x2,%rax
  8174a8:	48 01 d0             	add    %rdx,%rax
  8174ab:	48 c1 e0 03          	shl    $0x3,%rax
  8174af:	48 89 c2             	mov    %rax,%rdx
  8174b2:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8174b9:	00 00 00 
  8174bc:	48 01 c2             	add    %rax,%rdx
  8174bf:	48 b8 40 6c b5 00 00 	movabs $0xb56c40,%rax
  8174c6:	00 00 00 
  8174c9:	48 89 10             	mov    %rdx,(%rax)
  8174cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8174cf:	48 63 d0             	movslq %eax,%rdx
  8174d2:	48 89 d0             	mov    %rdx,%rax
  8174d5:	48 c1 e0 03          	shl    $0x3,%rax
  8174d9:	48 01 d0             	add    %rdx,%rax
  8174dc:	48 c1 e0 02          	shl    $0x2,%rax
  8174e0:	48 01 d0             	add    %rdx,%rax
  8174e3:	48 c1 e0 03          	shl    $0x3,%rax
  8174e7:	48 89 c2             	mov    %rax,%rdx
  8174ea:	48 b8 40 d8 b4 00 00 	movabs $0xb4d840,%rax
  8174f1:	00 00 00 
  8174f4:	48 01 d0             	add    %rdx,%rax
  8174f7:	48 ba 40 6c b5 00 00 	movabs $0xb56c40,%rdx
  8174fe:	00 00 00 
  817501:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
    mboxes[mbox].freed = 1;
  817508:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81750f:	00 00 00 
  817512:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817515:	48 63 d0             	movslq %eax,%rdx
  817518:	48 89 d0             	mov    %rdx,%rax
  81751b:	48 c1 e0 03          	shl    $0x3,%rax
  81751f:	48 01 d0             	add    %rdx,%rax
  817522:	48 c1 e0 02          	shl    $0x2,%rax
  817526:	48 01 d0             	add    %rdx,%rax
  817529:	48 c1 e0 03          	shl    $0x3,%rax
  81752d:	48 01 c8             	add    %rcx,%rax
  817530:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  817536:	c9                   	leaveq 
  817537:	c3                   	retq   

0000000000817538 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  817538:	55                   	push   %rbp
  817539:	48 89 e5             	mov    %rsp,%rbp
  81753c:	48 83 ec 10          	sub    $0x10,%rsp
  817540:	89 7d fc             	mov    %edi,-0x4(%rbp)
  817543:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  817547:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81754b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81754e:	48 89 d6             	mov    %rdx,%rsi
  817551:	89 c7                	mov    %eax,%edi
  817553:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  81755a:	00 00 00 
  81755d:	ff d0                	callq  *%rax
  81755f:	84 c0                	test   %al,%al
  817561:	74 35                	je     817598 <sys_mbox_post+0x60>
  817563:	48 b9 e8 26 82 00 00 	movabs $0x8226e8,%rcx
  81756a:	00 00 00 
  81756d:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  817574:	00 00 00 
  817577:	be 6c 00 00 00       	mov    $0x6c,%esi
  81757c:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817583:	00 00 00 
  817586:	b8 00 00 00 00       	mov    $0x0,%eax
  81758b:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817592:	00 00 00 
  817595:	41 ff d0             	callq  *%r8
}
  817598:	c9                   	leaveq 
  817599:	c3                   	retq   

000000000081759a <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  81759a:	55                   	push   %rbp
  81759b:	48 89 e5             	mov    %rsp,%rbp
  81759e:	48 83 ec 20          	sub    $0x20,%rsp
  8175a2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8175a5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  8175a9:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8175b0:	00 00 00 
  8175b3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8175b6:	48 63 d0             	movslq %eax,%rdx
  8175b9:	48 89 d0             	mov    %rdx,%rax
  8175bc:	48 c1 e0 03          	shl    $0x3,%rax
  8175c0:	48 01 d0             	add    %rdx,%rax
  8175c3:	48 c1 e0 02          	shl    $0x2,%rax
  8175c7:	48 01 d0             	add    %rdx,%rax
  8175ca:	48 c1 e0 03          	shl    $0x3,%rax
  8175ce:	48 01 c8             	add    %rcx,%rax
  8175d1:	8b 00                	mov    (%rax),%eax
  8175d3:	85 c0                	test   %eax,%eax
  8175d5:	74 35                	je     81760c <sys_mbox_trypost+0x72>
  8175d7:	48 b9 d1 26 82 00 00 	movabs $0x8226d1,%rcx
  8175de:	00 00 00 
  8175e1:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  8175e8:	00 00 00 
  8175eb:	be 72 00 00 00       	mov    $0x72,%esi
  8175f0:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  8175f7:	00 00 00 
  8175fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8175ff:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817606:	00 00 00 
  817609:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  81760c:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817613:	00 00 00 
  817616:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817619:	48 63 d0             	movslq %eax,%rdx
  81761c:	48 89 d0             	mov    %rdx,%rax
  81761f:	48 c1 e0 03          	shl    $0x3,%rax
  817623:	48 01 d0             	add    %rdx,%rax
  817626:	48 c1 e0 02          	shl    $0x2,%rax
  81762a:	48 01 d0             	add    %rdx,%rax
  81762d:	48 c1 e0 03          	shl    $0x3,%rax
  817631:	48 01 c8             	add    %rcx,%rax
  817634:	48 05 10 01 00 00    	add    $0x110,%rax
  81763a:	8b 40 04             	mov    0x4(%rax),%eax
  81763d:	be 00 00 00 00       	mov    $0x0,%esi
  817642:	89 c7                	mov    %eax,%edi
  817644:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  81764b:	00 00 00 
  81764e:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  817650:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817657:	00 00 00 
  81765a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81765d:	48 63 d0             	movslq %eax,%rdx
  817660:	48 89 d0             	mov    %rdx,%rax
  817663:	48 c1 e0 03          	shl    $0x3,%rax
  817667:	48 01 d0             	add    %rdx,%rax
  81766a:	48 c1 e0 02          	shl    $0x2,%rax
  81766e:	48 01 d0             	add    %rdx,%rax
  817671:	48 c1 e0 03          	shl    $0x3,%rax
  817675:	48 01 c8             	add    %rcx,%rax
  817678:	8b 48 08             	mov    0x8(%rax),%ecx
  81767b:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817682:	00 00 00 
  817685:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817688:	48 63 d0             	movslq %eax,%rdx
  81768b:	48 89 d0             	mov    %rdx,%rax
  81768e:	48 c1 e0 03          	shl    $0x3,%rax
  817692:	48 01 d0             	add    %rdx,%rax
  817695:	48 c1 e0 02          	shl    $0x2,%rax
  817699:	48 01 d0             	add    %rdx,%rax
  81769c:	48 c1 e0 03          	shl    $0x3,%rax
  8176a0:	48 01 f0             	add    %rsi,%rax
  8176a3:	8b 40 04             	mov    0x4(%rax),%eax
  8176a6:	39 c1                	cmp    %eax,%ecx
  8176a8:	75 0a                	jne    8176b4 <sys_mbox_trypost+0x11a>
	return ERR_MEM;
  8176aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8176af:	e9 4c 01 00 00       	jmpq   817800 <sys_mbox_trypost+0x266>

    int slot = mboxes[mbox].nextq;
  8176b4:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8176bb:	00 00 00 
  8176be:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8176c1:	48 63 d0             	movslq %eax,%rdx
  8176c4:	48 89 d0             	mov    %rdx,%rax
  8176c7:	48 c1 e0 03          	shl    $0x3,%rax
  8176cb:	48 01 d0             	add    %rdx,%rax
  8176ce:	48 c1 e0 02          	shl    $0x2,%rax
  8176d2:	48 01 d0             	add    %rdx,%rax
  8176d5:	48 c1 e0 03          	shl    $0x3,%rax
  8176d9:	48 01 c8             	add    %rcx,%rax
  8176dc:	8b 40 08             	mov    0x8(%rax),%eax
  8176df:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  8176e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176e5:	8d 50 01             	lea    0x1(%rax),%edx
  8176e8:	89 d0                	mov    %edx,%eax
  8176ea:	c1 f8 1f             	sar    $0x1f,%eax
  8176ed:	c1 e8 1b             	shr    $0x1b,%eax
  8176f0:	01 c2                	add    %eax,%edx
  8176f2:	83 e2 1f             	and    $0x1f,%edx
  8176f5:	89 d1                	mov    %edx,%ecx
  8176f7:	29 c1                	sub    %eax,%ecx
  8176f9:	89 c8                	mov    %ecx,%eax
  8176fb:	89 c1                	mov    %eax,%ecx
  8176fd:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817704:	00 00 00 
  817707:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81770a:	48 63 d0             	movslq %eax,%rdx
  81770d:	48 89 d0             	mov    %rdx,%rax
  817710:	48 c1 e0 03          	shl    $0x3,%rax
  817714:	48 01 d0             	add    %rdx,%rax
  817717:	48 c1 e0 02          	shl    $0x2,%rax
  81771b:	48 01 d0             	add    %rdx,%rax
  81771e:	48 c1 e0 03          	shl    $0x3,%rax
  817722:	48 01 f0             	add    %rsi,%rax
  817725:	89 48 08             	mov    %ecx,0x8(%rax)
    mboxes[mbox].msg[slot] = msg;
  817728:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  81772f:	00 00 00 
  817732:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817735:	48 63 f0             	movslq %eax,%rsi
  817738:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81773b:	48 63 d0             	movslq %eax,%rdx
  81773e:	48 89 d0             	mov    %rdx,%rax
  817741:	48 c1 e0 03          	shl    $0x3,%rax
  817745:	48 01 d0             	add    %rdx,%rax
  817748:	48 c1 e0 02          	shl    $0x2,%rax
  81774c:	48 01 d0             	add    %rdx,%rax
  81774f:	48 01 f0             	add    %rsi,%rax
  817752:	48 8d 50 02          	lea    0x2(%rax),%rdx
  817756:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81775a:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  81775e:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817765:	00 00 00 
  817768:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81776b:	48 63 d0             	movslq %eax,%rdx
  81776e:	48 89 d0             	mov    %rdx,%rax
  817771:	48 c1 e0 03          	shl    $0x3,%rax
  817775:	48 01 d0             	add    %rdx,%rax
  817778:	48 c1 e0 02          	shl    $0x2,%rax
  81777c:	48 01 d0             	add    %rdx,%rax
  81777f:	48 c1 e0 03          	shl    $0x3,%rax
  817783:	48 01 c8             	add    %rcx,%rax
  817786:	8b 40 04             	mov    0x4(%rax),%eax
  817789:	83 f8 ff             	cmp    $0xffffffff,%eax
  81778c:	75 2f                	jne    8177bd <sys_mbox_trypost+0x223>
	mboxes[mbox].head = slot;
  81778e:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817795:	00 00 00 
  817798:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81779b:	48 63 d0             	movslq %eax,%rdx
  81779e:	48 89 d0             	mov    %rdx,%rax
  8177a1:	48 c1 e0 03          	shl    $0x3,%rax
  8177a5:	48 01 d0             	add    %rdx,%rax
  8177a8:	48 c1 e0 02          	shl    $0x2,%rax
  8177ac:	48 01 d0             	add    %rdx,%rax
  8177af:	48 c1 e0 03          	shl    $0x3,%rax
  8177b3:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8177b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8177ba:	89 42 04             	mov    %eax,0x4(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  8177bd:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  8177c4:	00 00 00 
  8177c7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8177ca:	48 63 d0             	movslq %eax,%rdx
  8177cd:	48 89 d0             	mov    %rdx,%rax
  8177d0:	48 c1 e0 03          	shl    $0x3,%rax
  8177d4:	48 01 d0             	add    %rdx,%rax
  8177d7:	48 c1 e0 02          	shl    $0x2,%rax
  8177db:	48 01 d0             	add    %rdx,%rax
  8177de:	48 c1 e0 03          	shl    $0x3,%rax
  8177e2:	48 01 c8             	add    %rcx,%rax
  8177e5:	48 05 10 01 00 00    	add    $0x110,%rax
  8177eb:	8b 00                	mov    (%rax),%eax
  8177ed:	89 c7                	mov    %eax,%edi
  8177ef:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  8177f6:	00 00 00 
  8177f9:	ff d0                	callq  *%rax

    return ERR_OK;
  8177fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  817800:	c9                   	leaveq 
  817801:	c3                   	retq   

0000000000817802 <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  817802:	55                   	push   %rbp
  817803:	48 89 e5             	mov    %rsp,%rbp
  817806:	48 83 ec 20          	sub    $0x20,%rsp
  81780a:	89 f8                	mov    %edi,%eax
  81780c:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  81780f:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817816:	00 00 00 
  817819:	48 8b 00             	mov    (%rax),%rax
  81781c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817820:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817825:	75 25                	jne    81784c <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817827:	48 bf 10 27 82 00 00 	movabs $0x822710,%rdi
  81782e:	00 00 00 
  817831:	b8 00 00 00 00       	mov    $0x0,%eax
  817836:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  81783d:	00 00 00 
  817840:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817842:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817847:	e9 b5 00 00 00       	jmpq   817901 <sys_sem_new+0xff>
    }
    LIST_REMOVE(se, link);
  81784c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817850:	48 8b 40 10          	mov    0x10(%rax),%rax
  817854:	48 85 c0             	test   %rax,%rax
  817857:	74 14                	je     81786d <sys_sem_new+0x6b>
  817859:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81785d:	48 8b 40 10          	mov    0x10(%rax),%rax
  817861:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817865:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817869:	48 89 50 18          	mov    %rdx,0x18(%rax)
  81786d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817871:	48 8b 40 18          	mov    0x18(%rax),%rax
  817875:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817879:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81787d:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817880:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817884:	8b 00                	mov    (%rax),%eax
  817886:	85 c0                	test   %eax,%eax
  817888:	75 35                	jne    8178bf <sys_sem_new+0xbd>
  81788a:	48 b9 36 27 82 00 00 	movabs $0x822736,%rcx
  817891:	00 00 00 
  817894:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  81789b:	00 00 00 
  81789e:	be 8d 00 00 00       	mov    $0x8d,%esi
  8178a3:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  8178aa:	00 00 00 
  8178ad:	b8 00 00 00 00       	mov    $0x0,%eax
  8178b2:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  8178b9:	00 00 00 
  8178bc:	41 ff d0             	callq  *%r8
    se->freed = 0;
  8178bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178c3:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  8178c9:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  8178cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178d1:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  8178d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178d9:	8b 40 04             	mov    0x4(%rax),%eax
  8178dc:	8d 50 01             	lea    0x1(%rax),%edx
  8178df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8178e3:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  8178e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8178ea:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8178f1:	00 00 00 
  8178f4:	48 89 d1             	mov    %rdx,%rcx
  8178f7:	48 29 c1             	sub    %rax,%rcx
  8178fa:	48 89 c8             	mov    %rcx,%rax
  8178fd:	48 c1 f8 05          	sar    $0x5,%rax
}
  817901:	c9                   	leaveq 
  817902:	c3                   	retq   

0000000000817903 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817903:	55                   	push   %rbp
  817904:	48 89 e5             	mov    %rsp,%rbp
  817907:	48 83 ec 10          	sub    $0x10,%rsp
  81790b:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  81790e:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817915:	00 00 00 
  817918:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81791b:	48 63 d2             	movslq %edx,%rdx
  81791e:	48 c1 e2 05          	shl    $0x5,%rdx
  817922:	48 01 d0             	add    %rdx,%rax
  817925:	8b 00                	mov    (%rax),%eax
  817927:	85 c0                	test   %eax,%eax
  817929:	74 35                	je     817960 <sys_sem_free+0x5d>
  81792b:	48 b9 40 27 82 00 00 	movabs $0x822740,%rcx
  817932:	00 00 00 
  817935:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  81793c:	00 00 00 
  81793f:	be 98 00 00 00       	mov    $0x98,%esi
  817944:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  81794b:	00 00 00 
  81794e:	b8 00 00 00 00       	mov    $0x0,%eax
  817953:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  81795a:	00 00 00 
  81795d:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  817960:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817967:	00 00 00 
  81796a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81796d:	48 63 d2             	movslq %edx,%rdx
  817970:	48 c1 e2 05          	shl    $0x5,%rdx
  817974:	48 01 d0             	add    %rdx,%rax
  817977:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  81797d:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817984:	00 00 00 
  817987:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81798a:	48 63 d2             	movslq %edx,%rdx
  81798d:	48 c1 e2 05          	shl    $0x5,%rdx
  817991:	48 01 d0             	add    %rdx,%rax
  817994:	8b 40 04             	mov    0x4(%rax),%eax
  817997:	8d 50 01             	lea    0x1(%rax),%edx
  81799a:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8179a1:	00 00 00 
  8179a4:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8179a7:	48 63 c9             	movslq %ecx,%rcx
  8179aa:	48 c1 e1 05          	shl    $0x5,%rcx
  8179ae:	48 01 c8             	add    %rcx,%rax
  8179b1:	89 50 04             	mov    %edx,0x4(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  8179b4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8179b7:	48 98                	cltq   
  8179b9:	48 89 c2             	mov    %rax,%rdx
  8179bc:	48 c1 e2 05          	shl    $0x5,%rdx
  8179c0:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  8179c7:	00 00 00 
  8179ca:	48 01 d0             	add    %rdx,%rax
  8179cd:	48 ba 20 d8 b4 00 00 	movabs $0xb4d820,%rdx
  8179d4:	00 00 00 
  8179d7:	48 8b 12             	mov    (%rdx),%rdx
  8179da:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8179de:	48 8b 40 10          	mov    0x10(%rax),%rax
  8179e2:	48 85 c0             	test   %rax,%rax
  8179e5:	74 2f                	je     817a16 <sys_sem_free+0x113>
  8179e7:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  8179ee:	00 00 00 
  8179f1:	48 8b 00             	mov    (%rax),%rax
  8179f4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8179f7:	48 63 d2             	movslq %edx,%rdx
  8179fa:	48 89 d1             	mov    %rdx,%rcx
  8179fd:	48 c1 e1 05          	shl    $0x5,%rcx
  817a01:	48 ba 20 b8 b4 00 00 	movabs $0xb4b820,%rdx
  817a08:	00 00 00 
  817a0b:	48 01 ca             	add    %rcx,%rdx
  817a0e:	48 83 c2 10          	add    $0x10,%rdx
  817a12:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817a16:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a19:	48 98                	cltq   
  817a1b:	48 89 c2             	mov    %rax,%rdx
  817a1e:	48 c1 e2 05          	shl    $0x5,%rdx
  817a22:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817a29:	00 00 00 
  817a2c:	48 01 c2             	add    %rax,%rdx
  817a2f:	48 b8 20 d8 b4 00 00 	movabs $0xb4d820,%rax
  817a36:	00 00 00 
  817a39:	48 89 10             	mov    %rdx,(%rax)
  817a3c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817a3f:	48 98                	cltq   
  817a41:	48 89 c2             	mov    %rax,%rdx
  817a44:	48 c1 e2 05          	shl    $0x5,%rdx
  817a48:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817a4f:	00 00 00 
  817a52:	48 01 d0             	add    %rdx,%rax
  817a55:	48 ba 20 d8 b4 00 00 	movabs $0xb4d820,%rdx
  817a5c:	00 00 00 
  817a5f:	48 89 50 18          	mov    %rdx,0x18(%rax)
}
  817a63:	c9                   	leaveq 
  817a64:	c3                   	retq   

0000000000817a65 <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  817a65:	55                   	push   %rbp
  817a66:	48 89 e5             	mov    %rsp,%rbp
  817a69:	48 83 ec 10          	sub    $0x10,%rsp
  817a6d:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817a70:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817a77:	00 00 00 
  817a7a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817a7d:	48 63 d2             	movslq %edx,%rdx
  817a80:	48 c1 e2 05          	shl    $0x5,%rdx
  817a84:	48 01 d0             	add    %rdx,%rax
  817a87:	8b 00                	mov    (%rax),%eax
  817a89:	85 c0                	test   %eax,%eax
  817a8b:	74 35                	je     817ac2 <sys_sem_signal+0x5d>
  817a8d:	48 b9 40 27 82 00 00 	movabs $0x822740,%rcx
  817a94:	00 00 00 
  817a97:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  817a9e:	00 00 00 
  817aa1:	be a1 00 00 00       	mov    $0xa1,%esi
  817aa6:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817aad:	00 00 00 
  817ab0:	b8 00 00 00 00       	mov    $0x0,%eax
  817ab5:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817abc:	00 00 00 
  817abf:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  817ac2:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ac9:	00 00 00 
  817acc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817acf:	48 63 d2             	movslq %edx,%rdx
  817ad2:	48 c1 e2 05          	shl    $0x5,%rdx
  817ad6:	48 01 d0             	add    %rdx,%rax
  817ad9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817add:	8d 50 01             	lea    0x1(%rax),%edx
  817ae0:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ae7:	00 00 00 
  817aea:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817aed:	48 63 c9             	movslq %ecx,%rcx
  817af0:	48 c1 e1 05          	shl    $0x5,%rcx
  817af4:	48 01 c8             	add    %rcx,%rax
  817af7:	66 89 50 08          	mov    %dx,0x8(%rax)
    if (sems[sem].waiters) {
  817afb:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817b02:	00 00 00 
  817b05:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817b08:	48 63 d2             	movslq %edx,%rdx
  817b0b:	48 c1 e2 05          	shl    $0x5,%rdx
  817b0f:	48 01 d0             	add    %rdx,%rax
  817b12:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  817b16:	66 85 c0             	test   %ax,%ax
  817b19:	74 49                	je     817b64 <sys_sem_signal+0xff>
	sems[sem].waiters = 0;
  817b1b:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817b22:	00 00 00 
  817b25:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817b28:	48 63 d2             	movslq %edx,%rdx
  817b2b:	48 c1 e2 05          	shl    $0x5,%rdx
  817b2f:	48 01 d0             	add    %rdx,%rax
  817b32:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
	thread_wakeup(&sems[sem].v);
  817b38:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b3b:	48 98                	cltq   
  817b3d:	48 89 c2             	mov    %rax,%rdx
  817b40:	48 c1 e2 05          	shl    $0x5,%rdx
  817b44:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817b4b:	00 00 00 
  817b4e:	48 01 d0             	add    %rdx,%rax
  817b51:	48 83 c0 08          	add    $0x8,%rax
  817b55:	48 89 c7             	mov    %rax,%rdi
  817b58:	48 b8 ec 85 81 00 00 	movabs $0x8185ec,%rax
  817b5f:	00 00 00 
  817b62:	ff d0                	callq  *%rax
    }
}
  817b64:	c9                   	leaveq 
  817b65:	c3                   	retq   

0000000000817b66 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  817b66:	55                   	push   %rbp
  817b67:	48 89 e5             	mov    %rsp,%rbp
  817b6a:	48 83 ec 30          	sub    $0x30,%rsp
  817b6e:	89 7d dc             	mov    %edi,-0x24(%rbp)
  817b71:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  817b74:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817b7b:	00 00 00 
  817b7e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817b81:	48 63 d2             	movslq %edx,%rdx
  817b84:	48 c1 e2 05          	shl    $0x5,%rdx
  817b88:	48 01 d0             	add    %rdx,%rax
  817b8b:	8b 00                	mov    (%rax),%eax
  817b8d:	85 c0                	test   %eax,%eax
  817b8f:	74 35                	je     817bc6 <sys_arch_sem_wait+0x60>
  817b91:	48 b9 40 27 82 00 00 	movabs $0x822740,%rcx
  817b98:	00 00 00 
  817b9b:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  817ba2:	00 00 00 
  817ba5:	be ac 00 00 00       	mov    $0xac,%esi
  817baa:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817bb1:	00 00 00 
  817bb4:	b8 00 00 00 00       	mov    $0x0,%eax
  817bb9:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817bc0:	00 00 00 
  817bc3:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  817bc6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  817bcd:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817bd4:	00 00 00 
  817bd7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817bda:	48 63 d2             	movslq %edx,%rdx
  817bdd:	48 c1 e2 05          	shl    $0x5,%rdx
  817be1:	48 01 d0             	add    %rdx,%rax
  817be4:	8b 40 04             	mov    0x4(%rax),%eax
  817be7:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  817bea:	e9 84 01 00 00       	jmpq   817d73 <sys_arch_sem_wait+0x20d>
	if (sems[sem].counter > 0) {
  817bef:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817bf6:	00 00 00 
  817bf9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817bfc:	48 63 d2             	movslq %edx,%rdx
  817bff:	48 c1 e2 05          	shl    $0x5,%rdx
  817c03:	48 01 d0             	add    %rdx,%rax
  817c06:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817c0a:	66 85 c0             	test   %ax,%ax
  817c0d:	74 41                	je     817c50 <sys_arch_sem_wait+0xea>
	    sems[sem].counter--;
  817c0f:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817c16:	00 00 00 
  817c19:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817c1c:	48 63 d2             	movslq %edx,%rdx
  817c1f:	48 c1 e2 05          	shl    $0x5,%rdx
  817c23:	48 01 d0             	add    %rdx,%rax
  817c26:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817c2a:	8d 50 ff             	lea    -0x1(%rax),%edx
  817c2d:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817c34:	00 00 00 
  817c37:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  817c3a:	48 63 c9             	movslq %ecx,%rcx
  817c3d:	48 c1 e1 05          	shl    $0x5,%rcx
  817c41:	48 01 c8             	add    %rcx,%rax
  817c44:	66 89 50 08          	mov    %dx,0x8(%rax)
	    return waited;
  817c48:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c4b:	e9 3e 01 00 00       	jmpq   817d8e <sys_arch_sem_wait+0x228>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  817c50:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  817c54:	75 0a                	jne    817c60 <sys_arch_sem_wait+0xfa>
	    return SYS_ARCH_TIMEOUT;
  817c56:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817c5b:	e9 2e 01 00 00       	jmpq   817d8e <sys_arch_sem_wait+0x228>
	} else {
	    uint32_t a = sys_time_msec();
  817c60:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  817c67:	00 00 00 
  817c6a:	ff d0                	callq  *%rax
  817c6c:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  817c6f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  817c73:	74 11                	je     817c86 <sys_arch_sem_wait+0x120>
  817c75:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c78:	8b 55 d8             	mov    -0x28(%rbp),%edx
  817c7b:	89 d1                	mov    %edx,%ecx
  817c7d:	29 c1                	sub    %eax,%ecx
  817c7f:	89 c8                	mov    %ecx,%eax
  817c81:	03 45 f4             	add    -0xc(%rbp),%eax
  817c84:	eb 05                	jmp    817c8b <sys_arch_sem_wait+0x125>
  817c86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817c8b:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  817c8e:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817c95:	00 00 00 
  817c98:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817c9b:	48 63 d2             	movslq %edx,%rdx
  817c9e:	48 c1 e2 05          	shl    $0x5,%rdx
  817ca2:	48 01 d0             	add    %rdx,%rax
  817ca5:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%rax)
	    uint32_t cur_v = sems[sem].v;
  817cab:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817cb2:	00 00 00 
  817cb5:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817cb8:	48 63 d2             	movslq %edx,%rdx
  817cbb:	48 c1 e2 05          	shl    $0x5,%rdx
  817cbf:	48 01 d0             	add    %rdx,%rax
  817cc2:	8b 40 08             	mov    0x8(%rax),%eax
  817cc5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  817cc8:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  817ccf:	00 00 00 
  817cd2:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  817cd4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  817cd7:	48 98                	cltq   
  817cd9:	48 89 c2             	mov    %rax,%rdx
  817cdc:	48 c1 e2 05          	shl    $0x5,%rdx
  817ce0:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817ce7:	00 00 00 
  817cea:	48 01 d0             	add    %rdx,%rax
  817ced:	48 8d 48 08          	lea    0x8(%rax),%rcx
  817cf1:	8b 55 f0             	mov    -0x10(%rbp),%edx
  817cf4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817cf7:	89 c6                	mov    %eax,%esi
  817cf9:	48 89 cf             	mov    %rcx,%rdi
  817cfc:	48 b8 3f 86 81 00 00 	movabs $0x81863f,%rax
  817d03:	00 00 00 
  817d06:	ff d0                	callq  *%rax
	    lwip_core_lock();
  817d08:	48 b8 c4 84 81 00 00 	movabs $0x8184c4,%rax
  817d0f:	00 00 00 
  817d12:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  817d14:	48 b8 20 b8 b4 00 00 	movabs $0xb4b820,%rax
  817d1b:	00 00 00 
  817d1e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817d21:	48 63 d2             	movslq %edx,%rdx
  817d24:	48 c1 e2 05          	shl    $0x5,%rdx
  817d28:	48 01 d0             	add    %rdx,%rax
  817d2b:	8b 40 04             	mov    0x4(%rax),%eax
  817d2e:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  817d31:	74 22                	je     817d55 <sys_arch_sem_wait+0x1ef>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  817d33:	48 bf 58 27 82 00 00 	movabs $0x822758,%rdi
  817d3a:	00 00 00 
  817d3d:	b8 00 00 00 00       	mov    $0x0,%eax
  817d42:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  817d49:	00 00 00 
  817d4c:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  817d4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817d53:	eb 39                	jmp    817d8e <sys_arch_sem_wait+0x228>
	    }
	    uint32_t b = sys_time_msec();
  817d55:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  817d5c:	00 00 00 
  817d5f:	ff d0                	callq  *%rax
  817d61:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  817d64:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817d67:	8b 55 e8             	mov    -0x18(%rbp),%edx
  817d6a:	89 d1                	mov    %edx,%ecx
  817d6c:	29 c1                	sub    %eax,%ecx
  817d6e:	89 c8                	mov    %ecx,%eax
  817d70:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  817d73:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  817d77:	0f 84 72 fe ff ff    	je     817bef <sys_arch_sem_wait+0x89>
  817d7d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817d80:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  817d83:	0f 82 66 fe ff ff    	jb     817bef <sys_arch_sem_wait+0x89>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  817d89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  817d8e:	c9                   	leaveq 
  817d8f:	c3                   	retq   

0000000000817d90 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  817d90:	55                   	push   %rbp
  817d91:	48 89 e5             	mov    %rsp,%rbp
  817d94:	48 83 ec 20          	sub    $0x20,%rsp
  817d98:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817d9b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  817d9f:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  817da2:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817da9:	00 00 00 
  817dac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817daf:	48 63 d0             	movslq %eax,%rdx
  817db2:	48 89 d0             	mov    %rdx,%rax
  817db5:	48 c1 e0 03          	shl    $0x3,%rax
  817db9:	48 01 d0             	add    %rdx,%rax
  817dbc:	48 c1 e0 02          	shl    $0x2,%rax
  817dc0:	48 01 d0             	add    %rdx,%rax
  817dc3:	48 c1 e0 03          	shl    $0x3,%rax
  817dc7:	48 01 c8             	add    %rcx,%rax
  817dca:	8b 00                	mov    (%rax),%eax
  817dcc:	85 c0                	test   %eax,%eax
  817dce:	74 35                	je     817e05 <sys_arch_mbox_fetch+0x75>
  817dd0:	48 b9 d1 26 82 00 00 	movabs $0x8226d1,%rcx
  817dd7:	00 00 00 
  817dda:	48 ba 39 26 82 00 00 	movabs $0x822639,%rdx
  817de1:	00 00 00 
  817de4:	be ce 00 00 00       	mov    $0xce,%esi
  817de9:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817df0:	00 00 00 
  817df3:	b8 00 00 00 00       	mov    $0x0,%eax
  817df8:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  817dff:	00 00 00 
  817e02:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  817e05:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e0c:	00 00 00 
  817e0f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e12:	48 63 d0             	movslq %eax,%rdx
  817e15:	48 89 d0             	mov    %rdx,%rax
  817e18:	48 c1 e0 03          	shl    $0x3,%rax
  817e1c:	48 01 d0             	add    %rdx,%rax
  817e1f:	48 c1 e0 02          	shl    $0x2,%rax
  817e23:	48 01 d0             	add    %rdx,%rax
  817e26:	48 c1 e0 03          	shl    $0x3,%rax
  817e2a:	48 01 c8             	add    %rcx,%rax
  817e2d:	48 05 10 01 00 00    	add    $0x110,%rax
  817e33:	8b 00                	mov    (%rax),%eax
  817e35:	8b 55 e8             	mov    -0x18(%rbp),%edx
  817e38:	89 d6                	mov    %edx,%esi
  817e3a:	89 c7                	mov    %eax,%edi
  817e3c:	48 b8 66 7b 81 00 00 	movabs $0x817b66,%rax
  817e43:	00 00 00 
  817e46:	ff d0                	callq  *%rax
  817e48:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  817e4b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  817e4f:	75 08                	jne    817e59 <sys_arch_mbox_fetch+0xc9>
	return waited;
  817e51:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e54:	e9 af 01 00 00       	jmpq   818008 <sys_arch_mbox_fetch+0x278>

    int slot = mboxes[mbox].head;
  817e59:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817e60:	00 00 00 
  817e63:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817e66:	48 63 d0             	movslq %eax,%rdx
  817e69:	48 89 d0             	mov    %rdx,%rax
  817e6c:	48 c1 e0 03          	shl    $0x3,%rax
  817e70:	48 01 d0             	add    %rdx,%rax
  817e73:	48 c1 e0 02          	shl    $0x2,%rax
  817e77:	48 01 d0             	add    %rdx,%rax
  817e7a:	48 c1 e0 03          	shl    $0x3,%rax
  817e7e:	48 01 c8             	add    %rcx,%rax
  817e81:	8b 40 04             	mov    0x4(%rax),%eax
  817e84:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  817e87:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  817e8b:	75 2a                	jne    817eb7 <sys_arch_mbox_fetch+0x127>
	panic("lwip: sys_arch_mbox_fetch: no message");
  817e8d:	48 ba 88 27 82 00 00 	movabs $0x822788,%rdx
  817e94:	00 00 00 
  817e97:	be d6 00 00 00       	mov    $0xd6,%esi
  817e9c:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  817ea3:	00 00 00 
  817ea6:	b8 00 00 00 00       	mov    $0x0,%eax
  817eab:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  817eb2:	00 00 00 
  817eb5:	ff d1                	callq  *%rcx
    if (msg)
  817eb7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  817ebc:	74 39                	je     817ef7 <sys_arch_mbox_fetch+0x167>
	*msg = mboxes[mbox].msg[slot];
  817ebe:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817ec5:	00 00 00 
  817ec8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  817ecb:	48 63 f0             	movslq %eax,%rsi
  817ece:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ed1:	48 63 d0             	movslq %eax,%rdx
  817ed4:	48 89 d0             	mov    %rdx,%rax
  817ed7:	48 c1 e0 03          	shl    $0x3,%rax
  817edb:	48 01 d0             	add    %rdx,%rax
  817ede:	48 c1 e0 02          	shl    $0x2,%rax
  817ee2:	48 01 d0             	add    %rdx,%rax
  817ee5:	48 01 f0             	add    %rsi,%rax
  817ee8:	48 83 c0 02          	add    $0x2,%rax
  817eec:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  817ef0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817ef4:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  817ef7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  817efa:	8d 50 01             	lea    0x1(%rax),%edx
  817efd:	89 d0                	mov    %edx,%eax
  817eff:	c1 f8 1f             	sar    $0x1f,%eax
  817f02:	c1 e8 1b             	shr    $0x1b,%eax
  817f05:	01 c2                	add    %eax,%edx
  817f07:	83 e2 1f             	and    $0x1f,%edx
  817f0a:	89 d1                	mov    %edx,%ecx
  817f0c:	29 c1                	sub    %eax,%ecx
  817f0e:	89 c8                	mov    %ecx,%eax
  817f10:	89 c1                	mov    %eax,%ecx
  817f12:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817f19:	00 00 00 
  817f1c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817f1f:	48 63 d0             	movslq %eax,%rdx
  817f22:	48 89 d0             	mov    %rdx,%rax
  817f25:	48 c1 e0 03          	shl    $0x3,%rax
  817f29:	48 01 d0             	add    %rdx,%rax
  817f2c:	48 c1 e0 02          	shl    $0x2,%rax
  817f30:	48 01 d0             	add    %rdx,%rax
  817f33:	48 c1 e0 03          	shl    $0x3,%rax
  817f37:	48 01 f0             	add    %rsi,%rax
  817f3a:	89 48 04             	mov    %ecx,0x4(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  817f3d:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817f44:	00 00 00 
  817f47:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817f4a:	48 63 d0             	movslq %eax,%rdx
  817f4d:	48 89 d0             	mov    %rdx,%rax
  817f50:	48 c1 e0 03          	shl    $0x3,%rax
  817f54:	48 01 d0             	add    %rdx,%rax
  817f57:	48 c1 e0 02          	shl    $0x2,%rax
  817f5b:	48 01 d0             	add    %rdx,%rax
  817f5e:	48 c1 e0 03          	shl    $0x3,%rax
  817f62:	48 01 c8             	add    %rcx,%rax
  817f65:	8b 48 04             	mov    0x4(%rax),%ecx
  817f68:	48 be 40 d8 b4 00 00 	movabs $0xb4d840,%rsi
  817f6f:	00 00 00 
  817f72:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817f75:	48 63 d0             	movslq %eax,%rdx
  817f78:	48 89 d0             	mov    %rdx,%rax
  817f7b:	48 c1 e0 03          	shl    $0x3,%rax
  817f7f:	48 01 d0             	add    %rdx,%rax
  817f82:	48 c1 e0 02          	shl    $0x2,%rax
  817f86:	48 01 d0             	add    %rdx,%rax
  817f89:	48 c1 e0 03          	shl    $0x3,%rax
  817f8d:	48 01 f0             	add    %rsi,%rax
  817f90:	8b 40 08             	mov    0x8(%rax),%eax
  817f93:	39 c1                	cmp    %eax,%ecx
  817f95:	75 2f                	jne    817fc6 <sys_arch_mbox_fetch+0x236>
	mboxes[mbox].head = -1;
  817f97:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817f9e:	00 00 00 
  817fa1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817fa4:	48 63 d0             	movslq %eax,%rdx
  817fa7:	48 89 d0             	mov    %rdx,%rax
  817faa:	48 c1 e0 03          	shl    $0x3,%rax
  817fae:	48 01 d0             	add    %rdx,%rax
  817fb1:	48 c1 e0 02          	shl    $0x2,%rax
  817fb5:	48 01 d0             	add    %rdx,%rax
  817fb8:	48 c1 e0 03          	shl    $0x3,%rax
  817fbc:	48 01 c8             	add    %rcx,%rax
  817fbf:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  817fc6:	48 b9 40 d8 b4 00 00 	movabs $0xb4d840,%rcx
  817fcd:	00 00 00 
  817fd0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817fd3:	48 63 d0             	movslq %eax,%rdx
  817fd6:	48 89 d0             	mov    %rdx,%rax
  817fd9:	48 c1 e0 03          	shl    $0x3,%rax
  817fdd:	48 01 d0             	add    %rdx,%rax
  817fe0:	48 c1 e0 02          	shl    $0x2,%rax
  817fe4:	48 01 d0             	add    %rdx,%rax
  817fe7:	48 c1 e0 03          	shl    $0x3,%rax
  817feb:	48 01 c8             	add    %rcx,%rax
  817fee:	48 05 10 01 00 00    	add    $0x110,%rax
  817ff4:	8b 40 04             	mov    0x4(%rax),%eax
  817ff7:	89 c7                	mov    %eax,%edi
  817ff9:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  818000:	00 00 00 
  818003:	ff d0                	callq  *%rax
    return waited;
  818005:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818008:	c9                   	leaveq 
  818009:	c3                   	retq   

000000000081800a <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  81800a:	55                   	push   %rbp
  81800b:	48 89 e5             	mov    %rsp,%rbp
  81800e:	48 83 ec 10          	sub    $0x10,%rsp
  818012:	89 7d fc             	mov    %edi,-0x4(%rbp)
  818015:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  818019:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81801d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818020:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  818025:	48 89 ce             	mov    %rcx,%rsi
  818028:	89 c7                	mov    %eax,%edi
  81802a:	48 b8 90 7d 81 00 00 	movabs $0x817d90,%rax
  818031:	00 00 00 
  818034:	ff d0                	callq  *%rax
}
  818036:	c9                   	leaveq 
  818037:	c3                   	retq   

0000000000818038 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  818038:	55                   	push   %rbp
  818039:	48 89 e5             	mov    %rsp,%rbp
  81803c:	48 83 ec 20          	sub    $0x20,%rsp
  818040:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  818044:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818048:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  81804c:	48 b8 c4 84 81 00 00 	movabs $0x8184c4,%rax
  818053:	00 00 00 
  818056:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  818058:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81805c:	48 8b 10             	mov    (%rax),%rdx
  81805f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818063:	48 8b 40 08          	mov    0x8(%rax),%rax
  818067:	48 89 c7             	mov    %rax,%rdi
  81806a:	ff d2                	callq  *%rdx
    lwip_core_unlock();
  81806c:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  818073:	00 00 00 
  818076:	ff d0                	callq  *%rax
    free(lt);
  818078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81807c:	48 89 c7             	mov    %rax,%rdi
  81807f:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  818086:	00 00 00 
  818089:	ff d0                	callq  *%rax
}
  81808b:	c9                   	leaveq 
  81808c:	c3                   	retq   

000000000081808d <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  81808d:	55                   	push   %rbp
  81808e:	48 89 e5             	mov    %rsp,%rbp
  818091:	48 83 ec 30          	sub    $0x30,%rsp
  818095:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818099:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81809d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8180a1:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  8180a4:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  8180a8:	bf 10 00 00 00       	mov    $0x10,%edi
  8180ad:	48 b8 09 48 80 00 00 	movabs $0x804809,%rax
  8180b4:	00 00 00 
  8180b7:	ff d0                	callq  *%rax
  8180b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  8180bd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8180c2:	75 2a                	jne    8180ee <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  8180c4:	48 ba b0 27 82 00 00 	movabs $0x8227b0,%rdx
  8180cb:	00 00 00 
  8180ce:	be fd 00 00 00       	mov    $0xfd,%esi
  8180d3:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  8180da:	00 00 00 
  8180dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8180e2:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8180e9:	00 00 00 
  8180ec:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  8180ee:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  8180f5:	7e 30                	jle    818127 <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  8180f7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8180fa:	89 c1                	mov    %eax,%ecx
  8180fc:	48 ba de 27 82 00 00 	movabs $0x8227de,%rdx
  818103:	00 00 00 
  818106:	be 00 01 00 00       	mov    $0x100,%esi
  81810b:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  818112:	00 00 00 
  818115:	b8 00 00 00 00       	mov    $0x0,%eax
  81811a:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  818121:	00 00 00 
  818124:	41 ff d0             	callq  *%r8

    lt->func = thread;
  818127:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81812b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81812f:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  818132:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818136:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81813a:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  81813e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818142:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  818146:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  81814a:	48 89 d1             	mov    %rdx,%rcx
  81814d:	48 ba 38 80 81 00 00 	movabs $0x818038,%rdx
  818154:	00 00 00 
  818157:	48 89 c7             	mov    %rax,%rdi
  81815a:	48 b8 b7 88 81 00 00 	movabs $0x8188b7,%rax
  818161:	00 00 00 
  818164:	ff d0                	callq  *%rax
  818166:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  818169:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  81816d:	79 3f                	jns    8181ae <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  81816f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818172:	89 c7                	mov    %eax,%edi
  818174:	48 b8 47 8f 81 00 00 	movabs $0x818f47,%rax
  81817b:	00 00 00 
  81817e:	ff d0                	callq  *%rax
  818180:	48 89 c1             	mov    %rax,%rcx
  818183:	48 ba f0 27 82 00 00 	movabs $0x8227f0,%rdx
  81818a:	00 00 00 
  81818d:	be 09 01 00 00       	mov    $0x109,%esi
  818192:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  818199:	00 00 00 
  81819c:	b8 00 00 00 00       	mov    $0x0,%eax
  8181a1:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  8181a8:	00 00 00 
  8181ab:	41 ff d0             	callq  *%r8

    return tid;
  8181ae:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  8181b1:	c9                   	leaveq 
  8181b2:	c3                   	retq   

00000000008181b3 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  8181b3:	55                   	push   %rbp
  8181b4:	48 89 e5             	mov    %rsp,%rbp
  8181b7:	48 83 ec 20          	sub    $0x20,%rsp
  8181bb:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  8181be:	48 b8 c4 84 81 00 00 	movabs $0x8184c4,%rax
  8181c5:	00 00 00 
  8181c8:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8181ca:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8181cd:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  8181d2:	89 c8                	mov    %ecx,%eax
  8181d4:	f7 e2                	mul    %edx
  8181d6:	c1 ea 08             	shr    $0x8,%edx
  8181d9:	89 d0                	mov    %edx,%eax
  8181db:	c1 e0 08             	shl    $0x8,%eax
  8181de:	01 d0                	add    %edx,%eax
  8181e0:	89 ca                	mov    %ecx,%edx
  8181e2:	29 c2                	sub    %eax,%edx
  8181e4:	89 d0                	mov    %edx,%eax
  8181e6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8181ed:	00 
  8181ee:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8181f5:	00 00 00 
  8181f8:	48 01 d0             	add    %rdx,%rax
  8181fb:	48 8b 00             	mov    (%rax),%rax
  8181fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818202:	eb 60                	jmp    818264 <timeout_cleanup+0xb1>
	if (t->tid == tid) {
  818204:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818208:	8b 00                	mov    (%rax),%eax
  81820a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  81820d:	75 49                	jne    818258 <timeout_cleanup+0xa5>
	    LIST_REMOVE(t, link);
  81820f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818213:	48 8b 40 10          	mov    0x10(%rax),%rax
  818217:	48 85 c0             	test   %rax,%rax
  81821a:	74 14                	je     818230 <timeout_cleanup+0x7d>
  81821c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818220:	48 8b 40 10          	mov    0x10(%rax),%rax
  818224:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818228:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  81822c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818234:	48 8b 40 18          	mov    0x18(%rax),%rax
  818238:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81823c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  818240:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  818243:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818247:	48 89 c7             	mov    %rax,%rdi
  81824a:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  818251:	00 00 00 
  818254:	ff d0                	callq  *%rax
	    goto done;
  818256:	eb 13                	jmp    81826b <timeout_cleanup+0xb8>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818258:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81825c:	48 8b 40 10          	mov    0x10(%rax),%rax
  818260:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818264:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818269:	75 99                	jne    818204 <timeout_cleanup+0x51>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  81826b:	48 b8 ca 84 81 00 00 	movabs $0x8184ca,%rax
  818272:	00 00 00 
  818275:	ff d0                	callq  *%rax
}
  818277:	c9                   	leaveq 
  818278:	c3                   	retq   

0000000000818279 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  818279:	55                   	push   %rbp
  81827a:	48 89 e5             	mov    %rsp,%rbp
  81827d:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  818281:	48 b8 d7 85 81 00 00 	movabs $0x8185d7,%rax
  818288:	00 00 00 
  81828b:	ff d0                	callq  *%rax
  81828d:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818290:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818293:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  818298:	89 c8                	mov    %ecx,%eax
  81829a:	f7 e2                	mul    %edx
  81829c:	c1 ea 08             	shr    $0x8,%edx
  81829f:	89 d0                	mov    %edx,%eax
  8182a1:	c1 e0 08             	shl    $0x8,%eax
  8182a4:	01 d0                	add    %edx,%eax
  8182a6:	89 ca                	mov    %ecx,%edx
  8182a8:	29 c2                	sub    %eax,%edx
  8182aa:	89 d0                	mov    %edx,%eax
  8182ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8182b3:	00 
  8182b4:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8182bb:	00 00 00 
  8182be:	48 01 d0             	add    %rdx,%rax
  8182c1:	48 8b 00             	mov    (%rax),%rax
  8182c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8182c8:	eb 1b                	jmp    8182e5 <sys_arch_timeouts+0x6c>
	if (t->tid == tid)
  8182ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8182ce:	8b 00                	mov    (%rax),%eax
  8182d0:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8182d3:	0f 84 e0 01 00 00    	je     8184b9 <sys_arch_timeouts+0x240>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8182d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8182dd:	48 8b 40 10          	mov    0x10(%rax),%rax
  8182e1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8182e5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8182ea:	75 de                	jne    8182ca <sys_arch_timeouts+0x51>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  8182ec:	bf 20 00 00 00       	mov    $0x20,%edi
  8182f1:	48 b8 09 48 80 00 00 	movabs $0x804809,%rax
  8182f8:	00 00 00 
  8182fb:	ff d0                	callq  *%rax
  8182fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  818301:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818306:	75 2a                	jne    818332 <sys_arch_timeouts+0xb9>
	panic("sys_arch_timeouts: cannot malloc");
  818308:	48 ba 20 28 82 00 00 	movabs $0x822820,%rdx
  81830f:	00 00 00 
  818312:	be 2c 01 00 00       	mov    $0x12c,%esi
  818317:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  81831e:	00 00 00 
  818321:	b8 00 00 00 00       	mov    $0x0,%eax
  818326:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81832d:	00 00 00 
  818330:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  818332:	48 bf b3 81 81 00 00 	movabs $0x8181b3,%rdi
  818339:	00 00 00 
  81833c:	48 b8 70 87 81 00 00 	movabs $0x818770,%rax
  818343:	00 00 00 
  818346:	ff d0                	callq  *%rax
  818348:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  81834b:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  81834f:	79 3f                	jns    818390 <sys_arch_timeouts+0x117>
	panic("thread_onhalt failed: %s", e2s(r));
  818351:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818354:	89 c7                	mov    %eax,%edi
  818356:	48 b8 47 8f 81 00 00 	movabs $0x818f47,%rax
  81835d:	00 00 00 
  818360:	ff d0                	callq  *%rax
  818362:	48 89 c1             	mov    %rax,%rcx
  818365:	48 ba 41 28 82 00 00 	movabs $0x822841,%rdx
  81836c:	00 00 00 
  81836f:	be 30 01 00 00       	mov    $0x130,%esi
  818374:	48 bf 4e 26 82 00 00 	movabs $0x82264e,%rdi
  81837b:	00 00 00 
  81837e:	b8 00 00 00 00       	mov    $0x0,%eax
  818383:	49 b8 20 0f 80 00 00 	movabs $0x800f20,%r8
  81838a:	00 00 00 
  81838d:	41 ff d0             	callq  *%r8

    t->tid = tid;
  818390:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818394:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818397:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81839d:	48 83 c0 08          	add    $0x8,%rax
  8183a1:	ba 08 00 00 00       	mov    $0x8,%edx
  8183a6:	be 00 00 00 00       	mov    $0x0,%esi
  8183ab:	48 89 c7             	mov    %rax,%rdi
  8183ae:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  8183b5:	00 00 00 
  8183b8:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  8183ba:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8183bd:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  8183c2:	89 c8                	mov    %ecx,%eax
  8183c4:	f7 e2                	mul    %edx
  8183c6:	c1 ea 08             	shr    $0x8,%edx
  8183c9:	89 d0                	mov    %edx,%eax
  8183cb:	c1 e0 08             	shl    $0x8,%eax
  8183ce:	01 d0                	add    %edx,%eax
  8183d0:	89 ca                	mov    %ecx,%edx
  8183d2:	29 c2                	sub    %eax,%edx
  8183d4:	89 d0                	mov    %edx,%eax
  8183d6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8183dd:	00 
  8183de:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8183e5:	00 00 00 
  8183e8:	48 01 d0             	add    %rdx,%rax
  8183eb:	48 8b 10             	mov    (%rax),%rdx
  8183ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183f2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8183f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183fa:	48 8b 40 10          	mov    0x10(%rax),%rax
  8183fe:	48 85 c0             	test   %rax,%rax
  818401:	74 40                	je     818443 <sys_arch_timeouts+0x1ca>
  818403:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818406:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  81840b:	89 c8                	mov    %ecx,%eax
  81840d:	f7 e2                	mul    %edx
  81840f:	c1 ea 08             	shr    $0x8,%edx
  818412:	89 d0                	mov    %edx,%eax
  818414:	c1 e0 08             	shl    $0x8,%eax
  818417:	01 d0                	add    %edx,%eax
  818419:	89 ca                	mov    %ecx,%edx
  81841b:	29 c2                	sub    %eax,%edx
  81841d:	89 d0                	mov    %edx,%eax
  81841f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818426:	00 
  818427:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  81842e:	00 00 00 
  818431:	48 01 d0             	add    %rdx,%rax
  818434:	48 8b 00             	mov    (%rax),%rax
  818437:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81843b:	48 83 c2 10          	add    $0x10,%rdx
  81843f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818443:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818446:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  81844b:	89 c8                	mov    %ecx,%eax
  81844d:	f7 e2                	mul    %edx
  81844f:	c1 ea 08             	shr    $0x8,%edx
  818452:	89 d0                	mov    %edx,%eax
  818454:	c1 e0 08             	shl    $0x8,%eax
  818457:	01 d0                	add    %edx,%eax
  818459:	89 ca                	mov    %ecx,%edx
  81845b:	29 c2                	sub    %eax,%edx
  81845d:	89 d0                	mov    %edx,%eax
  81845f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818466:	00 
  818467:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  81846e:	00 00 00 
  818471:	48 01 c2             	add    %rax,%rdx
  818474:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818478:	48 89 02             	mov    %rax,(%rdx)
  81847b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  81847e:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  818483:	89 c8                	mov    %ecx,%eax
  818485:	f7 e2                	mul    %edx
  818487:	c1 ea 08             	shr    $0x8,%edx
  81848a:	89 d0                	mov    %edx,%eax
  81848c:	c1 e0 08             	shl    $0x8,%eax
  81848f:	01 d0                	add    %edx,%eax
  818491:	89 ca                	mov    %ecx,%edx
  818493:	29 c2                	sub    %eax,%edx
  818495:	89 d0                	mov    %edx,%eax
  818497:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81849e:	00 
  81849f:	48 b8 60 6c b5 00 00 	movabs $0xb56c60,%rax
  8184a6:	00 00 00 
  8184a9:	48 01 d0             	add    %rdx,%rax
  8184ac:	48 89 c2             	mov    %rax,%rdx
  8184af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184b3:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8184b7:	eb 01                	jmp    8184ba <sys_arch_timeouts+0x241>
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
	if (t->tid == tid)
	    goto out;
  8184b9:	90                   	nop
    t->tid = tid;
    memset(&t->tmo, 0, sizeof(t->tmo));
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);

out:
    return &t->tmo;
  8184ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184be:	48 83 c0 08          	add    $0x8,%rax
}
  8184c2:	c9                   	leaveq 
  8184c3:	c3                   	retq   

00000000008184c4 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  8184c4:	55                   	push   %rbp
  8184c5:	48 89 e5             	mov    %rsp,%rbp
}
  8184c8:	5d                   	pop    %rbp
  8184c9:	c3                   	retq   

00000000008184ca <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  8184ca:	55                   	push   %rbp
  8184cb:	48 89 e5             	mov    %rsp,%rbp
}
  8184ce:	5d                   	pop    %rbp
  8184cf:	c3                   	retq   

00000000008184d0 <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  8184d0:	55                   	push   %rbp
  8184d1:	48 89 e5             	mov    %rsp,%rbp
  8184d4:	48 83 ec 08          	sub    $0x8,%rsp
  8184d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  8184dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184e0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  8184e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184eb:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8184f2:	00 
}
  8184f3:	c9                   	leaveq 
  8184f4:	c3                   	retq   

00000000008184f5 <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  8184f5:	55                   	push   %rbp
  8184f6:	48 89 e5             	mov    %rsp,%rbp
  8184f9:	48 83 ec 10          	sub    $0x10,%rsp
  8184fd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818501:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  818505:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818509:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818510:	00 00 00 00 
    if (!tq->tq_first) {
  818514:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818518:	48 8b 00             	mov    (%rax),%rax
  81851b:	48 85 c0             	test   %rax,%rax
  81851e:	75 19                	jne    818539 <threadq_push+0x44>
	tq->tq_first = tc;
  818520:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818524:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818528:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  81852b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81852f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818533:	48 89 50 08          	mov    %rdx,0x8(%rax)
  818537:	eb 1f                	jmp    818558 <threadq_push+0x63>
    } else {
	tq->tq_last->tc_queue_link = tc;
  818539:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81853d:	48 8b 40 08          	mov    0x8(%rax),%rax
  818541:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818545:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  81854c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818550:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818554:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818558:	c9                   	leaveq 
  818559:	c3                   	retq   

000000000081855a <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  81855a:	55                   	push   %rbp
  81855b:	48 89 e5             	mov    %rsp,%rbp
  81855e:	48 83 ec 18          	sub    $0x18,%rsp
  818562:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  818566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81856a:	48 8b 00             	mov    (%rax),%rax
  81856d:	48 85 c0             	test   %rax,%rax
  818570:	75 07                	jne    818579 <threadq_pop+0x1f>
	return 0;
  818572:	b8 00 00 00 00       	mov    $0x0,%eax
  818577:	eb 30                	jmp    8185a9 <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818579:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81857d:	48 8b 00             	mov    (%rax),%rax
  818580:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  818584:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818588:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  81858f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818593:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  818596:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81859a:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8185a1:	00 00 00 00 
    return tc;
  8185a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8185a9:	c9                   	leaveq 
  8185aa:	c3                   	retq   

00000000008185ab <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  8185ab:	55                   	push   %rbp
  8185ac:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  8185af:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  8185b6:	00 00 00 
  8185b9:	48 b8 d0 84 81 00 00 	movabs $0x8184d0,%rax
  8185c0:	00 00 00 
  8185c3:	ff d0                	callq  *%rax
    max_tid = 0;
  8185c5:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  8185cc:	00 00 00 
  8185cf:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8185d5:	5d                   	pop    %rbp
  8185d6:	c3                   	retq   

00000000008185d7 <thread_id>:

uint32_t
thread_id(void) {
  8185d7:	55                   	push   %rbp
  8185d8:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  8185db:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8185e2:	00 00 00 
  8185e5:	48 8b 00             	mov    (%rax),%rax
  8185e8:	8b 00                	mov    (%rax),%eax
}
  8185ea:	5d                   	pop    %rbp
  8185eb:	c3                   	retq   

00000000008185ec <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  8185ec:	55                   	push   %rbp
  8185ed:	48 89 e5             	mov    %rsp,%rbp
  8185f0:	48 83 ec 18          	sub    $0x18,%rsp
  8185f4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  8185f8:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  8185ff:	00 00 00 
  818602:	48 8b 00             	mov    (%rax),%rax
  818605:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  818609:	eb 2b                	jmp    818636 <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  81860b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81860f:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  818616:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81861a:	75 0b                	jne    818627 <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  81861c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818620:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  818627:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81862b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818632:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  818636:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81863b:	75 ce                	jne    81860b <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  81863d:	c9                   	leaveq 
  81863e:	c3                   	retq   

000000000081863f <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  81863f:	55                   	push   %rbp
  818640:	48 89 e5             	mov    %rsp,%rbp
  818643:	48 83 ec 20          	sub    $0x20,%rsp
  818647:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81864b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  81864e:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  818651:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  818658:	00 00 00 
  81865b:	ff d0                	callq  *%rax
  81865d:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818660:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818663:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  818666:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  81866d:	00 00 00 
  818670:	48 8b 00             	mov    (%rax),%rax
  818673:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818677:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  81867e:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818685:	00 00 00 
  818688:	48 8b 00             	mov    (%rax),%rax
  81868b:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  818692:	eb 4d                	jmp    8186e1 <thread_wait+0xa2>
	if (p < s)
  818694:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818697:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  81869a:	72 4f                	jb     8186eb <thread_wait+0xac>
	    break;
	if (addr && *addr != val)
  81869c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8186a1:	74 0b                	je     8186ae <thread_wait+0x6f>
  8186a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8186a7:	8b 00                	mov    (%rax),%eax
  8186a9:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8186ac:	75 40                	jne    8186ee <thread_wait+0xaf>
	    break;
	if (cur_tc->tc_wakeup)
  8186ae:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8186b5:	00 00 00 
  8186b8:	48 8b 00             	mov    (%rax),%rax
  8186bb:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  8186c2:	84 c0                	test   %al,%al
  8186c4:	75 2b                	jne    8186f1 <thread_wait+0xb2>
	    break;

	thread_yield();
  8186c6:	48 b8 38 8b 81 00 00 	movabs $0x818b38,%rax
  8186cd:	00 00 00 
  8186d0:	ff d0                	callq  *%rax
	p = sys_time_msec();
  8186d2:	48 b8 d1 28 80 00 00 	movabs $0x8028d1,%rax
  8186d9:	00 00 00 
  8186dc:	ff d0                	callq  *%rax
  8186de:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  8186e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8186e4:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8186e7:	72 ab                	jb     818694 <thread_wait+0x55>
  8186e9:	eb 07                	jmp    8186f2 <thread_wait+0xb3>
	if (p < s)
	    break;
  8186eb:	90                   	nop
  8186ec:	eb 04                	jmp    8186f2 <thread_wait+0xb3>
	if (addr && *addr != val)
	    break;
  8186ee:	90                   	nop
  8186ef:	eb 01                	jmp    8186f2 <thread_wait+0xb3>
	if (cur_tc->tc_wakeup)
	    break;
  8186f1:	90                   	nop

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  8186f2:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8186f9:	00 00 00 
  8186fc:	48 8b 00             	mov    (%rax),%rax
  8186ff:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  818706:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  81870a:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818711:	00 00 00 
  818714:	48 8b 00             	mov    (%rax),%rax
  818717:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  81871e:	c9                   	leaveq 
  81871f:	c3                   	retq   

0000000000818720 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818720:	55                   	push   %rbp
  818721:	48 89 e5             	mov    %rsp,%rbp
  818724:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818728:	48 b8 80 74 b5 00 00 	movabs $0xb57480,%rax
  81872f:	00 00 00 
  818732:	48 8b 00             	mov    (%rax),%rax
  818735:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  818740:	eb 22                	jmp    818764 <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  818742:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818746:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  81874d:	84 c0                	test   %al,%al
  81874f:	74 04                	je     818755 <thread_wakeups_pending+0x35>
	    ++n;
  818751:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  818755:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818759:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818760:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818764:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818769:	75 d7                	jne    818742 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  81876b:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  81876e:	c9                   	leaveq 
  81876f:	c3                   	retq   

0000000000818770 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818770:	55                   	push   %rbp
  818771:	48 89 e5             	mov    %rsp,%rbp
  818774:	48 83 ec 08          	sub    $0x8,%rsp
  818778:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  81877c:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818783:	00 00 00 
  818786:	48 8b 00             	mov    (%rax),%rax
  818789:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  81878f:	83 f8 03             	cmp    $0x3,%eax
  818792:	7e 07                	jle    81879b <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818794:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818799:	eb 3d                	jmp    8187d8 <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  81879b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8187a2:	00 00 00 
  8187a5:	48 8b 08             	mov    (%rax),%rcx
  8187a8:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  8187af:	00 00 00 
  8187b2:	48 8b 00             	mov    (%rax),%rax
  8187b5:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  8187bb:	48 63 f2             	movslq %edx,%rsi
  8187be:	48 8d 7e 18          	lea    0x18(%rsi),%rdi
  8187c2:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8187c6:	48 89 34 f9          	mov    %rsi,(%rcx,%rdi,8)
  8187ca:	83 c2 01             	add    $0x1,%edx
  8187cd:	89 90 e0 00 00 00    	mov    %edx,0xe0(%rax)
    return 0;
  8187d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8187d8:	c9                   	leaveq 
  8187d9:	c3                   	retq   

00000000008187da <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  8187da:	55                   	push   %rbp
  8187db:	48 89 e5             	mov    %rsp,%rbp
  8187de:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  8187e2:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  8187e9:	00 00 00 
  8187ec:	8b 00                	mov    (%rax),%eax
  8187ee:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8187f1:	8d 50 01             	lea    0x1(%rax),%edx
  8187f4:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  8187fb:	00 00 00 
  8187fe:	89 10                	mov    %edx,(%rax)
    if (max_tid == (uint32_t)~0)
  818800:	48 b8 70 74 b5 00 00 	movabs $0xb57470,%rax
  818807:	00 00 00 
  81880a:	8b 00                	mov    (%rax),%eax
  81880c:	83 f8 ff             	cmp    $0xffffffff,%eax
  81880f:	75 2a                	jne    81883b <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  818811:	48 ba 5a 28 82 00 00 	movabs $0x82285a,%rdx
  818818:	00 00 00 
  81881b:	be 54 00 00 00       	mov    $0x54,%esi
  818820:	48 bf 78 28 82 00 00 	movabs $0x822878,%rdi
  818827:	00 00 00 
  81882a:	b8 00 00 00 00       	mov    $0x0,%eax
  81882f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  818836:	00 00 00 
  818839:	ff d1                	callq  *%rcx
    return tid;
  81883b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  81883e:	c9                   	leaveq 
  81883f:	c3                   	retq   

0000000000818840 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818840:	55                   	push   %rbp
  818841:	48 89 e5             	mov    %rsp,%rbp
  818844:	48 83 ec 10          	sub    $0x10,%rsp
  818848:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81884c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818850:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818854:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818858:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81885c:	ba 1f 00 00 00       	mov    $0x1f,%edx
  818861:	48 89 c6             	mov    %rax,%rsi
  818864:	48 89 cf             	mov    %rcx,%rdi
  818867:	48 b8 bd 1d 80 00 00 	movabs $0x801dbd,%rax
  81886e:	00 00 00 
  818871:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  818873:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818877:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  81887b:	c9                   	leaveq 
  81887c:	c3                   	retq   

000000000081887d <thread_entry>:

static void
thread_entry(void) {
  81887d:	55                   	push   %rbp
  81887e:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  818881:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818888:	00 00 00 
  81888b:	48 8b 00             	mov    (%rax),%rax
  81888e:	48 8b 50 30          	mov    0x30(%rax),%rdx
  818892:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818899:	00 00 00 
  81889c:	48 8b 00             	mov    (%rax),%rax
  81889f:	8b 40 38             	mov    0x38(%rax),%eax
  8188a2:	89 c0                	mov    %eax,%eax
  8188a4:	48 89 c7             	mov    %rax,%rdi
  8188a7:	ff d2                	callq  *%rdx
    thread_halt();
  8188a9:	48 b8 be 8a 81 00 00 	movabs $0x818abe,%rax
  8188b0:	00 00 00 
  8188b3:	ff d0                	callq  *%rax
}
  8188b5:	5d                   	pop    %rbp
  8188b6:	c3                   	retq   

00000000008188b7 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  8188b7:	55                   	push   %rbp
  8188b8:	48 89 e5             	mov    %rsp,%rbp
  8188bb:	48 83 ec 30          	sub    $0x30,%rsp
  8188bf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8188c3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8188c7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8188cb:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  8188cf:	bf f0 00 00 00       	mov    $0xf0,%edi
  8188d4:	48 b8 09 48 80 00 00 	movabs $0x804809,%rax
  8188db:	00 00 00 
  8188de:	ff d0                	callq  *%rax
  8188e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  8188e4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8188e9:	75 0a                	jne    8188f5 <thread_create+0x3e>
	return -E_NO_MEM;
  8188eb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8188f0:	e9 4d 01 00 00       	jmpq   818a42 <thread_create+0x18b>

    memset(tc, 0, sizeof(struct thread_context));
  8188f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8188f9:	ba f0 00 00 00       	mov    $0xf0,%edx
  8188fe:	be 00 00 00 00       	mov    $0x0,%esi
  818903:	48 89 c7             	mov    %rax,%rdi
  818906:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  81890d:	00 00 00 
  818910:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  818912:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818916:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81891a:	48 89 d6             	mov    %rdx,%rsi
  81891d:	48 89 c7             	mov    %rax,%rdi
  818920:	48 b8 40 88 81 00 00 	movabs $0x818840,%rax
  818927:	00 00 00 
  81892a:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  81892c:	48 b8 da 87 81 00 00 	movabs $0x8187da,%rax
  818933:	00 00 00 
  818936:	ff d0                	callq  *%rax
  818938:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81893c:	89 02                	mov    %eax,(%rdx)

    tc->tc_stack_bottom = malloc(stack_size);
  81893e:	bf 00 10 00 00       	mov    $0x1000,%edi
  818943:	48 b8 09 48 80 00 00 	movabs $0x804809,%rax
  81894a:	00 00 00 
  81894d:	ff d0                	callq  *%rax
  81894f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818953:	48 89 42 08          	mov    %rax,0x8(%rdx)
    if (!tc->tc_stack_bottom) {
  818957:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81895b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81895f:	48 85 c0             	test   %rax,%rax
  818962:	75 1d                	jne    818981 <thread_create+0xca>
	free(tc);
  818964:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818968:	48 89 c7             	mov    %rax,%rdi
  81896b:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  818972:	00 00 00 
  818975:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  818977:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81897c:	e9 c1 00 00 00       	jmpq   818a42 <thread_create+0x18b>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  818981:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818985:	48 8b 40 08          	mov    0x8(%rax),%rax
  818989:	48 05 00 10 00 00    	add    $0x1000,%rax
  81898f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  818993:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  818998:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81899c:	ba 08 00 00 00       	mov    $0x8,%edx
  8189a1:	be 00 00 00 00       	mov    $0x0,%esi
  8189a6:	48 89 c7             	mov    %rax,%rdi
  8189a9:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  8189b0:	00 00 00 
  8189b3:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  8189b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189b9:	48 83 c0 40          	add    $0x40,%rax
  8189bd:	ba 70 00 00 00       	mov    $0x70,%edx
  8189c2:	be 00 00 00 00       	mov    $0x0,%esi
  8189c7:	48 89 c7             	mov    %rax,%rdi
  8189ca:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  8189d1:	00 00 00 
  8189d4:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  8189d6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8189da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189de:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  8189e2:	48 ba 7d 88 81 00 00 	movabs $0x81887d,%rdx
  8189e9:	00 00 00 
  8189ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189f0:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  8189f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8189f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8189fc:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  818a00:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818a04:	89 c2                	mov    %eax,%edx
  818a06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a0a:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  818a0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a11:	48 89 c6             	mov    %rax,%rsi
  818a14:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818a1b:	00 00 00 
  818a1e:	48 b8 f5 84 81 00 00 	movabs $0x8184f5,%rax
  818a25:	00 00 00 
  818a28:	ff d0                	callq  *%rax

    if (tid)
  818a2a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818a2f:	74 0c                	je     818a3d <thread_create+0x186>
	*tid = tc->tc_tid;
  818a31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a35:	8b 10                	mov    (%rax),%edx
  818a37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a3b:	89 10                	mov    %edx,(%rax)
    return 0;
  818a3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818a42:	c9                   	leaveq 
  818a43:	c3                   	retq   

0000000000818a44 <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  818a44:	55                   	push   %rbp
  818a45:	48 89 e5             	mov    %rsp,%rbp
  818a48:	48 83 ec 20          	sub    $0x20,%rsp
  818a4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  818a50:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818a55:	74 64                	je     818abb <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818a57:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  818a5e:	eb 20                	jmp    818a80 <thread_clean+0x3c>
	tc->tc_onhalt[i](tc->tc_tid);
  818a60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a64:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818a67:	48 63 d2             	movslq %edx,%rdx
  818a6a:	48 83 c2 18          	add    $0x18,%rdx
  818a6e:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  818a72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a76:	8b 00                	mov    (%rax),%eax
  818a78:	89 c7                	mov    %eax,%edi
  818a7a:	ff d2                	callq  *%rdx
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818a7c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  818a80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a84:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818a8a:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  818a8d:	7f d1                	jg     818a60 <thread_clean+0x1c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  818a8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818a93:	48 8b 40 08          	mov    0x8(%rax),%rax
  818a97:	48 89 c7             	mov    %rax,%rdi
  818a9a:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  818aa1:	00 00 00 
  818aa4:	ff d0                	callq  *%rax
    free(tc);
  818aa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818aaa:	48 89 c7             	mov    %rax,%rdi
  818aad:	48 b8 89 4b 80 00 00 	movabs $0x804b89,%rax
  818ab4:	00 00 00 
  818ab7:	ff d0                	callq  *%rax
  818ab9:	eb 01                	jmp    818abc <thread_clean+0x78>
    return 0;
}

static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;
  818abb:	90                   	nop
    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
    free(tc);
}
  818abc:	c9                   	leaveq 
  818abd:	c3                   	retq   

0000000000818abe <thread_halt>:

void
thread_halt() {
  818abe:	55                   	push   %rbp
  818abf:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  818ac2:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  818ac9:	00 00 00 
  818acc:	48 b8 5a 85 81 00 00 	movabs $0x81855a,%rax
  818ad3:	00 00 00 
  818ad6:	ff d0                	callq  *%rax
  818ad8:	48 89 c7             	mov    %rax,%rdi
  818adb:	48 b8 44 8a 81 00 00 	movabs $0x818a44,%rax
  818ae2:	00 00 00 
  818ae5:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  818ae7:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818aee:	00 00 00 
  818af1:	48 8b 00             	mov    (%rax),%rax
  818af4:	48 89 c6             	mov    %rax,%rsi
  818af7:	48 bf 90 74 b5 00 00 	movabs $0xb57490,%rdi
  818afe:	00 00 00 
  818b01:	48 b8 f5 84 81 00 00 	movabs $0x8184f5,%rax
  818b08:	00 00 00 
  818b0b:	ff d0                	callq  *%rax
    cur_tc = NULL;
  818b0d:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b14:	00 00 00 
  818b17:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  818b1e:	48 b8 38 8b 81 00 00 	movabs $0x818b38,%rax
  818b25:	00 00 00 
  818b28:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  818b2a:	48 b8 fc 0e 80 00 00 	movabs $0x800efc,%rax
  818b31:	00 00 00 
  818b34:	ff d0                	callq  *%rax
}
  818b36:	5d                   	pop    %rbp
  818b37:	c3                   	retq   

0000000000818b38 <thread_yield>:

void
thread_yield(void) {
  818b38:	55                   	push   %rbp
  818b39:	48 89 e5             	mov    %rsp,%rbp
  818b3c:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  818b40:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818b47:	00 00 00 
  818b4a:	48 b8 5a 85 81 00 00 	movabs $0x81855a,%rax
  818b51:	00 00 00 
  818b54:	ff d0                	callq  *%rax
  818b56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  818b5a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818b5f:	0f 84 92 00 00 00    	je     818bf7 <thread_yield+0xbf>
	return;

    if (cur_tc) {
  818b65:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b6c:	00 00 00 
  818b6f:	48 8b 00             	mov    (%rax),%rax
  818b72:	48 85 c0             	test   %rax,%rax
  818b75:	74 4a                	je     818bc1 <thread_yield+0x89>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  818b77:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818b7e:	00 00 00 
  818b81:	48 8b 00             	mov    (%rax),%rax
  818b84:	48 83 c0 40          	add    $0x40,%rax
  818b88:	48 89 c7             	mov    %rax,%rdi
  818b8b:	48 b8 60 8e 81 00 00 	movabs $0x818e60,%rax
  818b92:	00 00 00 
  818b95:	ff d0                	callq  *%rax
  818b97:	85 c0                	test   %eax,%eax
  818b99:	75 5f                	jne    818bfa <thread_yield+0xc2>
	    return;
	threadq_push(&thread_queue, cur_tc);
  818b9b:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818ba2:	00 00 00 
  818ba5:	48 8b 00             	mov    (%rax),%rax
  818ba8:	48 89 c6             	mov    %rax,%rsi
  818bab:	48 bf 80 74 b5 00 00 	movabs $0xb57480,%rdi
  818bb2:	00 00 00 
  818bb5:	48 b8 f5 84 81 00 00 	movabs $0x8184f5,%rax
  818bbc:	00 00 00 
  818bbf:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  818bc1:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818bc8:	00 00 00 
  818bcb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818bcf:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  818bd2:	48 b8 78 74 b5 00 00 	movabs $0xb57478,%rax
  818bd9:	00 00 00 
  818bdc:	48 8b 00             	mov    (%rax),%rax
  818bdf:	48 83 c0 40          	add    $0x40,%rax
  818be3:	be 01 00 00 00       	mov    $0x1,%esi
  818be8:	48 89 c7             	mov    %rax,%rdi
  818beb:	48 b8 b0 8e 81 00 00 	movabs $0x818eb0,%rax
  818bf2:	00 00 00 
  818bf5:	ff d0                	callq  *%rax
void
thread_yield(void) {
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;
  818bf7:	90                   	nop
  818bf8:	eb 01                	jmp    818bfb <thread_yield+0xc3>

    if (cur_tc) {
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
	    return;
  818bfa:	90                   	nop
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  818bfb:	c9                   	leaveq 
  818bfc:	c3                   	retq   

0000000000818bfd <print_jb>:

static void
print_jb(struct thread_context *tc) {
  818bfd:	55                   	push   %rbp
  818bfe:	48 89 e5             	mov    %rsp,%rbp
  818c01:	48 83 ec 10          	sub    $0x10,%rsp
  818c05:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  818c09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c0d:	48 83 c0 10          	add    $0x10,%rax
  818c11:	48 89 c6             	mov    %rax,%rsi
  818c14:	48 bf 93 28 82 00 00 	movabs $0x822893,%rdi
  818c1b:	00 00 00 
  818c1e:	b8 00 00 00 00       	mov    $0x0,%eax
  818c23:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818c2a:	00 00 00 
  818c2d:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  818c2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c33:	48 8b 40 40          	mov    0x40(%rax),%rax
  818c37:	48 89 c6             	mov    %rax,%rsi
  818c3a:	48 bf af 28 82 00 00 	movabs $0x8228af,%rdi
  818c41:	00 00 00 
  818c44:	b8 00 00 00 00       	mov    $0x0,%eax
  818c49:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818c50:	00 00 00 
  818c53:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  818c55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c59:	48 8b 40 48          	mov    0x48(%rax),%rax
  818c5d:	48 89 c6             	mov    %rax,%rsi
  818c60:	48 bf b9 28 82 00 00 	movabs $0x8228b9,%rdi
  818c67:	00 00 00 
  818c6a:	b8 00 00 00 00       	mov    $0x0,%eax
  818c6f:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818c76:	00 00 00 
  818c79:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  818c7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c7f:	48 8b 40 50          	mov    0x50(%rax),%rax
  818c83:	48 89 c6             	mov    %rax,%rsi
  818c86:	48 bf c3 28 82 00 00 	movabs $0x8228c3,%rdi
  818c8d:	00 00 00 
  818c90:	b8 00 00 00 00       	mov    $0x0,%eax
  818c95:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818c9c:	00 00 00 
  818c9f:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  818ca1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ca5:	48 8b 40 58          	mov    0x58(%rax),%rax
  818ca9:	48 89 c6             	mov    %rax,%rsi
  818cac:	48 bf cd 28 82 00 00 	movabs $0x8228cd,%rdi
  818cb3:	00 00 00 
  818cb6:	b8 00 00 00 00       	mov    $0x0,%eax
  818cbb:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818cc2:	00 00 00 
  818cc5:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  818cc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ccb:	48 8b 40 60          	mov    0x60(%rax),%rax
  818ccf:	48 89 c6             	mov    %rax,%rsi
  818cd2:	48 bf d7 28 82 00 00 	movabs $0x8228d7,%rdi
  818cd9:	00 00 00 
  818cdc:	b8 00 00 00 00       	mov    $0x0,%eax
  818ce1:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818ce8:	00 00 00 
  818ceb:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  818ced:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818cf1:	48 8b 40 68          	mov    0x68(%rax),%rax
  818cf5:	48 89 c6             	mov    %rax,%rsi
  818cf8:	48 bf e1 28 82 00 00 	movabs $0x8228e1,%rdi
  818cff:	00 00 00 
  818d02:	b8 00 00 00 00       	mov    $0x0,%eax
  818d07:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818d0e:	00 00 00 
  818d11:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  818d13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d17:	48 8b 40 70          	mov    0x70(%rax),%rax
  818d1b:	48 89 c6             	mov    %rax,%rsi
  818d1e:	48 bf eb 28 82 00 00 	movabs $0x8228eb,%rdi
  818d25:	00 00 00 
  818d28:	b8 00 00 00 00       	mov    $0x0,%eax
  818d2d:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818d34:	00 00 00 
  818d37:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  818d39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d3d:	48 8b 40 78          	mov    0x78(%rax),%rax
  818d41:	48 89 c6             	mov    %rax,%rsi
  818d44:	48 bf f5 28 82 00 00 	movabs $0x8228f5,%rdi
  818d4b:	00 00 00 
  818d4e:	b8 00 00 00 00       	mov    $0x0,%eax
  818d53:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818d5a:	00 00 00 
  818d5d:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  818d5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d63:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  818d6a:	48 89 c6             	mov    %rax,%rsi
  818d6d:	48 bf ff 28 82 00 00 	movabs $0x8228ff,%rdi
  818d74:	00 00 00 
  818d77:	b8 00 00 00 00       	mov    $0x0,%eax
  818d7c:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818d83:	00 00 00 
  818d86:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  818d88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818d8c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  818d93:	48 89 c6             	mov    %rax,%rsi
  818d96:	48 bf 09 29 82 00 00 	movabs $0x822909,%rdi
  818d9d:	00 00 00 
  818da0:	b8 00 00 00 00       	mov    $0x0,%eax
  818da5:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818dac:	00 00 00 
  818daf:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  818db1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818db5:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  818dbc:	48 89 c6             	mov    %rax,%rsi
  818dbf:	48 bf 13 29 82 00 00 	movabs $0x822913,%rdi
  818dc6:	00 00 00 
  818dc9:	b8 00 00 00 00       	mov    $0x0,%eax
  818dce:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818dd5:	00 00 00 
  818dd8:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  818dda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818dde:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  818de5:	48 89 c6             	mov    %rax,%rsi
  818de8:	48 bf 1d 29 82 00 00 	movabs $0x82291d,%rdi
  818def:	00 00 00 
  818df2:	b8 00 00 00 00       	mov    $0x0,%eax
  818df7:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818dfe:	00 00 00 
  818e01:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  818e03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e07:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  818e0e:	48 89 c6             	mov    %rax,%rsi
  818e11:	48 bf 27 29 82 00 00 	movabs $0x822927,%rdi
  818e18:	00 00 00 
  818e1b:	b8 00 00 00 00       	mov    $0x0,%eax
  818e20:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818e27:	00 00 00 
  818e2a:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  818e2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e30:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  818e37:	48 89 c6             	mov    %rax,%rsi
  818e3a:	48 bf 30 29 82 00 00 	movabs $0x822930,%rdi
  818e41:	00 00 00 
  818e44:	b8 00 00 00 00       	mov    $0x0,%eax
  818e49:	48 ba 5b 11 80 00 00 	movabs $0x80115b,%rdx
  818e50:	00 00 00 
  818e53:	ff d2                	callq  *%rdx
}
  818e55:	c9                   	leaveq 
  818e56:	c3                   	retq   
	...

0000000000818e60 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  818e60:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  818e63:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  818e67:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  818e6a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  818e6f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  818e73:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  818e77:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  818e7b:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  818e7f:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  818e83:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  818e87:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  818e8b:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  818e8f:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  818e93:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  818e97:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  818e9b:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  818e9f:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  818ea3:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  818eaa:	c3                   	retq   
  818eab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000818eb0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  818eb0:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  818eb3:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  818eb6:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  818eb9:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  818ebd:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  818ec1:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  818ec5:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  818ec9:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  818ecd:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  818ed1:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  818ed5:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  818ed9:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  818edd:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  818ee1:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  818ee5:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  818ee9:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  818eed:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  818ef0:	ff e1                	jmpq   *%rcx
	...

0000000000818ef4 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  818ef4:	55                   	push   %rbp
  818ef5:	48 89 e5             	mov    %rsp,%rbp
  818ef8:	48 83 ec 20          	sub    $0x20,%rsp
  818efc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  818f00:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  818f07:	00 00 00 
  818f0a:	8b 00                	mov    (%rax),%eax
  818f0c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  818f0f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818f12:	89 c7                	mov    %eax,%edi
  818f14:	48 b8 47 8f 81 00 00 	movabs $0x818f47,%rax
  818f1b:	00 00 00 
  818f1e:	ff d0                	callq  *%rax
  818f20:	48 89 c2             	mov    %rax,%rdx
  818f23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818f27:	48 89 c6             	mov    %rax,%rsi
  818f2a:	48 bf 1d 2e 82 00 00 	movabs $0x822e1d,%rdi
  818f31:	00 00 00 
  818f34:	b8 00 00 00 00       	mov    $0x0,%eax
  818f39:	48 b9 5b 11 80 00 00 	movabs $0x80115b,%rcx
  818f40:	00 00 00 
  818f43:	ff d1                	callq  *%rcx
}
  818f45:	c9                   	leaveq 
  818f46:	c3                   	retq   

0000000000818f47 <e2s>:

const char *
e2s(int err) {
  818f47:	55                   	push   %rbp
  818f48:	48 89 e5             	mov    %rsp,%rbp
  818f4b:	48 83 ec 08          	sub    $0x8,%rsp
  818f4f:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  818f52:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  818f59:	00 00 00 
  818f5c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818f5f:	48 63 d2             	movslq %edx,%rdx
  818f62:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  818f66:	c9                   	leaveq 
  818f67:	c3                   	retq   

0000000000818f68 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  818f68:	55                   	push   %rbp
  818f69:	48 89 e5             	mov    %rsp,%rbp
  818f6c:	48 83 ec 08          	sub    $0x8,%rsp
  818f70:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  818f74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f78:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  818f7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f80:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  818f86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f8a:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  818f8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f92:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  818f96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f9a:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  818f9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fa2:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  818fa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818faa:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  818fae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fb2:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  818fb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fba:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  818fbe:	c9                   	leaveq 
  818fbf:	c3                   	retq   

0000000000818fc0 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  818fc0:	55                   	push   %rbp
  818fc1:	48 89 e5             	mov    %rsp,%rbp
  818fc4:	48 83 ec 40          	sub    $0x40,%rsp
  818fc8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  818fcc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  818fd0:	ba 07 00 00 00       	mov    $0x7,%edx
  818fd5:	be 00 00 00 10       	mov    $0x10000000,%esi
  818fda:	bf 00 00 00 00       	mov    $0x0,%edi
  818fdf:	48 b8 64 26 80 00 00 	movabs $0x802664,%rax
  818fe6:	00 00 00 
  818fe9:	ff d0                	callq  *%rax
  818feb:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  818fee:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  818ff2:	79 2a                	jns    81901e <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  818ff4:	48 ba 28 2e 82 00 00 	movabs $0x822e28,%rdx
  818ffb:	00 00 00 
  818ffe:	be 55 00 00 00       	mov    $0x55,%esi
  819003:	48 bf 4f 2e 82 00 00 	movabs $0x822e4f,%rdi
  81900a:	00 00 00 
  81900d:	b8 00 00 00 00       	mov    $0x0,%eax
  819012:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819019:	00 00 00 
  81901c:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  81901e:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  819025:	10 

    struct jif *jif;
    jif = netif->state;
  819026:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81902a:	48 8b 40 30          	mov    0x30(%rax),%rax
  81902e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  819032:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819036:	48 83 c0 04          	add    $0x4,%rax
  81903a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  81903e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819045:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819049:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81904d:	e9 9a 00 00 00       	jmpq   8190ec <low_level_output+0x12c>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  819052:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819056:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81905a:	0f b7 c0             	movzwl %ax,%eax
  81905d:	03 45 fc             	add    -0x4(%rbp),%eax
  819060:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819065:	7e 3e                	jle    8190a5 <low_level_output+0xe5>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819067:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81906b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81906f:	0f b7 c0             	movzwl %ax,%eax
  819072:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819075:	41 89 d0             	mov    %edx,%r8d
  819078:	89 c1                	mov    %eax,%ecx
  81907a:	48 ba 68 2e 82 00 00 	movabs $0x822e68,%rdx
  819081:	00 00 00 
  819084:	be 64 00 00 00       	mov    $0x64,%esi
  819089:	48 bf 4f 2e 82 00 00 	movabs $0x822e4f,%rdi
  819090:	00 00 00 
  819093:	b8 00 00 00 00       	mov    $0x0,%eax
  819098:	49 b9 20 0f 80 00 00 	movabs $0x800f20,%r9
  81909f:	00 00 00 
  8190a2:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  8190a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8190a9:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8190ad:	0f b7 d0             	movzwl %ax,%edx
  8190b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8190b4:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8190b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8190bb:	48 98                	cltq   
  8190bd:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8190c1:	48 89 ce             	mov    %rcx,%rsi
  8190c4:	48 89 c7             	mov    %rax,%rdi
  8190c7:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  8190ce:	00 00 00 
  8190d1:	ff d0                	callq  *%rax
	txsize += q->len;
  8190d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8190d7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8190db:	0f b7 c0             	movzwl %ax,%eax
  8190de:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8190e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8190e5:	48 8b 00             	mov    (%rax),%rax
  8190e8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8190ec:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8190f1:	0f 85 5b ff ff ff    	jne    819052 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  8190f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8190fb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8190fe:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  819100:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819104:	8b 40 08             	mov    0x8(%rax),%eax
  819107:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81910b:	b9 07 00 00 00       	mov    $0x7,%ecx
  819110:	be 0b 00 00 00       	mov    $0xb,%esi
  819115:	89 c7                	mov    %eax,%edi
  819117:	48 b8 ff 31 80 00 00 	movabs $0x8031ff,%rax
  81911e:	00 00 00 
  819121:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  819123:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819127:	48 89 c6             	mov    %rax,%rsi
  81912a:	bf 00 00 00 00       	mov    $0x0,%edi
  81912f:	48 b8 0f 27 80 00 00 	movabs $0x80270f,%rax
  819136:	00 00 00 
  819139:	ff d0                	callq  *%rax

    return ERR_OK;
  81913b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819140:	c9                   	leaveq 
  819141:	c3                   	retq   

0000000000819142 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  819142:	55                   	push   %rbp
  819143:	48 89 e5             	mov    %rsp,%rbp
  819146:	48 83 ec 50          	sub    $0x50,%rsp
  81914a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  81914e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819152:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  819156:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81915a:	8b 00                	mov    (%rax),%eax
  81915c:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819160:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  819164:	0f b7 c0             	movzwl %ax,%eax
  819167:	ba 03 00 00 00       	mov    $0x3,%edx
  81916c:	89 c6                	mov    %eax,%esi
  81916e:	bf 03 00 00 00       	mov    $0x3,%edi
  819173:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  81917a:	00 00 00 
  81917d:	ff d0                	callq  *%rax
  81917f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  819183:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  819188:	75 0a                	jne    819194 <low_level_input+0x52>
	return 0;
  81918a:	b8 00 00 00 00       	mov    $0x0,%eax
  81918f:	e9 89 00 00 00       	jmpq   81921d <low_level_input+0xdb>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  819194:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819198:	48 83 c0 04          	add    $0x4,%rax
  81919c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  8191a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8191a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8191ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8191af:	eb 61                	jmp    819212 <low_level_input+0xd0>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  8191b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8191b5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8191b9:	0f b7 c0             	movzwl %ax,%eax
  8191bc:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  8191bf:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  8191c3:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8191c6:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8191c9:	7d 0a                	jge    8191d5 <low_level_input+0x93>
	    bytes = len - copied;
  8191cb:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  8191cf:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8191d2:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  8191d5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8191d8:	48 63 d0             	movslq %eax,%rdx
  8191db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8191de:	48 98                	cltq   
  8191e0:	48 89 c1             	mov    %rax,%rcx
  8191e3:	48 03 4d c8          	add    -0x38(%rbp),%rcx
  8191e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8191eb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8191ef:	48 89 ce             	mov    %rcx,%rsi
  8191f2:	48 89 c7             	mov    %rax,%rdi
  8191f5:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  8191fc:	00 00 00 
  8191ff:	ff d0                	callq  *%rax
	copied += bytes;
  819201:	8b 45 ec             	mov    -0x14(%rbp),%eax
  819204:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819207:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81920b:	48 8b 00             	mov    (%rax),%rax
  81920e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  819212:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819217:	75 98                	jne    8191b1 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  819219:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  81921d:	c9                   	leaveq 
  81921e:	c3                   	retq   

000000000081921f <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  81921f:	55                   	push   %rbp
  819220:	48 89 e5             	mov    %rsp,%rbp
  819223:	48 83 ec 20          	sub    $0x20,%rsp
  819227:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81922b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81922f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  819233:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819237:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81923b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81923f:	48 89 ce             	mov    %rcx,%rsi
  819242:	48 89 c7             	mov    %rax,%rdi
  819245:	48 b8 09 65 81 00 00 	movabs $0x816509,%rax
  81924c:	00 00 00 
  81924f:	ff d0                	callq  *%rax
}
  819251:	c9                   	leaveq 
  819252:	c3                   	retq   

0000000000819253 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  819253:	55                   	push   %rbp
  819254:	48 89 e5             	mov    %rsp,%rbp
  819257:	48 83 ec 30          	sub    $0x30,%rsp
  81925b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81925f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  819263:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819267:	48 8b 40 30          	mov    0x30(%rax),%rax
  81926b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  81926f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819273:	48 89 c7             	mov    %rax,%rdi
  819276:	48 b8 42 91 81 00 00 	movabs $0x819142,%rax
  81927d:	00 00 00 
  819280:	ff d0                	callq  *%rax
  819282:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  819286:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81928b:	0f 84 bc 00 00 00    	je     81934d <jif_input+0xfa>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  819291:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819295:	48 8b 40 08          	mov    0x8(%rax),%rax
  819299:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  81929d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8192a1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8192a5:	0f b7 c0             	movzwl %ax,%eax
  8192a8:	89 c7                	mov    %eax,%edi
  8192aa:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8192b1:	00 00 00 
  8192b4:	ff d0                	callq  *%rax
  8192b6:	0f b7 c0             	movzwl %ax,%eax
  8192b9:	3d 00 08 00 00       	cmp    $0x800,%eax
  8192be:	74 09                	je     8192c9 <jif_input+0x76>
  8192c0:	3d 06 08 00 00       	cmp    $0x806,%eax
  8192c5:	74 4e                	je     819315 <jif_input+0xc2>
  8192c7:	eb 6f                	jmp    819338 <jif_input+0xe5>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  8192c9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8192cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8192d1:	48 89 d6             	mov    %rdx,%rsi
  8192d4:	48 89 c7             	mov    %rax,%rdi
  8192d7:	48 b8 32 61 81 00 00 	movabs $0x816132,%rax
  8192de:	00 00 00 
  8192e1:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  8192e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8192e7:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  8192ec:	48 89 c7             	mov    %rax,%rdi
  8192ef:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  8192f6:	00 00 00 
  8192f9:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  8192fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8192ff:	48 8b 48 18          	mov    0x18(%rax),%rcx
  819303:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  819307:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81930b:	48 89 d6             	mov    %rdx,%rsi
  81930e:	48 89 c7             	mov    %rax,%rdi
  819311:	ff d1                	callq  *%rcx
	break;
  819313:	eb 39                	jmp    81934e <jif_input+0xfb>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  819315:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819319:	48 8b 08             	mov    (%rax),%rcx
  81931c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819320:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819324:	48 89 ce             	mov    %rcx,%rsi
  819327:	48 89 c7             	mov    %rax,%rdi
  81932a:	48 b8 c9 61 81 00 00 	movabs $0x8161c9,%rax
  819331:	00 00 00 
  819334:	ff d0                	callq  *%rax
	break;
  819336:	eb 16                	jmp    81934e <jif_input+0xfb>

    default:
	pbuf_free(p);
  819338:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81933c:	48 89 c7             	mov    %rax,%rdi
  81933f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  819346:	00 00 00 
  819349:	ff d0                	callq  *%rax
  81934b:	eb 01                	jmp    81934e <jif_input+0xfb>
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  81934d:	90                   	nop
	break;

    default:
	pbuf_free(p);
    }
}
  81934e:	c9                   	leaveq 
  81934f:	c3                   	retq   

0000000000819350 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  819350:	55                   	push   %rbp
  819351:	48 89 e5             	mov    %rsp,%rbp
  819354:	48 83 ec 30          	sub    $0x30,%rsp
  819358:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  81935c:	bf 10 00 00 00       	mov    $0x10,%edi
  819361:	48 b8 99 c3 80 00 00 	movabs $0x80c399,%rax
  819368:	00 00 00 
  81936b:	ff d0                	callq  *%rax
  81936d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (jif == NULL) {
  819371:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819376:	75 0a                	jne    819382 <jif_init+0x32>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  819378:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81937d:	e9 ce 00 00 00       	jmpq   819450 <jif_init+0x100>
    }

    output_envid = (envid_t *)netif->state;
  819382:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819386:	48 8b 40 30          	mov    0x30(%rax),%rax
  81938a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    netif->state = jif;
  81938e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819392:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819396:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  81939a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81939e:	48 ba 1f 92 81 00 00 	movabs $0x81921f,%rdx
  8193a5:	00 00 00 
  8193a8:	48 89 50 20          	mov    %rdx,0x20(%rax)
    netif->linkoutput = low_level_output;
  8193ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8193b0:	48 ba c0 8f 81 00 00 	movabs $0x818fc0,%rdx
  8193b7:	00 00 00 
  8193ba:	48 89 50 28          	mov    %rdx,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  8193be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8193c2:	48 83 c0 4b          	add    $0x4b,%rax
  8193c6:	ba 02 00 00 00       	mov    $0x2,%edx
  8193cb:	48 be 91 2e 82 00 00 	movabs $0x822e91,%rsi
  8193d2:	00 00 00 
  8193d5:	48 89 c7             	mov    %rax,%rdi
  8193d8:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  8193df:	00 00 00 
  8193e2:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  8193e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8193e8:	48 8d 50 41          	lea    0x41(%rax),%rdx
  8193ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193f0:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  8193f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8193f7:	8b 10                	mov    (%rax),%edx
  8193f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8193fd:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  819400:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819404:	48 89 c7             	mov    %rax,%rdi
  819407:	48 b8 68 8f 81 00 00 	movabs $0x818f68,%rax
  81940e:	00 00 00 
  819411:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  819413:	48 bf 94 2e 82 00 00 	movabs $0x822e94,%rdi
  81941a:	00 00 00 
  81941d:	48 b8 9c 26 81 00 00 	movabs $0x81269c,%rax
  819424:	00 00 00 
  819427:	ff d0                	callq  *%rax
  819429:	89 45 ec             	mov    %eax,-0x14(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  81942c:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  819430:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819434:	ba 00 00 00 00       	mov    $0x0,%edx
  819439:	48 89 ce             	mov    %rcx,%rsi
  81943c:	48 89 c7             	mov    %rax,%rdi
  81943f:	48 b8 9b 66 81 00 00 	movabs $0x81669b,%rax
  819446:	00 00 00 
  819449:	ff d0                	callq  *%rax

    return ERR_OK;
  81944b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819450:	c9                   	leaveq 
  819451:	c3                   	retq   
	...

0000000000819454 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  819454:	55                   	push   %rbp
  819455:	48 89 e5             	mov    %rsp,%rbp
  819458:	48 83 ec 40          	sub    $0x40,%rsp
  81945c:	89 7d cc             	mov    %edi,-0x34(%rbp)
  81945f:	89 f0                	mov    %esi,%eax
  819461:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  819465:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  819468:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81946c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  81946f:	48 89 d6             	mov    %rdx,%rsi
  819472:	89 c7                	mov    %eax,%edi
  819474:	48 b8 d8 aa 81 00 00 	movabs $0x81aad8,%rax
  81947b:	00 00 00 
  81947e:	ff d0                	callq  *%rax
  819480:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  819484:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819489:	0f 84 62 01 00 00    	je     8195f1 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  81948f:	48 b8 8f aa 81 00 00 	movabs $0x81aa8f,%rax
  819496:	00 00 00 
  819499:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  81949d:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  8194a1:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  8194a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194a8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  8194ac:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8194b0:	48 89 c7             	mov    %rax,%rdi
  8194b3:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  8194ba:	00 00 00 
  8194bd:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  8194bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194c3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8194c7:	84 c0                	test   %al,%al
  8194c9:	0f 84 22 01 00 00    	je     8195f1 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  8194cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8194d7:	48 85 c0             	test   %rax,%rax
  8194da:	74 2a                	je     819506 <netconn_new_with_proto_and_callback+0xb2>
  8194dc:	48 ba a0 2e 82 00 00 	movabs $0x822ea0,%rdx
  8194e3:	00 00 00 
  8194e6:	be 52 00 00 00       	mov    $0x52,%esi
  8194eb:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  8194f2:	00 00 00 
  8194f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8194fa:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819501:	00 00 00 
  819504:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  819506:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81950a:	8b 40 14             	mov    0x14(%rax),%eax
  81950d:	83 f8 ff             	cmp    $0xffffffff,%eax
  819510:	75 2a                	jne    81953c <netconn_new_with_proto_and_callback+0xe8>
  819512:	48 ba d8 2e 82 00 00 	movabs $0x822ed8,%rdx
  819519:	00 00 00 
  81951c:	be 53 00 00 00       	mov    $0x53,%esi
  819521:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819528:	00 00 00 
  81952b:	b8 00 00 00 00       	mov    $0x0,%eax
  819530:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819537:	00 00 00 
  81953a:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  81953c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819540:	8b 40 18             	mov    0x18(%rax),%eax
  819543:	83 f8 ff             	cmp    $0xffffffff,%eax
  819546:	75 2a                	jne    819572 <netconn_new_with_proto_and_callback+0x11e>
  819548:	48 ba f1 2e 82 00 00 	movabs $0x822ef1,%rdx
  81954f:	00 00 00 
  819552:	be 54 00 00 00       	mov    $0x54,%esi
  819557:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  81955e:	00 00 00 
  819561:	b8 00 00 00 00       	mov    $0x0,%eax
  819566:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81956d:	00 00 00 
  819570:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819572:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819576:	8b 40 1c             	mov    0x1c(%rax),%eax
  819579:	83 f8 ff             	cmp    $0xffffffff,%eax
  81957c:	74 2a                	je     8195a8 <netconn_new_with_proto_and_callback+0x154>
  81957e:	48 ba 08 2f 82 00 00 	movabs $0x822f08,%rdx
  819585:	00 00 00 
  819588:	be 55 00 00 00       	mov    $0x55,%esi
  81958d:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819594:	00 00 00 
  819597:	b8 00 00 00 00       	mov    $0x0,%eax
  81959c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8195a3:	00 00 00 
  8195a6:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  8195a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195ac:	8b 40 14             	mov    0x14(%rax),%eax
  8195af:	89 c7                	mov    %eax,%edi
  8195b1:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  8195b8:	00 00 00 
  8195bb:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  8195bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195c1:	8b 40 18             	mov    0x18(%rax),%eax
  8195c4:	89 c7                	mov    %eax,%edi
  8195c6:	48 b8 19 73 81 00 00 	movabs $0x817319,%rax
  8195cd:	00 00 00 
  8195d0:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  8195d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195d6:	48 89 c6             	mov    %rax,%rsi
  8195d9:	bf 07 00 00 00       	mov    $0x7,%edi
  8195de:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  8195e5:	00 00 00 
  8195e8:	ff d0                	callq  *%rax
      return NULL;
  8195ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8195ef:	eb 04                	jmp    8195f5 <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  8195f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8195f5:	c9                   	leaveq 
  8195f6:	c3                   	retq   

00000000008195f7 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  8195f7:	55                   	push   %rbp
  8195f8:	48 89 e5             	mov    %rsp,%rbp
  8195fb:	48 83 ec 40          	sub    $0x40,%rsp
  8195ff:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  819603:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819608:	75 07                	jne    819611 <netconn_delete+0x1a>
    return ERR_OK;
  81960a:	b8 00 00 00 00       	mov    $0x0,%eax
  81960f:	eb 4d                	jmp    81965e <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  819611:	48 b8 a2 b0 81 00 00 	movabs $0x81b0a2,%rax
  819618:	00 00 00 
  81961b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81961f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819623:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819627:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81962b:	48 89 c7             	mov    %rax,%rdi
  81962e:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819635:	00 00 00 
  819638:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  81963a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81963e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  819645:	00 
  netconn_free(conn);
  819646:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81964a:	48 89 c7             	mov    %rax,%rdi
  81964d:	48 b8 0c ac 81 00 00 	movabs $0x81ac0c,%rax
  819654:	00 00 00 
  819657:	ff d0                	callq  *%rax

  return ERR_OK;
  819659:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81965e:	c9                   	leaveq 
  81965f:	c3                   	retq   

0000000000819660 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819660:	55                   	push   %rbp
  819661:	48 89 e5             	mov    %rsp,%rbp
  819664:	48 83 ec 10          	sub    $0x10,%rsp
  819668:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  81966c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819671:	75 2a                	jne    81969d <netconn_type+0x3d>
  819673:	48 ba 29 2f 82 00 00 	movabs $0x822f29,%rdx
  81967a:	00 00 00 
  81967d:	be 84 00 00 00       	mov    $0x84,%esi
  819682:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819689:	00 00 00 
  81968c:	b8 00 00 00 00       	mov    $0x0,%eax
  819691:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819698:	00 00 00 
  81969b:	ff d1                	callq  *%rcx
  return conn->type;
  81969d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196a1:	8b 00                	mov    (%rax),%eax
}
  8196a3:	c9                   	leaveq 
  8196a4:	c3                   	retq   

00000000008196a5 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  8196a5:	55                   	push   %rbp
  8196a6:	48 89 e5             	mov    %rsp,%rbp
  8196a9:	48 83 ec 50          	sub    $0x50,%rsp
  8196ad:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8196b1:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8196b5:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8196b9:	89 c8                	mov    %ecx,%eax
  8196bb:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  8196be:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8196c3:	75 2a                	jne    8196ef <netconn_getaddr+0x4a>
  8196c5:	48 ba 44 2f 82 00 00 	movabs $0x822f44,%rdx
  8196cc:	00 00 00 
  8196cf:	be 98 00 00 00       	mov    $0x98,%esi
  8196d4:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  8196db:	00 00 00 
  8196de:	b8 00 00 00 00       	mov    $0x0,%eax
  8196e3:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8196ea:	00 00 00 
  8196ed:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  8196ef:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8196f4:	75 2a                	jne    819720 <netconn_getaddr+0x7b>
  8196f6:	48 ba 62 2f 82 00 00 	movabs $0x822f62,%rdx
  8196fd:	00 00 00 
  819700:	be 99 00 00 00       	mov    $0x99,%esi
  819705:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  81970c:	00 00 00 
  81970f:	b8 00 00 00 00       	mov    $0x0,%eax
  819714:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81971b:	00 00 00 
  81971e:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819720:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819725:	75 2a                	jne    819751 <netconn_getaddr+0xac>
  819727:	48 ba 80 2f 82 00 00 	movabs $0x822f80,%rdx
  81972e:	00 00 00 
  819731:	be 9a 00 00 00       	mov    $0x9a,%esi
  819736:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  81973d:	00 00 00 
  819740:	b8 00 00 00 00       	mov    $0x0,%eax
  819745:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81974c:	00 00 00 
  81974f:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  819751:	48 b8 56 bc 81 00 00 	movabs $0x81bc56,%rax
  819758:	00 00 00 
  81975b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81975f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819763:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819767:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81976b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  81976f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819773:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819777:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  81977b:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  81977e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819782:	48 89 c7             	mov    %rax,%rdi
  819785:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  81978c:	00 00 00 
  81978f:	ff d0                	callq  *%rax

  return conn->err;
  819791:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819795:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819799:	c9                   	leaveq 
  81979a:	c3                   	retq   

000000000081979b <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  81979b:	55                   	push   %rbp
  81979c:	48 89 e5             	mov    %rsp,%rbp
  81979f:	48 83 ec 50          	sub    $0x50,%rsp
  8197a3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8197a7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8197ab:	89 d0                	mov    %edx,%eax
  8197ad:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  8197b1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8197b6:	75 2a                	jne    8197e2 <netconn_bind+0x47>
  8197b8:	48 ba 9e 2f 82 00 00 	movabs $0x822f9e,%rdx
  8197bf:	00 00 00 
  8197c2:	be b5 00 00 00       	mov    $0xb5,%esi
  8197c7:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  8197ce:	00 00 00 
  8197d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8197d6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8197dd:	00 00 00 
  8197e0:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  8197e2:	48 b8 e1 b1 81 00 00 	movabs $0x81b1e1,%rax
  8197e9:	00 00 00 
  8197ec:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8197f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8197f4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  8197f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8197fc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819800:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819804:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  819808:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81980c:	48 89 c7             	mov    %rax,%rdi
  81980f:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819816:	00 00 00 
  819819:	ff d0                	callq  *%rax
  return conn->err;
  81981b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81981f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819823:	c9                   	leaveq 
  819824:	c3                   	retq   

0000000000819825 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819825:	55                   	push   %rbp
  819826:	48 89 e5             	mov    %rsp,%rbp
  819829:	48 83 ec 50          	sub    $0x50,%rsp
  81982d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819831:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819835:	89 d0                	mov    %edx,%eax
  819837:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  81983b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819840:	75 2a                	jne    81986c <netconn_connect+0x47>
  819842:	48 ba b9 2f 82 00 00 	movabs $0x822fb9,%rdx
  819849:	00 00 00 
  81984c:	be cc 00 00 00       	mov    $0xcc,%esi
  819851:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819858:	00 00 00 
  81985b:	b8 00 00 00 00       	mov    $0x0,%eax
  819860:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819867:	00 00 00 
  81986a:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  81986c:	48 b8 91 b3 81 00 00 	movabs $0x81b391,%rax
  819873:	00 00 00 
  819876:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81987a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81987e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819882:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819886:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  81988a:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  81988e:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  819892:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819896:	48 89 c7             	mov    %rax,%rdi
  819899:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  8198a0:	00 00 00 
  8198a3:	ff d0                	callq  *%rax
  return conn->err;
  8198a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198a9:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  8198ad:	c9                   	leaveq 
  8198ae:	c3                   	retq   

00000000008198af <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  8198af:	55                   	push   %rbp
  8198b0:	48 89 e5             	mov    %rsp,%rbp
  8198b3:	48 83 ec 40          	sub    $0x40,%rsp
  8198b7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  8198bb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8198c0:	75 2a                	jne    8198ec <netconn_disconnect+0x3d>
  8198c2:	48 ba d8 2f 82 00 00 	movabs $0x822fd8,%rdx
  8198c9:	00 00 00 
  8198cc:	be e2 00 00 00       	mov    $0xe2,%esi
  8198d1:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  8198d8:	00 00 00 
  8198db:	b8 00 00 00 00       	mov    $0x0,%eax
  8198e0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8198e7:	00 00 00 
  8198ea:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  8198ec:	48 b8 00 b5 81 00 00 	movabs $0x81b500,%rax
  8198f3:	00 00 00 
  8198f6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8198fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8198fe:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  819902:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819906:	48 89 c7             	mov    %rax,%rdi
  819909:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819910:	00 00 00 
  819913:	ff d0                	callq  *%rax
  return conn->err;
  819915:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819919:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81991d:	c9                   	leaveq 
  81991e:	c3                   	retq   

000000000081991f <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  81991f:	55                   	push   %rbp
  819920:	48 89 e5             	mov    %rsp,%rbp
  819923:	48 83 ec 40          	sub    $0x40,%rsp
  819927:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81992b:	89 f0                	mov    %esi,%eax
  81992d:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  819930:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819935:	75 2a                	jne    819961 <netconn_listen_with_backlog+0x42>
  819937:	48 ba f9 2f 82 00 00 	movabs $0x822ff9,%rdx
  81993e:	00 00 00 
  819941:	be fa 00 00 00       	mov    $0xfa,%esi
  819946:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  81994d:	00 00 00 
  819950:	b8 00 00 00 00       	mov    $0x0,%eax
  819955:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81995c:	00 00 00 
  81995f:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  819961:	48 b8 53 b5 81 00 00 	movabs $0x81b553,%rax
  819968:	00 00 00 
  81996b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81996f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819973:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  819977:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81997b:	48 89 c7             	mov    %rax,%rdi
  81997e:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819985:	00 00 00 
  819988:	ff d0                	callq  *%rax
  return conn->err;
  81998a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81998e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819992:	c9                   	leaveq 
  819993:	c3                   	retq   

0000000000819994 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  819994:	55                   	push   %rbp
  819995:	48 89 e5             	mov    %rsp,%rbp
  819998:	48 83 ec 20          	sub    $0x20,%rsp
  81999c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  8199a0:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8199a5:	75 2a                	jne    8199d1 <netconn_accept+0x3d>
  8199a7:	48 ba 16 30 82 00 00 	movabs $0x823016,%rdx
  8199ae:	00 00 00 
  8199b1:	be 10 01 00 00       	mov    $0x110,%esi
  8199b6:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  8199bd:	00 00 00 
  8199c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8199c5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8199cc:	00 00 00 
  8199cf:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  8199d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8199d5:	8b 40 1c             	mov    0x1c(%rax),%eax
  8199d8:	83 f8 ff             	cmp    $0xffffffff,%eax
  8199db:	75 2a                	jne    819a07 <netconn_accept+0x73>
  8199dd:	48 ba 38 30 82 00 00 	movabs $0x823038,%rdx
  8199e4:	00 00 00 
  8199e7:	be 11 01 00 00       	mov    $0x111,%esi
  8199ec:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  8199f3:	00 00 00 
  8199f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8199fb:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819a02:	00 00 00 
  819a05:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  819a07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a0b:	8b 40 1c             	mov    0x1c(%rax),%eax
  819a0e:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  819a12:	ba 00 00 00 00       	mov    $0x0,%edx
  819a17:	48 89 ce             	mov    %rcx,%rsi
  819a1a:	89 c7                	mov    %eax,%edi
  819a1c:	48 b8 90 7d 81 00 00 	movabs $0x817d90,%rax
  819a23:	00 00 00 
  819a26:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  819a28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a2c:	48 8b 40 38          	mov    0x38(%rax),%rax
  819a30:	48 85 c0             	test   %rax,%rax
  819a33:	74 1b                	je     819a50 <netconn_accept+0xbc>
  819a35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a39:	48 8b 48 38          	mov    0x38(%rax),%rcx
  819a3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819a41:	ba 00 00 00 00       	mov    $0x0,%edx
  819a46:	be 01 00 00 00       	mov    $0x1,%esi
  819a4b:	48 89 c7             	mov    %rax,%rdi
  819a4e:	ff d1                	callq  *%rcx
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  819a50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819a54:	c9                   	leaveq 
  819a55:	c3                   	retq   

0000000000819a56 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  819a56:	55                   	push   %rbp
  819a57:	48 89 e5             	mov    %rsp,%rbp
  819a5a:	48 83 ec 50          	sub    $0x50,%rsp
  819a5e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  819a62:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  819a69:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  819a6a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819a6f:	75 2a                	jne    819a9b <netconn_recv+0x45>
  819a71:	48 ba 5b 30 82 00 00 	movabs $0x82305b,%rdx
  819a78:	00 00 00 
  819a7b:	be 3a 01 00 00       	mov    $0x13a,%esi
  819a80:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819a87:	00 00 00 
  819a8a:	b8 00 00 00 00       	mov    $0x0,%eax
  819a8f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819a96:	00 00 00 
  819a99:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  819a9b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819a9f:	8b 40 18             	mov    0x18(%rax),%eax
  819aa2:	83 f8 ff             	cmp    $0xffffffff,%eax
  819aa5:	75 12                	jne    819ab9 <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  819aa7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819aab:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  819aaf:	b8 00 00 00 00       	mov    $0x0,%eax
  819ab4:	e9 22 02 00 00       	jmpq   819cdb <netconn_recv+0x285>
  }

  if (ERR_IS_FATAL(conn->err)) {
  819ab9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819abd:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819ac1:	3c fc                	cmp    $0xfc,%al
  819ac3:	7d 0a                	jge    819acf <netconn_recv+0x79>
    return NULL;
  819ac5:	b8 00 00 00 00       	mov    $0x0,%eax
  819aca:	e9 0c 02 00 00       	jmpq   819cdb <netconn_recv+0x285>
  }

  if (conn->type == NETCONN_TCP) {
  819acf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ad3:	8b 00                	mov    (%rax),%eax
  819ad5:	83 f8 10             	cmp    $0x10,%eax
  819ad8:	0f 85 80 01 00 00    	jne    819c5e <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  819ade:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ae2:	8b 40 04             	mov    0x4(%rax),%eax
  819ae5:	83 f8 02             	cmp    $0x2,%eax
  819ae8:	75 12                	jne    819afc <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  819aea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819aee:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  819af2:	b8 00 00 00 00       	mov    $0x0,%eax
  819af7:	e9 df 01 00 00       	jmpq   819cdb <netconn_recv+0x285>
    }

    buf = memp_malloc(MEMP_NETBUF);
  819afc:	bf 06 00 00 00       	mov    $0x6,%edi
  819b01:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  819b08:	00 00 00 
  819b0b:	ff d0                	callq  *%rax
  819b0d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  819b11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819b15:	48 85 c0             	test   %rax,%rax
  819b18:	75 12                	jne    819b2c <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  819b1a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b1e:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  819b22:	b8 00 00 00 00       	mov    $0x0,%eax
  819b27:	e9 af 01 00 00       	jmpq   819cdb <netconn_recv+0x285>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  819b2c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b30:	8b 40 18             	mov    0x18(%rax),%eax
  819b33:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  819b37:	ba 00 00 00 00       	mov    $0x0,%edx
  819b3c:	48 89 ce             	mov    %rcx,%rsi
  819b3f:	89 c7                	mov    %eax,%edi
  819b41:	48 b8 90 7d 81 00 00 	movabs $0x817d90,%rax
  819b48:	00 00 00 
  819b4b:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  819b4d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819b51:	48 85 c0             	test   %rax,%rax
  819b54:	74 24                	je     819b7a <netconn_recv+0x124>
      len = p->tot_len;
  819b56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819b5a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819b5e:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  819b62:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b66:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  819b6a:	89 c2                	mov    %eax,%edx
  819b6c:	66 2b 55 fe          	sub    -0x2(%rbp),%dx
  819b70:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b74:	66 89 50 24          	mov    %dx,0x24(%rax)
  819b78:	eb 06                	jmp    819b80 <netconn_recv+0x12a>
    } else {
      len = 0;
  819b7a:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  819b80:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b84:	48 8b 40 38          	mov    0x38(%rax),%rax
  819b88:	48 85 c0             	test   %rax,%rax
  819b8b:	74 1a                	je     819ba7 <netconn_recv+0x151>
  819b8d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b91:	48 8b 48 38          	mov    0x38(%rax),%rcx
  819b95:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  819b99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819b9d:	be 01 00 00 00       	mov    $0x1,%esi
  819ba2:	48 89 c7             	mov    %rax,%rdi
  819ba5:	ff d1                	callq  *%rcx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  819ba7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819bab:	48 85 c0             	test   %rax,%rax
  819bae:	75 36                	jne    819be6 <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  819bb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819bb4:	48 89 c6             	mov    %rax,%rsi
  819bb7:	bf 06 00 00 00       	mov    $0x6,%edi
  819bbc:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  819bc3:	00 00 00 
  819bc6:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  819bc8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819bcc:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819bd0:	84 c0                	test   %al,%al
  819bd2:	75 08                	jne    819bdc <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  819bd4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819bd8:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  819bdc:	b8 00 00 00 00       	mov    $0x0,%eax
  819be1:	e9 f5 00 00 00       	jmpq   819cdb <netconn_recv+0x285>
    }

    buf->p = p;
  819be6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819bea:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819bee:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  819bf1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819bf5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819bf9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  819bfd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c01:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  819c07:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c0b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  819c12:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  819c13:	48 b8 8b b8 81 00 00 	movabs $0x81b88b,%rax
  819c1a:	00 00 00 
  819c1d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  819c21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c25:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  819c29:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c2d:	48 85 c0             	test   %rax,%rax
  819c30:	74 11                	je     819c43 <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  819c32:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c36:	48 8b 00             	mov    (%rax),%rax
  819c39:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819c3d:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  819c41:	eb 06                	jmp    819c49 <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  819c43:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  819c49:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819c4d:	48 89 c7             	mov    %rax,%rdi
  819c50:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819c57:	00 00 00 
  819c5a:	ff d0                	callq  *%rax
  819c5c:	eb 79                	jmp    819cd7 <netconn_recv+0x281>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  819c5e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c62:	8b 40 18             	mov    0x18(%rax),%eax
  819c65:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  819c69:	ba 00 00 00 00       	mov    $0x0,%edx
  819c6e:	48 89 ce             	mov    %rcx,%rsi
  819c71:	89 c7                	mov    %eax,%edi
  819c73:	48 b8 90 7d 81 00 00 	movabs $0x817d90,%rax
  819c7a:	00 00 00 
  819c7d:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  819c7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c83:	48 85 c0             	test   %rax,%rax
  819c86:	74 4f                	je     819cd7 <netconn_recv+0x281>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  819c88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c8c:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  819c90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819c94:	48 8b 00             	mov    (%rax),%rax
  819c97:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819c9b:	66 29 c2             	sub    %ax,%dx
  819c9e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ca2:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  819ca6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819caa:	48 8b 40 38          	mov    0x38(%rax),%rax
  819cae:	48 85 c0             	test   %rax,%rax
  819cb1:	74 24                	je     819cd7 <netconn_recv+0x281>
  819cb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819cb7:	48 8b 48 38          	mov    0x38(%rax),%rcx
  819cbb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819cbf:	48 8b 00             	mov    (%rax),%rax
  819cc2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819cc6:	0f b7 d0             	movzwl %ax,%edx
  819cc9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ccd:	be 01 00 00 00       	mov    $0x1,%esi
  819cd2:	48 89 c7             	mov    %rax,%rdi
  819cd5:	ff d1                	callq  *%rcx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  819cd7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  819cdb:	c9                   	leaveq 
  819cdc:	c3                   	retq   

0000000000819cdd <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  819cdd:	55                   	push   %rbp
  819cde:	48 89 e5             	mov    %rsp,%rbp
  819ce1:	48 83 ec 20          	sub    $0x20,%rsp
  819ce5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  819ce9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  819ced:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  819cf1:	89 c8                	mov    %ecx,%eax
  819cf3:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  819cf7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819cfc:	74 34                	je     819d32 <netconn_sendto+0x55>
    buf->addr = addr;
  819cfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819d02:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819d06:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  819d0a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819d0e:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  819d12:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  819d16:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819d1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819d1e:	48 89 d6             	mov    %rdx,%rsi
  819d21:	48 89 c7             	mov    %rax,%rdi
  819d24:	48 b8 39 9d 81 00 00 	movabs $0x819d39,%rax
  819d2b:	00 00 00 
  819d2e:	ff d0                	callq  *%rax
  819d30:	eb 05                	jmp    819d37 <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  819d32:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  819d37:	c9                   	leaveq 
  819d38:	c3                   	retq   

0000000000819d39 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  819d39:	55                   	push   %rbp
  819d3a:	48 89 e5             	mov    %rsp,%rbp
  819d3d:	48 83 ec 40          	sub    $0x40,%rsp
  819d41:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819d45:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  819d49:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819d4e:	75 2a                	jne    819d7a <netconn_send+0x41>
  819d50:	48 ba 76 30 82 00 00 	movabs $0x823076,%rdx
  819d57:	00 00 00 
  819d5a:	be b9 01 00 00       	mov    $0x1b9,%esi
  819d5f:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819d66:	00 00 00 
  819d69:	b8 00 00 00 00       	mov    $0x0,%eax
  819d6e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819d75:	00 00 00 
  819d78:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  819d7a:	48 b8 fb b6 81 00 00 	movabs $0x81b6fb,%rax
  819d81:	00 00 00 
  819d84:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819d88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d8c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  819d90:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819d94:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  819d98:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819d9c:	48 89 c7             	mov    %rax,%rdi
  819d9f:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819da6:	00 00 00 
  819da9:	ff d0                	callq  *%rax
  return conn->err;
  819dab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819daf:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819db3:	c9                   	leaveq 
  819db4:	c3                   	retq   

0000000000819db5 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  819db5:	55                   	push   %rbp
  819db6:	48 89 e5             	mov    %rsp,%rbp
  819db9:	48 83 ec 50          	sub    $0x50,%rsp
  819dbd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819dc1:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819dc5:	89 55 bc             	mov    %edx,-0x44(%rbp)
  819dc8:	89 c8                	mov    %ecx,%eax
  819dca:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  819dcd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819dd2:	75 2a                	jne    819dfe <netconn_write+0x49>
  819dd4:	48 ba 91 30 82 00 00 	movabs $0x823091,%rdx
  819ddb:	00 00 00 
  819dde:	be d3 01 00 00       	mov    $0x1d3,%esi
  819de3:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819dea:	00 00 00 
  819ded:	b8 00 00 00 00       	mov    $0x0,%eax
  819df2:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819df9:	00 00 00 
  819dfc:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  819dfe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e02:	8b 00                	mov    (%rax),%eax
  819e04:	83 f8 10             	cmp    $0x10,%eax
  819e07:	74 2a                	je     819e33 <netconn_write+0x7e>
  819e09:	48 ba b0 30 82 00 00 	movabs $0x8230b0,%rdx
  819e10:	00 00 00 
  819e13:	be d4 01 00 00       	mov    $0x1d4,%esi
  819e18:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819e1f:	00 00 00 
  819e22:	b8 00 00 00 00       	mov    $0x0,%eax
  819e27:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819e2e:	00 00 00 
  819e31:	ff d1                	callq  *%rcx

  msg.function = do_write;
  819e33:	48 b8 b5 bb 81 00 00 	movabs $0x81bbb5,%rax
  819e3a:	00 00 00 
  819e3d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819e41:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e45:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  819e49:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819e4d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  819e51:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  819e55:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  819e58:	8b 45 bc             	mov    -0x44(%rbp),%eax
  819e5b:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  819e5e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819e62:	48 89 c7             	mov    %rax,%rdi
  819e65:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819e6c:	00 00 00 
  819e6f:	ff d0                	callq  *%rax
  return conn->err;
  819e71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e75:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819e79:	c9                   	leaveq 
  819e7a:	c3                   	retq   

0000000000819e7b <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  819e7b:	55                   	push   %rbp
  819e7c:	48 89 e5             	mov    %rsp,%rbp
  819e7f:	48 83 ec 40          	sub    $0x40,%rsp
  819e83:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  819e87:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819e8c:	75 2a                	jne    819eb8 <netconn_close+0x3d>
  819e8e:	48 ba d2 30 82 00 00 	movabs $0x8230d2,%rdx
  819e95:	00 00 00 
  819e98:	be ed 01 00 00       	mov    $0x1ed,%esi
  819e9d:	48 bf c1 2e 82 00 00 	movabs $0x822ec1,%rdi
  819ea4:	00 00 00 
  819ea7:	b8 00 00 00 00       	mov    $0x0,%eax
  819eac:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  819eb3:	00 00 00 
  819eb6:	ff d1                	callq  *%rcx

  msg.function = do_close;
  819eb8:	48 b8 db bd 81 00 00 	movabs $0x81bddb,%rax
  819ebf:	00 00 00 
  819ec2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819ec6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819eca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819ece:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819ed2:	48 89 c7             	mov    %rax,%rdi
  819ed5:	48 b8 d7 86 80 00 00 	movabs $0x8086d7,%rax
  819edc:	00 00 00 
  819edf:	ff d0                	callq  *%rax
  return conn->err;
  819ee1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ee5:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819ee9:	c9                   	leaveq 
  819eea:	c3                   	retq   
	...

0000000000819eec <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  819eec:	55                   	push   %rbp
  819eed:	48 89 e5             	mov    %rsp,%rbp
  819ef0:	48 83 ec 40          	sub    $0x40,%rsp
  819ef4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  819ef8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  819efc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  819f00:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  819f04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819f08:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  819f0c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819f11:	0f 84 74 01 00 00    	je     81a08b <recv_raw+0x19f>
  819f17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819f1b:	8b 40 18             	mov    0x18(%rax),%eax
  819f1e:	83 f8 ff             	cmp    $0xffffffff,%eax
  819f21:	0f 84 64 01 00 00    	je     81a08b <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  819f27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f2b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819f2f:	0f b7 c0             	movzwl %ax,%eax
  819f32:	ba 00 00 00 00       	mov    $0x0,%edx
  819f37:	89 c6                	mov    %eax,%esi
  819f39:	bf 03 00 00 00       	mov    $0x3,%edi
  819f3e:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  819f45:	00 00 00 
  819f48:	ff d0                	callq  *%rax
  819f4a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  819f4e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819f53:	74 39                	je     819f8e <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  819f55:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  819f59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f5d:	48 89 d6             	mov    %rdx,%rsi
  819f60:	48 89 c7             	mov    %rax,%rdi
  819f63:	48 b8 d4 db 80 00 00 	movabs $0x80dbd4,%rax
  819f6a:	00 00 00 
  819f6d:	ff d0                	callq  *%rax
  819f6f:	84 c0                	test   %al,%al
  819f71:	74 1b                	je     819f8e <recv_raw+0xa2>
        pbuf_free(q);
  819f73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819f77:	48 89 c7             	mov    %rax,%rdi
  819f7a:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  819f81:	00 00 00 
  819f84:	ff d0                	callq  *%rax
        q = NULL;
  819f86:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  819f8d:	00 
      }
    }

    if(q != NULL) {
  819f8e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819f93:	0f 84 f2 00 00 00    	je     81a08b <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  819f99:	bf 06 00 00 00       	mov    $0x6,%edi
  819f9e:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  819fa5:	00 00 00 
  819fa8:	ff d0                	callq  *%rax
  819faa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  819fae:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819fb3:	75 1d                	jne    819fd2 <recv_raw+0xe6>
        pbuf_free(q);
  819fb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819fb9:	48 89 c7             	mov    %rax,%rdi
  819fbc:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  819fc3:	00 00 00 
  819fc6:	ff d0                	callq  *%rax
        return 0;
  819fc8:	b8 00 00 00 00       	mov    $0x0,%eax
  819fcd:	e9 be 00 00 00       	jmpq   81a090 <recv_raw+0x1a4>
      }

      buf->p = q;
  819fd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819fd6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819fda:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  819fdd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819fe1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819fe5:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  819fe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819fed:	48 8b 40 08          	mov    0x8(%rax),%rax
  819ff1:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  819ff5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819ff9:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  819ffd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a001:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a005:	0f b6 d0             	movzbl %al,%edx
  81a008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a00c:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a010:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a014:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a018:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a01c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a020:	01 c2                	add    %eax,%edx
  81a022:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a026:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a02a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a02e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a032:	48 85 c0             	test   %rax,%rax
  81a035:	74 21                	je     81a058 <recv_raw+0x16c>
  81a037:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a03b:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a03f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a043:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a047:	0f b7 d0             	movzwl %ax,%edx
  81a04a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a04e:	be 00 00 00 00       	mov    $0x0,%esi
  81a053:	48 89 c7             	mov    %rax,%rdi
  81a056:	ff d1                	callq  *%rcx
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a058:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a05c:	8b 40 18             	mov    0x18(%rax),%eax
  81a05f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a063:	48 89 d6             	mov    %rdx,%rsi
  81a066:	89 c7                	mov    %eax,%edi
  81a068:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  81a06f:	00 00 00 
  81a072:	ff d0                	callq  *%rax
  81a074:	84 c0                	test   %al,%al
  81a076:	74 13                	je     81a08b <recv_raw+0x19f>
        netbuf_delete(buf);
  81a078:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a07c:	48 89 c7             	mov    %rax,%rdi
  81a07f:	48 b8 bc 88 80 00 00 	movabs $0x8088bc,%rax
  81a086:	00 00 00 
  81a089:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a08b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a090:	c9                   	leaveq 
  81a091:	c3                   	retq   

000000000081a092 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a092:	55                   	push   %rbp
  81a093:	48 89 e5             	mov    %rsp,%rbp
  81a096:	48 83 ec 40          	sub    $0x40,%rsp
  81a09a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a09e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a0a2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a0a6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a0aa:	44 89 c0             	mov    %r8d,%eax
  81a0ad:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a0b1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a0b6:	75 2a                	jne    81a0e2 <recv_udp+0x50>
  81a0b8:	48 ba f0 30 82 00 00 	movabs $0x8230f0,%rdx
  81a0bf:	00 00 00 
  81a0c2:	be 8e 00 00 00       	mov    $0x8e,%esi
  81a0c7:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a0ce:	00 00 00 
  81a0d1:	b8 00 00 00 00       	mov    $0x0,%eax
  81a0d6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a0dd:	00 00 00 
  81a0e0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a0e2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a0e7:	75 2a                	jne    81a113 <recv_udp+0x81>
  81a0e9:	48 ba 30 31 82 00 00 	movabs $0x823130,%rdx
  81a0f0:	00 00 00 
  81a0f3:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a0f8:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a0ff:	00 00 00 
  81a102:	b8 00 00 00 00       	mov    $0x0,%eax
  81a107:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a10e:	00 00 00 
  81a111:	ff d1                	callq  *%rcx
  conn = arg;
  81a113:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a117:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a11b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a11f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a123:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a127:	74 2a                	je     81a153 <recv_udp+0xc1>
  81a129:	48 ba 4f 31 82 00 00 	movabs $0x82314f,%rdx
  81a130:	00 00 00 
  81a133:	be 91 00 00 00       	mov    $0x91,%esi
  81a138:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a13f:	00 00 00 
  81a142:	b8 00 00 00 00       	mov    $0x0,%eax
  81a147:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a14e:	00 00 00 
  81a151:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a153:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a158:	74 0c                	je     81a166 <recv_udp+0xd4>
  81a15a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a15e:	8b 40 18             	mov    0x18(%rax),%eax
  81a161:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a164:	75 18                	jne    81a17e <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a166:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a16a:	48 89 c7             	mov    %rax,%rdi
  81a16d:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81a174:	00 00 00 
  81a177:	ff d0                	callq  *%rax
    return;
  81a179:	e9 df 00 00 00       	jmpq   81a25d <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a17e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a183:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  81a18a:	00 00 00 
  81a18d:	ff d0                	callq  *%rax
  81a18f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a193:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a198:	75 18                	jne    81a1b2 <recv_udp+0x120>
    pbuf_free(p);
  81a19a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a19e:	48 89 c7             	mov    %rax,%rdi
  81a1a1:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81a1a8:	00 00 00 
  81a1ab:	ff d0                	callq  *%rax
    return;
  81a1ad:	e9 ab 00 00 00       	jmpq   81a25d <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a1b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1b6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a1ba:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a1bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1c1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a1c5:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a1c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1cd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a1d1:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a1d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1d9:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a1dd:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a1e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1e5:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a1e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a1ed:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a1f1:	01 c2                	add    %eax,%edx
  81a1f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1f7:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a1fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1ff:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a203:	48 85 c0             	test   %rax,%rax
  81a206:	74 21                	je     81a229 <recv_udp+0x197>
  81a208:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a20c:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a210:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a214:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a218:	0f b7 d0             	movzwl %ax,%edx
  81a21b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a21f:	be 00 00 00 00       	mov    $0x0,%esi
  81a224:	48 89 c7             	mov    %rax,%rdi
  81a227:	ff d1                	callq  *%rcx
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a229:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a22d:	8b 40 18             	mov    0x18(%rax),%eax
  81a230:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a234:	48 89 d6             	mov    %rdx,%rsi
  81a237:	89 c7                	mov    %eax,%edi
  81a239:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  81a240:	00 00 00 
  81a243:	ff d0                	callq  *%rax
  81a245:	84 c0                	test   %al,%al
  81a247:	74 14                	je     81a25d <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a249:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a24d:	48 89 c7             	mov    %rax,%rdi
  81a250:	48 b8 bc 88 80 00 00 	movabs $0x8088bc,%rax
  81a257:	00 00 00 
  81a25a:	ff d0                	callq  *%rax
    return;
  81a25c:	90                   	nop
  }
}
  81a25d:	c9                   	leaveq 
  81a25e:	c3                   	retq   

000000000081a25f <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81a25f:	55                   	push   %rbp
  81a260:	48 89 e5             	mov    %rsp,%rbp
  81a263:	48 83 ec 30          	sub    $0x30,%rsp
  81a267:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a26b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a26f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a273:	89 c8                	mov    %ecx,%eax
  81a275:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81a278:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a27d:	75 2a                	jne    81a2a9 <recv_tcp+0x4a>
  81a27f:	48 ba 70 31 82 00 00 	movabs $0x823170,%rdx
  81a286:	00 00 00 
  81a289:	be c1 00 00 00       	mov    $0xc1,%esi
  81a28e:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a295:	00 00 00 
  81a298:	b8 00 00 00 00       	mov    $0x0,%eax
  81a29d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a2a4:	00 00 00 
  81a2a7:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81a2a9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a2ae:	75 2a                	jne    81a2da <recv_tcp+0x7b>
  81a2b0:	48 ba 98 31 82 00 00 	movabs $0x823198,%rdx
  81a2b7:	00 00 00 
  81a2ba:	be c2 00 00 00       	mov    $0xc2,%esi
  81a2bf:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a2c6:	00 00 00 
  81a2c9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2ce:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a2d5:	00 00 00 
  81a2d8:	ff d1                	callq  *%rcx
  conn = arg;
  81a2da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a2de:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81a2e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a2e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a2ea:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a2ee:	74 2a                	je     81a31a <recv_tcp+0xbb>
  81a2f0:	48 ba b7 31 82 00 00 	movabs $0x8231b7,%rdx
  81a2f7:	00 00 00 
  81a2fa:	be c4 00 00 00       	mov    $0xc4,%esi
  81a2ff:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a306:	00 00 00 
  81a309:	b8 00 00 00 00       	mov    $0x0,%eax
  81a30e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a315:	00 00 00 
  81a318:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a31a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a31f:	74 0c                	je     81a32d <recv_tcp+0xce>
  81a321:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a325:	8b 40 18             	mov    0x18(%rax),%eax
  81a328:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a32b:	75 0a                	jne    81a337 <recv_tcp+0xd8>
    return ERR_VAL;
  81a32d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81a332:	e9 8f 00 00 00       	jmpq   81a3c6 <recv_tcp+0x167>
  }

  conn->err = err;
  81a337:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a33b:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81a33f:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81a342:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81a347:	74 24                	je     81a36d <recv_tcp+0x10e>
    len = p->tot_len;
  81a349:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a34d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a351:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81a355:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a359:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81a35d:	89 c2                	mov    %eax,%edx
  81a35f:	66 03 55 fe          	add    -0x2(%rbp),%dx
  81a363:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a367:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a36b:	eb 06                	jmp    81a373 <recv_tcp+0x114>
  } else {
    len = 0;
  81a36d:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81a373:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a377:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a37b:	48 85 c0             	test   %rax,%rax
  81a37e:	74 1a                	je     81a39a <recv_tcp+0x13b>
  81a380:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a384:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a388:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a38c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a390:	be 00 00 00 00       	mov    $0x0,%esi
  81a395:	48 89 c7             	mov    %rax,%rdi
  81a398:	ff d1                	callq  *%rcx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81a39a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a39e:	8b 40 18             	mov    0x18(%rax),%eax
  81a3a1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a3a5:	48 89 d6             	mov    %rdx,%rsi
  81a3a8:	89 c7                	mov    %eax,%edi
  81a3aa:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  81a3b1:	00 00 00 
  81a3b4:	ff d0                	callq  *%rax
  81a3b6:	84 c0                	test   %al,%al
  81a3b8:	74 07                	je     81a3c1 <recv_tcp+0x162>
    return ERR_MEM;
  81a3ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a3bf:	eb 05                	jmp    81a3c6 <recv_tcp+0x167>
  }

  return ERR_OK;
  81a3c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a3c6:	c9                   	leaveq 
  81a3c7:	c3                   	retq   

000000000081a3c8 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81a3c8:	55                   	push   %rbp
  81a3c9:	48 89 e5             	mov    %rsp,%rbp
  81a3cc:	48 83 ec 20          	sub    $0x20,%rsp
  81a3d0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a3d4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81a3d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a3dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a3e0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a3e5:	75 2a                	jne    81a411 <poll_tcp+0x49>
  81a3e7:	48 ba d5 31 82 00 00 	movabs $0x8231d5,%rdx
  81a3ee:	00 00 00 
  81a3f1:	be eb 00 00 00       	mov    $0xeb,%esi
  81a3f6:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a3fd:	00 00 00 
  81a400:	b8 00 00 00 00       	mov    $0x0,%eax
  81a405:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a40c:	00 00 00 
  81a40f:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a411:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a415:	8b 40 04             	mov    0x4(%rax),%eax
  81a418:	83 f8 01             	cmp    $0x1,%eax
  81a41b:	75 15                	jne    81a432 <poll_tcp+0x6a>
    do_writemore(conn);
  81a41d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a421:	48 89 c7             	mov    %rax,%rdi
  81a424:	48 b8 05 b9 81 00 00 	movabs $0x81b905,%rax
  81a42b:	00 00 00 
  81a42e:	ff d0                	callq  *%rax
  81a430:	eb 1f                	jmp    81a451 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81a432:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a436:	8b 40 04             	mov    0x4(%rax),%eax
  81a439:	83 f8 04             	cmp    $0x4,%eax
  81a43c:	75 13                	jne    81a451 <poll_tcp+0x89>
    do_close_internal(conn);
  81a43e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a442:	48 89 c7             	mov    %rax,%rdi
  81a445:	48 b8 76 ad 81 00 00 	movabs $0x81ad76,%rax
  81a44c:	00 00 00 
  81a44f:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81a451:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a456:	c9                   	leaveq 
  81a457:	c3                   	retq   

000000000081a458 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81a458:	55                   	push   %rbp
  81a459:	48 89 e5             	mov    %rsp,%rbp
  81a45c:	48 83 ec 30          	sub    $0x30,%rsp
  81a460:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a464:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a468:	89 d0                	mov    %edx,%eax
  81a46a:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81a46e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a472:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a476:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a47b:	75 2a                	jne    81a4a7 <sent_tcp+0x4f>
  81a47d:	48 ba d5 31 82 00 00 	movabs $0x8231d5,%rdx
  81a484:	00 00 00 
  81a487:	be 03 01 00 00       	mov    $0x103,%esi
  81a48c:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a493:	00 00 00 
  81a496:	b8 00 00 00 00       	mov    $0x0,%eax
  81a49b:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a4a2:	00 00 00 
  81a4a5:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a4a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4ab:	8b 40 04             	mov    0x4(%rax),%eax
  81a4ae:	83 f8 01             	cmp    $0x1,%eax
  81a4b1:	75 4c                	jne    81a4ff <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81a4b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a4bb:	48 85 c0             	test   %rax,%rax
  81a4be:	75 2a                	jne    81a4ea <sent_tcp+0x92>
  81a4c0:	48 ba e2 31 82 00 00 	movabs $0x8231e2,%rdx
  81a4c7:	00 00 00 
  81a4ca:	be 06 01 00 00       	mov    $0x106,%esi
  81a4cf:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a4d6:	00 00 00 
  81a4d9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a4de:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a4e5:	00 00 00 
  81a4e8:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81a4ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a4ee:	48 89 c7             	mov    %rax,%rdi
  81a4f1:	48 b8 05 b9 81 00 00 	movabs $0x81b905,%rax
  81a4f8:	00 00 00 
  81a4fb:	ff d0                	callq  *%rax
  81a4fd:	eb 1f                	jmp    81a51e <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81a4ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a503:	8b 40 04             	mov    0x4(%rax),%eax
  81a506:	83 f8 04             	cmp    $0x4,%eax
  81a509:	75 13                	jne    81a51e <sent_tcp+0xc6>
    do_close_internal(conn);
  81a50b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a50f:	48 89 c7             	mov    %rax,%rdi
  81a512:	48 b8 76 ad 81 00 00 	movabs $0x81ad76,%rax
  81a519:	00 00 00 
  81a51c:	ff d0                	callq  *%rax
  }

  if (conn) {
  81a51e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a523:	74 46                	je     81a56b <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81a525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a529:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a52d:	48 85 c0             	test   %rax,%rax
  81a530:	74 39                	je     81a56b <sent_tcp+0x113>
  81a532:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a536:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a53a:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81a53e:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81a542:	76 27                	jbe    81a56b <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81a544:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a548:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a54c:	48 85 c0             	test   %rax,%rax
  81a54f:	74 1a                	je     81a56b <sent_tcp+0x113>
  81a551:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a555:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a559:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81a55d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a561:	be 02 00 00 00       	mov    $0x2,%esi
  81a566:	48 89 c7             	mov    %rax,%rdi
  81a569:	ff d1                	callq  *%rcx
    }
  }
  
  return ERR_OK;
  81a56b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a570:	c9                   	leaveq 
  81a571:	c3                   	retq   

000000000081a572 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81a572:	55                   	push   %rbp
  81a573:	48 89 e5             	mov    %rsp,%rbp
  81a576:	48 83 ec 20          	sub    $0x20,%rsp
  81a57a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a57e:	89 f0                	mov    %esi,%eax
  81a580:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81a583:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a587:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a58b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a590:	75 2a                	jne    81a5bc <err_tcp+0x4a>
  81a592:	48 ba d5 31 82 00 00 	movabs $0x8231d5,%rdx
  81a599:	00 00 00 
  81a59c:	be 22 01 00 00       	mov    $0x122,%esi
  81a5a1:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a5a8:	00 00 00 
  81a5ab:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5b0:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a5b7:	00 00 00 
  81a5ba:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81a5bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5c0:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a5c7:	00 

  conn->err = err;
  81a5c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5cc:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81a5d0:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81a5d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5d7:	8b 40 18             	mov    0x18(%rax),%eax
  81a5da:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a5dd:	74 42                	je     81a621 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a5df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5e3:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a5e7:	48 85 c0             	test   %rax,%rax
  81a5ea:	74 1b                	je     81a607 <err_tcp+0x95>
  81a5ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5f0:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a5f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5f8:	ba 00 00 00 00       	mov    $0x0,%edx
  81a5fd:	be 00 00 00 00       	mov    $0x0,%esi
  81a602:	48 89 c7             	mov    %rax,%rdi
  81a605:	ff d1                	callq  *%rcx
    sys_mbox_post(conn->recvmbox, NULL);
  81a607:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a60b:	8b 40 18             	mov    0x18(%rax),%eax
  81a60e:	be 00 00 00 00       	mov    $0x0,%esi
  81a613:	89 c7                	mov    %eax,%edi
  81a615:	48 b8 38 75 81 00 00 	movabs $0x817538,%rax
  81a61c:	00 00 00 
  81a61f:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81a621:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a625:	8b 40 14             	mov    0x14(%rax),%eax
  81a628:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a62b:	74 2c                	je     81a659 <err_tcp+0xe7>
  81a62d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a631:	8b 40 04             	mov    0x4(%rax),%eax
  81a634:	83 f8 03             	cmp    $0x3,%eax
  81a637:	75 20                	jne    81a659 <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81a639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a63d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81a644:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a648:	8b 40 14             	mov    0x14(%rax),%eax
  81a64b:	89 c7                	mov    %eax,%edi
  81a64d:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81a654:	00 00 00 
  81a657:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81a659:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a65d:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a660:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a663:	74 42                	je     81a6a7 <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a665:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a669:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a66d:	48 85 c0             	test   %rax,%rax
  81a670:	74 1b                	je     81a68d <err_tcp+0x11b>
  81a672:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a676:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a67a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a67e:	ba 00 00 00 00       	mov    $0x0,%edx
  81a683:	be 00 00 00 00       	mov    $0x0,%esi
  81a688:	48 89 c7             	mov    %rax,%rdi
  81a68b:	ff d1                	callq  *%rcx
    sys_mbox_post(conn->acceptmbox, NULL);
  81a68d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a691:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a694:	be 00 00 00 00       	mov    $0x0,%esi
  81a699:	89 c7                	mov    %eax,%edi
  81a69b:	48 b8 38 75 81 00 00 	movabs $0x817538,%rax
  81a6a2:	00 00 00 
  81a6a5:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81a6a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ab:	8b 40 04             	mov    0x4(%rax),%eax
  81a6ae:	83 f8 01             	cmp    $0x1,%eax
  81a6b1:	74 0c                	je     81a6bf <err_tcp+0x14d>
  81a6b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6b7:	8b 40 04             	mov    0x4(%rax),%eax
  81a6ba:	83 f8 04             	cmp    $0x4,%eax
  81a6bd:	75 20                	jne    81a6df <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81a6bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6c3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81a6ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ce:	8b 40 14             	mov    0x14(%rax),%eax
  81a6d1:	89 c7                	mov    %eax,%edi
  81a6d3:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81a6da:	00 00 00 
  81a6dd:	ff d0                	callq  *%rax
  }
}
  81a6df:	c9                   	leaveq 
  81a6e0:	c3                   	retq   

000000000081a6e1 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81a6e1:	55                   	push   %rbp
  81a6e2:	48 89 e5             	mov    %rsp,%rbp
  81a6e5:	48 83 ec 20          	sub    $0x20,%rsp
  81a6e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81a6ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a6f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a6f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81a6f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a6fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a701:	48 89 d6             	mov    %rdx,%rsi
  81a704:	48 89 c7             	mov    %rax,%rdi
  81a707:	48 b8 36 03 81 00 00 	movabs $0x810336,%rax
  81a70e:	00 00 00 
  81a711:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81a713:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a717:	48 be 5f a2 81 00 00 	movabs $0x81a25f,%rsi
  81a71e:	00 00 00 
  81a721:	48 89 c7             	mov    %rax,%rdi
  81a724:	48 b8 54 03 81 00 00 	movabs $0x810354,%rax
  81a72b:	00 00 00 
  81a72e:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81a730:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a734:	48 be 58 a4 81 00 00 	movabs $0x81a458,%rsi
  81a73b:	00 00 00 
  81a73e:	48 89 c7             	mov    %rax,%rdi
  81a741:	48 b8 75 03 81 00 00 	movabs $0x810375,%rax
  81a748:	00 00 00 
  81a74b:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81a74d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a751:	ba 04 00 00 00       	mov    $0x4,%edx
  81a756:	48 be c8 a3 81 00 00 	movabs $0x81a3c8,%rsi
  81a75d:	00 00 00 
  81a760:	48 89 c7             	mov    %rax,%rdi
  81a763:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81a76a:	00 00 00 
  81a76d:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81a76f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a773:	48 be 72 a5 81 00 00 	movabs $0x81a572,%rsi
  81a77a:	00 00 00 
  81a77d:	48 89 c7             	mov    %rax,%rdi
  81a780:	48 b8 96 03 81 00 00 	movabs $0x810396,%rax
  81a787:	00 00 00 
  81a78a:	ff d0                	callq  *%rax
}
  81a78c:	c9                   	leaveq 
  81a78d:	c3                   	retq   

000000000081a78e <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81a78e:	55                   	push   %rbp
  81a78f:	48 89 e5             	mov    %rsp,%rbp
  81a792:	48 83 ec 30          	sub    $0x30,%rsp
  81a796:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a79a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a79e:	89 d0                	mov    %edx,%eax
  81a7a0:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81a7a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a7a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81a7ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7af:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a7b2:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a7b5:	75 2a                	jne    81a7e1 <accept_function+0x53>
  81a7b7:	48 ba f8 31 82 00 00 	movabs $0x8231f8,%rdx
  81a7be:	00 00 00 
  81a7c1:	be 65 01 00 00       	mov    $0x165,%esi
  81a7c6:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a7cd:	00 00 00 
  81a7d0:	b8 00 00 00 00       	mov    $0x0,%eax
  81a7d5:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a7dc:	00 00 00 
  81a7df:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81a7e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7e5:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81a7e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7ed:	8b 00                	mov    (%rax),%eax
  81a7ef:	48 89 d6             	mov    %rdx,%rsi
  81a7f2:	89 c7                	mov    %eax,%edi
  81a7f4:	48 b8 d8 aa 81 00 00 	movabs $0x81aad8,%rax
  81a7fb:	00 00 00 
  81a7fe:	ff d0                	callq  *%rax
  81a800:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81a804:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a809:	75 0a                	jne    81a815 <accept_function+0x87>
    return ERR_MEM;
  81a80b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a810:	e9 9d 00 00 00       	jmpq   81a8b2 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81a815:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a819:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81a81d:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81a821:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a825:	48 89 c7             	mov    %rax,%rdi
  81a828:	48 b8 e1 a6 81 00 00 	movabs $0x81a6e1,%rax
  81a82f:	00 00 00 
  81a832:	ff d0                	callq  *%rax
  newconn->err = err;
  81a834:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a838:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81a83c:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a83f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a843:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a847:	48 85 c0             	test   %rax,%rax
  81a84a:	74 1b                	je     81a867 <accept_function+0xd9>
  81a84c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a850:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a854:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a858:	ba 00 00 00 00       	mov    $0x0,%edx
  81a85d:	be 00 00 00 00       	mov    $0x0,%esi
  81a862:	48 89 c7             	mov    %rax,%rdi
  81a865:	ff d1                	callq  *%rcx

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81a867:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a86b:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a86e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a872:	48 89 d6             	mov    %rdx,%rsi
  81a875:	89 c7                	mov    %eax,%edi
  81a877:	48 b8 9a 75 81 00 00 	movabs $0x81759a,%rax
  81a87e:	00 00 00 
  81a881:	ff d0                	callq  *%rax
  81a883:	84 c0                	test   %al,%al
  81a885:	74 26                	je     81a8ad <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81a887:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a88b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a892:	00 
    netconn_free(newconn);
  81a893:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a897:	48 89 c7             	mov    %rax,%rdi
  81a89a:	48 b8 0c ac 81 00 00 	movabs $0x81ac0c,%rax
  81a8a1:	00 00 00 
  81a8a4:	ff d0                	callq  *%rax
    return ERR_MEM;
  81a8a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a8ab:	eb 05                	jmp    81a8b2 <accept_function+0x124>
  }
  return ERR_OK;
  81a8ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a8b2:	c9                   	leaveq 
  81a8b3:	c3                   	retq   

000000000081a8b4 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81a8b4:	55                   	push   %rbp
  81a8b5:	48 89 e5             	mov    %rsp,%rbp
  81a8b8:	53                   	push   %rbx
  81a8b9:	48 83 ec 18          	sub    $0x18,%rsp
  81a8bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81a8c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8c5:	48 8b 00             	mov    (%rax),%rax
  81a8c8:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81a8cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8d0:	48 8b 00             	mov    (%rax),%rax
  81a8d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8d7:	48 85 c0             	test   %rax,%rax
  81a8da:	74 2a                	je     81a906 <pcb_new+0x52>
  81a8dc:	48 ba 28 32 82 00 00 	movabs $0x823228,%rdx
  81a8e3:	00 00 00 
  81a8e6:	be 8a 01 00 00       	mov    $0x18a,%esi
  81a8eb:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81a8f2:	00 00 00 
  81a8f5:	b8 00 00 00 00       	mov    $0x0,%eax
  81a8fa:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81a901:	00 00 00 
  81a904:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81a906:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a90a:	48 8b 00             	mov    (%rax),%rax
  81a90d:	8b 00                	mov    (%rax),%eax
  81a90f:	25 f0 00 00 00       	and    $0xf0,%eax
  81a914:	83 f8 20             	cmp    $0x20,%eax
  81a917:	0f 84 87 00 00 00    	je     81a9a4 <pcb_new+0xf0>
  81a91d:	83 f8 40             	cmp    $0x40,%eax
  81a920:	74 0e                	je     81a930 <pcb_new+0x7c>
  81a922:	83 f8 10             	cmp    $0x10,%eax
  81a925:	0f 84 fa 00 00 00    	je     81aa25 <pcb_new+0x171>
  81a92b:	e9 41 01 00 00       	jmpq   81aa71 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81a930:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a934:	48 8b 18             	mov    (%rax),%rbx
  81a937:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a93b:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81a93f:	0f b6 c0             	movzbl %al,%eax
  81a942:	89 c7                	mov    %eax,%edi
  81a944:	48 b8 30 fc 81 00 00 	movabs $0x81fc30,%rax
  81a94b:	00 00 00 
  81a94e:	ff d0                	callq  *%rax
  81a950:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81a954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a958:	48 8b 00             	mov    (%rax),%rax
  81a95b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a95f:	48 85 c0             	test   %rax,%rax
  81a962:	75 10                	jne    81a974 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81a964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a968:	48 8b 00             	mov    (%rax),%rax
  81a96b:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81a96f:	e9 09 01 00 00       	jmpq   81aa7d <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81a974:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a978:	48 8b 10             	mov    (%rax),%rdx
  81a97b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a97f:	48 8b 00             	mov    (%rax),%rax
  81a982:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a986:	48 be ec 9e 81 00 00 	movabs $0x819eec,%rsi
  81a98d:	00 00 00 
  81a990:	48 89 c7             	mov    %rax,%rdi
  81a993:	48 b8 80 f9 81 00 00 	movabs $0x81f980,%rax
  81a99a:	00 00 00 
  81a99d:	ff d0                	callq  *%rax
     break;
  81a99f:	e9 d9 00 00 00       	jmpq   81aa7d <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81a9a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9a8:	48 8b 18             	mov    (%rax),%rbx
  81a9ab:	48 b8 09 54 81 00 00 	movabs $0x815409,%rax
  81a9b2:	00 00 00 
  81a9b5:	ff d0                	callq  *%rax
  81a9b7:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81a9bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9bf:	48 8b 00             	mov    (%rax),%rax
  81a9c2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a9c6:	48 85 c0             	test   %rax,%rax
  81a9c9:	75 10                	jne    81a9db <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81a9cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9cf:	48 8b 00             	mov    (%rax),%rax
  81a9d2:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81a9d6:	e9 a2 00 00 00       	jmpq   81aa7d <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81a9db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9df:	48 8b 00             	mov    (%rax),%rax
  81a9e2:	8b 00                	mov    (%rax),%eax
  81a9e4:	83 f8 22             	cmp    $0x22,%eax
  81a9e7:	75 0f                	jne    81a9f8 <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81a9e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9ed:	48 8b 00             	mov    (%rax),%rax
  81a9f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a9f4:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81a9f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a9fc:	48 8b 10             	mov    (%rax),%rdx
  81a9ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa03:	48 8b 00             	mov    (%rax),%rax
  81aa06:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa0a:	48 be 92 a0 81 00 00 	movabs $0x81a092,%rsi
  81aa11:	00 00 00 
  81aa14:	48 89 c7             	mov    %rax,%rdi
  81aa17:	48 b8 31 53 81 00 00 	movabs $0x815331,%rax
  81aa1e:	00 00 00 
  81aa21:	ff d0                	callq  *%rax
     break;
  81aa23:	eb 58                	jmp    81aa7d <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81aa25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa29:	48 8b 18             	mov    (%rax),%rbx
  81aa2c:	48 b8 1f 03 81 00 00 	movabs $0x81031f,%rax
  81aa33:	00 00 00 
  81aa36:	ff d0                	callq  *%rax
  81aa38:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81aa3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa40:	48 8b 00             	mov    (%rax),%rax
  81aa43:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aa47:	48 85 c0             	test   %rax,%rax
  81aa4a:	75 0d                	jne    81aa59 <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81aa4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa50:	48 8b 00             	mov    (%rax),%rax
  81aa53:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81aa57:	eb 24                	jmp    81aa7d <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81aa59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa5d:	48 8b 00             	mov    (%rax),%rax
  81aa60:	48 89 c7             	mov    %rax,%rdi
  81aa63:	48 b8 e1 a6 81 00 00 	movabs $0x81a6e1,%rax
  81aa6a:	00 00 00 
  81aa6d:	ff d0                	callq  *%rax
     break;
  81aa6f:	eb 0c                	jmp    81aa7d <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81aa71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa75:	48 8b 00             	mov    (%rax),%rax
  81aa78:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81aa7c:	90                   	nop
   }

  return msg->conn->err;
  81aa7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aa81:	48 8b 00             	mov    (%rax),%rax
  81aa84:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81aa88:	48 83 c4 18          	add    $0x18,%rsp
  81aa8c:	5b                   	pop    %rbx
  81aa8d:	5d                   	pop    %rbp
  81aa8e:	c3                   	retq   

000000000081aa8f <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81aa8f:	55                   	push   %rbp
  81aa90:	48 89 e5             	mov    %rsp,%rbp
  81aa93:	48 83 ec 10          	sub    $0x10,%rsp
  81aa97:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81aa9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa9f:	48 8b 00             	mov    (%rax),%rax
  81aaa2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aaa6:	48 85 c0             	test   %rax,%rax
  81aaa9:	75 13                	jne    81aabe <do_newconn+0x2f>
     pcb_new(msg);
  81aaab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aaaf:	48 89 c7             	mov    %rax,%rdi
  81aab2:	48 b8 b4 a8 81 00 00 	movabs $0x81a8b4,%rax
  81aab9:	00 00 00 
  81aabc:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81aabe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aac2:	48 8b 00             	mov    (%rax),%rax
  81aac5:	8b 40 14             	mov    0x14(%rax),%eax
  81aac8:	89 c7                	mov    %eax,%edi
  81aaca:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81aad1:	00 00 00 
  81aad4:	ff d0                	callq  *%rax
}
  81aad6:	c9                   	leaveq 
  81aad7:	c3                   	retq   

000000000081aad8 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81aad8:	55                   	push   %rbp
  81aad9:	48 89 e5             	mov    %rsp,%rbp
  81aadc:	48 83 ec 20          	sub    $0x20,%rsp
  81aae0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81aae3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81aae7:	bf 07 00 00 00       	mov    $0x7,%edi
  81aaec:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  81aaf3:	00 00 00 
  81aaf6:	ff d0                	callq  *%rax
  81aaf8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81aafc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ab01:	75 0a                	jne    81ab0d <netconn_alloc+0x35>
    return NULL;
  81ab03:	b8 00 00 00 00       	mov    $0x0,%eax
  81ab08:	e9 fd 00 00 00       	jmpq   81ac0a <netconn_alloc+0x132>
  }

  conn->err = ERR_OK;
  81ab0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab11:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81ab15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab19:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81ab1c:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81ab1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab22:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ab29:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81ab2a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81ab31:	bf 00 00 00 00       	mov    $0x0,%edi
  81ab36:	48 b8 02 78 81 00 00 	movabs $0x817802,%rax
  81ab3d:	00 00 00 
  81ab40:	ff d0                	callq  *%rax
  81ab42:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ab46:	89 42 14             	mov    %eax,0x14(%rdx)
  81ab49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab4d:	8b 40 14             	mov    0x14(%rax),%eax
  81ab50:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ab53:	75 22                	jne    81ab77 <netconn_alloc+0x9f>
    memp_free(MEMP_NETCONN, conn);
  81ab55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab59:	48 89 c6             	mov    %rax,%rsi
  81ab5c:	bf 07 00 00 00       	mov    $0x7,%edi
  81ab61:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81ab68:	00 00 00 
  81ab6b:	ff d0                	callq  *%rax
    return NULL;
  81ab6d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ab72:	e9 93 00 00 00       	jmpq   81ac0a <netconn_alloc+0x132>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81ab77:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81ab7a:	89 c7                	mov    %eax,%edi
  81ab7c:	48 b8 36 71 81 00 00 	movabs $0x817136,%rax
  81ab83:	00 00 00 
  81ab86:	ff d0                	callq  *%rax
  81ab88:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ab8c:	89 42 18             	mov    %eax,0x18(%rdx)
  81ab8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab93:	8b 40 18             	mov    0x18(%rax),%eax
  81ab96:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ab99:	75 34                	jne    81abcf <netconn_alloc+0xf7>
    sys_sem_free(conn->op_completed);
  81ab9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ab9f:	8b 40 14             	mov    0x14(%rax),%eax
  81aba2:	89 c7                	mov    %eax,%edi
  81aba4:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  81abab:	00 00 00 
  81abae:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81abb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abb4:	48 89 c6             	mov    %rax,%rsi
  81abb7:	bf 07 00 00 00       	mov    $0x7,%edi
  81abbc:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81abc3:	00 00 00 
  81abc6:	ff d0                	callq  *%rax
    return NULL;
  81abc8:	b8 00 00 00 00       	mov    $0x0,%eax
  81abcd:	eb 3b                	jmp    81ac0a <netconn_alloc+0x132>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81abcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abd3:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81abda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abde:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81abe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abe9:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81abf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81abf4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81abf8:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81abfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac00:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81ac06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81ac0a:	c9                   	leaveq 
  81ac0b:	c3                   	retq   

000000000081ac0c <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81ac0c:	55                   	push   %rbp
  81ac0d:	48 89 e5             	mov    %rsp,%rbp
  81ac10:	48 83 ec 20          	sub    $0x20,%rsp
  81ac14:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81ac18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac1c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac20:	48 85 c0             	test   %rax,%rax
  81ac23:	74 2a                	je     81ac4f <netconn_free+0x43>
  81ac25:	48 ba 48 32 82 00 00 	movabs $0x823248,%rdx
  81ac2c:	00 00 00 
  81ac2f:	be 26 02 00 00       	mov    $0x226,%esi
  81ac34:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81ac3b:	00 00 00 
  81ac3e:	b8 00 00 00 00       	mov    $0x0,%eax
  81ac43:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ac4a:	00 00 00 
  81ac4d:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81ac4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac53:	8b 40 18             	mov    0x18(%rax),%eax
  81ac56:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ac59:	74 7f                	je     81acda <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81ac5b:	eb 3c                	jmp    81ac99 <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81ac5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac61:	8b 00                	mov    (%rax),%eax
  81ac63:	83 f8 10             	cmp    $0x10,%eax
  81ac66:	75 1e                	jne    81ac86 <netconn_free+0x7a>
        if(mem != NULL) {
  81ac68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac6c:	48 85 c0             	test   %rax,%rax
  81ac6f:	74 28                	je     81ac99 <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81ac71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac75:	48 89 c7             	mov    %rax,%rdi
  81ac78:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81ac7f:	00 00 00 
  81ac82:	ff d0                	callq  *%rax
  81ac84:	eb 13                	jmp    81ac99 <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81ac86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac8a:	48 89 c7             	mov    %rax,%rdi
  81ac8d:	48 b8 bc 88 80 00 00 	movabs $0x8088bc,%rax
  81ac94:	00 00 00 
  81ac97:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81ac99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac9d:	8b 40 18             	mov    0x18(%rax),%eax
  81aca0:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81aca4:	48 89 d6             	mov    %rdx,%rsi
  81aca7:	89 c7                	mov    %eax,%edi
  81aca9:	48 b8 0a 80 81 00 00 	movabs $0x81800a,%rax
  81acb0:	00 00 00 
  81acb3:	ff d0                	callq  *%rax
  81acb5:	83 f8 ff             	cmp    $0xffffffff,%eax
  81acb8:	75 a3                	jne    81ac5d <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81acba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acbe:	8b 40 18             	mov    0x18(%rax),%eax
  81acc1:	89 c7                	mov    %eax,%edi
  81acc3:	48 b8 19 73 81 00 00 	movabs $0x817319,%rax
  81acca:	00 00 00 
  81accd:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81accf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acd3:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81acda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acde:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ace1:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ace4:	74 56                	je     81ad3c <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81ace6:	eb 13                	jmp    81acfb <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81ace8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acec:	48 89 c7             	mov    %rax,%rdi
  81acef:	48 b8 f7 95 81 00 00 	movabs $0x8195f7,%rax
  81acf6:	00 00 00 
  81acf9:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81acfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81acff:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ad02:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81ad06:	48 89 d6             	mov    %rdx,%rsi
  81ad09:	89 c7                	mov    %eax,%edi
  81ad0b:	48 b8 0a 80 81 00 00 	movabs $0x81800a,%rax
  81ad12:	00 00 00 
  81ad15:	ff d0                	callq  *%rax
  81ad17:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad1a:	75 cc                	jne    81ace8 <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81ad1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad20:	8b 40 1c             	mov    0x1c(%rax),%eax
  81ad23:	89 c7                	mov    %eax,%edi
  81ad25:	48 b8 19 73 81 00 00 	movabs $0x817319,%rax
  81ad2c:	00 00 00 
  81ad2f:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81ad31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad35:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81ad3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad40:	8b 40 14             	mov    0x14(%rax),%eax
  81ad43:	89 c7                	mov    %eax,%edi
  81ad45:	48 b8 03 79 81 00 00 	movabs $0x817903,%rax
  81ad4c:	00 00 00 
  81ad4f:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81ad51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad55:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81ad5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ad60:	48 89 c6             	mov    %rax,%rsi
  81ad63:	bf 07 00 00 00       	mov    $0x7,%edi
  81ad68:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81ad6f:	00 00 00 
  81ad72:	ff d0                	callq  *%rax
}
  81ad74:	c9                   	leaveq 
  81ad75:	c3                   	retq   

000000000081ad76 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81ad76:	55                   	push   %rbp
  81ad77:	48 89 e5             	mov    %rsp,%rbp
  81ad7a:	48 83 ec 20          	sub    $0x20,%rsp
  81ad7e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81ad82:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81ad87:	75 2a                	jne    81adb3 <do_close_internal+0x3d>
  81ad89:	48 ba 76 32 82 00 00 	movabs $0x823276,%rdx
  81ad90:	00 00 00 
  81ad93:	be 53 02 00 00       	mov    $0x253,%esi
  81ad98:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81ad9f:	00 00 00 
  81ada2:	b8 00 00 00 00       	mov    $0x0,%eax
  81ada7:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81adae:	00 00 00 
  81adb1:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81adb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81adb7:	8b 00                	mov    (%rax),%eax
  81adb9:	83 f8 10             	cmp    $0x10,%eax
  81adbc:	74 2a                	je     81ade8 <do_close_internal+0x72>
  81adbe:	48 ba 83 32 82 00 00 	movabs $0x823283,%rdx
  81adc5:	00 00 00 
  81adc8:	be 54 02 00 00       	mov    $0x254,%esi
  81adcd:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81add4:	00 00 00 
  81add7:	b8 00 00 00 00       	mov    $0x0,%eax
  81addc:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ade3:	00 00 00 
  81ade6:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81ade8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81adec:	8b 40 04             	mov    0x4(%rax),%eax
  81adef:	83 f8 04             	cmp    $0x4,%eax
  81adf2:	74 2a                	je     81ae1e <do_close_internal+0xa8>
  81adf4:	48 ba a8 32 82 00 00 	movabs $0x8232a8,%rdx
  81adfb:	00 00 00 
  81adfe:	be 55 02 00 00       	mov    $0x255,%esi
  81ae03:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81ae0a:	00 00 00 
  81ae0d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ae12:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ae19:	00 00 00 
  81ae1c:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81ae1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae22:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae26:	48 85 c0             	test   %rax,%rax
  81ae29:	75 2a                	jne    81ae55 <do_close_internal+0xdf>
  81ae2b:	48 ba cc 32 82 00 00 	movabs $0x8232cc,%rdx
  81ae32:	00 00 00 
  81ae35:	be 56 02 00 00       	mov    $0x256,%esi
  81ae3a:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81ae41:	00 00 00 
  81ae44:	b8 00 00 00 00       	mov    $0x0,%eax
  81ae49:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ae50:	00 00 00 
  81ae53:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81ae55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae59:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae5d:	be 00 00 00 00       	mov    $0x0,%esi
  81ae62:	48 89 c7             	mov    %rax,%rdi
  81ae65:	48 b8 36 03 81 00 00 	movabs $0x810336,%rax
  81ae6c:	00 00 00 
  81ae6f:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81ae71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae75:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae79:	8b 40 18             	mov    0x18(%rax),%eax
  81ae7c:	83 f8 01             	cmp    $0x1,%eax
  81ae7f:	75 21                	jne    81aea2 <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81ae81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae85:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae89:	be 00 00 00 00       	mov    $0x0,%esi
  81ae8e:	48 89 c7             	mov    %rax,%rdi
  81ae91:	48 b8 b7 03 81 00 00 	movabs $0x8103b7,%rax
  81ae98:	00 00 00 
  81ae9b:	ff d0                	callq  *%rax
  81ae9d:	e9 91 00 00 00       	jmpq   81af33 <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81aea2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aea6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aeaa:	be 00 00 00 00       	mov    $0x0,%esi
  81aeaf:	48 89 c7             	mov    %rax,%rdi
  81aeb2:	48 b8 54 03 81 00 00 	movabs $0x810354,%rax
  81aeb9:	00 00 00 
  81aebc:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81aebe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aec2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aec6:	be 00 00 00 00       	mov    $0x0,%esi
  81aecb:	48 89 c7             	mov    %rax,%rdi
  81aece:	48 b8 b7 03 81 00 00 	movabs $0x8103b7,%rax
  81aed5:	00 00 00 
  81aed8:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81aeda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aede:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aee2:	be 00 00 00 00       	mov    $0x0,%esi
  81aee7:	48 89 c7             	mov    %rax,%rdi
  81aeea:	48 b8 75 03 81 00 00 	movabs $0x810375,%rax
  81aef1:	00 00 00 
  81aef4:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81aef6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aefa:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aefe:	ba 04 00 00 00       	mov    $0x4,%edx
  81af03:	be 00 00 00 00       	mov    $0x0,%esi
  81af08:	48 89 c7             	mov    %rax,%rdi
  81af0b:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81af12:	00 00 00 
  81af15:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81af17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af1b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af1f:	be 00 00 00 00       	mov    $0x0,%esi
  81af24:	48 89 c7             	mov    %rax,%rdi
  81af27:	48 b8 96 03 81 00 00 	movabs $0x810396,%rax
  81af2e:	00 00 00 
  81af31:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81af33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af37:	48 8b 40 08          	mov    0x8(%rax),%rax
  81af3b:	48 89 c7             	mov    %rax,%rdi
  81af3e:	48 b8 a9 e6 80 00 00 	movabs $0x80e6a9,%rax
  81af45:	00 00 00 
  81af48:	ff d0                	callq  *%rax
  81af4a:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81af4d:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81af51:	0f 85 89 00 00 00    	jne    81afe0 <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81af57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af5b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81af62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af66:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81af6d:	00 
    conn->err = ERR_OK;
  81af6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af72:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81af76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af7a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81af7e:	48 85 c0             	test   %rax,%rax
  81af81:	74 1b                	je     81af9e <do_close_internal+0x228>
  81af83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af87:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81af8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af8f:	ba 00 00 00 00       	mov    $0x0,%edx
  81af94:	be 00 00 00 00       	mov    $0x0,%esi
  81af99:	48 89 c7             	mov    %rax,%rdi
  81af9c:	ff d1                	callq  *%rcx
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81af9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afa2:	48 8b 40 38          	mov    0x38(%rax),%rax
  81afa6:	48 85 c0             	test   %rax,%rax
  81afa9:	74 1b                	je     81afc6 <do_close_internal+0x250>
  81afab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afaf:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81afb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afb7:	ba 00 00 00 00       	mov    $0x0,%edx
  81afbc:	be 02 00 00 00       	mov    $0x2,%esi
  81afc1:	48 89 c7             	mov    %rax,%rdi
  81afc4:	ff d1                	callq  *%rcx
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81afc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afca:	8b 40 14             	mov    0x14(%rax),%eax
  81afcd:	89 c7                	mov    %eax,%edi
  81afcf:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81afd6:	00 00 00 
  81afd9:	ff d0                	callq  *%rax
  81afdb:	e9 c0 00 00 00       	jmpq   81b0a0 <do_close_internal+0x32a>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81afe0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afe4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81afe8:	8b 40 18             	mov    0x18(%rax),%eax
  81afeb:	83 f8 01             	cmp    $0x1,%eax
  81afee:	75 2a                	jne    81b01a <do_close_internal+0x2a4>
  81aff0:	48 ba e0 32 82 00 00 	movabs $0x8232e0,%rdx
  81aff7:	00 00 00 
  81affa:	be 75 02 00 00       	mov    $0x275,%esi
  81afff:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81b006:	00 00 00 
  81b009:	b8 00 00 00 00       	mov    $0x0,%eax
  81b00e:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81b015:	00 00 00 
  81b018:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b01a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b01e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b022:	48 be 58 a4 81 00 00 	movabs $0x81a458,%rsi
  81b029:	00 00 00 
  81b02c:	48 89 c7             	mov    %rax,%rdi
  81b02f:	48 b8 75 03 81 00 00 	movabs $0x810375,%rax
  81b036:	00 00 00 
  81b039:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b03b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b03f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b043:	ba 04 00 00 00       	mov    $0x4,%edx
  81b048:	48 be c8 a3 81 00 00 	movabs $0x81a3c8,%rsi
  81b04f:	00 00 00 
  81b052:	48 89 c7             	mov    %rax,%rdi
  81b055:	48 b8 d5 03 81 00 00 	movabs $0x8103d5,%rax
  81b05c:	00 00 00 
  81b05f:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b061:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b065:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b069:	48 be 72 a5 81 00 00 	movabs $0x81a572,%rsi
  81b070:	00 00 00 
  81b073:	48 89 c7             	mov    %rax,%rdi
  81b076:	48 b8 96 03 81 00 00 	movabs $0x810396,%rax
  81b07d:	00 00 00 
  81b080:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b082:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b086:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b08a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b08e:	48 89 d6             	mov    %rdx,%rsi
  81b091:	48 89 c7             	mov    %rax,%rdi
  81b094:	48 b8 36 03 81 00 00 	movabs $0x810336,%rax
  81b09b:	00 00 00 
  81b09e:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b0a0:	c9                   	leaveq 
  81b0a1:	c3                   	retq   

000000000081b0a2 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b0a2:	55                   	push   %rbp
  81b0a3:	48 89 e5             	mov    %rsp,%rbp
  81b0a6:	48 83 ec 10          	sub    $0x10,%rsp
  81b0aa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b0ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0b2:	48 8b 00             	mov    (%rax),%rax
  81b0b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0b9:	48 85 c0             	test   %rax,%rax
  81b0bc:	0f 84 94 00 00 00    	je     81b156 <do_delconn+0xb4>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b0c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0c6:	48 8b 00             	mov    (%rax),%rax
  81b0c9:	8b 00                	mov    (%rax),%eax
  81b0cb:	25 f0 00 00 00       	and    $0xf0,%eax
  81b0d0:	83 f8 20             	cmp    $0x20,%eax
  81b0d3:	74 28                	je     81b0fd <do_delconn+0x5b>
  81b0d5:	83 f8 40             	cmp    $0x40,%eax
  81b0d8:	74 07                	je     81b0e1 <do_delconn+0x3f>
  81b0da:	83 f8 10             	cmp    $0x10,%eax
  81b0dd:	74 4d                	je     81b12c <do_delconn+0x8a>
  81b0df:	eb 74                	jmp    81b155 <do_delconn+0xb3>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b0e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b0e5:	48 8b 00             	mov    (%rax),%rax
  81b0e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0ec:	48 89 c7             	mov    %rax,%rdi
  81b0ef:	48 b8 86 fb 81 00 00 	movabs $0x81fb86,%rax
  81b0f6:	00 00 00 
  81b0f9:	ff d0                	callq  *%rax
      break;
  81b0fb:	eb 59                	jmp    81b156 <do_delconn+0xb4>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b0fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b101:	48 8b 00             	mov    (%rax),%rax
  81b104:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b108:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b10f:	00 
      udp_remove(msg->conn->pcb.udp);
  81b110:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b114:	48 8b 00             	mov    (%rax),%rax
  81b117:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b11b:	48 89 c7             	mov    %rax,%rdi
  81b11e:	48 b8 5f 53 81 00 00 	movabs $0x81535f,%rax
  81b125:	00 00 00 
  81b128:	ff d0                	callq  *%rax
      break;
  81b12a:	eb 2a                	jmp    81b156 <do_delconn+0xb4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b12c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b130:	48 8b 00             	mov    (%rax),%rax
  81b133:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b13a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b13e:	48 8b 00             	mov    (%rax),%rax
  81b141:	48 89 c7             	mov    %rax,%rdi
  81b144:	48 b8 76 ad 81 00 00 	movabs $0x81ad76,%rax
  81b14b:	00 00 00 
  81b14e:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b150:	e9 8a 00 00 00       	jmpq   81b1df <do_delconn+0x13d>
#endif /* LWIP_TCP */
    default:
      break;
  81b155:	90                   	nop
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b156:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b15a:	48 8b 00             	mov    (%rax),%rax
  81b15d:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b161:	48 85 c0             	test   %rax,%rax
  81b164:	74 21                	je     81b187 <do_delconn+0xe5>
  81b166:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b16a:	48 8b 00             	mov    (%rax),%rax
  81b16d:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81b171:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b175:	48 8b 00             	mov    (%rax),%rax
  81b178:	ba 00 00 00 00       	mov    $0x0,%edx
  81b17d:	be 00 00 00 00       	mov    $0x0,%esi
  81b182:	48 89 c7             	mov    %rax,%rdi
  81b185:	ff d1                	callq  *%rcx
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b187:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b18b:	48 8b 00             	mov    (%rax),%rax
  81b18e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b192:	48 85 c0             	test   %rax,%rax
  81b195:	74 21                	je     81b1b8 <do_delconn+0x116>
  81b197:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b19b:	48 8b 00             	mov    (%rax),%rax
  81b19e:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81b1a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1a6:	48 8b 00             	mov    (%rax),%rax
  81b1a9:	ba 00 00 00 00       	mov    $0x0,%edx
  81b1ae:	be 02 00 00 00       	mov    $0x2,%esi
  81b1b3:	48 89 c7             	mov    %rax,%rdi
  81b1b6:	ff d1                	callq  *%rcx

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b1b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1bc:	48 8b 00             	mov    (%rax),%rax
  81b1bf:	8b 40 14             	mov    0x14(%rax),%eax
  81b1c2:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b1c5:	74 18                	je     81b1df <do_delconn+0x13d>
    sys_sem_signal(msg->conn->op_completed);
  81b1c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b1cb:	48 8b 00             	mov    (%rax),%rax
  81b1ce:	8b 40 14             	mov    0x14(%rax),%eax
  81b1d1:	89 c7                	mov    %eax,%edi
  81b1d3:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b1da:	00 00 00 
  81b1dd:	ff d0                	callq  *%rax
  }
}
  81b1df:	c9                   	leaveq 
  81b1e0:	c3                   	retq   

000000000081b1e1 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b1e1:	55                   	push   %rbp
  81b1e2:	48 89 e5             	mov    %rsp,%rbp
  81b1e5:	53                   	push   %rbx
  81b1e6:	48 83 ec 18          	sub    $0x18,%rsp
  81b1ea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b1ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1f2:	48 8b 00             	mov    (%rax),%rax
  81b1f5:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b1f9:	3c fc                	cmp    $0xfc,%al
  81b1fb:	0f 8c f0 00 00 00    	jl     81b2f1 <do_bind+0x110>
    if (msg->conn->pcb.tcp != NULL) {
  81b201:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b205:	48 8b 00             	mov    (%rax),%rax
  81b208:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b20c:	48 85 c0             	test   %rax,%rax
  81b20f:	0f 84 d1 00 00 00    	je     81b2e6 <do_bind+0x105>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b215:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b219:	48 8b 00             	mov    (%rax),%rax
  81b21c:	8b 00                	mov    (%rax),%eax
  81b21e:	25 f0 00 00 00       	and    $0xf0,%eax
  81b223:	83 f8 20             	cmp    $0x20,%eax
  81b226:	74 43                	je     81b26b <do_bind+0x8a>
  81b228:	83 f8 40             	cmp    $0x40,%eax
  81b22b:	74 0a                	je     81b237 <do_bind+0x56>
  81b22d:	83 f8 10             	cmp    $0x10,%eax
  81b230:	74 75                	je     81b2a7 <do_bind+0xc6>
  81b232:	e9 ad 00 00 00       	jmpq   81b2e4 <do_bind+0x103>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b237:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b23b:	48 8b 18             	mov    (%rax),%rbx
  81b23e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b242:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b246:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b24a:	48 8b 00             	mov    (%rax),%rax
  81b24d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b251:	48 89 d6             	mov    %rdx,%rsi
  81b254:	48 89 c7             	mov    %rax,%rdi
  81b257:	48 b8 1d f9 81 00 00 	movabs $0x81f91d,%rax
  81b25e:	00 00 00 
  81b261:	ff d0                	callq  *%rax
  81b263:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b266:	e9 86 00 00 00       	jmpq   81b2f1 <do_bind+0x110>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b26b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b26f:	48 8b 18             	mov    (%rax),%rbx
  81b272:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b276:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b27a:	0f b7 d0             	movzwl %ax,%edx
  81b27d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b281:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b289:	48 8b 00             	mov    (%rax),%rax
  81b28c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b290:	48 89 ce             	mov    %rcx,%rsi
  81b293:	48 89 c7             	mov    %rax,%rdi
  81b296:	48 b8 b3 50 81 00 00 	movabs $0x8150b3,%rax
  81b29d:	00 00 00 
  81b2a0:	ff d0                	callq  *%rax
  81b2a2:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b2a5:	eb 4a                	jmp    81b2f1 <do_bind+0x110>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b2a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2ab:	48 8b 18             	mov    (%rax),%rbx
  81b2ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2b2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b2b6:	0f b7 d0             	movzwl %ax,%edx
  81b2b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2bd:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b2c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2c5:	48 8b 00             	mov    (%rax),%rax
  81b2c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2cc:	48 89 ce             	mov    %rcx,%rsi
  81b2cf:	48 89 c7             	mov    %rax,%rdi
  81b2d2:	48 b8 fa ea 80 00 00 	movabs $0x80eafa,%rax
  81b2d9:	00 00 00 
  81b2dc:	ff d0                	callq  *%rax
  81b2de:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b2e1:	90                   	nop
  81b2e2:	eb 0d                	jmp    81b2f1 <do_bind+0x110>
#endif /* LWIP_TCP */
      default:
        break;
  81b2e4:	eb 0b                	jmp    81b2f1 <do_bind+0x110>
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81b2e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2ea:	48 8b 00             	mov    (%rax),%rax
  81b2ed:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b2f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b2f5:	48 8b 00             	mov    (%rax),%rax
  81b2f8:	8b 40 14             	mov    0x14(%rax),%eax
  81b2fb:	89 c7                	mov    %eax,%edi
  81b2fd:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b304:	00 00 00 
  81b307:	ff d0                	callq  *%rax
}
  81b309:	48 83 c4 18          	add    $0x18,%rsp
  81b30d:	5b                   	pop    %rbx
  81b30e:	5d                   	pop    %rbp
  81b30f:	c3                   	retq   

000000000081b310 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81b310:	55                   	push   %rbp
  81b311:	48 89 e5             	mov    %rsp,%rbp
  81b314:	48 83 ec 30          	sub    $0x30,%rsp
  81b318:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81b31c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81b320:	89 d0                	mov    %edx,%eax
  81b322:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81b325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b329:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81b32d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b332:	75 07                	jne    81b33b <do_connected+0x2b>
    return ERR_VAL;
  81b334:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81b339:	eb 54                	jmp    81b38f <do_connected+0x7f>
  }

  conn->err = err;
  81b33b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b33f:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81b343:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81b346:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b34a:	8b 00                	mov    (%rax),%eax
  81b34c:	83 f8 10             	cmp    $0x10,%eax
  81b34f:	75 19                	jne    81b36a <do_connected+0x5a>
  81b351:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81b355:	75 13                	jne    81b36a <do_connected+0x5a>
    setup_tcp(conn);
  81b357:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b35b:	48 89 c7             	mov    %rax,%rdi
  81b35e:	48 b8 e1 a6 81 00 00 	movabs $0x81a6e1,%rax
  81b365:	00 00 00 
  81b368:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81b36a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b36e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81b375:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b379:	8b 40 14             	mov    0x14(%rax),%eax
  81b37c:	89 c7                	mov    %eax,%edi
  81b37e:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b385:	00 00 00 
  81b388:	ff d0                	callq  *%rax
  return ERR_OK;
  81b38a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b38f:	c9                   	leaveq 
  81b390:	c3                   	retq   

000000000081b391 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81b391:	55                   	push   %rbp
  81b392:	48 89 e5             	mov    %rsp,%rbp
  81b395:	53                   	push   %rbx
  81b396:	48 83 ec 18          	sub    $0x18,%rsp
  81b39a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81b39e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3a2:	48 8b 00             	mov    (%rax),%rax
  81b3a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3a9:	48 85 c0             	test   %rax,%rax
  81b3ac:	75 1d                	jne    81b3cb <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81b3ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3b2:	48 8b 00             	mov    (%rax),%rax
  81b3b5:	8b 40 14             	mov    0x14(%rax),%eax
  81b3b8:	89 c7                	mov    %eax,%edi
  81b3ba:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b3c1:	00 00 00 
  81b3c4:	ff d0                	callq  *%rax
    return;
  81b3c6:	e9 2e 01 00 00       	jmpq   81b4f9 <do_connect+0x168>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b3cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3cf:	48 8b 00             	mov    (%rax),%rax
  81b3d2:	8b 00                	mov    (%rax),%eax
  81b3d4:	25 f0 00 00 00       	and    $0xf0,%eax
  81b3d9:	83 f8 20             	cmp    $0x20,%eax
  81b3dc:	74 5f                	je     81b43d <do_connect+0xac>
  81b3de:	83 f8 40             	cmp    $0x40,%eax
  81b3e1:	74 0e                	je     81b3f1 <do_connect+0x60>
  81b3e3:	83 f8 10             	cmp    $0x10,%eax
  81b3e6:	0f 84 a5 00 00 00    	je     81b491 <do_connect+0x100>
  81b3ec:	e9 07 01 00 00       	jmpq   81b4f8 <do_connect+0x167>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b3f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3f5:	48 8b 18             	mov    (%rax),%rbx
  81b3f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3fc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b400:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b404:	48 8b 00             	mov    (%rax),%rax
  81b407:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b40b:	48 89 d6             	mov    %rdx,%rsi
  81b40e:	48 89 c7             	mov    %rax,%rdi
  81b411:	48 b8 4e f9 81 00 00 	movabs $0x81f94e,%rax
  81b418:	00 00 00 
  81b41b:	ff d0                	callq  *%rax
  81b41d:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b420:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b424:	48 8b 00             	mov    (%rax),%rax
  81b427:	8b 40 14             	mov    0x14(%rax),%eax
  81b42a:	89 c7                	mov    %eax,%edi
  81b42c:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b433:	00 00 00 
  81b436:	ff d0                	callq  *%rax
    break;
  81b438:	e9 bc 00 00 00       	jmpq   81b4f9 <do_connect+0x168>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b43d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b441:	48 8b 18             	mov    (%rax),%rbx
  81b444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b448:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b44c:	0f b7 d0             	movzwl %ax,%edx
  81b44f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b453:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b45b:	48 8b 00             	mov    (%rax),%rax
  81b45e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b462:	48 89 ce             	mov    %rcx,%rsi
  81b465:	48 89 c7             	mov    %rax,%rdi
  81b468:	48 b8 f9 51 81 00 00 	movabs $0x8151f9,%rax
  81b46f:	00 00 00 
  81b472:	ff d0                	callq  *%rax
  81b474:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b477:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b47b:	48 8b 00             	mov    (%rax),%rax
  81b47e:	8b 40 14             	mov    0x14(%rax),%eax
  81b481:	89 c7                	mov    %eax,%edi
  81b483:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b48a:	00 00 00 
  81b48d:	ff d0                	callq  *%rax
    break;
  81b48f:	eb 68                	jmp    81b4f9 <do_connect+0x168>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81b491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b495:	48 8b 00             	mov    (%rax),%rax
  81b498:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81b49f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4a3:	48 8b 00             	mov    (%rax),%rax
  81b4a6:	48 89 c7             	mov    %rax,%rdi
  81b4a9:	48 b8 e1 a6 81 00 00 	movabs $0x81a6e1,%rax
  81b4b0:	00 00 00 
  81b4b3:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81b4b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4b9:	48 8b 18             	mov    (%rax),%rbx
  81b4bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4c0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b4c4:	0f b7 d0             	movzwl %ax,%edx
  81b4c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4cb:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81b4cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4d3:	48 8b 00             	mov    (%rax),%rax
  81b4d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4da:	48 b9 10 b3 81 00 00 	movabs $0x81b310,%rcx
  81b4e1:	00 00 00 
  81b4e4:	48 89 c7             	mov    %rax,%rdi
  81b4e7:	48 b8 31 f2 80 00 00 	movabs $0x80f231,%rax
  81b4ee:	00 00 00 
  81b4f1:	ff d0                	callq  *%rax
  81b4f3:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81b4f6:	eb 01                	jmp    81b4f9 <do_connect+0x168>
#endif /* LWIP_TCP */
  default:
    break;
  81b4f8:	90                   	nop
  }
}
  81b4f9:	48 83 c4 18          	add    $0x18,%rsp
  81b4fd:	5b                   	pop    %rbx
  81b4fe:	5d                   	pop    %rbp
  81b4ff:	c3                   	retq   

000000000081b500 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81b500:	55                   	push   %rbp
  81b501:	48 89 e5             	mov    %rsp,%rbp
  81b504:	48 83 ec 10          	sub    $0x10,%rsp
  81b508:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81b50c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b510:	48 8b 00             	mov    (%rax),%rax
  81b513:	8b 00                	mov    (%rax),%eax
  81b515:	25 f0 00 00 00       	and    $0xf0,%eax
  81b51a:	83 f8 20             	cmp    $0x20,%eax
  81b51d:	75 1a                	jne    81b539 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81b51f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b523:	48 8b 00             	mov    (%rax),%rax
  81b526:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b52a:	48 89 c7             	mov    %rax,%rdi
  81b52d:	48 b8 f2 52 81 00 00 	movabs $0x8152f2,%rax
  81b534:	00 00 00 
  81b537:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81b539:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b53d:	48 8b 00             	mov    (%rax),%rax
  81b540:	8b 40 14             	mov    0x14(%rax),%eax
  81b543:	89 c7                	mov    %eax,%edi
  81b545:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b54c:	00 00 00 
  81b54f:	ff d0                	callq  *%rax
}
  81b551:	c9                   	leaveq 
  81b552:	c3                   	retq   

000000000081b553 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81b553:	55                   	push   %rbp
  81b554:	48 89 e5             	mov    %rsp,%rbp
  81b557:	53                   	push   %rbx
  81b558:	48 83 ec 28          	sub    $0x28,%rsp
  81b55c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b560:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b564:	48 8b 00             	mov    (%rax),%rax
  81b567:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b56b:	3c fc                	cmp    $0xfc,%al
  81b56d:	0f 8c 69 01 00 00    	jl     81b6dc <do_listen+0x189>
    if (msg->conn->pcb.tcp != NULL) {
  81b573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b577:	48 8b 00             	mov    (%rax),%rax
  81b57a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b57e:	48 85 c0             	test   %rax,%rax
  81b581:	0f 84 55 01 00 00    	je     81b6dc <do_listen+0x189>
      if (msg->conn->type == NETCONN_TCP) {
  81b587:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b58b:	48 8b 00             	mov    (%rax),%rax
  81b58e:	8b 00                	mov    (%rax),%eax
  81b590:	83 f8 10             	cmp    $0x10,%eax
  81b593:	0f 85 43 01 00 00    	jne    81b6dc <do_listen+0x189>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81b599:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b59d:	48 8b 00             	mov    (%rax),%rax
  81b5a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5a4:	8b 40 18             	mov    0x18(%rax),%eax
  81b5a7:	85 c0                	test   %eax,%eax
  81b5a9:	0f 85 22 01 00 00    	jne    81b6d1 <do_listen+0x17e>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81b5af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5b3:	48 8b 00             	mov    (%rax),%rax
  81b5b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5ba:	be ff 00 00 00       	mov    $0xff,%esi
  81b5bf:	48 89 c7             	mov    %rax,%rdi
  81b5c2:	48 b8 7b ed 80 00 00 	movabs $0x80ed7b,%rax
  81b5c9:	00 00 00 
  81b5cc:	ff d0                	callq  *%rax
  81b5ce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81b5d2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b5d7:	75 10                	jne    81b5e9 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81b5d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5dd:	48 8b 00             	mov    (%rax),%rax
  81b5e0:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81b5e4:	e9 f3 00 00 00       	jmpq   81b6dc <do_listen+0x189>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81b5e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5ed:	48 8b 00             	mov    (%rax),%rax
  81b5f0:	8b 40 18             	mov    0x18(%rax),%eax
  81b5f3:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b5f6:	74 26                	je     81b61e <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81b5f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b5fc:	48 8b 00             	mov    (%rax),%rax
  81b5ff:	8b 40 18             	mov    0x18(%rax),%eax
  81b602:	89 c7                	mov    %eax,%edi
  81b604:	48 b8 19 73 81 00 00 	movabs $0x817319,%rax
  81b60b:	00 00 00 
  81b60e:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81b610:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b614:	48 8b 00             	mov    (%rax),%rax
  81b617:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81b61e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b622:	48 8b 00             	mov    (%rax),%rax
  81b625:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b628:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b62b:	75 2e                	jne    81b65b <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81b62d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b631:	48 8b 18             	mov    (%rax),%rbx
  81b634:	bf 00 00 00 00       	mov    $0x0,%edi
  81b639:	48 b8 36 71 81 00 00 	movabs $0x817136,%rax
  81b640:	00 00 00 
  81b643:	ff d0                	callq  *%rax
  81b645:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81b648:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81b64b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b64e:	75 0b                	jne    81b65b <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81b650:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b654:	48 8b 00             	mov    (%rax),%rax
  81b657:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81b65b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b65f:	48 8b 00             	mov    (%rax),%rax
  81b662:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b666:	84 c0                	test   %al,%al
  81b668:	75 72                	jne    81b6dc <do_listen+0x189>
              msg->conn->state = NETCONN_LISTEN;
  81b66a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b66e:	48 8b 00             	mov    (%rax),%rax
  81b671:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81b678:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b67c:	48 8b 00             	mov    (%rax),%rax
  81b67f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b683:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81b687:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b68b:	48 8b 10             	mov    (%rax),%rdx
  81b68e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b692:	48 8b 00             	mov    (%rax),%rax
  81b695:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b699:	48 89 d6             	mov    %rdx,%rsi
  81b69c:	48 89 c7             	mov    %rax,%rdi
  81b69f:	48 b8 36 03 81 00 00 	movabs $0x810336,%rax
  81b6a6:	00 00 00 
  81b6a9:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81b6ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b6af:	48 8b 00             	mov    (%rax),%rax
  81b6b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6b6:	48 be 8e a7 81 00 00 	movabs $0x81a78e,%rsi
  81b6bd:	00 00 00 
  81b6c0:	48 89 c7             	mov    %rax,%rdi
  81b6c3:	48 b8 b7 03 81 00 00 	movabs $0x8103b7,%rax
  81b6ca:	00 00 00 
  81b6cd:	ff d0                	callq  *%rax
  81b6cf:	eb 0b                	jmp    81b6dc <do_listen+0x189>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81b6d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b6d5:	48 8b 00             	mov    (%rax),%rax
  81b6d8:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81b6dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b6e0:	48 8b 00             	mov    (%rax),%rax
  81b6e3:	8b 40 14             	mov    0x14(%rax),%eax
  81b6e6:	89 c7                	mov    %eax,%edi
  81b6e8:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b6ef:	00 00 00 
  81b6f2:	ff d0                	callq  *%rax
}
  81b6f4:	48 83 c4 28          	add    $0x28,%rsp
  81b6f8:	5b                   	pop    %rbx
  81b6f9:	5d                   	pop    %rbp
  81b6fa:	c3                   	retq   

000000000081b6fb <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81b6fb:	55                   	push   %rbp
  81b6fc:	48 89 e5             	mov    %rsp,%rbp
  81b6ff:	53                   	push   %rbx
  81b700:	48 83 ec 18          	sub    $0x18,%rsp
  81b704:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b708:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b70c:	48 8b 00             	mov    (%rax),%rax
  81b70f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b713:	3c fc                	cmp    $0xfc,%al
  81b715:	0f 8c 51 01 00 00    	jl     81b86c <do_send+0x171>
    if (msg->conn->pcb.tcp != NULL) {
  81b71b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b71f:	48 8b 00             	mov    (%rax),%rax
  81b722:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b726:	48 85 c0             	test   %rax,%rax
  81b729:	0f 84 3d 01 00 00    	je     81b86c <do_send+0x171>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b72f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b733:	48 8b 00             	mov    (%rax),%rax
  81b736:	8b 00                	mov    (%rax),%eax
  81b738:	25 f0 00 00 00       	and    $0xf0,%eax
  81b73d:	83 f8 20             	cmp    $0x20,%eax
  81b740:	0f 84 94 00 00 00    	je     81b7da <do_send+0xdf>
  81b746:	83 f8 40             	cmp    $0x40,%eax
  81b749:	0f 85 1c 01 00 00    	jne    81b86b <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81b74f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b753:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b757:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b75b:	48 85 c0             	test   %rax,%rax
  81b75e:	75 37                	jne    81b797 <do_send+0x9c>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81b760:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b764:	48 8b 18             	mov    (%rax),%rbx
  81b767:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b76b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b76f:	48 8b 10             	mov    (%rax),%rdx
  81b772:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b776:	48 8b 00             	mov    (%rax),%rax
  81b779:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b77d:	48 89 d6             	mov    %rdx,%rsi
  81b780:	48 89 c7             	mov    %rax,%rdi
  81b783:	48 b8 52 fb 81 00 00 	movabs $0x81fb52,%rax
  81b78a:	00 00 00 
  81b78d:	ff d0                	callq  *%rax
  81b78f:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81b792:	e9 d5 00 00 00       	jmpq   81b86c <do_send+0x171>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81b797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b79b:	48 8b 18             	mov    (%rax),%rbx
  81b79e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7a6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81b7aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7b2:	48 8b 08             	mov    (%rax),%rcx
  81b7b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7b9:	48 8b 00             	mov    (%rax),%rax
  81b7bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7c0:	48 89 ce             	mov    %rcx,%rsi
  81b7c3:	48 89 c7             	mov    %rax,%rdi
  81b7c6:	48 b8 ae f9 81 00 00 	movabs $0x81f9ae,%rax
  81b7cd:	00 00 00 
  81b7d0:	ff d0                	callq  *%rax
  81b7d2:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81b7d5:	e9 92 00 00 00       	jmpq   81b86c <do_send+0x171>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81b7da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7de:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7e2:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b7e6:	48 85 c0             	test   %rax,%rax
  81b7e9:	75 34                	jne    81b81f <do_send+0x124>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81b7eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7ef:	48 8b 18             	mov    (%rax),%rbx
  81b7f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b7f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b7fa:	48 8b 10             	mov    (%rax),%rdx
  81b7fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b801:	48 8b 00             	mov    (%rax),%rax
  81b804:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b808:	48 89 d6             	mov    %rdx,%rsi
  81b80b:	48 89 c7             	mov    %rax,%rdi
  81b80e:	48 b8 5a 4d 81 00 00 	movabs $0x814d5a,%rax
  81b815:	00 00 00 
  81b818:	ff d0                	callq  *%rax
  81b81a:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81b81d:	eb 4d                	jmp    81b86c <do_send+0x171>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81b81f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b823:	48 8b 18             	mov    (%rax),%rbx
  81b826:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b82a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b82e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81b832:	0f b7 c8             	movzwl %ax,%ecx
  81b835:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b839:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b83d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81b841:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b845:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b849:	48 8b 30             	mov    (%rax),%rsi
  81b84c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b850:	48 8b 00             	mov    (%rax),%rax
  81b853:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b857:	48 89 c7             	mov    %rax,%rdi
  81b85a:	48 b8 9b 4d 81 00 00 	movabs $0x814d9b,%rax
  81b861:	00 00 00 
  81b864:	ff d0                	callq  *%rax
  81b866:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81b869:	eb 01                	jmp    81b86c <do_send+0x171>
#endif /* LWIP_UDP */
      default:
        break;
  81b86b:	90                   	nop
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b86c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b870:	48 8b 00             	mov    (%rax),%rax
  81b873:	8b 40 14             	mov    0x14(%rax),%eax
  81b876:	89 c7                	mov    %eax,%edi
  81b878:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b87f:	00 00 00 
  81b882:	ff d0                	callq  *%rax
}
  81b884:	48 83 c4 18          	add    $0x18,%rsp
  81b888:	5b                   	pop    %rbx
  81b889:	5d                   	pop    %rbp
  81b88a:	c3                   	retq   

000000000081b88b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81b88b:	55                   	push   %rbp
  81b88c:	48 89 e5             	mov    %rsp,%rbp
  81b88f:	48 83 ec 10          	sub    $0x10,%rsp
  81b893:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b897:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b89b:	48 8b 00             	mov    (%rax),%rax
  81b89e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b8a2:	3c fc                	cmp    $0xfc,%al
  81b8a4:	7c 45                	jl     81b8eb <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81b8a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8aa:	48 8b 00             	mov    (%rax),%rax
  81b8ad:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b8b1:	48 85 c0             	test   %rax,%rax
  81b8b4:	74 35                	je     81b8eb <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81b8b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8ba:	48 8b 00             	mov    (%rax),%rax
  81b8bd:	8b 00                	mov    (%rax),%eax
  81b8bf:	83 f8 10             	cmp    $0x10,%eax
  81b8c2:	75 27                	jne    81b8eb <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81b8c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8c8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81b8cc:	0f b7 d0             	movzwl %ax,%edx
  81b8cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8d3:	48 8b 00             	mov    (%rax),%rax
  81b8d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b8da:	89 d6                	mov    %edx,%esi
  81b8dc:	48 89 c7             	mov    %rax,%rdi
  81b8df:	48 b8 be ef 80 00 00 	movabs $0x80efbe,%rax
  81b8e6:	00 00 00 
  81b8e9:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81b8eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b8ef:	48 8b 00             	mov    (%rax),%rax
  81b8f2:	8b 40 14             	mov    0x14(%rax),%eax
  81b8f5:	89 c7                	mov    %eax,%edi
  81b8f7:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81b8fe:	00 00 00 
  81b901:	ff d0                	callq  *%rax
}
  81b903:	c9                   	leaveq 
  81b904:	c3                   	retq   

000000000081b905 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81b905:	55                   	push   %rbp
  81b906:	48 89 e5             	mov    %rsp,%rbp
  81b909:	48 83 ec 30          	sub    $0x30,%rsp
  81b90d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81b911:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81b915:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b919:	8b 40 04             	mov    0x4(%rax),%eax
  81b91c:	83 f8 01             	cmp    $0x1,%eax
  81b91f:	74 2a                	je     81b94b <do_writemore+0x46>
  81b921:	48 ba 03 33 82 00 00 	movabs $0x823303,%rdx
  81b928:	00 00 00 
  81b92b:	be b8 03 00 00       	mov    $0x3b8,%esi
  81b930:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81b937:	00 00 00 
  81b93a:	b8 00 00 00 00       	mov    $0x0,%eax
  81b93f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81b946:	00 00 00 
  81b949:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81b94b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b94f:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b953:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b957:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b95b:	8b 40 30             	mov    0x30(%rax),%eax
  81b95e:	48 98                	cltq   
  81b960:	48 01 d0             	add    %rdx,%rax
  81b963:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81b967:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b96b:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b96f:	8b 50 10             	mov    0x10(%rax),%edx
  81b972:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b976:	8b 40 30             	mov    0x30(%rax),%eax
  81b979:	89 d1                	mov    %edx,%ecx
  81b97b:	29 c1                	sub    %eax,%ecx
  81b97d:	89 c8                	mov    %ecx,%eax
  81b97f:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81b984:	7e 08                	jle    81b98e <do_writemore+0x89>
    len = 0xffff;
  81b986:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81b98c:	eb 1f                	jmp    81b9ad <do_writemore+0xa8>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81b98e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b992:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b996:	8b 40 10             	mov    0x10(%rax),%eax
  81b999:	89 c2                	mov    %eax,%edx
  81b99b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b99f:	8b 40 30             	mov    0x30(%rax),%eax
  81b9a2:	89 d1                	mov    %edx,%ecx
  81b9a4:	66 29 c1             	sub    %ax,%cx
  81b9a7:	89 c8                	mov    %ecx,%eax
  81b9a9:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81b9ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b9b1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9b5:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81b9b9:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81b9bd:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81b9c1:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81b9c5:	73 08                	jae    81b9cf <do_writemore+0xca>
    /* don't try to write more than sendbuf */
    len = available;
  81b9c7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81b9cb:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81b9cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b9d3:	48 8b 40 28          	mov    0x28(%rax),%rax
  81b9d7:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81b9db:	0f b6 c8             	movzbl %al,%ecx
  81b9de:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81b9e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b9e6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9ea:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81b9ee:	48 89 c7             	mov    %rax,%rdi
  81b9f1:	48 b8 89 2b 81 00 00 	movabs $0x812b89,%rax
  81b9f8:	00 00 00 
  81b9fb:	ff d0                	callq  *%rax
  81b9fd:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81ba00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba04:	8b 50 30             	mov    0x30(%rax),%edx
  81ba07:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81ba0b:	01 c2                	add    %eax,%edx
  81ba0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba11:	48 8b 40 28          	mov    0x28(%rax),%rax
  81ba15:	8b 40 10             	mov    0x10(%rax),%eax
  81ba18:	39 c2                	cmp    %eax,%edx
  81ba1a:	7e 2a                	jle    81ba46 <do_writemore+0x141>
  81ba1c:	48 ba 20 33 82 00 00 	movabs $0x823320,%rdx
  81ba23:	00 00 00 
  81ba26:	be cd 03 00 00       	mov    $0x3cd,%esi
  81ba2b:	48 bf 12 31 82 00 00 	movabs $0x823112,%rdi
  81ba32:	00 00 00 
  81ba35:	b8 00 00 00 00       	mov    $0x0,%eax
  81ba3a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ba41:	00 00 00 
  81ba44:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81ba46:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81ba4a:	0f 85 07 01 00 00    	jne    81bb57 <do_writemore+0x252>
    conn->write_offset += len;
  81ba50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba54:	8b 50 30             	mov    0x30(%rax),%edx
  81ba57:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81ba5b:	01 c2                	add    %eax,%edx
  81ba5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba61:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81ba64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba68:	8b 50 30             	mov    0x30(%rax),%edx
  81ba6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba6f:	48 8b 40 28          	mov    0x28(%rax),%rax
  81ba73:	8b 40 10             	mov    0x10(%rax),%eax
  81ba76:	39 c2                	cmp    %eax,%edx
  81ba78:	75 1b                	jne    81ba95 <do_writemore+0x190>
      /* everything was written */
      write_finished = 1;
  81ba7a:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81ba7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba82:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81ba89:	00 
      conn->write_offset = 0;
  81ba8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba8e:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81ba95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ba99:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba9d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81baa4:	48 85 c0             	test   %rax,%rax
  81baa7:	74 41                	je     81baea <do_writemore+0x1e5>
  81baa9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81baad:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bab1:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81bab5:	0f b6 c0             	movzbl %al,%eax
  81bab8:	83 e0 40             	and    $0x40,%eax
  81babb:	85 c0                	test   %eax,%eax
  81babd:	75 2b                	jne    81baea <do_writemore+0x1e5>
  81babf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bac3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bac7:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bace:	48 85 c0             	test   %rax,%rax
  81bad1:	74 30                	je     81bb03 <do_writemore+0x1fe>
  81bad3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bad7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81badb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bae2:	48 8b 00             	mov    (%rax),%rax
  81bae5:	48 85 c0             	test   %rax,%rax
  81bae8:	74 19                	je     81bb03 <do_writemore+0x1fe>
  81baea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81baee:	48 8b 40 08          	mov    0x8(%rax),%rax
  81baf2:	48 89 c7             	mov    %rax,%rdi
  81baf5:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81bafc:	00 00 00 
  81baff:	ff d0                	callq  *%rax
  81bb01:	eb 05                	jmp    81bb08 <do_writemore+0x203>
  81bb03:	b8 00 00 00 00       	mov    $0x0,%eax
  81bb08:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81bb0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb0f:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81bb13:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81bb16:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bb1a:	75 6c                	jne    81bb88 <do_writemore+0x283>
  81bb1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb20:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb24:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bb28:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81bb2c:	77 5a                	ja     81bb88 <do_writemore+0x283>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81bb2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb32:	48 8b 40 38          	mov    0x38(%rax),%rax
  81bb36:	48 85 c0             	test   %rax,%rax
  81bb39:	74 4d                	je     81bb88 <do_writemore+0x283>
  81bb3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb3f:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81bb43:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bb47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb4b:	be 03 00 00 00       	mov    $0x3,%esi
  81bb50:	48 89 c7             	mov    %rax,%rdi
  81bb53:	ff d1                	callq  *%rcx
  81bb55:	eb 31                	jmp    81bb88 <do_writemore+0x283>
    }
  } else if (err == ERR_MEM) {
  81bb57:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81bb5b:	75 1c                	jne    81bb79 <do_writemore+0x274>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81bb5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb61:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb65:	48 89 c7             	mov    %rax,%rdi
  81bb68:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81bb6f:	00 00 00 
  81bb72:	ff d0                	callq  *%rax
  81bb74:	88 45 ed             	mov    %al,-0x13(%rbp)
  81bb77:	eb 0f                	jmp    81bb88 <do_writemore+0x283>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81bb79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb7d:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81bb81:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81bb84:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81bb88:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81bb8c:	74 20                	je     81bbae <do_writemore+0x2a9>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81bb8e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb92:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81bb99:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb9d:	8b 40 14             	mov    0x14(%rax),%eax
  81bba0:	89 c7                	mov    %eax,%edi
  81bba2:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81bba9:	00 00 00 
  81bbac:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81bbae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81bbb3:	c9                   	leaveq 
  81bbb4:	c3                   	retq   

000000000081bbb5 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81bbb5:	55                   	push   %rbp
  81bbb6:	48 89 e5             	mov    %rsp,%rbp
  81bbb9:	48 83 ec 10          	sub    $0x10,%rsp
  81bbbd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bbc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bbc5:	48 8b 00             	mov    (%rax),%rax
  81bbc8:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bbcc:	3c fc                	cmp    $0xfc,%al
  81bbce:	7c 6c                	jl     81bc3c <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81bbd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bbd4:	48 8b 00             	mov    (%rax),%rax
  81bbd7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bbdb:	48 85 c0             	test   %rax,%rax
  81bbde:	74 51                	je     81bc31 <do_write+0x7c>
  81bbe0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bbe4:	48 8b 00             	mov    (%rax),%rax
  81bbe7:	8b 00                	mov    (%rax),%eax
  81bbe9:	83 f8 10             	cmp    $0x10,%eax
  81bbec:	75 43                	jne    81bc31 <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81bbee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bbf2:	48 8b 00             	mov    (%rax),%rax
  81bbf5:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81bbfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc00:	48 8b 00             	mov    (%rax),%rax
  81bc03:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bc07:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81bc0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc0f:	48 8b 00             	mov    (%rax),%rax
  81bc12:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81bc19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc1d:	48 8b 00             	mov    (%rax),%rax
  81bc20:	48 89 c7             	mov    %rax,%rdi
  81bc23:	48 b8 05 b9 81 00 00 	movabs $0x81b905,%rax
  81bc2a:	00 00 00 
  81bc2d:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81bc2f:	eb 23                	jmp    81bc54 <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81bc31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc35:	48 8b 00             	mov    (%rax),%rax
  81bc38:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81bc3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc40:	48 8b 00             	mov    (%rax),%rax
  81bc43:	8b 40 14             	mov    0x14(%rax),%eax
  81bc46:	89 c7                	mov    %eax,%edi
  81bc48:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81bc4f:	00 00 00 
  81bc52:	ff d0                	callq  *%rax
}
  81bc54:	c9                   	leaveq 
  81bc55:	c3                   	retq   

000000000081bc56 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81bc56:	55                   	push   %rbp
  81bc57:	48 89 e5             	mov    %rsp,%rbp
  81bc5a:	48 83 ec 10          	sub    $0x10,%rsp
  81bc5e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81bc62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc66:	48 8b 00             	mov    (%rax),%rax
  81bc69:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc6d:	48 85 c0             	test   %rax,%rax
  81bc70:	0f 84 40 01 00 00    	je     81bdb6 <do_getaddr+0x160>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81bc76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bc7a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc7e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bc82:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81bc86:	84 d2                	test   %dl,%dl
  81bc88:	74 11                	je     81bc9b <do_getaddr+0x45>
  81bc8a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bc8e:	48 8b 12             	mov    (%rdx),%rdx
  81bc91:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bc95:	8b 12                	mov    (%rdx),%edx
  81bc97:	89 10                	mov    %edx,(%rax)
  81bc99:	eb 10                	jmp    81bcab <do_getaddr+0x55>
  81bc9b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bc9f:	48 8b 12             	mov    (%rdx),%rdx
  81bca2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bca6:	8b 52 04             	mov    0x4(%rdx),%edx
  81bca9:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81bcab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bcaf:	48 8b 00             	mov    (%rax),%rax
  81bcb2:	8b 00                	mov    (%rax),%eax
  81bcb4:	25 f0 00 00 00       	and    $0xf0,%eax
  81bcb9:	83 f8 20             	cmp    $0x20,%eax
  81bcbc:	74 51                	je     81bd0f <do_getaddr+0xb9>
  81bcbe:	83 f8 40             	cmp    $0x40,%eax
  81bcc1:	74 0e                	je     81bcd1 <do_getaddr+0x7b>
  81bcc3:	83 f8 10             	cmp    $0x10,%eax
  81bcc6:	0f 84 b1 00 00 00    	je     81bd7d <do_getaddr+0x127>
  81bccc:	e9 f0 00 00 00       	jmpq   81bdc1 <do_getaddr+0x16b>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81bcd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bcd5:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bcd9:	84 c0                	test   %al,%al
  81bcdb:	74 22                	je     81bcff <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81bcdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bce1:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bce5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bce9:	48 8b 12             	mov    (%rdx),%rdx
  81bcec:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bcf0:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81bcf4:	0f b6 d2             	movzbl %dl,%edx
  81bcf7:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81bcfa:	e9 c2 00 00 00       	jmpq   81bdc1 <do_getaddr+0x16b>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81bcff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd03:	48 8b 00             	mov    (%rax),%rax
  81bd06:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81bd0a:	e9 b2 00 00 00       	jmpq   81bdc1 <do_getaddr+0x16b>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81bd0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd13:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bd17:	84 c0                	test   %al,%al
  81bd19:	74 1f                	je     81bd3a <do_getaddr+0xe4>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81bd1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd1f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bd23:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bd27:	48 8b 12             	mov    (%rdx),%rdx
  81bd2a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bd2e:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81bd32:	66 89 10             	mov    %dx,(%rax)
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81bd35:	e9 87 00 00 00       	jmpq   81bdc1 <do_getaddr+0x16b>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81bd3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd3e:	48 8b 00             	mov    (%rax),%rax
  81bd41:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd45:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bd49:	0f b6 c0             	movzbl %al,%eax
  81bd4c:	83 e0 04             	and    $0x4,%eax
  81bd4f:	85 c0                	test   %eax,%eax
  81bd51:	75 0d                	jne    81bd60 <do_getaddr+0x10a>
          msg->conn->err = ERR_CONN;
  81bd53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd57:	48 8b 00             	mov    (%rax),%rax
  81bd5a:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81bd5e:	eb 61                	jmp    81bdc1 <do_getaddr+0x16b>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81bd60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd64:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bd68:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bd6c:	48 8b 12             	mov    (%rdx),%rdx
  81bd6f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bd73:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81bd77:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81bd7a:	90                   	nop
  81bd7b:	eb 44                	jmp    81bdc1 <do_getaddr+0x16b>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81bd7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd81:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bd85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd89:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bd8d:	84 c0                	test   %al,%al
  81bd8f:	74 11                	je     81bda2 <do_getaddr+0x14c>
  81bd91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bd95:	48 8b 00             	mov    (%rax),%rax
  81bd98:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd9c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81bda0:	eb 0f                	jmp    81bdb1 <do_getaddr+0x15b>
  81bda2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bda6:	48 8b 00             	mov    (%rax),%rax
  81bda9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdad:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81bdb1:	66 89 02             	mov    %ax,(%rdx)
      break;
  81bdb4:	eb 0b                	jmp    81bdc1 <do_getaddr+0x16b>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81bdb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdba:	48 8b 00             	mov    (%rax),%rax
  81bdbd:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81bdc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdc5:	48 8b 00             	mov    (%rax),%rax
  81bdc8:	8b 40 14             	mov    0x14(%rax),%eax
  81bdcb:	89 c7                	mov    %eax,%edi
  81bdcd:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81bdd4:	00 00 00 
  81bdd7:	ff d0                	callq  *%rax
}
  81bdd9:	c9                   	leaveq 
  81bdda:	c3                   	retq   

000000000081bddb <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81bddb:	55                   	push   %rbp
  81bddc:	48 89 e5             	mov    %rsp,%rbp
  81bddf:	48 83 ec 10          	sub    $0x10,%rsp
  81bde3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81bde7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdeb:	48 8b 00             	mov    (%rax),%rax
  81bdee:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdf2:	48 85 c0             	test   %rax,%rax
  81bdf5:	74 34                	je     81be2b <do_close+0x50>
  81bdf7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdfb:	48 8b 00             	mov    (%rax),%rax
  81bdfe:	8b 00                	mov    (%rax),%eax
  81be00:	83 f8 10             	cmp    $0x10,%eax
  81be03:	75 26                	jne    81be2b <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81be05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be09:	48 8b 00             	mov    (%rax),%rax
  81be0c:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81be13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be17:	48 8b 00             	mov    (%rax),%rax
  81be1a:	48 89 c7             	mov    %rax,%rdi
  81be1d:	48 b8 76 ad 81 00 00 	movabs $0x81ad76,%rax
  81be24:	00 00 00 
  81be27:	ff d0                	callq  *%rax
  81be29:	eb 23                	jmp    81be4e <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81be2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be2f:	48 8b 00             	mov    (%rax),%rax
  81be32:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81be36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be3a:	48 8b 00             	mov    (%rax),%rax
  81be3d:	8b 40 14             	mov    0x14(%rax),%eax
  81be40:	89 c7                	mov    %eax,%edi
  81be42:	48 b8 65 7a 81 00 00 	movabs $0x817a65,%rax
  81be49:	00 00 00 
  81be4c:	ff d0                	callq  *%rax
  }
}
  81be4e:	c9                   	leaveq 
  81be4f:	c3                   	retq   

000000000081be50 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81be50:	55                   	push   %rbp
  81be51:	48 89 e5             	mov    %rsp,%rbp
  81be54:	53                   	push   %rbx
  81be55:	48 83 ec 38          	sub    $0x38,%rsp
  81be59:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81be5d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81be61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81be65:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81be69:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81be70:	00 00 00 
  81be73:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81be76:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81be7a:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81be7e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81be85:	00 00 00 
  81be88:	48 8b 00             	mov    (%rax),%rax
  81be8b:	0f b7 00             	movzwl (%rax),%eax
  81be8e:	0f b7 c0             	movzwl %ax,%eax
  81be91:	89 c7                	mov    %eax,%edi
  81be93:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81be9a:	00 00 00 
  81be9d:	ff d0                	callq  *%rax
  81be9f:	66 c1 e8 08          	shr    $0x8,%ax
  81bea3:	0f b7 c0             	movzwl %ax,%eax
  81bea6:	83 e0 0f             	and    $0xf,%eax
  81bea9:	c1 e0 02             	shl    $0x2,%eax
  81beac:	48 98                	cltq   
  81beae:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81beb2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81beb9:	00 00 00 
  81bebc:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81bebf:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81bec6:	00 00 00 
  81bec9:	48 8b 00             	mov    (%rax),%rax
  81becc:	0f b7 00             	movzwl (%rax),%eax
  81becf:	0f b7 c0             	movzwl %ax,%eax
  81bed2:	89 c7                	mov    %eax,%edi
  81bed4:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81bedb:	00 00 00 
  81bede:	ff d0                	callq  *%rax
  81bee0:	66 c1 e8 08          	shr    $0x8,%ax
  81bee4:	83 e0 0f             	and    $0xf,%eax
  81bee7:	c1 e0 02             	shl    $0x2,%eax
  81beea:	f7 d8                	neg    %eax
  81beec:	0f bf d0             	movswl %ax,%edx
  81beef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bef3:	89 d6                	mov    %edx,%esi
  81bef5:	48 89 c7             	mov    %rax,%rdi
  81bef8:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81beff:	00 00 00 
  81bf02:	ff d0                	callq  *%rax
  81bf04:	84 c0                	test   %al,%al
  81bf06:	75 0e                	jne    81bf16 <tcp_input+0xc6>
  81bf08:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bf0c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81bf10:	66 83 f8 13          	cmp    $0x13,%ax
  81bf14:	77 18                	ja     81bf2e <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81bf16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bf1a:	48 89 c7             	mov    %rax,%rdi
  81bf1d:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81bf24:	00 00 00 
  81bf27:	ff d0                	callq  *%rax
    return;
  81bf29:	e9 fd 0b 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81bf2e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81bf35:	00 00 00 
  81bf38:	48 8b 00             	mov    (%rax),%rax
  81bf3b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81bf3f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81bf43:	48 89 c6             	mov    %rax,%rsi
  81bf46:	48 89 d7             	mov    %rdx,%rdi
  81bf49:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  81bf50:	00 00 00 
  81bf53:	ff d0                	callq  *%rax
  81bf55:	84 c0                	test   %al,%al
  81bf57:	75 38                	jne    81bf91 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81bf59:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81bf60:	00 00 00 
  81bf63:	48 8b 00             	mov    (%rax),%rax
  81bf66:	8b 58 10             	mov    0x10(%rax),%ebx
  81bf69:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81bf6e:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81bf75:	00 00 00 
  81bf78:	ff d0                	callq  *%rax
  81bf7a:	21 c3                	and    %eax,%ebx
  81bf7c:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81bf81:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81bf88:	00 00 00 
  81bf8b:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81bf8d:	39 c3                	cmp    %eax,%ebx
  81bf8f:	75 18                	jne    81bfa9 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81bf91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bf95:	48 89 c7             	mov    %rax,%rdi
  81bf98:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81bf9f:	00 00 00 
  81bfa2:	ff d0                	callq  *%rax
    return;
  81bfa4:	e9 82 0b 00 00       	jmpq   81cb2b <tcp_input+0xcdb>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81bfa9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bfad:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81bfb1:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81bfb4:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81bfbb:	00 00 00 
  81bfbe:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81bfc1:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81bfc5:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81bfcc:	00 00 00 
  81bfcf:	48 8b 00             	mov    (%rax),%rax
  81bfd2:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81bfd6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bfda:	41 89 c8             	mov    %ecx,%r8d
  81bfdd:	b9 06 00 00 00       	mov    $0x6,%ecx
  81bfe2:	48 89 c7             	mov    %rax,%rdi
  81bfe5:	48 b8 49 22 81 00 00 	movabs $0x812249,%rax
  81bfec:	00 00 00 
  81bfef:	ff d0                	callq  *%rax
  81bff1:	66 85 c0             	test   %ax,%ax
  81bff4:	74 18                	je     81c00e <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81bff6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81bffa:	48 89 c7             	mov    %rax,%rdi
  81bffd:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c004:	00 00 00 
  81c007:	ff d0                	callq  *%rax
    return;
  81c009:	e9 1d 0b 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c00e:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c015:	00 00 00 
  81c018:	48 8b 00             	mov    (%rax),%rax
  81c01b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c01f:	0f b7 c0             	movzwl %ax,%eax
  81c022:	89 c7                	mov    %eax,%edi
  81c024:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81c02b:	00 00 00 
  81c02e:	ff d0                	callq  *%rax
  81c030:	66 c1 e8 0c          	shr    $0xc,%ax
  81c034:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c037:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c03b:	b8 00 00 00 00       	mov    $0x0,%eax
  81c040:	66 29 d0             	sub    %dx,%ax
  81c043:	c1 e0 02             	shl    $0x2,%eax
  81c046:	0f bf d0             	movswl %ax,%edx
  81c049:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c04d:	89 d6                	mov    %edx,%esi
  81c04f:	48 89 c7             	mov    %rax,%rdi
  81c052:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81c059:	00 00 00 
  81c05c:	ff d0                	callq  *%rax
  81c05e:	84 c0                	test   %al,%al
  81c060:	74 18                	je     81c07a <tcp_input+0x22a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c062:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c066:	48 89 c7             	mov    %rax,%rdi
  81c069:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c070:	00 00 00 
  81c073:	ff d0                	callq  *%rax
    return;
  81c075:	e9 b1 0a 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c07a:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c081:	00 00 00 
  81c084:	48 8b 18             	mov    (%rax),%rbx
  81c087:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c08e:	00 00 00 
  81c091:	48 8b 00             	mov    (%rax),%rax
  81c094:	0f b7 00             	movzwl (%rax),%eax
  81c097:	0f b7 c0             	movzwl %ax,%eax
  81c09a:	89 c7                	mov    %eax,%edi
  81c09c:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81c0a3:	00 00 00 
  81c0a6:	ff d0                	callq  *%rax
  81c0a8:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c0ab:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c0b2:	00 00 00 
  81c0b5:	48 8b 18             	mov    (%rax),%rbx
  81c0b8:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c0bf:	00 00 00 
  81c0c2:	48 8b 00             	mov    (%rax),%rax
  81c0c5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c0c9:	0f b7 c0             	movzwl %ax,%eax
  81c0cc:	89 c7                	mov    %eax,%edi
  81c0ce:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81c0d5:	00 00 00 
  81c0d8:	ff d0                	callq  *%rax
  81c0da:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c0de:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c0e5:	00 00 00 
  81c0e8:	48 8b 18             	mov    (%rax),%rbx
  81c0eb:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c0f2:	00 00 00 
  81c0f5:	48 8b 00             	mov    (%rax),%rax
  81c0f8:	8b 40 04             	mov    0x4(%rax),%eax
  81c0fb:	89 c7                	mov    %eax,%edi
  81c0fd:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81c104:	00 00 00 
  81c107:	ff d0                	callq  *%rax
  81c109:	89 43 04             	mov    %eax,0x4(%rbx)
  81c10c:	8b 53 04             	mov    0x4(%rbx),%edx
  81c10f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81c116:	00 00 00 
  81c119:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c11b:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c122:	00 00 00 
  81c125:	48 8b 18             	mov    (%rax),%rbx
  81c128:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c12f:	00 00 00 
  81c132:	48 8b 00             	mov    (%rax),%rax
  81c135:	8b 40 08             	mov    0x8(%rax),%eax
  81c138:	89 c7                	mov    %eax,%edi
  81c13a:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81c141:	00 00 00 
  81c144:	ff d0                	callq  *%rax
  81c146:	89 43 08             	mov    %eax,0x8(%rbx)
  81c149:	8b 53 08             	mov    0x8(%rbx),%edx
  81c14c:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81c153:	00 00 00 
  81c156:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c158:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c15f:	00 00 00 
  81c162:	48 8b 18             	mov    (%rax),%rbx
  81c165:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c16c:	00 00 00 
  81c16f:	48 8b 00             	mov    (%rax),%rax
  81c172:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c176:	0f b7 c0             	movzwl %ax,%eax
  81c179:	89 c7                	mov    %eax,%edi
  81c17b:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81c182:	00 00 00 
  81c185:	ff d0                	callq  *%rax
  81c187:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c18b:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c192:	00 00 00 
  81c195:	48 8b 00             	mov    (%rax),%rax
  81c198:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c19c:	0f b7 c0             	movzwl %ax,%eax
  81c19f:	89 c7                	mov    %eax,%edi
  81c1a1:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81c1a8:	00 00 00 
  81c1ab:	ff d0                	callq  *%rax
  81c1ad:	89 c2                	mov    %eax,%edx
  81c1af:	83 e2 3f             	and    $0x3f,%edx
  81c1b2:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c1b9:	00 00 00 
  81c1bc:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c1be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c1c2:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c1c6:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c1cd:	00 00 00 
  81c1d0:	0f b6 00             	movzbl (%rax),%eax
  81c1d3:	0f b6 c0             	movzbl %al,%eax
  81c1d6:	83 e0 01             	and    $0x1,%eax
  81c1d9:	84 c0                	test   %al,%al
  81c1db:	75 17                	jne    81c1f4 <tcp_input+0x3a4>
  81c1dd:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c1e4:	00 00 00 
  81c1e7:	0f b6 00             	movzbl (%rax),%eax
  81c1ea:	0f b6 c0             	movzbl %al,%eax
  81c1ed:	83 e0 02             	and    $0x2,%eax
  81c1f0:	85 c0                	test   %eax,%eax
  81c1f2:	74 07                	je     81c1fb <tcp_input+0x3ab>
  81c1f4:	b8 01 00 00 00       	mov    $0x1,%eax
  81c1f9:	eb 05                	jmp    81c200 <tcp_input+0x3b0>
  81c1fb:	b8 00 00 00 00       	mov    $0x0,%eax
  81c200:	01 c2                	add    %eax,%edx
  81c202:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81c209:	00 00 00 
  81c20c:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c20f:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c216:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c217:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c21e:	00 00 00 
  81c221:	48 8b 00             	mov    (%rax),%rax
  81c224:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c228:	e9 e2 01 00 00       	jmpq   81c40f <tcp_input+0x5bf>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c22d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c231:	8b 40 18             	mov    0x18(%rax),%eax
  81c234:	85 c0                	test   %eax,%eax
  81c236:	75 2a                	jne    81c262 <tcp_input+0x412>
  81c238:	48 ba 40 33 82 00 00 	movabs $0x823340,%rdx
  81c23f:	00 00 00 
  81c242:	be b5 00 00 00       	mov    $0xb5,%esi
  81c247:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81c24e:	00 00 00 
  81c251:	b8 00 00 00 00       	mov    $0x0,%eax
  81c256:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81c25d:	00 00 00 
  81c260:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81c262:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c266:	8b 40 18             	mov    0x18(%rax),%eax
  81c269:	83 f8 0a             	cmp    $0xa,%eax
  81c26c:	75 2a                	jne    81c298 <tcp_input+0x448>
  81c26e:	48 ba 80 33 82 00 00 	movabs $0x823380,%rdx
  81c275:	00 00 00 
  81c278:	be b6 00 00 00       	mov    $0xb6,%esi
  81c27d:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81c284:	00 00 00 
  81c287:	b8 00 00 00 00       	mov    $0x0,%eax
  81c28c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81c293:	00 00 00 
  81c296:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81c298:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c29c:	8b 40 18             	mov    0x18(%rax),%eax
  81c29f:	83 f8 01             	cmp    $0x1,%eax
  81c2a2:	75 2a                	jne    81c2ce <tcp_input+0x47e>
  81c2a4:	48 ba b0 33 82 00 00 	movabs $0x8233b0,%rdx
  81c2ab:	00 00 00 
  81c2ae:	be b7 00 00 00       	mov    $0xb7,%esi
  81c2b3:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81c2ba:	00 00 00 
  81c2bd:	b8 00 00 00 00       	mov    $0x0,%eax
  81c2c2:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81c2c9:	00 00 00 
  81c2cc:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81c2ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c2d2:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c2d6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c2dd:	00 00 00 
  81c2e0:	48 8b 00             	mov    (%rax),%rax
  81c2e3:	0f b7 00             	movzwl (%rax),%eax
  81c2e6:	66 39 c2             	cmp    %ax,%dx
  81c2e9:	0f 85 0c 01 00 00    	jne    81c3fb <tcp_input+0x5ab>
       pcb->local_port == tcphdr->dest &&
  81c2ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c2f3:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c2f7:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c2fe:	00 00 00 
  81c301:	48 8b 00             	mov    (%rax),%rax
  81c304:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81c308:	66 39 c2             	cmp    %ax,%dx
  81c30b:	0f 85 ea 00 00 00    	jne    81c3fb <tcp_input+0x5ab>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c315:	8b 50 04             	mov    0x4(%rax),%edx
  81c318:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c31f:	00 00 00 
  81c322:	48 8b 00             	mov    (%rax),%rax
  81c325:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81c328:	39 c2                	cmp    %eax,%edx
  81c32a:	0f 85 cb 00 00 00    	jne    81c3fb <tcp_input+0x5ab>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c330:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c334:	8b 10                	mov    (%rax),%edx
  81c336:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c33d:	00 00 00 
  81c340:	48 8b 00             	mov    (%rax),%rax
  81c343:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c346:	39 c2                	cmp    %eax,%edx
  81c348:	0f 85 ad 00 00 00    	jne    81c3fb <tcp_input+0x5ab>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81c34e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c352:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c356:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c35a:	75 2a                	jne    81c386 <tcp_input+0x536>
  81c35c:	48 ba d8 33 82 00 00 	movabs $0x8233d8,%rdx
  81c363:	00 00 00 
  81c366:	be c0 00 00 00       	mov    $0xc0,%esi
  81c36b:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81c372:	00 00 00 
  81c375:	b8 00 00 00 00       	mov    $0x0,%eax
  81c37a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81c381:	00 00 00 
  81c384:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81c386:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c38b:	74 36                	je     81c3c3 <tcp_input+0x573>
        prev->next = pcb->next;
  81c38d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c391:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c395:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c399:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81c39d:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c3a4:	00 00 00 
  81c3a7:	48 8b 10             	mov    (%rax),%rdx
  81c3aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c3ae:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81c3b2:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c3b9:	00 00 00 
  81c3bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c3c0:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81c3c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c3c7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c3cb:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c3cf:	75 4b                	jne    81c41c <tcp_input+0x5cc>
  81c3d1:	48 ba 08 34 82 00 00 	movabs $0x823408,%rdx
  81c3d8:	00 00 00 
  81c3db:	be c6 00 00 00       	mov    $0xc6,%esi
  81c3e0:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81c3e7:	00 00 00 
  81c3ea:	b8 00 00 00 00       	mov    $0x0,%eax
  81c3ef:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81c3f6:	00 00 00 
  81c3f9:	ff d1                	callq  *%rcx
      break;
    }
    prev = pcb;
  81c3fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c3ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c403:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c407:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c40b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c40f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c414:	0f 85 13 fe ff ff    	jne    81c22d <tcp_input+0x3dd>
  81c41a:	eb 01                	jmp    81c41d <tcp_input+0x5cd>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
  81c41c:	90                   	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81c41d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c422:	0f 85 f2 01 00 00    	jne    81c61a <tcp_input+0x7ca>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c428:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81c42f:	00 00 00 
  81c432:	48 8b 00             	mov    (%rax),%rax
  81c435:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c439:	e9 dd 00 00 00       	jmpq   81c51b <tcp_input+0x6cb>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81c43e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c442:	8b 40 18             	mov    0x18(%rax),%eax
  81c445:	83 f8 0a             	cmp    $0xa,%eax
  81c448:	74 2a                	je     81c474 <tcp_input+0x624>
  81c44a:	48 ba 38 34 82 00 00 	movabs $0x823438,%rdx
  81c451:	00 00 00 
  81c454:	be d0 00 00 00       	mov    $0xd0,%esi
  81c459:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81c460:	00 00 00 
  81c463:	b8 00 00 00 00       	mov    $0x0,%eax
  81c468:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81c46f:	00 00 00 
  81c472:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81c474:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c478:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c47c:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c483:	00 00 00 
  81c486:	48 8b 00             	mov    (%rax),%rax
  81c489:	0f b7 00             	movzwl (%rax),%eax
  81c48c:	66 39 c2             	cmp    %ax,%dx
  81c48f:	75 7e                	jne    81c50f <tcp_input+0x6bf>
         pcb->local_port == tcphdr->dest &&
  81c491:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c495:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c499:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c4a0:	00 00 00 
  81c4a3:	48 8b 00             	mov    (%rax),%rax
  81c4a6:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81c4aa:	66 39 c2             	cmp    %ax,%dx
  81c4ad:	75 60                	jne    81c50f <tcp_input+0x6bf>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c4af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4b3:	8b 50 04             	mov    0x4(%rax),%edx
  81c4b6:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c4bd:	00 00 00 
  81c4c0:	48 8b 00             	mov    (%rax),%rax
  81c4c3:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81c4c6:	39 c2                	cmp    %eax,%edx
  81c4c8:	75 45                	jne    81c50f <tcp_input+0x6bf>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c4ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4ce:	8b 10                	mov    (%rax),%edx
  81c4d0:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c4d7:	00 00 00 
  81c4da:	48 8b 00             	mov    (%rax),%rax
  81c4dd:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c4e0:	39 c2                	cmp    %eax,%edx
  81c4e2:	75 2b                	jne    81c50f <tcp_input+0x6bf>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81c4e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4e8:	48 89 c7             	mov    %rax,%rdi
  81c4eb:	48 b8 32 ce 81 00 00 	movabs $0x81ce32,%rax
  81c4f2:	00 00 00 
  81c4f5:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c4f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c4fb:	48 89 c7             	mov    %rax,%rdi
  81c4fe:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c505:	00 00 00 
  81c508:	ff d0                	callq  *%rax
        return;
  81c50a:	e9 1c 06 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c50f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c513:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c517:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c51b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c520:	0f 85 18 ff ff ff    	jne    81c43e <tcp_input+0x5ee>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81c526:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c52d:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c52e:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c535:	00 00 00 
  81c538:	48 8b 00             	mov    (%rax),%rax
  81c53b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c53f:	e9 cb 00 00 00       	jmpq   81c60f <tcp_input+0x7bf>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c544:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c548:	48 85 c0             	test   %rax,%rax
  81c54b:	74 28                	je     81c575 <tcp_input+0x725>
  81c54d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c551:	8b 00                	mov    (%rax),%eax
  81c553:	85 c0                	test   %eax,%eax
  81c555:	74 1e                	je     81c575 <tcp_input+0x725>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c557:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c55b:	8b 10                	mov    (%rax),%edx
  81c55d:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81c564:	00 00 00 
  81c567:	48 8b 00             	mov    (%rax),%rax
  81c56a:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c56d:	39 c2                	cmp    %eax,%edx
  81c56f:	0f 85 86 00 00 00    	jne    81c5fb <tcp_input+0x7ab>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81c575:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c579:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c57d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c584:	00 00 00 
  81c587:	48 8b 00             	mov    (%rax),%rax
  81c58a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c58e:	66 39 c2             	cmp    %ax,%dx
  81c591:	75 68                	jne    81c5fb <tcp_input+0x7ab>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81c593:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c598:	74 36                	je     81c5d0 <tcp_input+0x780>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81c59a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c59e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c5a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c5a6:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81c5aa:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c5b1:	00 00 00 
  81c5b4:	48 8b 10             	mov    (%rax),%rdx
  81c5b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c5bb:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81c5bf:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c5c6:	00 00 00 
  81c5c9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81c5cd:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81c5d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c5d4:	48 89 c7             	mov    %rax,%rdi
  81c5d7:	48 b8 32 cb 81 00 00 	movabs $0x81cb32,%rax
  81c5de:	00 00 00 
  81c5e1:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c5e3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c5e7:	48 89 c7             	mov    %rax,%rdi
  81c5ea:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c5f1:	00 00 00 
  81c5f4:	ff d0                	callq  *%rax
        return;
  81c5f6:	e9 30 05 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
      }
      prev = (struct tcp_pcb *)lpcb;
  81c5fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c5ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c603:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c607:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c60b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c60f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81c614:	0f 85 2a ff ff ff    	jne    81c544 <tcp_input+0x6f4>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81c61a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c61f:	0f 84 3b 04 00 00    	je     81ca60 <tcp_input+0xc10>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81c625:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c62c:	00 00 00 
  81c62f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81c636:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c63a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c63e:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c645:	00 00 00 
  81c648:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81c64c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c650:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c654:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c65b:	00 00 00 
  81c65e:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81c662:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c669:	00 00 00 
  81c66c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81c670:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81c674:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81c67b:	00 00 00 
  81c67e:	48 8b 10             	mov    (%rax),%rdx
  81c681:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81c688:	00 00 00 
  81c68b:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81c68f:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c696:	00 00 00 
  81c699:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81c6a0:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81c6a7:	00 00 00 
  81c6aa:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81c6ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6b1:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c6b8:	48 85 c0             	test   %rax,%rax
  81c6bb:	0f 84 9f 00 00 00    	je     81c760 <tcp_input+0x910>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81c6c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6c5:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c6cc:	48 85 c0             	test   %rax,%rax
  81c6cf:	74 32                	je     81c703 <tcp_input+0x8b3>
  81c6d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6d5:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  81c6dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6e0:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  81c6e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6eb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c6ef:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c6f3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c6f8:	48 89 c7             	mov    %rax,%rdi
  81c6fb:	41 ff d0             	callq  *%r8
  81c6fe:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c701:	eb 2e                	jmp    81c731 <tcp_input+0x8e1>
  81c703:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81c707:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c70b:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c712:	48 85 c0             	test   %rax,%rax
  81c715:	74 1a                	je     81c731 <tcp_input+0x8e1>
  81c717:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c71b:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c722:	48 89 c7             	mov    %rax,%rdi
  81c725:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c72c:	00 00 00 
  81c72f:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81c731:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c735:	75 11                	jne    81c748 <tcp_input+0x8f8>
        pcb->refused_data = NULL;
  81c737:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c73b:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81c742:	00 00 00 00 
  81c746:	eb 18                	jmp    81c760 <tcp_input+0x910>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81c748:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c74c:	48 89 c7             	mov    %rax,%rdi
  81c74f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c756:	00 00 00 
  81c759:	ff d0                	callq  *%rax
        return;
  81c75b:	e9 cb 03 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
      }
    }

    tcp_input_pcb = pcb;
  81c760:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81c767:	00 00 00 
  81c76a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c76e:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81c771:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c775:	48 89 c7             	mov    %rax,%rdi
  81c778:	48 b8 e0 ce 81 00 00 	movabs $0x81cee0,%rax
  81c77f:	00 00 00 
  81c782:	ff d0                	callq  *%rax
  81c784:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81c787:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81c78e:	00 00 00 
  81c791:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81c798:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81c79c:	0f 84 73 02 00 00    	je     81ca15 <tcp_input+0xbc5>
      if (recv_flags & TF_RESET) {
  81c7a2:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81c7a9:	00 00 00 
  81c7ac:	0f b6 00             	movzbl (%rax),%eax
  81c7af:	0f b6 c0             	movzbl %al,%eax
  81c7b2:	83 e0 08             	and    $0x8,%eax
  81c7b5:	85 c0                	test   %eax,%eax
  81c7b7:	74 67                	je     81c820 <tcp_input+0x9d0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81c7b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7bd:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81c7c4:	48 85 c0             	test   %rax,%rax
  81c7c7:	74 1d                	je     81c7e6 <tcp_input+0x996>
  81c7c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7cd:	48 8b 90 c8 00 00 00 	mov    0xc8(%rax),%rdx
  81c7d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7d8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c7dc:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81c7e1:	48 89 c7             	mov    %rax,%rdi
  81c7e4:	ff d2                	callq  *%rdx
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81c7e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c7ea:	48 89 c6             	mov    %rax,%rsi
  81c7ed:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81c7f4:	00 00 00 
  81c7f7:	48 b8 08 05 81 00 00 	movabs $0x810508,%rax
  81c7fe:	00 00 00 
  81c801:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81c803:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c807:	48 89 c6             	mov    %rax,%rsi
  81c80a:	bf 02 00 00 00       	mov    $0x2,%edi
  81c80f:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81c816:	00 00 00 
  81c819:	ff d0                	callq  *%rax
  81c81b:	e9 f5 01 00 00       	jmpq   81ca15 <tcp_input+0xbc5>
      } else if (recv_flags & TF_CLOSED) {
  81c820:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81c827:	00 00 00 
  81c82a:	0f b6 00             	movzbl (%rax),%eax
  81c82d:	0f b6 c0             	movzbl %al,%eax
  81c830:	83 e0 10             	and    $0x10,%eax
  81c833:	85 c0                	test   %eax,%eax
  81c835:	74 3a                	je     81c871 <tcp_input+0xa21>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81c837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c83b:	48 89 c6             	mov    %rax,%rsi
  81c83e:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81c845:	00 00 00 
  81c848:	48 b8 08 05 81 00 00 	movabs $0x810508,%rax
  81c84f:	00 00 00 
  81c852:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81c854:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c858:	48 89 c6             	mov    %rax,%rsi
  81c85b:	bf 02 00 00 00       	mov    $0x2,%edi
  81c860:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81c867:	00 00 00 
  81c86a:	ff d0                	callq  *%rax
  81c86c:	e9 a4 01 00 00       	jmpq   81ca15 <tcp_input+0xbc5>
      } else {
        err = ERR_OK;
  81c871:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81c875:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c879:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81c87d:	66 85 c0             	test   %ax,%ax
  81c880:	74 3e                	je     81c8c0 <tcp_input+0xa70>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81c882:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c886:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81c88d:	48 85 c0             	test   %rax,%rax
  81c890:	74 2e                	je     81c8c0 <tcp_input+0xa70>
  81c892:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c896:	4c 8b 80 a0 00 00 00 	mov    0xa0(%rax),%r8
  81c89d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8a1:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81c8a5:	0f b7 d0             	movzwl %ax,%edx
  81c8a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8ac:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c8b0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81c8b4:	48 89 ce             	mov    %rcx,%rsi
  81c8b7:	48 89 c7             	mov    %rax,%rdi
  81c8ba:	41 ff d0             	callq  *%r8
  81c8bd:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81c8c0:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c8c7:	00 00 00 
  81c8ca:	48 8b 00             	mov    (%rax),%rax
  81c8cd:	48 85 c0             	test   %rax,%rax
  81c8d0:	0f 84 cf 00 00 00    	je     81c9a5 <tcp_input+0xb55>
          if(flags & TCP_PSH) {
  81c8d6:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81c8dd:	00 00 00 
  81c8e0:	0f b6 00             	movzbl (%rax),%eax
  81c8e3:	0f b6 c0             	movzbl %al,%eax
  81c8e6:	83 e0 08             	and    $0x8,%eax
  81c8e9:	85 c0                	test   %eax,%eax
  81c8eb:	74 24                	je     81c911 <tcp_input+0xac1>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81c8ed:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c8f4:	00 00 00 
  81c8f7:	48 8b 00             	mov    (%rax),%rax
  81c8fa:	48 ba e8 74 b5 00 00 	movabs $0xb574e8,%rdx
  81c901:	00 00 00 
  81c904:	48 8b 12             	mov    (%rdx),%rdx
  81c907:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81c90b:	83 ca 01             	or     $0x1,%edx
  81c90e:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81c911:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c915:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c91c:	48 85 c0             	test   %rax,%rax
  81c91f:	74 34                	je     81c955 <tcp_input+0xb05>
  81c921:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c925:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  81c92c:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c933:	00 00 00 
  81c936:	48 8b 10             	mov    (%rax),%rdx
  81c939:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c93d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c941:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c945:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c94a:	48 89 c7             	mov    %rax,%rdi
  81c94d:	41 ff d0             	callq  *%r8
  81c950:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c953:	eb 32                	jmp    81c987 <tcp_input+0xb37>
  81c955:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81c959:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c960:	00 00 00 
  81c963:	48 8b 00             	mov    (%rax),%rax
  81c966:	48 85 c0             	test   %rax,%rax
  81c969:	74 1c                	je     81c987 <tcp_input+0xb37>
  81c96b:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c972:	00 00 00 
  81c975:	48 8b 00             	mov    (%rax),%rax
  81c978:	48 89 c7             	mov    %rax,%rdi
  81c97b:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81c982:	00 00 00 
  81c985:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81c987:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c98b:	74 18                	je     81c9a5 <tcp_input+0xb55>
            pcb->refused_data = recv_data;
  81c98d:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81c994:	00 00 00 
  81c997:	48 8b 10             	mov    (%rax),%rdx
  81c99a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c99e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81c9a5:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81c9ac:	00 00 00 
  81c9af:	0f b6 00             	movzbl (%rax),%eax
  81c9b2:	0f b6 c0             	movzbl %al,%eax
  81c9b5:	83 e0 20             	and    $0x20,%eax
  81c9b8:	85 c0                	test   %eax,%eax
  81c9ba:	74 40                	je     81c9fc <tcp_input+0xbac>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81c9bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9c0:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c9c7:	48 85 c0             	test   %rax,%rax
  81c9ca:	74 2c                	je     81c9f8 <tcp_input+0xba8>
  81c9cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9d0:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  81c9d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9db:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c9df:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c9e3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c9e8:	ba 00 00 00 00       	mov    $0x0,%edx
  81c9ed:	48 89 c7             	mov    %rax,%rdi
  81c9f0:	41 ff d0             	callq  *%r8
  81c9f3:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c9f6:	eb 04                	jmp    81c9fc <tcp_input+0xbac>
  81c9f8:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81c9fc:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81ca00:	75 13                	jne    81ca15 <tcp_input+0xbc5>
          tcp_output(pcb);
  81ca02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca06:	48 89 c7             	mov    %rax,%rdi
  81ca09:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81ca10:	00 00 00 
  81ca13:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81ca15:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ca1c:	00 00 00 
  81ca1f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ca23:	48 85 c0             	test   %rax,%rax
  81ca26:	0f 84 ff 00 00 00    	je     81cb2b <tcp_input+0xcdb>
    {
      pbuf_free(inseg.p);
  81ca2c:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ca33:	00 00 00 
  81ca36:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ca3a:	48 89 c7             	mov    %rax,%rdi
  81ca3d:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81ca44:	00 00 00 
  81ca47:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81ca49:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ca50:	00 00 00 
  81ca53:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ca5a:	00 
  81ca5b:	e9 cb 00 00 00       	jmpq   81cb2b <tcp_input+0xcdb>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81ca60:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca67:	00 00 00 
  81ca6a:	48 8b 00             	mov    (%rax),%rax
  81ca6d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ca71:	0f b7 c0             	movzwl %ax,%eax
  81ca74:	89 c7                	mov    %eax,%edi
  81ca76:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ca7d:	00 00 00 
  81ca80:	ff d0                	callq  *%rax
  81ca82:	0f b7 c0             	movzwl %ax,%eax
  81ca85:	83 e0 04             	and    $0x4,%eax
  81ca88:	85 c0                	test   %eax,%eax
  81ca8a:	0f 85 88 00 00 00    	jne    81cb18 <tcp_input+0xcc8>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81ca90:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ca97:	00 00 00 
  81ca9a:	48 8b 00             	mov    (%rax),%rax
  81ca9d:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81caa0:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81caa4:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81caab:	00 00 00 
  81caae:	48 8b 00             	mov    (%rax),%rax
  81cab1:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cab5:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81cab8:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cabf:	00 00 00 
  81cac2:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cac5:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81cac9:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cad0:	00 00 00 
  81cad3:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cad6:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cada:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81cae1:	00 00 00 
  81cae4:	0f b7 00             	movzwl (%rax),%eax
  81cae7:	0f b7 f0             	movzwl %ax,%esi
  81caea:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81caf1:	00 00 00 
  81caf4:	8b 00                	mov    (%rax),%eax
  81caf6:	01 c6                	add    %eax,%esi
  81caf8:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81caff:	00 00 00 
  81cb02:	8b 00                	mov    (%rax),%eax
  81cb04:	45 89 c1             	mov    %r8d,%r9d
  81cb07:	41 89 f8             	mov    %edi,%r8d
  81cb0a:	89 c7                	mov    %eax,%edi
  81cb0c:	48 b8 f9 3f 81 00 00 	movabs $0x813ff9,%rax
  81cb13:	00 00 00 
  81cb16:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81cb18:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81cb1c:	48 89 c7             	mov    %rax,%rdi
  81cb1f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81cb26:	00 00 00 
  81cb29:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81cb2b:	48 83 c4 38          	add    $0x38,%rsp
  81cb2f:	5b                   	pop    %rbx
  81cb30:	5d                   	pop    %rbp
  81cb31:	c3                   	retq   

000000000081cb32 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81cb32:	55                   	push   %rbp
  81cb33:	48 89 e5             	mov    %rsp,%rbp
  81cb36:	48 83 ec 30          	sub    $0x30,%rsp
  81cb3a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81cb3e:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cb45:	00 00 00 
  81cb48:	0f b6 00             	movzbl (%rax),%eax
  81cb4b:	0f b6 c0             	movzbl %al,%eax
  81cb4e:	83 e0 10             	and    $0x10,%eax
  81cb51:	85 c0                	test   %eax,%eax
  81cb53:	0f 84 90 00 00 00    	je     81cbe9 <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cb59:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cb60:	00 00 00 
  81cb63:	48 8b 00             	mov    (%rax),%rax
  81cb66:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cb69:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cb6d:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cb74:	00 00 00 
  81cb77:	48 8b 00             	mov    (%rax),%rax
  81cb7a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cb7e:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81cb81:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cb88:	00 00 00 
  81cb8b:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cb8e:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81cb92:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cb99:	00 00 00 
  81cb9c:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cb9f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cba3:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81cbaa:	00 00 00 
  81cbad:	0f b7 00             	movzwl (%rax),%eax
  81cbb0:	0f b7 f0             	movzwl %ax,%esi
  81cbb3:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cbba:	00 00 00 
  81cbbd:	8b 00                	mov    (%rax),%eax
  81cbbf:	01 c6                	add    %eax,%esi
  81cbc1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81cbc8:	00 00 00 
  81cbcb:	8b 00                	mov    (%rax),%eax
  81cbcd:	83 c0 01             	add    $0x1,%eax
  81cbd0:	45 89 c1             	mov    %r8d,%r9d
  81cbd3:	41 89 f8             	mov    %edi,%r8d
  81cbd6:	89 c7                	mov    %eax,%edi
  81cbd8:	48 b8 f9 3f 81 00 00 	movabs $0x813ff9,%rax
  81cbdf:	00 00 00 
  81cbe2:	ff d0                	callq  *%rax
  81cbe4:	e9 42 02 00 00       	jmpq   81ce2b <tcp_listen_input+0x2f9>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81cbe9:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cbf0:	00 00 00 
  81cbf3:	0f b6 00             	movzbl (%rax),%eax
  81cbf6:	0f b6 c0             	movzbl %al,%eax
  81cbf9:	83 e0 02             	and    $0x2,%eax
  81cbfc:	85 c0                	test   %eax,%eax
  81cbfe:	0f 84 27 02 00 00    	je     81ce2b <tcp_listen_input+0x2f9>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81cc04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc08:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81cc0c:	0f b6 c0             	movzbl %al,%eax
  81cc0f:	89 c7                	mov    %eax,%edi
  81cc11:	48 b8 73 01 81 00 00 	movabs $0x810173,%rax
  81cc18:	00 00 00 
  81cc1b:	ff d0                	callq  *%rax
  81cc1d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81cc21:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81cc26:	75 0a                	jne    81cc32 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81cc28:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81cc2d:	e9 fe 01 00 00       	jmpq   81ce30 <tcp_listen_input+0x2fe>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81cc32:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc39:	00 00 00 
  81cc3c:	48 8b 00             	mov    (%rax),%rax
  81cc3f:	48 83 c0 10          	add    $0x10,%rax
  81cc43:	48 85 c0             	test   %rax,%rax
  81cc46:	74 12                	je     81cc5a <tcp_listen_input+0x128>
  81cc48:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc4f:	00 00 00 
  81cc52:	48 8b 00             	mov    (%rax),%rax
  81cc55:	8b 40 10             	mov    0x10(%rax),%eax
  81cc58:	eb 05                	jmp    81cc5f <tcp_listen_input+0x12d>
  81cc5a:	b8 00 00 00 00       	mov    $0x0,%eax
  81cc5f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cc63:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81cc65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cc69:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81cc6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cc71:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81cc75:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc7c:	00 00 00 
  81cc7f:	48 8b 00             	mov    (%rax),%rax
  81cc82:	48 83 c0 0c          	add    $0xc,%rax
  81cc86:	48 85 c0             	test   %rax,%rax
  81cc89:	74 12                	je     81cc9d <tcp_listen_input+0x16b>
  81cc8b:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81cc92:	00 00 00 
  81cc95:	48 8b 00             	mov    (%rax),%rax
  81cc98:	8b 40 0c             	mov    0xc(%rax),%eax
  81cc9b:	eb 05                	jmp    81cca2 <tcp_listen_input+0x170>
  81cc9d:	b8 00 00 00 00       	mov    $0x0,%eax
  81cca2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cca6:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81cca9:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81ccb0:	00 00 00 
  81ccb3:	48 8b 00             	mov    (%rax),%rax
  81ccb6:	0f b7 10             	movzwl (%rax),%edx
  81ccb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ccbd:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81ccc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ccc5:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81cccc:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ccd3:	00 00 00 
  81ccd6:	8b 00                	mov    (%rax),%eax
  81ccd8:	8d 50 01             	lea    0x1(%rax),%edx
  81ccdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ccdf:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81cce2:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81cce9:	00 00 00 
  81ccec:	48 8b 00             	mov    (%rax),%rax
  81ccef:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81ccf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ccf7:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81ccfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ccff:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81cd03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd07:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81cd0b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cd12:	00 00 00 
  81cd15:	8b 00                	mov    (%rax),%eax
  81cd17:	8d 50 ff             	lea    -0x1(%rax),%edx
  81cd1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd1e:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81cd21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd25:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81cd29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd2d:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81cd31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd35:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81cd39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd3d:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81cd44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cd48:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81cd4c:	89 c2                	mov    %eax,%edx
  81cd4e:	66 81 e2 99 01       	and    $0x199,%dx
  81cd53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd57:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81cd5b:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cd62:	00 00 00 
  81cd65:	48 8b 10             	mov    (%rax),%rdx
  81cd68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd6c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81cd70:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cd77:	00 00 00 
  81cd7a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cd7e:	48 89 10             	mov    %rdx,(%rax)
  81cd81:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  81cd88:	00 00 00 
  81cd8b:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81cd8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cd91:	48 89 c7             	mov    %rax,%rdi
  81cd94:	48 b8 a1 f6 81 00 00 	movabs $0x81f6a1,%rax
  81cd9b:	00 00 00 
  81cd9e:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81cda0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cda4:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81cda8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cdac:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cdb0:	0f b7 c0             	movzwl %ax,%eax
  81cdb3:	48 89 d6             	mov    %rdx,%rsi
  81cdb6:	89 c7                	mov    %eax,%edi
  81cdb8:	48 b8 3d 07 81 00 00 	movabs $0x81073d,%rax
  81cdbf:	00 00 00 
  81cdc2:	ff d0                	callq  *%rax
  81cdc4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cdc8:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81cdcc:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81cdd1:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  81cdd8:	00 00 00 
  81cddb:	ff d0                	callq  *%rax
  81cddd:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81cde0:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81cde4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cde8:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  81cdef:	49 89 d1             	mov    %rdx,%r9
  81cdf2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81cdf8:	b9 12 00 00 00       	mov    $0x12,%ecx
  81cdfd:	ba 00 00 00 00       	mov    $0x0,%edx
  81ce02:	be 00 00 00 00       	mov    $0x0,%esi
  81ce07:	48 89 c7             	mov    %rax,%rdi
  81ce0a:	48 b8 1d 2c 81 00 00 	movabs $0x812c1d,%rax
  81ce11:	00 00 00 
  81ce14:	ff d0                	callq  *%rax
    return tcp_output(npcb);
  81ce16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ce1a:	48 89 c7             	mov    %rax,%rdi
  81ce1d:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81ce24:	00 00 00 
  81ce27:	ff d0                	callq  *%rax
  81ce29:	eb 05                	jmp    81ce30 <tcp_listen_input+0x2fe>
  }
  return ERR_OK;
  81ce2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ce30:	c9                   	leaveq 
  81ce31:	c3                   	retq   

000000000081ce32 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81ce32:	55                   	push   %rbp
  81ce33:	48 89 e5             	mov    %rsp,%rbp
  81ce36:	48 83 ec 10          	sub    $0x10,%rsp
  81ce3a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81ce3e:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ce45:	00 00 00 
  81ce48:	0f b7 00             	movzwl (%rax),%eax
  81ce4b:	0f b7 d0             	movzwl %ax,%edx
  81ce4e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ce55:	00 00 00 
  81ce58:	8b 00                	mov    (%rax),%eax
  81ce5a:	01 c2                	add    %eax,%edx
  81ce5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ce60:	8b 40 30             	mov    0x30(%rax),%eax
  81ce63:	89 d1                	mov    %edx,%ecx
  81ce65:	29 c1                	sub    %eax,%ecx
  81ce67:	89 c8                	mov    %ecx,%eax
  81ce69:	85 c0                	test   %eax,%eax
  81ce6b:	7e 25                	jle    81ce92 <tcp_timewait_input+0x60>
    pcb->rcv_nxt = seqno + tcplen;
  81ce6d:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ce74:	00 00 00 
  81ce77:	0f b7 00             	movzwl (%rax),%eax
  81ce7a:	0f b7 d0             	movzwl %ax,%edx
  81ce7d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ce84:	00 00 00 
  81ce87:	8b 00                	mov    (%rax),%eax
  81ce89:	01 c2                	add    %eax,%edx
  81ce8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ce8f:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81ce92:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ce99:	00 00 00 
  81ce9c:	0f b7 00             	movzwl (%rax),%eax
  81ce9f:	66 85 c0             	test   %ax,%ax
  81cea2:	74 27                	je     81cecb <tcp_timewait_input+0x99>
    tcp_ack_now(pcb);
  81cea4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cea8:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81ceac:	89 c2                	mov    %eax,%edx
  81ceae:	83 ca 02             	or     $0x2,%edx
  81ceb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ceb5:	88 50 2c             	mov    %dl,0x2c(%rax)
  81ceb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cebc:	48 89 c7             	mov    %rax,%rdi
  81cebf:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81cec6:	00 00 00 
  81cec9:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81cecb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cecf:	48 89 c7             	mov    %rax,%rdi
  81ced2:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81ced9:	00 00 00 
  81cedc:	ff d0                	callq  *%rax
}
  81cede:	c9                   	leaveq 
  81cedf:	c3                   	retq   

000000000081cee0 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81cee0:	55                   	push   %rbp
  81cee1:	48 89 e5             	mov    %rsp,%rbp
  81cee4:	48 83 ec 30          	sub    $0x30,%rsp
  81cee8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81ceec:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81cef0:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81cef4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81cefb:	00 00 00 
  81cefe:	0f b6 00             	movzbl (%rax),%eax
  81cf01:	0f b6 c0             	movzbl %al,%eax
  81cf04:	83 e0 04             	and    $0x4,%eax
  81cf07:	85 c0                	test   %eax,%eax
  81cf09:	0f 84 e4 00 00 00    	je     81cff3 <tcp_process+0x113>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81cf0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cf13:	8b 40 18             	mov    0x18(%rax),%eax
  81cf16:	83 f8 02             	cmp    $0x2,%eax
  81cf19:	75 1d                	jne    81cf38 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81cf1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cf1f:	8b 50 60             	mov    0x60(%rax),%edx
  81cf22:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81cf29:	00 00 00 
  81cf2c:	8b 00                	mov    (%rax),%eax
  81cf2e:	39 c2                	cmp    %eax,%edx
  81cf30:	75 51                	jne    81cf83 <tcp_process+0xa3>
        acceptable = 1;
  81cf32:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81cf36:	eb 4b                	jmp    81cf83 <tcp_process+0xa3>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81cf38:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cf3f:	00 00 00 
  81cf42:	8b 10                	mov    (%rax),%edx
  81cf44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cf48:	8b 40 30             	mov    0x30(%rax),%eax
  81cf4b:	89 d1                	mov    %edx,%ecx
  81cf4d:	29 c1                	sub    %eax,%ecx
  81cf4f:	89 c8                	mov    %ecx,%eax
  81cf51:	85 c0                	test   %eax,%eax
  81cf53:	78 2e                	js     81cf83 <tcp_process+0xa3>
  81cf55:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81cf5c:	00 00 00 
  81cf5f:	8b 10                	mov    (%rax),%edx
  81cf61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cf65:	8b 48 30             	mov    0x30(%rax),%ecx
  81cf68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cf6c:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81cf70:	0f b7 c0             	movzwl %ax,%eax
  81cf73:	01 c8                	add    %ecx,%eax
  81cf75:	89 d1                	mov    %edx,%ecx
  81cf77:	29 c1                	sub    %eax,%ecx
  81cf79:	89 c8                	mov    %ecx,%eax
  81cf7b:	85 c0                	test   %eax,%eax
  81cf7d:	7f 04                	jg     81cf83 <tcp_process+0xa3>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81cf7f:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81cf83:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81cf87:	74 60                	je     81cfe9 <tcp_process+0x109>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81cf89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cf8d:	8b 40 18             	mov    0x18(%rax),%eax
  81cf90:	85 c0                	test   %eax,%eax
  81cf92:	75 2a                	jne    81cfbe <tcp_process+0xde>
  81cf94:	48 ba 68 34 82 00 00 	movabs $0x823468,%rdx
  81cf9b:	00 00 00 
  81cf9e:	be 09 02 00 00       	mov    $0x209,%esi
  81cfa3:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81cfaa:	00 00 00 
  81cfad:	b8 00 00 00 00       	mov    $0x0,%eax
  81cfb2:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81cfb9:	00 00 00 
  81cfbc:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81cfbe:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81cfc5:	00 00 00 
  81cfc8:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81cfcb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cfcf:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81cfd3:	89 c2                	mov    %eax,%edx
  81cfd5:	83 e2 fe             	and    $0xfffffffe,%edx
  81cfd8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81cfdc:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81cfdf:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81cfe4:	e9 e7 0b 00 00       	jmpq   81dbd0 <tcp_process+0xcf0>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81cfe9:	b8 00 00 00 00       	mov    $0x0,%eax
  81cfee:	e9 dd 0b 00 00       	jmpq   81dbd0 <tcp_process+0xcf0>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81cff3:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81cffa:	00 00 00 
  81cffd:	8b 10                	mov    (%rax),%edx
  81cfff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d003:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d006:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d00a:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d011:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d015:	8b 40 18             	mov    0x18(%rax),%eax
  81d018:	83 f8 09             	cmp    $0x9,%eax
  81d01b:	0f 87 94 0b 00 00    	ja     81dbb5 <tcp_process+0xcd5>
  81d021:	89 c0                	mov    %eax,%eax
  81d023:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d02a:	00 
  81d02b:	48 b8 b8 34 82 00 00 	movabs $0x8234b8,%rax
  81d032:	00 00 00 
  81d035:	48 01 d0             	add    %rdx,%rax
  81d038:	48 8b 00             	mov    (%rax),%rax
  81d03b:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d03d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d044:	00 00 00 
  81d047:	0f b6 00             	movzbl (%rax),%eax
  81d04a:	0f b6 c0             	movzbl %al,%eax
  81d04d:	83 e0 10             	and    $0x10,%eax
  81d050:	85 c0                	test   %eax,%eax
  81d052:	0f 84 5c 02 00 00    	je     81d2b4 <tcp_process+0x3d4>
  81d058:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d05f:	00 00 00 
  81d062:	0f b6 00             	movzbl (%rax),%eax
  81d065:	0f b6 c0             	movzbl %al,%eax
  81d068:	83 e0 02             	and    $0x2,%eax
  81d06b:	85 c0                	test   %eax,%eax
  81d06d:	0f 84 41 02 00 00    	je     81d2b4 <tcp_process+0x3d4>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d073:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d077:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d07e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d082:	8b 40 04             	mov    0x4(%rax),%eax
  81d085:	89 c7                	mov    %eax,%edi
  81d087:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81d08e:	00 00 00 
  81d091:	ff d0                	callq  *%rax
  81d093:	8d 50 01             	lea    0x1(%rax),%edx
  81d096:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d09d:	00 00 00 
  81d0a0:	8b 00                	mov    (%rax),%eax
  81d0a2:	39 c2                	cmp    %eax,%edx
  81d0a4:	0f 85 0a 02 00 00    	jne    81d2b4 <tcp_process+0x3d4>
      pcb->snd_buf++;
  81d0aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0ae:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d0b2:	8d 50 01             	lea    0x1(%rax),%edx
  81d0b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0b9:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d0bd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d0c4:	00 00 00 
  81d0c7:	8b 00                	mov    (%rax),%eax
  81d0c9:	8d 50 01             	lea    0x1(%rax),%edx
  81d0cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0d0:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d0d3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d0da:	00 00 00 
  81d0dd:	8b 10                	mov    (%rax),%edx
  81d0df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0e3:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d0e6:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d0ed:	00 00 00 
  81d0f0:	48 8b 00             	mov    (%rax),%rax
  81d0f3:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d0f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0fb:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d0ff:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d106:	00 00 00 
  81d109:	8b 00                	mov    (%rax),%eax
  81d10b:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d10e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d112:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d115:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d119:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d120:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d124:	48 89 c7             	mov    %rax,%rdi
  81d127:	48 b8 a1 f6 81 00 00 	movabs $0x81f6a1,%rax
  81d12e:	00 00 00 
  81d131:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d133:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d137:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d13b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d13f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d143:	0f b7 c0             	movzwl %ax,%eax
  81d146:	48 89 d6             	mov    %rdx,%rsi
  81d149:	89 c7                	mov    %eax,%edi
  81d14b:	48 b8 3d 07 81 00 00 	movabs $0x81073d,%rax
  81d152:	00 00 00 
  81d155:	ff d0                	callq  *%rax
  81d157:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d15b:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d15f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d163:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d167:	89 d0                	mov    %edx,%eax
  81d169:	c1 e0 02             	shl    $0x2,%eax
  81d16c:	01 d0                	add    %edx,%eax
  81d16e:	01 c0                	add    %eax,%eax
  81d170:	89 c2                	mov    %eax,%edx
  81d172:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d176:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d17a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d17e:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d182:	66 83 f8 01          	cmp    $0x1,%ax
  81d186:	75 0c                	jne    81d194 <tcp_process+0x2b4>
  81d188:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d18c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d190:	01 c0                	add    %eax,%eax
  81d192:	eb 08                	jmp    81d19c <tcp_process+0x2bc>
  81d194:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d198:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d19c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d1a0:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d1a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1a8:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d1ac:	66 85 c0             	test   %ax,%ax
  81d1af:	75 2a                	jne    81d1db <tcp_process+0x2fb>
  81d1b1:	48 ba 88 34 82 00 00 	movabs $0x823488,%rdx
  81d1b8:	00 00 00 
  81d1bb:	be 35 02 00 00       	mov    $0x235,%esi
  81d1c0:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81d1c7:	00 00 00 
  81d1ca:	b8 00 00 00 00       	mov    $0x0,%eax
  81d1cf:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81d1d6:	00 00 00 
  81d1d9:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d1db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1df:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d1e3:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d1e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1ea:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d1ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1f2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d1f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d1fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d201:	48 8b 10             	mov    (%rax),%rdx
  81d204:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d208:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d20f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d213:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d21a:	48 85 c0             	test   %rax,%rax
  81d21d:	75 0c                	jne    81d22b <tcp_process+0x34b>
        pcb->rtime = -1;
  81d21f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d223:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d229:	eb 12                	jmp    81d23d <tcp_process+0x35d>
      else {
        pcb->rtime = 0;
  81d22b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d22f:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d235:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d239:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d23d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d241:	48 89 c7             	mov    %rax,%rdi
  81d244:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  81d24b:	00 00 00 
  81d24e:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d250:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d254:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d25b:	48 85 c0             	test   %rax,%rax
  81d25e:	74 28                	je     81d288 <tcp_process+0x3a8>
  81d260:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d264:	4c 8b 80 b0 00 00 00 	mov    0xb0(%rax),%r8
  81d26b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d26f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d273:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81d277:	ba 00 00 00 00       	mov    $0x0,%edx
  81d27c:	48 89 ce             	mov    %rcx,%rsi
  81d27f:	48 89 c7             	mov    %rax,%rdi
  81d282:	41 ff d0             	callq  *%r8
  81d285:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81d288:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d28c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d290:	89 c2                	mov    %eax,%edx
  81d292:	83 ca 02             	or     $0x2,%edx
  81d295:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d299:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d29c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2a0:	48 89 c7             	mov    %rax,%rdi
  81d2a3:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81d2aa:	00 00 00 
  81d2ad:	ff d0                	callq  *%rax
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d2af:	e9 04 09 00 00       	jmpq   81dbb8 <tcp_process+0xcd8>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81d2b4:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d2bb:	00 00 00 
  81d2be:	0f b6 00             	movzbl (%rax),%eax
  81d2c1:	0f b6 c0             	movzbl %al,%eax
  81d2c4:	83 e0 10             	and    $0x10,%eax
  81d2c7:	85 c0                	test   %eax,%eax
  81d2c9:	0f 84 e9 08 00 00    	je     81dbb8 <tcp_process+0xcd8>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d2cf:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d2d6:	00 00 00 
  81d2d9:	48 8b 00             	mov    (%rax),%rax
  81d2dc:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d2df:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81d2e3:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d2ea:	00 00 00 
  81d2ed:	48 8b 00             	mov    (%rax),%rax
  81d2f0:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d2f4:	0f b7 f8             	movzwl %ax,%edi
  81d2f7:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d2fe:	00 00 00 
  81d301:	48 8b 00             	mov    (%rax),%rax
  81d304:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d308:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d30f:	00 00 00 
  81d312:	48 8b 00             	mov    (%rax),%rax
  81d315:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d319:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d320:	00 00 00 
  81d323:	0f b7 00             	movzwl (%rax),%eax
  81d326:	0f b7 f0             	movzwl %ax,%esi
  81d329:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d330:	00 00 00 
  81d333:	8b 00                	mov    (%rax),%eax
  81d335:	01 c6                	add    %eax,%esi
  81d337:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d33e:	00 00 00 
  81d341:	8b 00                	mov    (%rax),%eax
  81d343:	45 89 c1             	mov    %r8d,%r9d
  81d346:	41 89 f8             	mov    %edi,%r8d
  81d349:	89 c7                	mov    %eax,%edi
  81d34b:	48 b8 f9 3f 81 00 00 	movabs $0x813ff9,%rax
  81d352:	00 00 00 
  81d355:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d357:	e9 5c 08 00 00       	jmpq   81dbb8 <tcp_process+0xcd8>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d35c:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d363:	00 00 00 
  81d366:	0f b6 00             	movzbl (%rax),%eax
  81d369:	0f b6 c0             	movzbl %al,%eax
  81d36c:	83 e0 10             	and    $0x10,%eax
  81d36f:	85 c0                	test   %eax,%eax
  81d371:	0f 84 44 08 00 00    	je     81dbbb <tcp_process+0xcdb>
       !(flags & TCP_RST)) {
  81d377:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d37e:	00 00 00 
  81d381:	0f b6 00             	movzbl (%rax),%eax
  81d384:	0f b6 c0             	movzbl %al,%eax
  81d387:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d38a:	85 c0                	test   %eax,%eax
  81d38c:	0f 85 29 08 00 00    	jne    81dbbb <tcp_process+0xcdb>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d392:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d396:	8b 40 54             	mov    0x54(%rax),%eax
  81d399:	89 c2                	mov    %eax,%edx
  81d39b:	f7 d2                	not    %edx
  81d39d:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d3a4:	00 00 00 
  81d3a7:	8b 00                	mov    (%rax),%eax
  81d3a9:	01 d0                	add    %edx,%eax
  81d3ab:	85 c0                	test   %eax,%eax
  81d3ad:	0f 88 62 01 00 00    	js     81d515 <tcp_process+0x635>
  81d3b3:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d3ba:	00 00 00 
  81d3bd:	8b 10                	mov    (%rax),%edx
  81d3bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3c3:	8b 40 60             	mov    0x60(%rax),%eax
  81d3c6:	89 d1                	mov    %edx,%ecx
  81d3c8:	29 c1                	sub    %eax,%ecx
  81d3ca:	89 c8                	mov    %ecx,%eax
  81d3cc:	85 c0                	test   %eax,%eax
  81d3ce:	0f 8f 41 01 00 00    	jg     81d515 <tcp_process+0x635>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81d3d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3d8:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81d3df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3e3:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d3ea:	48 85 c0             	test   %rax,%rax
  81d3ed:	75 2a                	jne    81d419 <tcp_process+0x539>
  81d3ef:	48 ba 9e 34 82 00 00 	movabs $0x82349e,%rdx
  81d3f6:	00 00 00 
  81d3f9:	be 5b 02 00 00       	mov    $0x25b,%esi
  81d3fe:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81d405:	00 00 00 
  81d408:	b8 00 00 00 00       	mov    $0x0,%eax
  81d40d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81d414:	00 00 00 
  81d417:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81d419:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d41d:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d424:	48 85 c0             	test   %rax,%rax
  81d427:	74 28                	je     81d451 <tcp_process+0x571>
  81d429:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d42d:	4c 8b 80 b8 00 00 00 	mov    0xb8(%rax),%r8
  81d434:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d438:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d43c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81d440:	ba 00 00 00 00       	mov    $0x0,%edx
  81d445:	48 89 ce             	mov    %rcx,%rsi
  81d448:	48 89 c7             	mov    %rax,%rdi
  81d44b:	41 ff d0             	callq  *%r8
  81d44e:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81d451:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81d455:	74 1d                	je     81d474 <tcp_process+0x594>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81d457:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d45b:	48 89 c7             	mov    %rax,%rdi
  81d45e:	48 b8 31 e9 80 00 00 	movabs $0x80e931,%rax
  81d465:	00 00 00 
  81d468:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81d46a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81d46f:	e9 5c 07 00 00       	jmpq   81dbd0 <tcp_process+0xcf0>
        }
        old_cwnd = pcb->cwnd;
  81d474:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d478:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d47c:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81d480:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d484:	48 89 c7             	mov    %rax,%rdi
  81d487:	48 b8 d2 db 81 00 00 	movabs $0x81dbd2,%rax
  81d48e:	00 00 00 
  81d491:	ff d0                	callq  *%rax
  81d493:	88 45 ed             	mov    %al,-0x13(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d496:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  81d49b:	75 0c                	jne    81d4a9 <tcp_process+0x5c9>
  81d49d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4a1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d4a5:	01 c0                	add    %eax,%eax
  81d4a7:	eb 08                	jmp    81d4b1 <tcp_process+0x5d1>
  81d4a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4ad:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d4b1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d4b5:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81d4b9:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d4c0:	00 00 00 
  81d4c3:	0f b6 00             	movzbl (%rax),%eax
  81d4c6:	0f b6 c0             	movzbl %al,%eax
  81d4c9:	83 e0 01             	and    $0x1,%eax
  81d4cc:	84 c0                	test   %al,%al
  81d4ce:	0f 84 ce 00 00 00    	je     81d5a2 <tcp_process+0x6c2>
  81d4d4:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d4d8:	0f 84 c4 00 00 00    	je     81d5a2 <tcp_process+0x6c2>
          tcp_ack_now(pcb);
  81d4de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4e2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d4e6:	89 c2                	mov    %eax,%edx
  81d4e8:	83 ca 02             	or     $0x2,%edx
  81d4eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4ef:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d4f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d4f6:	48 89 c7             	mov    %rax,%rdi
  81d4f9:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81d500:	00 00 00 
  81d503:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81d505:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d509:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d510:	e9 8d 00 00 00       	jmpq   81d5a2 <tcp_process+0x6c2>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81d515:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d51c:	00 00 00 
  81d51f:	48 8b 00             	mov    (%rax),%rax
  81d522:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d525:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81d529:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81d530:	00 00 00 
  81d533:	48 8b 00             	mov    (%rax),%rax
  81d536:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d53a:	0f b7 f8             	movzwl %ax,%edi
  81d53d:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d544:	00 00 00 
  81d547:	48 8b 00             	mov    (%rax),%rax
  81d54a:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d54e:	48 b8 d0 74 b5 00 00 	movabs $0xb574d0,%rax
  81d555:	00 00 00 
  81d558:	48 8b 00             	mov    (%rax),%rax
  81d55b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d55f:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81d566:	00 00 00 
  81d569:	0f b7 00             	movzwl (%rax),%eax
  81d56c:	0f b7 f0             	movzwl %ax,%esi
  81d56f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81d576:	00 00 00 
  81d579:	8b 00                	mov    (%rax),%eax
  81d57b:	01 c6                	add    %eax,%esi
  81d57d:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d584:	00 00 00 
  81d587:	8b 00                	mov    (%rax),%eax
  81d589:	45 89 c1             	mov    %r8d,%r9d
  81d58c:	41 89 f8             	mov    %edi,%r8d
  81d58f:	89 c7                	mov    %eax,%edi
  81d591:	48 b8 f9 3f 81 00 00 	movabs $0x813ff9,%rax
  81d598:	00 00 00 
  81d59b:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81d59d:	e9 19 06 00 00       	jmpq   81dbbb <tcp_process+0xcdb>
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d5a2:	90                   	nop
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81d5a3:	e9 13 06 00 00       	jmpq   81dbbb <tcp_process+0xcdb>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81d5a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5ac:	48 89 c7             	mov    %rax,%rdi
  81d5af:	48 b8 d2 db 81 00 00 	movabs $0x81dbd2,%rax
  81d5b6:	00 00 00 
  81d5b9:	ff d0                	callq  *%rax
  81d5bb:	88 45 ed             	mov    %al,-0x13(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81d5be:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d5c5:	00 00 00 
  81d5c8:	0f b6 00             	movzbl (%rax),%eax
  81d5cb:	0f b6 c0             	movzbl %al,%eax
  81d5ce:	83 e0 01             	and    $0x1,%eax
  81d5d1:	84 c0                	test   %al,%al
  81d5d3:	0f 84 e5 05 00 00    	je     81dbbe <tcp_process+0xcde>
  81d5d9:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d5dd:	0f 84 db 05 00 00    	je     81dbbe <tcp_process+0xcde>
      tcp_ack_now(pcb);
  81d5e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5e7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d5eb:	89 c2                	mov    %eax,%edx
  81d5ed:	83 ca 02             	or     $0x2,%edx
  81d5f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5f4:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d5f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5fb:	48 89 c7             	mov    %rax,%rdi
  81d5fe:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81d605:	00 00 00 
  81d608:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81d60a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d60e:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81d615:	e9 a4 05 00 00       	jmpq   81dbbe <tcp_process+0xcde>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81d61a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d61e:	48 89 c7             	mov    %rax,%rdi
  81d621:	48 b8 d2 db 81 00 00 	movabs $0x81dbd2,%rax
  81d628:	00 00 00 
  81d62b:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81d62d:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d634:	00 00 00 
  81d637:	0f b6 00             	movzbl (%rax),%eax
  81d63a:	0f b6 c0             	movzbl %al,%eax
  81d63d:	83 e0 01             	and    $0x1,%eax
  81d640:	84 c0                	test   %al,%al
  81d642:	0f 84 bf 01 00 00    	je     81d807 <tcp_process+0x927>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d648:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d64f:	00 00 00 
  81d652:	0f b6 00             	movzbl (%rax),%eax
  81d655:	0f b6 c0             	movzbl %al,%eax
  81d658:	83 e0 10             	and    $0x10,%eax
  81d65b:	85 c0                	test   %eax,%eax
  81d65d:	0f 84 6d 01 00 00    	je     81d7d0 <tcp_process+0x8f0>
  81d663:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d667:	8b 50 60             	mov    0x60(%rax),%edx
  81d66a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d671:	00 00 00 
  81d674:	8b 00                	mov    (%rax),%eax
  81d676:	39 c2                	cmp    %eax,%edx
  81d678:	0f 85 52 01 00 00    	jne    81d7d0 <tcp_process+0x8f0>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81d67e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d682:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d686:	89 c2                	mov    %eax,%edx
  81d688:	83 ca 02             	or     $0x2,%edx
  81d68b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d68f:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d692:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d696:	48 89 c7             	mov    %rax,%rdi
  81d699:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81d6a0:	00 00 00 
  81d6a3:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81d6a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6a9:	48 89 c7             	mov    %rax,%rdi
  81d6ac:	48 b8 06 04 81 00 00 	movabs $0x810406,%rax
  81d6b3:	00 00 00 
  81d6b6:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81d6b8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d6bf:	00 00 00 
  81d6c2:	48 8b 00             	mov    (%rax),%rax
  81d6c5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d6c9:	75 23                	jne    81d6ee <tcp_process+0x80e>
  81d6cb:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d6d2:	00 00 00 
  81d6d5:	48 8b 00             	mov    (%rax),%rax
  81d6d8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d6dc:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d6e3:	00 00 00 
  81d6e6:	48 89 10             	mov    %rdx,(%rax)
  81d6e9:	e9 94 00 00 00       	jmpq   81d782 <tcp_process+0x8a2>
  81d6ee:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d6f5:	00 00 00 
  81d6f8:	48 8b 10             	mov    (%rax),%rdx
  81d6fb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d702:	00 00 00 
  81d705:	48 89 10             	mov    %rdx,(%rax)
  81d708:	eb 66                	jmp    81d770 <tcp_process+0x890>
  81d70a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d711:	00 00 00 
  81d714:	48 8b 00             	mov    (%rax),%rax
  81d717:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d71b:	48 85 c0             	test   %rax,%rax
  81d71e:	74 32                	je     81d752 <tcp_process+0x872>
  81d720:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d727:	00 00 00 
  81d72a:	48 8b 00             	mov    (%rax),%rax
  81d72d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d731:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d735:	75 1b                	jne    81d752 <tcp_process+0x872>
  81d737:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d73e:	00 00 00 
  81d741:	48 8b 00             	mov    (%rax),%rax
  81d744:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d748:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d74c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d750:	eb 30                	jmp    81d782 <tcp_process+0x8a2>
  81d752:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d759:	00 00 00 
  81d75c:	48 8b 00             	mov    (%rax),%rax
  81d75f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d763:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d76a:	00 00 00 
  81d76d:	48 89 10             	mov    %rdx,(%rax)
  81d770:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d777:	00 00 00 
  81d77a:	48 8b 00             	mov    (%rax),%rax
  81d77d:	48 85 c0             	test   %rax,%rax
  81d780:	75 88                	jne    81d70a <tcp_process+0x82a>
  81d782:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d786:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81d78d:	00 
        pcb->state = TIME_WAIT;
  81d78e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d792:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81d799:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81d7a0:	00 00 00 
  81d7a3:	48 8b 10             	mov    (%rax),%rdx
  81d7a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7aa:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d7ae:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81d7b5:	00 00 00 
  81d7b8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d7bc:	48 89 10             	mov    %rdx,(%rax)
  81d7bf:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  81d7c6:	00 00 00 
  81d7c9:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81d7cb:	e9 f1 03 00 00       	jmpq   81dbc1 <tcp_process+0xce1>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
  81d7d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7d4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d7d8:	89 c2                	mov    %eax,%edx
  81d7da:	83 ca 02             	or     $0x2,%edx
  81d7dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7e1:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d7e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7e8:	48 89 c7             	mov    %rax,%rdi
  81d7eb:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81d7f2:	00 00 00 
  81d7f5:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81d7f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7fb:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81d802:	e9 ba 03 00 00       	jmpq   81dbc1 <tcp_process+0xce1>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d807:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d80e:	00 00 00 
  81d811:	0f b6 00             	movzbl (%rax),%eax
  81d814:	0f b6 c0             	movzbl %al,%eax
  81d817:	83 e0 10             	and    $0x10,%eax
  81d81a:	85 c0                	test   %eax,%eax
  81d81c:	0f 84 9f 03 00 00    	je     81dbc1 <tcp_process+0xce1>
  81d822:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d826:	8b 50 60             	mov    0x60(%rax),%edx
  81d829:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81d830:	00 00 00 
  81d833:	8b 00                	mov    (%rax),%eax
  81d835:	39 c2                	cmp    %eax,%edx
  81d837:	0f 85 84 03 00 00    	jne    81dbc1 <tcp_process+0xce1>
      pcb->state = FIN_WAIT_2;
  81d83d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d841:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81d848:	e9 74 03 00 00       	jmpq   81dbc1 <tcp_process+0xce1>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81d84d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d851:	48 89 c7             	mov    %rax,%rdi
  81d854:	48 b8 d2 db 81 00 00 	movabs $0x81dbd2,%rax
  81d85b:	00 00 00 
  81d85e:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81d860:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d867:	00 00 00 
  81d86a:	0f b6 00             	movzbl (%rax),%eax
  81d86d:	0f b6 c0             	movzbl %al,%eax
  81d870:	83 e0 01             	and    $0x1,%eax
  81d873:	84 c0                	test   %al,%al
  81d875:	0f 84 49 03 00 00    	je     81dbc4 <tcp_process+0xce4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81d87b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d87f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d883:	89 c2                	mov    %eax,%edx
  81d885:	83 ca 02             	or     $0x2,%edx
  81d888:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d88c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d88f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d893:	48 89 c7             	mov    %rax,%rdi
  81d896:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81d89d:	00 00 00 
  81d8a0:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81d8a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d8a6:	48 89 c7             	mov    %rax,%rdi
  81d8a9:	48 b8 06 04 81 00 00 	movabs $0x810406,%rax
  81d8b0:	00 00 00 
  81d8b3:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81d8b5:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8bc:	00 00 00 
  81d8bf:	48 8b 00             	mov    (%rax),%rax
  81d8c2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d8c6:	75 23                	jne    81d8eb <tcp_process+0xa0b>
  81d8c8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8cf:	00 00 00 
  81d8d2:	48 8b 00             	mov    (%rax),%rax
  81d8d5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d8d9:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8e0:	00 00 00 
  81d8e3:	48 89 10             	mov    %rdx,(%rax)
  81d8e6:	e9 94 00 00 00       	jmpq   81d97f <tcp_process+0xa9f>
  81d8eb:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8f2:	00 00 00 
  81d8f5:	48 8b 10             	mov    (%rax),%rdx
  81d8f8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d8ff:	00 00 00 
  81d902:	48 89 10             	mov    %rdx,(%rax)
  81d905:	eb 66                	jmp    81d96d <tcp_process+0xa8d>
  81d907:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d90e:	00 00 00 
  81d911:	48 8b 00             	mov    (%rax),%rax
  81d914:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d918:	48 85 c0             	test   %rax,%rax
  81d91b:	74 32                	je     81d94f <tcp_process+0xa6f>
  81d91d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d924:	00 00 00 
  81d927:	48 8b 00             	mov    (%rax),%rax
  81d92a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d92e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d932:	75 1b                	jne    81d94f <tcp_process+0xa6f>
  81d934:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d93b:	00 00 00 
  81d93e:	48 8b 00             	mov    (%rax),%rax
  81d941:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d945:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d949:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d94d:	eb 30                	jmp    81d97f <tcp_process+0xa9f>
  81d94f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d956:	00 00 00 
  81d959:	48 8b 00             	mov    (%rax),%rax
  81d95c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d960:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d967:	00 00 00 
  81d96a:	48 89 10             	mov    %rdx,(%rax)
  81d96d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d974:	00 00 00 
  81d977:	48 8b 00             	mov    (%rax),%rax
  81d97a:	48 85 c0             	test   %rax,%rax
  81d97d:	75 88                	jne    81d907 <tcp_process+0xa27>
  81d97f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d983:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81d98a:	00 
      pcb->state = TIME_WAIT;
  81d98b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d98f:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81d996:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81d99d:	00 00 00 
  81d9a0:	48 8b 10             	mov    (%rax),%rdx
  81d9a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9a7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d9ab:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81d9b2:	00 00 00 
  81d9b5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d9b9:	48 89 10             	mov    %rdx,(%rax)
  81d9bc:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  81d9c3:	00 00 00 
  81d9c6:	ff d0                	callq  *%rax
    }
    break;
  81d9c8:	e9 f7 01 00 00       	jmpq   81dbc4 <tcp_process+0xce4>
  case CLOSING:
    tcp_receive(pcb);
  81d9cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9d1:	48 89 c7             	mov    %rax,%rdi
  81d9d4:	48 b8 d2 db 81 00 00 	movabs $0x81dbd2,%rax
  81d9db:	00 00 00 
  81d9de:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d9e0:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81d9e7:	00 00 00 
  81d9ea:	0f b6 00             	movzbl (%rax),%eax
  81d9ed:	0f b6 c0             	movzbl %al,%eax
  81d9f0:	83 e0 10             	and    $0x10,%eax
  81d9f3:	85 c0                	test   %eax,%eax
  81d9f5:	0f 84 cc 01 00 00    	je     81dbc7 <tcp_process+0xce7>
  81d9fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9ff:	8b 50 60             	mov    0x60(%rax),%edx
  81da02:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81da09:	00 00 00 
  81da0c:	8b 00                	mov    (%rax),%eax
  81da0e:	39 c2                	cmp    %eax,%edx
  81da10:	0f 85 b1 01 00 00    	jne    81dbc7 <tcp_process+0xce7>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81da16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da1a:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81da1e:	89 c2                	mov    %eax,%edx
  81da20:	83 ca 02             	or     $0x2,%edx
  81da23:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da27:	88 50 2c             	mov    %dl,0x2c(%rax)
  81da2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da2e:	48 89 c7             	mov    %rax,%rdi
  81da31:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81da38:	00 00 00 
  81da3b:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81da3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da41:	48 89 c7             	mov    %rax,%rdi
  81da44:	48 b8 06 04 81 00 00 	movabs $0x810406,%rax
  81da4b:	00 00 00 
  81da4e:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81da50:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81da57:	00 00 00 
  81da5a:	48 8b 00             	mov    (%rax),%rax
  81da5d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81da61:	75 23                	jne    81da86 <tcp_process+0xba6>
  81da63:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81da6a:	00 00 00 
  81da6d:	48 8b 00             	mov    (%rax),%rax
  81da70:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81da74:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81da7b:	00 00 00 
  81da7e:	48 89 10             	mov    %rdx,(%rax)
  81da81:	e9 94 00 00 00       	jmpq   81db1a <tcp_process+0xc3a>
  81da86:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81da8d:	00 00 00 
  81da90:	48 8b 10             	mov    (%rax),%rdx
  81da93:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81da9a:	00 00 00 
  81da9d:	48 89 10             	mov    %rdx,(%rax)
  81daa0:	eb 66                	jmp    81db08 <tcp_process+0xc28>
  81daa2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81daa9:	00 00 00 
  81daac:	48 8b 00             	mov    (%rax),%rax
  81daaf:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dab3:	48 85 c0             	test   %rax,%rax
  81dab6:	74 32                	je     81daea <tcp_process+0xc0a>
  81dab8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dabf:	00 00 00 
  81dac2:	48 8b 00             	mov    (%rax),%rax
  81dac5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dac9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dacd:	75 1b                	jne    81daea <tcp_process+0xc0a>
  81dacf:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dad6:	00 00 00 
  81dad9:	48 8b 00             	mov    (%rax),%rax
  81dadc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dae0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dae4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dae8:	eb 30                	jmp    81db1a <tcp_process+0xc3a>
  81daea:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81daf1:	00 00 00 
  81daf4:	48 8b 00             	mov    (%rax),%rax
  81daf7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dafb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db02:	00 00 00 
  81db05:	48 89 10             	mov    %rdx,(%rax)
  81db08:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db0f:	00 00 00 
  81db12:	48 8b 00             	mov    (%rax),%rax
  81db15:	48 85 c0             	test   %rax,%rax
  81db18:	75 88                	jne    81daa2 <tcp_process+0xbc2>
  81db1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db1e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81db25:	00 
      pcb->state = TIME_WAIT;
  81db26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db2a:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81db31:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81db38:	00 00 00 
  81db3b:	48 8b 10             	mov    (%rax),%rdx
  81db3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db42:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81db46:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81db4d:	00 00 00 
  81db50:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81db54:	48 89 10             	mov    %rdx,(%rax)
  81db57:	48 b8 f4 80 80 00 00 	movabs $0x8080f4,%rax
  81db5e:	00 00 00 
  81db61:	ff d0                	callq  *%rax
    }
    break;
  81db63:	eb 62                	jmp    81dbc7 <tcp_process+0xce7>
  case LAST_ACK:
    tcp_receive(pcb);
  81db65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db69:	48 89 c7             	mov    %rax,%rdi
  81db6c:	48 b8 d2 db 81 00 00 	movabs $0x81dbd2,%rax
  81db73:	00 00 00 
  81db76:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81db78:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81db7f:	00 00 00 
  81db82:	0f b6 00             	movzbl (%rax),%eax
  81db85:	0f b6 c0             	movzbl %al,%eax
  81db88:	83 e0 10             	and    $0x10,%eax
  81db8b:	85 c0                	test   %eax,%eax
  81db8d:	74 3b                	je     81dbca <tcp_process+0xcea>
  81db8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db93:	8b 50 60             	mov    0x60(%rax),%edx
  81db96:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81db9d:	00 00 00 
  81dba0:	8b 00                	mov    (%rax),%eax
  81dba2:	39 c2                	cmp    %eax,%edx
  81dba4:	75 24                	jne    81dbca <tcp_process+0xcea>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81dba6:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81dbad:	00 00 00 
  81dbb0:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81dbb3:	eb 15                	jmp    81dbca <tcp_process+0xcea>
  default:
    break;
  81dbb5:	90                   	nop
  81dbb6:	eb 13                	jmp    81dbcb <tcp_process+0xceb>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81dbb8:	90                   	nop
  81dbb9:	eb 10                	jmp    81dbcb <tcp_process+0xceb>
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81dbbb:	90                   	nop
  81dbbc:	eb 0d                	jmp    81dbcb <tcp_process+0xceb>
    accepted_inseq = tcp_receive(pcb);
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  81dbbe:	90                   	nop
  81dbbf:	eb 0a                	jmp    81dbcb <tcp_process+0xceb>
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81dbc1:	90                   	nop
  81dbc2:	eb 07                	jmp    81dbcb <tcp_process+0xceb>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81dbc4:	90                   	nop
  81dbc5:	eb 04                	jmp    81dbcb <tcp_process+0xceb>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81dbc7:	90                   	nop
  81dbc8:	eb 01                	jmp    81dbcb <tcp_process+0xceb>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
    }
    break;
  81dbca:	90                   	nop
  default:
    break;
  }
  return ERR_OK;
  81dbcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81dbd0:	c9                   	leaveq 
  81dbd1:	c3                   	retq   

000000000081dbd2 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81dbd2:	55                   	push   %rbp
  81dbd3:	48 89 e5             	mov    %rsp,%rbp
  81dbd6:	41 55                	push   %r13
  81dbd8:	41 54                	push   %r12
  81dbda:	53                   	push   %rbx
  81dbdb:	48 83 ec 58          	sub    $0x58,%rsp
  81dbdf:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81dbe3:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81dbe7:	48 b8 e0 74 b5 00 00 	movabs $0xb574e0,%rax
  81dbee:	00 00 00 
  81dbf1:	0f b6 00             	movzbl (%rax),%eax
  81dbf4:	0f b6 c0             	movzbl %al,%eax
  81dbf7:	83 e0 10             	and    $0x10,%eax
  81dbfa:	85 c0                	test   %eax,%eax
  81dbfc:	0f 84 ab 09 00 00    	je     81e5ad <tcp_receive+0x9db>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81dc02:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc06:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81dc0a:	0f b7 d0             	movzwl %ax,%edx
  81dc0d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc11:	8b 40 6c             	mov    0x6c(%rax),%eax
  81dc14:	01 d0                	add    %edx,%eax
  81dc16:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81dc19:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc1d:	8b 50 6c             	mov    0x6c(%rax),%edx
  81dc20:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dc27:	00 00 00 
  81dc2a:	8b 00                	mov    (%rax),%eax
  81dc2c:	89 d1                	mov    %edx,%ecx
  81dc2e:	29 c1                	sub    %eax,%ecx
  81dc30:	89 c8                	mov    %ecx,%eax
  81dc32:	85 c0                	test   %eax,%eax
  81dc34:	78 6d                	js     81dca3 <tcp_receive+0xd1>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81dc36:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc3a:	8b 50 6c             	mov    0x6c(%rax),%edx
  81dc3d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dc44:	00 00 00 
  81dc47:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81dc49:	39 c2                	cmp    %eax,%edx
  81dc4b:	75 1d                	jne    81dc6a <tcp_receive+0x98>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81dc4d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc51:	8b 50 70             	mov    0x70(%rax),%edx
  81dc54:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dc5b:	00 00 00 
  81dc5e:	8b 00                	mov    (%rax),%eax
  81dc60:	89 d3                	mov    %edx,%ebx
  81dc62:	29 c3                	sub    %eax,%ebx
  81dc64:	89 d8                	mov    %ebx,%eax
  81dc66:	85 c0                	test   %eax,%eax
  81dc68:	78 39                	js     81dca3 <tcp_receive+0xd1>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81dc6a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc6e:	8b 50 70             	mov    0x70(%rax),%edx
  81dc71:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dc78:	00 00 00 
  81dc7b:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81dc7d:	39 c2                	cmp    %eax,%edx
  81dc7f:	0f 85 84 00 00 00    	jne    81dd09 <tcp_receive+0x137>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81dc85:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dc8c:	00 00 00 
  81dc8f:	48 8b 00             	mov    (%rax),%rax
  81dc92:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81dc96:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dc9a:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81dc9e:	66 39 c2             	cmp    %ax,%dx
  81dca1:	76 66                	jbe    81dd09 <tcp_receive+0x137>
      pcb->snd_wnd = tcphdr->wnd;
  81dca3:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81dcaa:	00 00 00 
  81dcad:	48 8b 00             	mov    (%rax),%rax
  81dcb0:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81dcb4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dcb8:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81dcbc:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81dcc3:	00 00 00 
  81dcc6:	8b 10                	mov    (%rax),%edx
  81dcc8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dccc:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81dccf:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dcd6:	00 00 00 
  81dcd9:	8b 10                	mov    (%rax),%edx
  81dcdb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dcdf:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81dce2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dce6:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81dcea:	66 85 c0             	test   %ax,%ax
  81dced:	74 1a                	je     81dd09 <tcp_receive+0x137>
  81dcef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dcf3:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81dcfa:	84 c0                	test   %al,%al
  81dcfc:	74 0b                	je     81dd09 <tcp_receive+0x137>
          pcb->persist_backoff = 0;
  81dcfe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd02:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81dd09:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd0d:	8b 50 54             	mov    0x54(%rax),%edx
  81dd10:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dd17:	00 00 00 
  81dd1a:	8b 00                	mov    (%rax),%eax
  81dd1c:	39 c2                	cmp    %eax,%edx
  81dd1e:	0f 85 72 01 00 00    	jne    81de96 <tcp_receive+0x2c4>
      pcb->acked = 0;
  81dd24:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd28:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81dd2e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd32:	8b 50 6c             	mov    0x6c(%rax),%edx
  81dd35:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd39:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81dd3d:	0f b7 c0             	movzwl %ax,%eax
  81dd40:	01 d0                	add    %edx,%eax
  81dd42:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81dd45:	0f 85 7a 06 00 00    	jne    81e3c5 <tcp_receive+0x7f3>
        ++pcb->dupacks;
  81dd4b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd4f:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81dd53:	8d 50 01             	lea    0x1(%rax),%edx
  81dd56:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd5a:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81dd5d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd61:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81dd65:	3c 02                	cmp    $0x2,%al
  81dd67:	0f 86 58 06 00 00    	jbe    81e3c5 <tcp_receive+0x7f3>
  81dd6d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd71:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81dd78:	48 85 c0             	test   %rax,%rax
  81dd7b:	0f 84 44 06 00 00    	je     81e3c5 <tcp_receive+0x7f3>
          if (!(pcb->flags & TF_INFR)) {
  81dd81:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd85:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dd89:	0f b6 c0             	movzbl %al,%eax
  81dd8c:	83 e0 04             	and    $0x4,%eax
  81dd8f:	85 c0                	test   %eax,%eax
  81dd91:	0f 85 bd 00 00 00    	jne    81de54 <tcp_receive+0x282>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81dd97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dd9b:	48 89 c7             	mov    %rax,%rdi
  81dd9e:	48 b8 e0 42 81 00 00 	movabs $0x8142e0,%rax
  81dda5:	00 00 00 
  81dda8:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81ddaa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddae:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81ddb2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddb6:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81ddba:	66 39 c2             	cmp    %ax,%dx
  81ddbd:	76 17                	jbe    81ddd6 <tcp_receive+0x204>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81ddbf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddc3:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81ddc7:	89 c2                	mov    %eax,%edx
  81ddc9:	66 d1 ea             	shr    %dx
  81ddcc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddd0:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81ddd4:	eb 15                	jmp    81ddeb <tcp_receive+0x219>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81ddd6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddda:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81ddde:	89 c2                	mov    %eax,%edx
  81dde0:	66 d1 ea             	shr    %dx
  81dde3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dde7:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81ddeb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddef:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81ddf3:	0f b7 d0             	movzwl %ax,%edx
  81ddf6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddfa:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81ddfe:	0f b7 c0             	movzwl %ax,%eax
  81de01:	01 c0                	add    %eax,%eax
  81de03:	39 c2                	cmp    %eax,%edx
  81de05:	7d 13                	jge    81de1a <tcp_receive+0x248>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81de07:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de0b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81de0f:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81de12:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de16:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81de1a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de1e:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81de22:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de26:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81de2a:	89 d0                	mov    %edx,%eax
  81de2c:	01 c0                	add    %eax,%eax
  81de2e:	01 d0                	add    %edx,%eax
  81de30:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81de33:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de37:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81de3b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de3f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81de43:	89 c2                	mov    %eax,%edx
  81de45:	83 ca 04             	or     $0x4,%edx
  81de48:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de4c:	88 50 2c             	mov    %dl,0x2c(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81de4f:	e9 71 05 00 00       	jmpq   81e3c5 <tcp_receive+0x7f3>
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
            pcb->flags |= TF_INFR;
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81de54:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de58:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81de5c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de60:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81de64:	01 c2                	add    %eax,%edx
  81de66:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de6a:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81de6e:	66 39 c2             	cmp    %ax,%dx
  81de71:	0f 86 4e 05 00 00    	jbe    81e3c5 <tcp_receive+0x7f3>
              pcb->cwnd += pcb->mss;
  81de77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de7b:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81de7f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de83:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81de87:	01 c2                	add    %eax,%edx
  81de89:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de8d:	66 89 50 5a          	mov    %dx,0x5a(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81de91:	e9 2f 05 00 00       	jmpq   81e3c5 <tcp_receive+0x7f3>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81de96:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de9a:	8b 40 54             	mov    0x54(%rax),%eax
  81de9d:	89 c2                	mov    %eax,%edx
  81de9f:	f7 d2                	not    %edx
  81dea1:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81dea8:	00 00 00 
  81deab:	8b 00                	mov    (%rax),%eax
  81dead:	01 d0                	add    %edx,%eax
  81deaf:	85 c0                	test   %eax,%eax
  81deb1:	0f 88 b4 03 00 00    	js     81e26b <tcp_receive+0x699>
  81deb7:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81debe:	00 00 00 
  81dec1:	8b 10                	mov    (%rax),%edx
  81dec3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dec7:	8b 40 64             	mov    0x64(%rax),%eax
  81deca:	89 d1                	mov    %edx,%ecx
  81decc:	29 c1                	sub    %eax,%ecx
  81dece:	89 c8                	mov    %ecx,%eax
  81ded0:	85 c0                	test   %eax,%eax
  81ded2:	0f 8f 93 03 00 00    	jg     81e26b <tcp_receive+0x699>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81ded8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dedc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dee0:	0f b6 c0             	movzbl %al,%eax
  81dee3:	83 e0 04             	and    $0x4,%eax
  81dee6:	85 c0                	test   %eax,%eax
  81dee8:	74 24                	je     81df0e <tcp_receive+0x33c>
        pcb->flags &= ~TF_INFR;
  81deea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81deee:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81def2:	89 c2                	mov    %eax,%edx
  81def4:	83 e2 fb             	and    $0xfffffffb,%edx
  81def7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81defb:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81defe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df02:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81df06:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df0a:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81df0e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df12:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81df16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df1a:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81df1e:	66 c1 f8 03          	sar    $0x3,%ax
  81df22:	89 c2                	mov    %eax,%edx
  81df24:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df28:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81df2c:	01 d0                	add    %edx,%eax
  81df2e:	89 c2                	mov    %eax,%edx
  81df30:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df34:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81df38:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81df3f:	00 00 00 
  81df42:	8b 00                	mov    (%rax),%eax
  81df44:	89 c2                	mov    %eax,%edx
  81df46:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df4a:	8b 40 54             	mov    0x54(%rax),%eax
  81df4d:	66 29 c2             	sub    %ax,%dx
  81df50:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df54:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81df58:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df5c:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81df60:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df64:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81df68:	01 c2                	add    %eax,%edx
  81df6a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df6e:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81df72:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df76:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81df7a:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81df81:	00 00 00 
  81df84:	8b 10                	mov    (%rax),%edx
  81df86:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df8a:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81df8d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df91:	8b 40 18             	mov    0x18(%rax),%eax
  81df94:	83 f8 03             	cmp    $0x3,%eax
  81df97:	0f 86 c9 01 00 00    	jbe    81e166 <tcp_receive+0x594>
        if (pcb->cwnd < pcb->ssthresh) {
  81df9d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfa1:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81dfa5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfa9:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81dfad:	66 39 c2             	cmp    %ax,%dx
  81dfb0:	73 42                	jae    81dff4 <tcp_receive+0x422>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81dfb2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfb6:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81dfba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfbe:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dfc2:	01 c2                	add    %eax,%edx
  81dfc4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfc8:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81dfcc:	66 39 c2             	cmp    %ax,%dx
  81dfcf:	0f 86 91 01 00 00    	jbe    81e166 <tcp_receive+0x594>
            pcb->cwnd += pcb->mss;
  81dfd5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfd9:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81dfdd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfe1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dfe5:	01 c2                	add    %eax,%edx
  81dfe7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfeb:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81dfef:	e9 72 01 00 00       	jmpq   81e166 <tcp_receive+0x594>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81dff4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dff8:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81dffc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e000:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e004:	0f b7 d0             	movzwl %ax,%edx
  81e007:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e00b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e00f:	0f b7 c0             	movzwl %ax,%eax
  81e012:	0f af c2             	imul   %edx,%eax
  81e015:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e019:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e01d:	0f b7 d2             	movzwl %dx,%edx
  81e020:	89 55 94             	mov    %edx,-0x6c(%rbp)
  81e023:	89 c2                	mov    %eax,%edx
  81e025:	c1 fa 1f             	sar    $0x1f,%edx
  81e028:	f7 7d 94             	idivl  -0x6c(%rbp)
  81e02b:	01 c8                	add    %ecx,%eax
  81e02d:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e031:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e035:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e039:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e03d:	0f 83 23 01 00 00    	jae    81e166 <tcp_receive+0x594>
            pcb->cwnd = new_cwnd;
  81e043:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e047:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e04b:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e04f:	e9 12 01 00 00       	jmpq   81e166 <tcp_receive+0x594>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e054:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e058:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e05f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e063:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e067:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e06e:	48 8b 10             	mov    (%rax),%rdx
  81e071:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e075:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e07c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e080:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e084:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e088:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e08c:	48 89 c7             	mov    %rax,%rdi
  81e08f:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  81e096:	00 00 00 
  81e099:	ff d0                	callq  *%rax
  81e09b:	0f b6 c0             	movzbl %al,%eax
  81e09e:	66 39 c3             	cmp    %ax,%bx
  81e0a1:	73 2a                	jae    81e0cd <tcp_receive+0x4fb>
  81e0a3:	48 ba 08 35 82 00 00 	movabs $0x823508,%rdx
  81e0aa:	00 00 00 
  81e0ad:	be 55 03 00 00       	mov    $0x355,%esi
  81e0b2:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e0b9:	00 00 00 
  81e0bc:	b8 00 00 00 00       	mov    $0x0,%eax
  81e0c1:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e0c8:	00 00 00 
  81e0cb:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e0cd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0d1:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e0d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e0d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e0dd:	48 89 c7             	mov    %rax,%rdi
  81e0e0:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  81e0e7:	00 00 00 
  81e0ea:	ff d0                	callq  *%rax
  81e0ec:	0f b6 c0             	movzbl %al,%eax
  81e0ef:	89 da                	mov    %ebx,%edx
  81e0f1:	66 29 c2             	sub    %ax,%dx
  81e0f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0f8:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e0fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e100:	48 89 c7             	mov    %rax,%rdi
  81e103:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  81e10a:	00 00 00 
  81e10d:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e10f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e113:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e117:	66 85 c0             	test   %ax,%ax
  81e11a:	74 4b                	je     81e167 <tcp_receive+0x595>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e11c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e120:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e127:	48 85 c0             	test   %rax,%rax
  81e12a:	75 3b                	jne    81e167 <tcp_receive+0x595>
  81e12c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e130:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e137:	48 85 c0             	test   %rax,%rax
  81e13a:	75 2b                	jne    81e167 <tcp_receive+0x595>
  81e13c:	48 ba 30 35 82 00 00 	movabs $0x823530,%rdx
  81e143:	00 00 00 
  81e146:	be 5c 03 00 00       	mov    $0x35c,%esi
  81e14b:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e152:	00 00 00 
  81e155:	b8 00 00 00 00       	mov    $0x0,%eax
  81e15a:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e161:	00 00 00 
  81e164:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e166:	90                   	nop
  81e167:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e16b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e172:	48 85 c0             	test   %rax,%rax
  81e175:	0f 84 bd 00 00 00    	je     81e238 <tcp_receive+0x666>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e17b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e17f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e186:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e18a:	8b 40 04             	mov    0x4(%rax),%eax
  81e18d:	89 c7                	mov    %eax,%edi
  81e18f:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81e196:	00 00 00 
  81e199:	ff d0                	callq  *%rax
  81e19b:	89 c3                	mov    %eax,%ebx
  81e19d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1a1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e1a8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e1ac:	44 0f b7 e0          	movzwl %ax,%r12d
  81e1b0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1b4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e1bb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e1bf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e1c3:	0f b7 c0             	movzwl %ax,%eax
  81e1c6:	89 c7                	mov    %eax,%edi
  81e1c8:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81e1cf:	00 00 00 
  81e1d2:	ff d0                	callq  *%rax
  81e1d4:	0f b7 c0             	movzwl %ax,%eax
  81e1d7:	83 e0 01             	and    $0x1,%eax
  81e1da:	84 c0                	test   %al,%al
  81e1dc:	75 2e                	jne    81e20c <tcp_receive+0x63a>
  81e1de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1e2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e1e9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e1ed:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e1f1:	0f b7 c0             	movzwl %ax,%eax
  81e1f4:	89 c7                	mov    %eax,%edi
  81e1f6:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81e1fd:	00 00 00 
  81e200:	ff d0                	callq  *%rax
  81e202:	0f b7 c0             	movzwl %ax,%eax
  81e205:	83 e0 02             	and    $0x2,%eax
  81e208:	85 c0                	test   %eax,%eax
  81e20a:	74 07                	je     81e213 <tcp_receive+0x641>
  81e20c:	b8 01 00 00 00       	mov    $0x1,%eax
  81e211:	eb 05                	jmp    81e218 <tcp_receive+0x646>
  81e213:	b8 00 00 00 00       	mov    $0x0,%eax
  81e218:	44 01 e0             	add    %r12d,%eax
  81e21b:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e21e:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e225:	00 00 00 
  81e228:	8b 00                	mov    (%rax),%eax
  81e22a:	89 d1                	mov    %edx,%ecx
  81e22c:	29 c1                	sub    %eax,%ecx
  81e22e:	89 c8                	mov    %ecx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e230:	85 c0                	test   %eax,%eax
  81e232:	0f 8e 1c fe ff ff    	jle    81e054 <tcp_receive+0x482>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e238:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e23c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e243:	48 85 c0             	test   %rax,%rax
  81e246:	75 0c                	jne    81e254 <tcp_receive+0x682>
        pcb->rtime = -1;
  81e248:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e24c:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e252:	eb 0a                	jmp    81e25e <tcp_receive+0x68c>
      else
        pcb->rtime = 0;
  81e254:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e258:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e25e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e262:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e266:	e9 5a 01 00 00       	jmpq   81e3c5 <tcp_receive+0x7f3>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e26b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e26f:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e275:	e9 4b 01 00 00       	jmpq   81e3c5 <tcp_receive+0x7f3>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81e27a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e27e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e285:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81e289:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e28d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e294:	48 8b 10             	mov    (%rax),%rdx
  81e297:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e29b:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e2a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2a6:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e2aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e2ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e2b2:	48 89 c7             	mov    %rax,%rdi
  81e2b5:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  81e2bc:	00 00 00 
  81e2bf:	ff d0                	callq  *%rax
  81e2c1:	0f b6 c0             	movzbl %al,%eax
  81e2c4:	66 39 c3             	cmp    %ax,%bx
  81e2c7:	73 2a                	jae    81e2f3 <tcp_receive+0x721>
  81e2c9:	48 ba 08 35 82 00 00 	movabs $0x823508,%rdx
  81e2d0:	00 00 00 
  81e2d3:	be 7f 03 00 00       	mov    $0x37f,%esi
  81e2d8:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e2df:	00 00 00 
  81e2e2:	b8 00 00 00 00       	mov    $0x0,%eax
  81e2e7:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e2ee:	00 00 00 
  81e2f1:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81e2f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2f7:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e2fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e2ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e303:	48 89 c7             	mov    %rax,%rdi
  81e306:	48 b8 01 d9 80 00 00 	movabs $0x80d901,%rax
  81e30d:	00 00 00 
  81e310:	ff d0                	callq  *%rax
  81e312:	0f b6 c0             	movzbl %al,%eax
  81e315:	89 da                	mov    %ebx,%edx
  81e317:	66 29 c2             	sub    %ax,%dx
  81e31a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e31e:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81e322:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e326:	48 89 c7             	mov    %rax,%rdi
  81e329:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  81e330:	00 00 00 
  81e333:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81e335:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e339:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e33d:	66 85 c0             	test   %ax,%ax
  81e340:	74 4a                	je     81e38c <tcp_receive+0x7ba>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81e342:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e346:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e34d:	48 85 c0             	test   %rax,%rax
  81e350:	75 3a                	jne    81e38c <tcp_receive+0x7ba>
  81e352:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e356:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e35d:	48 85 c0             	test   %rax,%rax
  81e360:	75 2a                	jne    81e38c <tcp_receive+0x7ba>
  81e362:	48 ba 30 35 82 00 00 	movabs $0x823530,%rdx
  81e369:	00 00 00 
  81e36c:	be 85 03 00 00       	mov    $0x385,%esi
  81e371:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e378:	00 00 00 
  81e37b:	b8 00 00 00 00       	mov    $0x0,%eax
  81e380:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e387:	00 00 00 
  81e38a:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81e38c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e390:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e397:	48 85 c0             	test   %rax,%rax
  81e39a:	74 2a                	je     81e3c6 <tcp_receive+0x7f4>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81e39c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3a0:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e3a7:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e3ab:	8b 40 04             	mov    0x4(%rax),%eax
  81e3ae:	89 c7                	mov    %eax,%edi
  81e3b0:	48 b8 e9 2a 81 00 00 	movabs $0x812ae9,%rax
  81e3b7:	00 00 00 
  81e3ba:	ff d0                	callq  *%rax
  81e3bc:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e3c0:	89 42 60             	mov    %eax,0x60(%rdx)
  81e3c3:	eb 01                	jmp    81e3c6 <tcp_receive+0x7f4>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e3c5:	90                   	nop
  81e3c6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3ca:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e3d1:	48 85 c0             	test   %rax,%rax
  81e3d4:	0f 84 db 00 00 00    	je     81e4b5 <tcp_receive+0x8e3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e3da:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e3e1:	00 00 00 
  81e3e4:	44 8b 20             	mov    (%rax),%r12d
  81e3e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3eb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e3f2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e3f6:	8b 40 04             	mov    0x4(%rax),%eax
  81e3f9:	89 c7                	mov    %eax,%edi
  81e3fb:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81e402:	00 00 00 
  81e405:	ff d0                	callq  *%rax
  81e407:	89 c3                	mov    %eax,%ebx
  81e409:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e40d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e414:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e418:	44 0f b7 e8          	movzwl %ax,%r13d
  81e41c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e420:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e427:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e42b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e42f:	0f b7 c0             	movzwl %ax,%eax
  81e432:	89 c7                	mov    %eax,%edi
  81e434:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81e43b:	00 00 00 
  81e43e:	ff d0                	callq  *%rax
  81e440:	0f b7 c0             	movzwl %ax,%eax
  81e443:	83 e0 01             	and    $0x1,%eax
  81e446:	84 c0                	test   %al,%al
  81e448:	75 2e                	jne    81e478 <tcp_receive+0x8a6>
  81e44a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e44e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e455:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e459:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e45d:	0f b7 c0             	movzwl %ax,%eax
  81e460:	89 c7                	mov    %eax,%edi
  81e462:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81e469:	00 00 00 
  81e46c:	ff d0                	callq  *%rax
  81e46e:	0f b7 c0             	movzwl %ax,%eax
  81e471:	83 e0 02             	and    $0x2,%eax
  81e474:	85 c0                	test   %eax,%eax
  81e476:	74 07                	je     81e47f <tcp_receive+0x8ad>
  81e478:	b8 01 00 00 00       	mov    $0x1,%eax
  81e47d:	eb 05                	jmp    81e484 <tcp_receive+0x8b2>
  81e47f:	b8 00 00 00 00       	mov    $0x0,%eax
  81e484:	44 01 e8             	add    %r13d,%eax
  81e487:	01 d8                	add    %ebx,%eax
  81e489:	44 89 e3             	mov    %r12d,%ebx
  81e48c:	29 c3                	sub    %eax,%ebx
  81e48e:	89 d8                	mov    %ebx,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e490:	85 c0                	test   %eax,%eax
  81e492:	78 21                	js     81e4b5 <tcp_receive+0x8e3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e494:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e49b:	00 00 00 
  81e49e:	8b 10                	mov    (%rax),%edx
  81e4a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4a4:	8b 40 64             	mov    0x64(%rax),%eax
  81e4a7:	89 d1                	mov    %edx,%ecx
  81e4a9:	29 c1                	sub    %eax,%ecx
  81e4ab:	89 c8                	mov    %ecx,%eax
  81e4ad:	85 c0                	test   %eax,%eax
  81e4af:	0f 8e c5 fd ff ff    	jle    81e27a <tcp_receive+0x6a8>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81e4b5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4b9:	8b 40 44             	mov    0x44(%rax),%eax
  81e4bc:	85 c0                	test   %eax,%eax
  81e4be:	0f 84 e9 00 00 00    	je     81e5ad <tcp_receive+0x9db>
  81e4c4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4c8:	8b 50 48             	mov    0x48(%rax),%edx
  81e4cb:	48 b8 dc 74 b5 00 00 	movabs $0xb574dc,%rax
  81e4d2:	00 00 00 
  81e4d5:	8b 00                	mov    (%rax),%eax
  81e4d7:	89 d3                	mov    %edx,%ebx
  81e4d9:	29 c3                	sub    %eax,%ebx
  81e4db:	89 d8                	mov    %ebx,%eax
  81e4dd:	85 c0                	test   %eax,%eax
  81e4df:	0f 89 c8 00 00 00    	jns    81e5ad <tcp_receive+0x9db>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81e4e5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81e4ec:	00 00 00 
  81e4ef:	8b 00                	mov    (%rax),%eax
  81e4f1:	89 c2                	mov    %eax,%edx
  81e4f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4f7:	8b 40 44             	mov    0x44(%rax),%eax
  81e4fa:	89 d1                	mov    %edx,%ecx
  81e4fc:	66 29 c1             	sub    %ax,%cx
  81e4ff:	89 c8                	mov    %ecx,%eax
  81e501:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81e505:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e509:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e50d:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e511:	66 c1 f8 03          	sar    $0x3,%ax
  81e515:	89 d3                	mov    %edx,%ebx
  81e517:	66 29 c3             	sub    %ax,%bx
  81e51a:	89 d8                	mov    %ebx,%eax
  81e51c:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81e520:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e524:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e528:	89 c2                	mov    %eax,%edx
  81e52a:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e52e:	01 d0                	add    %edx,%eax
  81e530:	89 c2                	mov    %eax,%edx
  81e532:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e536:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81e53a:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81e53f:	79 0a                	jns    81e54b <tcp_receive+0x979>
        m = -m;
  81e541:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e545:	f7 d8                	neg    %eax
  81e547:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81e54b:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e54f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e553:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e557:	66 c1 f8 02          	sar    $0x2,%ax
  81e55b:	89 d1                	mov    %edx,%ecx
  81e55d:	66 29 c1             	sub    %ax,%cx
  81e560:	89 c8                	mov    %ecx,%eax
  81e562:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81e566:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e56a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e56e:	89 c2                	mov    %eax,%edx
  81e570:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e574:	01 d0                	add    %edx,%eax
  81e576:	89 c2                	mov    %eax,%edx
  81e578:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e57c:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e580:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e584:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e588:	66 c1 f8 03          	sar    $0x3,%ax
  81e58c:	89 c2                	mov    %eax,%edx
  81e58e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e592:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e596:	01 d0                	add    %edx,%eax
  81e598:	89 c2                	mov    %eax,%edx
  81e59a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e59e:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81e5a2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5a6:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81e5ad:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81e5b4:	00 00 00 
  81e5b7:	0f b7 00             	movzwl (%rax),%eax
  81e5ba:	66 85 c0             	test   %ax,%ax
  81e5bd:	0f 84 5e 10 00 00    	je     81f621 <tcp_receive+0x1a4f>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81e5c3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5c7:	8b 50 30             	mov    0x30(%rax),%edx
  81e5ca:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e5d1:	00 00 00 
  81e5d4:	8b 00                	mov    (%rax),%eax
  81e5d6:	f7 d0                	not    %eax
  81e5d8:	01 d0                	add    %edx,%eax
  81e5da:	85 c0                	test   %eax,%eax
  81e5dc:	0f 88 b9 02 00 00    	js     81e89b <tcp_receive+0xcc9>
  81e5e2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5e6:	8b 50 30             	mov    0x30(%rax),%edx
  81e5e9:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81e5f0:	00 00 00 
  81e5f3:	0f b7 00             	movzwl (%rax),%eax
  81e5f6:	0f b7 c8             	movzwl %ax,%ecx
  81e5f9:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e600:	00 00 00 
  81e603:	8b 00                	mov    (%rax),%eax
  81e605:	01 c8                	add    %ecx,%eax
  81e607:	89 d3                	mov    %edx,%ebx
  81e609:	29 c3                	sub    %eax,%ebx
  81e60b:	89 d8                	mov    %ebx,%eax
  81e60d:	83 c0 01             	add    $0x1,%eax
  81e610:	85 c0                	test   %eax,%eax
  81e612:	0f 8f 83 02 00 00    	jg     81e89b <tcp_receive+0xcc9>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81e618:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e61c:	8b 50 30             	mov    0x30(%rax),%edx
  81e61f:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e626:	00 00 00 
  81e629:	8b 00                	mov    (%rax),%eax
  81e62b:	89 d1                	mov    %edx,%ecx
  81e62d:	29 c1                	sub    %eax,%ecx
  81e62f:	89 c8                	mov    %ecx,%eax
  81e631:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81e634:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e63b:	00 00 00 
  81e63e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e642:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81e646:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e64d:	00 00 00 
  81e650:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e654:	48 85 c0             	test   %rax,%rax
  81e657:	75 2a                	jne    81e683 <tcp_receive+0xab1>
  81e659:	48 ba 50 35 82 00 00 	movabs $0x823550,%rdx
  81e660:	00 00 00 
  81e663:	be e5 03 00 00       	mov    $0x3e5,%esi
  81e668:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e66f:	00 00 00 
  81e672:	b8 00 00 00 00       	mov    $0x0,%eax
  81e677:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e67e:	00 00 00 
  81e681:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81e683:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81e68a:	7e 2a                	jle    81e6b6 <tcp_receive+0xae4>
  81e68c:	48 ba 60 35 82 00 00 	movabs $0x823560,%rdx
  81e693:	00 00 00 
  81e696:	be e6 03 00 00       	mov    $0x3e6,%esi
  81e69b:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e6a2:	00 00 00 
  81e6a5:	b8 00 00 00 00       	mov    $0x0,%eax
  81e6aa:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e6b1:	00 00 00 
  81e6b4:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81e6b6:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e6bd:	00 00 00 
  81e6c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e6c4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e6c8:	0f b7 c0             	movzwl %ax,%eax
  81e6cb:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e6ce:	0f 8d f0 00 00 00    	jge    81e7c4 <tcp_receive+0xbf2>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81e6d4:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e6db:	00 00 00 
  81e6de:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e6e2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e6e6:	0f b7 c0             	movzwl %ax,%eax
  81e6e9:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e6ec:	7d 2a                	jge    81e718 <tcp_receive+0xb46>
  81e6ee:	48 ba 6f 35 82 00 00 	movabs $0x82356f,%rdx
  81e6f5:	00 00 00 
  81e6f8:	be e8 03 00 00       	mov    $0x3e8,%esi
  81e6fd:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e704:	00 00 00 
  81e707:	b8 00 00 00 00       	mov    $0x0,%eax
  81e70c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e713:	00 00 00 
  81e716:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81e718:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e71f:	00 00 00 
  81e722:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e726:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81e72a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e72d:	89 d3                	mov    %edx,%ebx
  81e72f:	66 29 c3             	sub    %ax,%bx
  81e732:	89 d8                	mov    %ebx,%eax
  81e734:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81e738:	eb 2f                	jmp    81e769 <tcp_receive+0xb97>
          off -= p->len;
  81e73a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e73e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e742:	0f b7 c0             	movzwl %ax,%eax
  81e745:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81e748:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e74c:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81e750:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81e754:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e758:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81e75e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e762:	48 8b 00             	mov    (%rax),%rax
  81e765:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81e769:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e76d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e771:	0f b7 c0             	movzwl %ax,%eax
  81e774:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e777:	7c c1                	jl     81e73a <tcp_receive+0xb68>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81e779:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e77c:	f7 d8                	neg    %eax
  81e77e:	0f bf d0             	movswl %ax,%edx
  81e781:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e785:	89 d6                	mov    %edx,%esi
  81e787:	48 89 c7             	mov    %rax,%rdi
  81e78a:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81e791:	00 00 00 
  81e794:	ff d0                	callq  *%rax
  81e796:	84 c0                	test   %al,%al
  81e798:	74 7f                	je     81e819 <tcp_receive+0xc47>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e79a:	48 ba 7f 35 82 00 00 	movabs $0x82357f,%rdx
  81e7a1:	00 00 00 
  81e7a4:	be f5 03 00 00       	mov    $0x3f5,%esi
  81e7a9:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e7b0:	00 00 00 
  81e7b3:	b8 00 00 00 00       	mov    $0x0,%eax
  81e7b8:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e7bf:	00 00 00 
  81e7c2:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81e7c4:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e7c7:	f7 d8                	neg    %eax
  81e7c9:	0f bf d0             	movswl %ax,%edx
  81e7cc:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e7d3:	00 00 00 
  81e7d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e7da:	89 d6                	mov    %edx,%esi
  81e7dc:	48 89 c7             	mov    %rax,%rdi
  81e7df:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81e7e6:	00 00 00 
  81e7e9:	ff d0                	callq  *%rax
  81e7eb:	84 c0                	test   %al,%al
  81e7ed:	74 2a                	je     81e819 <tcp_receive+0xc47>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e7ef:	48 ba 7f 35 82 00 00 	movabs $0x82357f,%rdx
  81e7f6:	00 00 00 
  81e7f9:	be fa 03 00 00       	mov    $0x3fa,%esi
  81e7fe:	48 bf 67 33 82 00 00 	movabs $0x823367,%rdi
  81e805:	00 00 00 
  81e808:	b8 00 00 00 00       	mov    $0x0,%eax
  81e80d:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81e814:	00 00 00 
  81e817:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81e819:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e81d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81e821:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e828:	00 00 00 
  81e82b:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81e82f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e836:	00 00 00 
  81e839:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81e83d:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e844:	00 00 00 
  81e847:	8b 00                	mov    (%rax),%eax
  81e849:	89 c1                	mov    %eax,%ecx
  81e84b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e84f:	8b 40 30             	mov    0x30(%rax),%eax
  81e852:	89 cb                	mov    %ecx,%ebx
  81e854:	66 29 c3             	sub    %ax,%bx
  81e857:	89 d8                	mov    %ebx,%eax
  81e859:	01 c2                	add    %eax,%edx
  81e85b:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e862:	00 00 00 
  81e865:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81e869:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e870:	00 00 00 
  81e873:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e877:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e87b:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81e87e:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81e885:	00 00 00 
  81e888:	89 0a                	mov    %ecx,(%rdx)
  81e88a:	48 ba d8 74 b5 00 00 	movabs $0xb574d8,%rdx
  81e891:	00 00 00 
  81e894:	8b 12                	mov    (%rdx),%edx
  81e896:	89 50 04             	mov    %edx,0x4(%rax)
  81e899:	eb 44                	jmp    81e8df <tcp_receive+0xd0d>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81e89b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e8a2:	00 00 00 
  81e8a5:	8b 10                	mov    (%rax),%edx
  81e8a7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8ab:	8b 40 30             	mov    0x30(%rax),%eax
  81e8ae:	89 d1                	mov    %edx,%ecx
  81e8b0:	29 c1                	sub    %eax,%ecx
  81e8b2:	89 c8                	mov    %ecx,%eax
  81e8b4:	85 c0                	test   %eax,%eax
  81e8b6:	79 27                	jns    81e8df <tcp_receive+0xd0d>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81e8b8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8bc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e8c0:	89 c2                	mov    %eax,%edx
  81e8c2:	83 ca 02             	or     $0x2,%edx
  81e8c5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8c9:	88 50 2c             	mov    %dl,0x2c(%rax)
  81e8cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8d0:	48 89 c7             	mov    %rax,%rdi
  81e8d3:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81e8da:	00 00 00 
  81e8dd:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81e8df:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e8e6:	00 00 00 
  81e8e9:	8b 10                	mov    (%rax),%edx
  81e8eb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e8ef:	8b 40 30             	mov    0x30(%rax),%eax
  81e8f2:	89 d3                	mov    %edx,%ebx
  81e8f4:	29 c3                	sub    %eax,%ebx
  81e8f6:	89 d8                	mov    %ebx,%eax
  81e8f8:	85 c0                	test   %eax,%eax
  81e8fa:	0f 88 f8 0c 00 00    	js     81f5f8 <tcp_receive+0x1a26>
  81e900:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e907:	00 00 00 
  81e90a:	8b 10                	mov    (%rax),%edx
  81e90c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e910:	8b 48 30             	mov    0x30(%rax),%ecx
  81e913:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e917:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81e91b:	0f b7 c0             	movzwl %ax,%eax
  81e91e:	01 c8                	add    %ecx,%eax
  81e920:	89 d1                	mov    %edx,%ecx
  81e922:	29 c1                	sub    %eax,%ecx
  81e924:	89 c8                	mov    %ecx,%eax
  81e926:	83 c0 01             	add    $0x1,%eax
  81e929:	85 c0                	test   %eax,%eax
  81e92b:	0f 8f c7 0c 00 00    	jg     81f5f8 <tcp_receive+0x1a26>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81e931:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e935:	8b 50 30             	mov    0x30(%rax),%edx
  81e938:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e93f:	00 00 00 
  81e942:	8b 00                	mov    (%rax),%eax
  81e944:	39 c2                	cmp    %eax,%edx
  81e946:	0f 85 4b 07 00 00    	jne    81f097 <tcp_receive+0x14c5>
        accepted_inseq = 1; 
  81e94c:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81e950:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e954:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e95b:	48 85 c0             	test   %rax,%rax
  81e95e:	0f 84 4f 01 00 00    	je     81eab3 <tcp_receive+0xee1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81e964:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e968:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e96f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e973:	8b 50 04             	mov    0x4(%rax),%edx
  81e976:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e97d:	00 00 00 
  81e980:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e984:	0f b7 c8             	movzwl %ax,%ecx
  81e987:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e98e:	00 00 00 
  81e991:	8b 00                	mov    (%rax),%eax
  81e993:	01 c8                	add    %ecx,%eax
  81e995:	89 d3                	mov    %edx,%ebx
  81e997:	29 c3                	sub    %eax,%ebx
  81e999:	89 d8                	mov    %ebx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81e99b:	85 c0                	test   %eax,%eax
  81e99d:	0f 8f 10 01 00 00    	jg     81eab3 <tcp_receive+0xee1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81e9a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9a7:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e9ae:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e9b2:	66 85 c0             	test   %ax,%ax
  81e9b5:	74 66                	je     81ea1d <tcp_receive+0xe4b>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81e9b7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e9bb:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81e9c2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e9c6:	8b 40 04             	mov    0x4(%rax),%eax
  81e9c9:	89 c2                	mov    %eax,%edx
  81e9cb:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81e9d2:	00 00 00 
  81e9d5:	8b 00                	mov    (%rax),%eax
  81e9d7:	66 29 c2             	sub    %ax,%dx
  81e9da:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e9e1:	00 00 00 
  81e9e4:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81e9e8:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81e9ef:	00 00 00 
  81e9f2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e9f6:	0f b7 d0             	movzwl %ax,%edx
  81e9f9:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea00:	00 00 00 
  81ea03:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ea07:	89 d6                	mov    %edx,%esi
  81ea09:	48 89 c7             	mov    %rax,%rdi
  81ea0c:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  81ea13:	00 00 00 
  81ea16:	ff d0                	callq  *%rax
  81ea18:	e9 96 00 00 00       	jmpq   81eab3 <tcp_receive+0xee1>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ea1d:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ea24:	00 00 00 
  81ea27:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ea2b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ea2f:	0f b7 c0             	movzwl %ax,%eax
  81ea32:	89 c7                	mov    %eax,%edi
  81ea34:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ea3b:	00 00 00 
  81ea3e:	ff d0                	callq  *%rax
  81ea40:	0f b7 d8             	movzwl %ax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81ea43:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea47:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ea4e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ea52:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ea56:	0f b7 c0             	movzwl %ax,%eax
  81ea59:	89 c7                	mov    %eax,%edi
  81ea5b:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ea62:	00 00 00 
  81ea65:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ea67:	0f b7 c0             	movzwl %ax,%eax
  81ea6a:	31 d8                	xor    %ebx,%eax
  81ea6c:	83 e0 03             	and    $0x3,%eax
  81ea6f:	85 c0                	test   %eax,%eax
  81ea71:	75 40                	jne    81eab3 <tcp_receive+0xee1>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81ea73:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea77:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ea7e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81ea82:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea86:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ea8d:	48 8b 10             	mov    (%rax),%rdx
  81ea90:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea94:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81ea9b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81ea9f:	48 89 c6             	mov    %rax,%rsi
  81eaa2:	bf 04 00 00 00       	mov    $0x4,%edi
  81eaa7:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81eaae:	00 00 00 
  81eab1:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81eab3:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eaba:	00 00 00 
  81eabd:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81eac1:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eac8:	00 00 00 
  81eacb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eacf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ead3:	0f b7 c0             	movzwl %ax,%eax
  81ead6:	89 c7                	mov    %eax,%edi
  81ead8:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81eadf:	00 00 00 
  81eae2:	ff d0                	callq  *%rax
  81eae4:	0f b7 c0             	movzwl %ax,%eax
  81eae7:	83 e0 01             	and    $0x1,%eax
  81eaea:	84 c0                	test   %al,%al
  81eaec:	75 2d                	jne    81eb1b <tcp_receive+0xf49>
  81eaee:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81eaf5:	00 00 00 
  81eaf8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eafc:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eb00:	0f b7 c0             	movzwl %ax,%eax
  81eb03:	89 c7                	mov    %eax,%edi
  81eb05:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81eb0c:	00 00 00 
  81eb0f:	ff d0                	callq  *%rax
  81eb11:	0f b7 c0             	movzwl %ax,%eax
  81eb14:	83 e0 02             	and    $0x2,%eax
  81eb17:	85 c0                	test   %eax,%eax
  81eb19:	74 07                	je     81eb22 <tcp_receive+0xf50>
  81eb1b:	b8 01 00 00 00       	mov    $0x1,%eax
  81eb20:	eb 05                	jmp    81eb27 <tcp_receive+0xf55>
  81eb22:	b8 00 00 00 00       	mov    $0x0,%eax
  81eb27:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81eb2a:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eb31:	00 00 00 
  81eb34:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81eb37:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb3b:	8b 40 18             	mov    0x18(%rax),%eax
  81eb3e:	83 f8 07             	cmp    $0x7,%eax
  81eb41:	74 20                	je     81eb63 <tcp_receive+0xf91>
          pcb->rcv_nxt += tcplen;
  81eb43:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb47:	8b 50 30             	mov    0x30(%rax),%edx
  81eb4a:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eb51:	00 00 00 
  81eb54:	0f b7 00             	movzwl (%rax),%eax
  81eb57:	0f b7 c0             	movzwl %ax,%eax
  81eb5a:	01 c2                	add    %eax,%edx
  81eb5c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb60:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81eb63:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb67:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81eb6b:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eb72:	00 00 00 
  81eb75:	0f b7 00             	movzwl (%rax),%eax
  81eb78:	66 39 c2             	cmp    %ax,%dx
  81eb7b:	73 0c                	jae    81eb89 <tcp_receive+0xfb7>
          pcb->rcv_wnd = 0;
  81eb7d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb81:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81eb87:	eb 20                	jmp    81eba9 <tcp_receive+0xfd7>
        } else {
          pcb->rcv_wnd -= tcplen;
  81eb89:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb8d:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81eb91:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81eb98:	00 00 00 
  81eb9b:	0f b7 00             	movzwl (%rax),%eax
  81eb9e:	66 29 c2             	sub    %ax,%dx
  81eba1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eba5:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81eba9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebad:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81ebb1:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ebb8:	00 00 00 
  81ebbb:	0f b7 00             	movzwl (%rax),%eax
  81ebbe:	66 39 c2             	cmp    %ax,%dx
  81ebc1:	73 0c                	jae    81ebcf <tcp_receive+0xffd>
          pcb->rcv_ann_wnd = 0;
  81ebc3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebc7:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81ebcd:	eb 20                	jmp    81ebef <tcp_receive+0x101d>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81ebcf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebd3:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81ebd7:	48 b8 e2 74 b5 00 00 	movabs $0xb574e2,%rax
  81ebde:	00 00 00 
  81ebe1:	0f b7 00             	movzwl (%rax),%eax
  81ebe4:	66 29 c2             	sub    %ax,%dx
  81ebe7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ebeb:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81ebef:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ebf6:	00 00 00 
  81ebf9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ebfd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ec01:	66 85 c0             	test   %ax,%ax
  81ec04:	74 2d                	je     81ec33 <tcp_receive+0x1061>
          recv_data = inseg.p;
  81ec06:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec0d:	00 00 00 
  81ec10:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ec14:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ec1b:	00 00 00 
  81ec1e:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81ec21:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec28:	00 00 00 
  81ec2b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ec32:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81ec33:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81ec3a:	00 00 00 
  81ec3d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec41:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ec45:	0f b7 c0             	movzwl %ax,%eax
  81ec48:	89 c7                	mov    %eax,%edi
  81ec4a:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ec51:	00 00 00 
  81ec54:	ff d0                	callq  *%rax
  81ec56:	0f b7 c0             	movzwl %ax,%eax
  81ec59:	83 e0 01             	and    $0x1,%eax
  81ec5c:	84 c0                	test   %al,%al
  81ec5e:	0f 84 96 03 00 00    	je     81effa <tcp_receive+0x1428>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81ec64:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81ec6b:	00 00 00 
  81ec6e:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81ec71:	e9 84 03 00 00       	jmpq   81effa <tcp_receive+0x1428>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81ec76:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec7a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ec81:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81ec85:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec89:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ec90:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec94:	8b 50 04             	mov    0x4(%rax),%edx
  81ec97:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81ec9e:	00 00 00 
  81eca1:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81eca3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eca7:	8b 58 30             	mov    0x30(%rax),%ebx
  81ecaa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ecae:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ecb2:	44 0f b7 e0          	movzwl %ax,%r12d
  81ecb6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ecba:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ecbe:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ecc2:	0f b7 c0             	movzwl %ax,%eax
  81ecc5:	89 c7                	mov    %eax,%edi
  81ecc7:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ecce:	00 00 00 
  81ecd1:	ff d0                	callq  *%rax
  81ecd3:	0f b7 c0             	movzwl %ax,%eax
  81ecd6:	83 e0 01             	and    $0x1,%eax
  81ecd9:	84 c0                	test   %al,%al
  81ecdb:	75 27                	jne    81ed04 <tcp_receive+0x1132>
  81ecdd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ece1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ece5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ece9:	0f b7 c0             	movzwl %ax,%eax
  81ecec:	89 c7                	mov    %eax,%edi
  81ecee:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ecf5:	00 00 00 
  81ecf8:	ff d0                	callq  *%rax
  81ecfa:	0f b7 c0             	movzwl %ax,%eax
  81ecfd:	83 e0 02             	and    $0x2,%eax
  81ed00:	85 c0                	test   %eax,%eax
  81ed02:	74 07                	je     81ed0b <tcp_receive+0x1139>
  81ed04:	b8 01 00 00 00       	mov    $0x1,%eax
  81ed09:	eb 05                	jmp    81ed10 <tcp_receive+0x113e>
  81ed0b:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed10:	44 01 e0             	add    %r12d,%eax
  81ed13:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81ed16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed1a:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81ed1d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed21:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81ed25:	0f b7 d8             	movzwl %ax,%ebx
  81ed28:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ed2c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ed30:	44 0f b7 e0          	movzwl %ax,%r12d
  81ed34:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ed38:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ed3c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ed40:	0f b7 c0             	movzwl %ax,%eax
  81ed43:	89 c7                	mov    %eax,%edi
  81ed45:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ed4c:	00 00 00 
  81ed4f:	ff d0                	callq  *%rax
  81ed51:	0f b7 c0             	movzwl %ax,%eax
  81ed54:	83 e0 01             	and    $0x1,%eax
  81ed57:	84 c0                	test   %al,%al
  81ed59:	75 27                	jne    81ed82 <tcp_receive+0x11b0>
  81ed5b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ed5f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ed63:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ed67:	0f b7 c0             	movzwl %ax,%eax
  81ed6a:	89 c7                	mov    %eax,%edi
  81ed6c:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ed73:	00 00 00 
  81ed76:	ff d0                	callq  *%rax
  81ed78:	0f b7 c0             	movzwl %ax,%eax
  81ed7b:	83 e0 02             	and    $0x2,%eax
  81ed7e:	85 c0                	test   %eax,%eax
  81ed80:	74 07                	je     81ed89 <tcp_receive+0x11b7>
  81ed82:	b8 01 00 00 00       	mov    $0x1,%eax
  81ed87:	eb 05                	jmp    81ed8e <tcp_receive+0x11bc>
  81ed89:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed8e:	44 01 e0             	add    %r12d,%eax
  81ed91:	39 c3                	cmp    %eax,%ebx
  81ed93:	7d 0c                	jge    81eda1 <tcp_receive+0x11cf>
            pcb->rcv_wnd = 0;
  81ed95:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed99:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81ed9f:	eb 7b                	jmp    81ee1c <tcp_receive+0x124a>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81eda1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eda5:	0f b7 58 34          	movzwl 0x34(%rax),%ebx
  81eda9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81edad:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81edb2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81edb6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81edba:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81edbe:	0f b7 c0             	movzwl %ax,%eax
  81edc1:	89 c7                	mov    %eax,%edi
  81edc3:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81edca:	00 00 00 
  81edcd:	ff d0                	callq  *%rax
  81edcf:	0f b7 c0             	movzwl %ax,%eax
  81edd2:	83 e0 01             	and    $0x1,%eax
  81edd5:	84 c0                	test   %al,%al
  81edd7:	75 27                	jne    81ee00 <tcp_receive+0x122e>
  81edd9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eddd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ede1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ede5:	0f b7 c0             	movzwl %ax,%eax
  81ede8:	89 c7                	mov    %eax,%edi
  81edea:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81edf1:	00 00 00 
  81edf4:	ff d0                	callq  *%rax
  81edf6:	0f b7 c0             	movzwl %ax,%eax
  81edf9:	83 e0 02             	and    $0x2,%eax
  81edfc:	85 c0                	test   %eax,%eax
  81edfe:	74 07                	je     81ee07 <tcp_receive+0x1235>
  81ee00:	b8 01 00 00 00       	mov    $0x1,%eax
  81ee05:	eb 05                	jmp    81ee0c <tcp_receive+0x123a>
  81ee07:	b8 00 00 00 00       	mov    $0x0,%eax
  81ee0c:	44 01 e0             	add    %r12d,%eax
  81ee0f:	89 da                	mov    %ebx,%edx
  81ee11:	66 29 c2             	sub    %ax,%dx
  81ee14:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee18:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81ee1c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee20:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81ee24:	0f b7 d8             	movzwl %ax,%ebx
  81ee27:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ee2b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ee2f:	44 0f b7 e0          	movzwl %ax,%r12d
  81ee33:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ee37:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee3b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ee3f:	0f b7 c0             	movzwl %ax,%eax
  81ee42:	89 c7                	mov    %eax,%edi
  81ee44:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ee4b:	00 00 00 
  81ee4e:	ff d0                	callq  *%rax
  81ee50:	0f b7 c0             	movzwl %ax,%eax
  81ee53:	83 e0 01             	and    $0x1,%eax
  81ee56:	84 c0                	test   %al,%al
  81ee58:	75 27                	jne    81ee81 <tcp_receive+0x12af>
  81ee5a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ee5e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee62:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ee66:	0f b7 c0             	movzwl %ax,%eax
  81ee69:	89 c7                	mov    %eax,%edi
  81ee6b:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81ee72:	00 00 00 
  81ee75:	ff d0                	callq  *%rax
  81ee77:	0f b7 c0             	movzwl %ax,%eax
  81ee7a:	83 e0 02             	and    $0x2,%eax
  81ee7d:	85 c0                	test   %eax,%eax
  81ee7f:	74 07                	je     81ee88 <tcp_receive+0x12b6>
  81ee81:	b8 01 00 00 00       	mov    $0x1,%eax
  81ee86:	eb 05                	jmp    81ee8d <tcp_receive+0x12bb>
  81ee88:	b8 00 00 00 00       	mov    $0x0,%eax
  81ee8d:	44 01 e0             	add    %r12d,%eax
  81ee90:	39 c3                	cmp    %eax,%ebx
  81ee92:	7d 0c                	jge    81eea0 <tcp_receive+0x12ce>
            pcb->rcv_ann_wnd = 0;
  81ee94:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee98:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81ee9e:	eb 7b                	jmp    81ef1b <tcp_receive+0x1349>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81eea0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eea4:	0f b7 58 36          	movzwl 0x36(%rax),%ebx
  81eea8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eeac:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81eeb1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eeb5:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eeb9:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eebd:	0f b7 c0             	movzwl %ax,%eax
  81eec0:	89 c7                	mov    %eax,%edi
  81eec2:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81eec9:	00 00 00 
  81eecc:	ff d0                	callq  *%rax
  81eece:	0f b7 c0             	movzwl %ax,%eax
  81eed1:	83 e0 01             	and    $0x1,%eax
  81eed4:	84 c0                	test   %al,%al
  81eed6:	75 27                	jne    81eeff <tcp_receive+0x132d>
  81eed8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eedc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eee0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eee4:	0f b7 c0             	movzwl %ax,%eax
  81eee7:	89 c7                	mov    %eax,%edi
  81eee9:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81eef0:	00 00 00 
  81eef3:	ff d0                	callq  *%rax
  81eef5:	0f b7 c0             	movzwl %ax,%eax
  81eef8:	83 e0 02             	and    $0x2,%eax
  81eefb:	85 c0                	test   %eax,%eax
  81eefd:	74 07                	je     81ef06 <tcp_receive+0x1334>
  81eeff:	b8 01 00 00 00       	mov    $0x1,%eax
  81ef04:	eb 05                	jmp    81ef0b <tcp_receive+0x1339>
  81ef06:	b8 00 00 00 00       	mov    $0x0,%eax
  81ef0b:	44 01 e0             	add    %r12d,%eax
  81ef0e:	89 da                	mov    %ebx,%edx
  81ef10:	66 29 c2             	sub    %ax,%dx
  81ef13:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef17:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81ef1b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef1f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ef23:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ef27:	66 85 c0             	test   %ax,%ax
  81ef2a:	74 5c                	je     81ef88 <tcp_receive+0x13b6>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81ef2c:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ef33:	00 00 00 
  81ef36:	48 8b 00             	mov    (%rax),%rax
  81ef39:	48 85 c0             	test   %rax,%rax
  81ef3c:	74 29                	je     81ef67 <tcp_receive+0x1395>
              pbuf_cat(recv_data, cseg->p);
  81ef3e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef42:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ef46:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ef4d:	00 00 00 
  81ef50:	48 8b 00             	mov    (%rax),%rax
  81ef53:	48 89 d6             	mov    %rdx,%rsi
  81ef56:	48 89 c7             	mov    %rax,%rdi
  81ef59:	48 b8 57 d9 80 00 00 	movabs $0x80d957,%rax
  81ef60:	00 00 00 
  81ef63:	ff d0                	callq  *%rax
  81ef65:	eb 15                	jmp    81ef7c <tcp_receive+0x13aa>
            } else {
              recv_data = cseg->p;
  81ef67:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef6b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ef6f:	48 b8 e8 74 b5 00 00 	movabs $0xb574e8,%rax
  81ef76:	00 00 00 
  81ef79:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81ef7c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef80:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ef87:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81ef88:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef8c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef90:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef94:	0f b7 c0             	movzwl %ax,%eax
  81ef97:	89 c7                	mov    %eax,%edi
  81ef99:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81efa0:	00 00 00 
  81efa3:	ff d0                	callq  *%rax
  81efa5:	0f b7 c0             	movzwl %ax,%eax
  81efa8:	83 e0 01             	and    $0x1,%eax
  81efab:	84 c0                	test   %al,%al
  81efad:	74 24                	je     81efd3 <tcp_receive+0x1401>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81efaf:	48 b8 e4 74 b5 00 00 	movabs $0xb574e4,%rax
  81efb6:	00 00 00 
  81efb9:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81efbc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efc0:	8b 40 18             	mov    0x18(%rax),%eax
  81efc3:	83 f8 04             	cmp    $0x4,%eax
  81efc6:	75 0b                	jne    81efd3 <tcp_receive+0x1401>
              pcb->state = CLOSE_WAIT;
  81efc8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efcc:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81efd3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81efd7:	48 8b 10             	mov    (%rax),%rdx
  81efda:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efde:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81efe5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81efe9:	48 89 c7             	mov    %rax,%rdi
  81efec:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  81eff3:	00 00 00 
  81eff6:	ff d0                	callq  *%rax
  81eff8:	eb 01                	jmp    81effb <tcp_receive+0x1429>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81effa:	90                   	nop
  81effb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81efff:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f006:	48 85 c0             	test   %rax,%rax
  81f009:	74 21                	je     81f02c <tcp_receive+0x145a>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f00b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f00f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f016:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f01a:	8b 50 04             	mov    0x4(%rax),%edx
  81f01d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f021:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f024:	39 c2                	cmp    %eax,%edx
  81f026:	0f 84 4a fc ff ff    	je     81ec76 <tcp_receive+0x10a4>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f02c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f030:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f034:	0f b6 c0             	movzbl %al,%eax
  81f037:	83 e0 01             	and    $0x1,%eax
  81f03a:	84 c0                	test   %al,%al
  81f03c:	74 40                	je     81f07e <tcp_receive+0x14ac>
  81f03e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f042:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f046:	89 c2                	mov    %eax,%edx
  81f048:	83 e2 fe             	and    $0xfffffffe,%edx
  81f04b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f04f:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f052:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f056:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f05a:	89 c2                	mov    %eax,%edx
  81f05c:	83 ca 02             	or     $0x2,%edx
  81f05f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f063:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f066:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f06a:	48 89 c7             	mov    %rax,%rdi
  81f06d:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81f074:	00 00 00 
  81f077:	ff d0                	callq  *%rax
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f079:	e9 14 06 00 00       	jmpq   81f692 <tcp_receive+0x1ac0>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f07e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f082:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f086:	89 c2                	mov    %eax,%edx
  81f088:	83 ca 01             	or     $0x1,%edx
  81f08b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f08f:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f092:	e9 fb 05 00 00       	jmpq   81f692 <tcp_receive+0x1ac0>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f097:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f09b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f09f:	89 c2                	mov    %eax,%edx
  81f0a1:	83 ca 02             	or     $0x2,%edx
  81f0a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0a8:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f0ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0af:	48 89 c7             	mov    %rax,%rdi
  81f0b2:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81f0b9:	00 00 00 
  81f0bc:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f0be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0c2:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f0c9:	48 85 c0             	test   %rax,%rax
  81f0cc:	75 26                	jne    81f0f4 <tcp_receive+0x1522>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f0ce:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f0d5:	00 00 00 
  81f0d8:	48 b8 4d ff 80 00 00 	movabs $0x80ff4d,%rax
  81f0df:	00 00 00 
  81f0e2:	ff d0                	callq  *%rax
  81f0e4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81f0e8:	48 89 82 90 00 00 00 	mov    %rax,0x90(%rdx)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f0ef:	e9 9e 05 00 00       	jmpq   81f692 <tcp_receive+0x1ac0>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f0f4:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f0fb:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f0fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f100:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f107:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f10b:	e9 c5 04 00 00       	jmpq   81f5d5 <tcp_receive+0x1a03>
            if (seqno == next->tcphdr->seqno) {
  81f110:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f114:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f118:	8b 50 04             	mov    0x4(%rax),%edx
  81f11b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f122:	00 00 00 
  81f125:	8b 00                	mov    (%rax),%eax
  81f127:	39 c2                	cmp    %eax,%edx
  81f129:	0f 85 22 01 00 00    	jne    81f251 <tcp_receive+0x167f>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f12f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f136:	00 00 00 
  81f139:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f13d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f141:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f145:	66 39 c2             	cmp    %ax,%dx
  81f148:	0f 86 97 04 00 00    	jbe    81f5e5 <tcp_receive+0x1a13>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f14e:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f155:	00 00 00 
  81f158:	48 b8 4d ff 80 00 00 	movabs $0x80ff4d,%rax
  81f15f:	00 00 00 
  81f162:	ff d0                	callq  *%rax
  81f164:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f168:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f16d:	0f 84 75 04 00 00    	je     81f5e8 <tcp_receive+0x1a16>
                  cseg->next = next->next;
  81f173:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f177:	48 8b 10             	mov    (%rax),%rdx
  81f17a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f17e:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f181:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f186:	74 0d                	je     81f195 <tcp_receive+0x15c3>
                    prev->next = cseg;
  81f188:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f18c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f190:	48 89 10             	mov    %rdx,(%rax)
  81f193:	eb 0f                	jmp    81f1a4 <tcp_receive+0x15d2>
                  } else {
                    pcb->ooseq = cseg;
  81f195:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f199:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f19d:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f1a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f1a8:	48 89 c7             	mov    %rax,%rdi
  81f1ab:	48 b8 d3 fe 80 00 00 	movabs $0x80fed3,%rax
  81f1b2:	00 00 00 
  81f1b5:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f1b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1bb:	48 8b 00             	mov    (%rax),%rax
  81f1be:	48 85 c0             	test   %rax,%rax
  81f1c1:	0f 84 21 04 00 00    	je     81f5e8 <tcp_receive+0x1a16>
                    next = cseg->next;
  81f1c7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1cb:	48 8b 00             	mov    (%rax),%rax
  81f1ce:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f1d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1d6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f1da:	0f b7 d0             	movzwl %ax,%edx
  81f1dd:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f1e4:	00 00 00 
  81f1e7:	8b 00                	mov    (%rax),%eax
  81f1e9:	01 c2                	add    %eax,%edx
  81f1eb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f1ef:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1f3:	8b 40 04             	mov    0x4(%rax),%eax
  81f1f6:	89 d1                	mov    %edx,%ecx
  81f1f8:	29 c1                	sub    %eax,%ecx
  81f1fa:	89 c8                	mov    %ecx,%eax
  81f1fc:	85 c0                	test   %eax,%eax
  81f1fe:	0f 8e e4 03 00 00    	jle    81f5e8 <tcp_receive+0x1a16>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f204:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f208:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f20c:	8b 40 04             	mov    0x4(%rax),%eax
  81f20f:	89 c2                	mov    %eax,%edx
  81f211:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f218:	00 00 00 
  81f21b:	8b 00                	mov    (%rax),%eax
  81f21d:	66 29 c2             	sub    %ax,%dx
  81f220:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f224:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f228:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f22c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f230:	0f b7 d0             	movzwl %ax,%edx
  81f233:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f237:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f23b:	89 d6                	mov    %edx,%esi
  81f23d:	48 89 c7             	mov    %rax,%rdi
  81f240:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  81f247:	00 00 00 
  81f24a:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f24c:	e9 97 03 00 00       	jmpq   81f5e8 <tcp_receive+0x1a16>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  81f251:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f256:	0f 85 f7 00 00 00    	jne    81f353 <tcp_receive+0x1781>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f25c:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f263:	00 00 00 
  81f266:	8b 10                	mov    (%rax),%edx
  81f268:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f26c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f270:	8b 40 04             	mov    0x4(%rax),%eax
  81f273:	89 d3                	mov    %edx,%ebx
  81f275:	29 c3                	sub    %eax,%ebx
  81f277:	89 d8                	mov    %ebx,%eax
  81f279:	85 c0                	test   %eax,%eax
  81f27b:	0f 89 67 02 00 00    	jns    81f4e8 <tcp_receive+0x1916>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f281:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f288:	00 00 00 
  81f28b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f28f:	0f b7 d0             	movzwl %ax,%edx
  81f292:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f299:	00 00 00 
  81f29c:	8b 00                	mov    (%rax),%eax
  81f29e:	01 c2                	add    %eax,%edx
  81f2a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f2a4:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f2a8:	8b 40 04             	mov    0x4(%rax),%eax
  81f2ab:	89 d1                	mov    %edx,%ecx
  81f2ad:	29 c1                	sub    %eax,%ecx
  81f2af:	89 c8                	mov    %ecx,%eax
  81f2b1:	85 c0                	test   %eax,%eax
  81f2b3:	7e 5a                	jle    81f30f <tcp_receive+0x173d>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f2b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f2b9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f2bd:	8b 40 04             	mov    0x4(%rax),%eax
  81f2c0:	89 c2                	mov    %eax,%edx
  81f2c2:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f2c9:	00 00 00 
  81f2cc:	8b 00                	mov    (%rax),%eax
  81f2ce:	66 29 c2             	sub    %ax,%dx
  81f2d1:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f2d8:	00 00 00 
  81f2db:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81f2df:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f2e6:	00 00 00 
  81f2e9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f2ed:	0f b7 d0             	movzwl %ax,%edx
  81f2f0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f2f7:	00 00 00 
  81f2fa:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f2fe:	89 d6                	mov    %edx,%esi
  81f300:	48 89 c7             	mov    %rax,%rdi
  81f303:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  81f30a:	00 00 00 
  81f30d:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81f30f:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f316:	00 00 00 
  81f319:	48 b8 4d ff 80 00 00 	movabs $0x80ff4d,%rax
  81f320:	00 00 00 
  81f323:	ff d0                	callq  *%rax
  81f325:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81f329:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f32e:	0f 84 b7 02 00 00    	je     81f5eb <tcp_receive+0x1a19>
                    cseg->next = next;
  81f334:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f338:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f33c:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81f33f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f343:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f347:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81f34e:	e9 98 02 00 00       	jmpq   81f5eb <tcp_receive+0x1a19>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81f353:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f357:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f35b:	8b 40 04             	mov    0x4(%rax),%eax
  81f35e:	89 c2                	mov    %eax,%edx
  81f360:	f7 d2                	not    %edx
  81f362:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f369:	00 00 00 
  81f36c:	8b 00                	mov    (%rax),%eax
  81f36e:	01 d0                	add    %edx,%eax
  81f370:	85 c0                	test   %eax,%eax
  81f372:	0f 88 70 01 00 00    	js     81f4e8 <tcp_receive+0x1916>
  81f378:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f37f:	00 00 00 
  81f382:	8b 10                	mov    (%rax),%edx
  81f384:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f388:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f38c:	8b 40 04             	mov    0x4(%rax),%eax
  81f38f:	89 d3                	mov    %edx,%ebx
  81f391:	29 c3                	sub    %eax,%ebx
  81f393:	89 d8                	mov    %ebx,%eax
  81f395:	83 c0 01             	add    $0x1,%eax
  81f398:	85 c0                	test   %eax,%eax
  81f39a:	0f 8f 48 01 00 00    	jg     81f4e8 <tcp_receive+0x1916>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f3a0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f3a7:	00 00 00 
  81f3aa:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f3ae:	0f b7 d0             	movzwl %ax,%edx
  81f3b1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f3b8:	00 00 00 
  81f3bb:	8b 00                	mov    (%rax),%eax
  81f3bd:	01 c2                	add    %eax,%edx
  81f3bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f3c3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3c7:	8b 40 04             	mov    0x4(%rax),%eax
  81f3ca:	89 d1                	mov    %edx,%ecx
  81f3cc:	29 c1                	sub    %eax,%ecx
  81f3ce:	89 c8                	mov    %ecx,%eax
  81f3d0:	85 c0                	test   %eax,%eax
  81f3d2:	7e 5a                	jle    81f42e <tcp_receive+0x185c>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f3d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f3d8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3dc:	8b 40 04             	mov    0x4(%rax),%eax
  81f3df:	89 c2                	mov    %eax,%edx
  81f3e1:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f3e8:	00 00 00 
  81f3eb:	8b 00                	mov    (%rax),%eax
  81f3ed:	66 29 c2             	sub    %ax,%dx
  81f3f0:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f3f7:	00 00 00 
  81f3fa:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81f3fe:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f405:	00 00 00 
  81f408:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f40c:	0f b7 d0             	movzwl %ax,%edx
  81f40f:	48 b8 a0 74 b5 00 00 	movabs $0xb574a0,%rax
  81f416:	00 00 00 
  81f419:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f41d:	89 d6                	mov    %edx,%esi
  81f41f:	48 89 c7             	mov    %rax,%rdi
  81f422:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  81f429:	00 00 00 
  81f42c:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81f42e:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f435:	00 00 00 
  81f438:	48 b8 4d ff 80 00 00 	movabs $0x80ff4d,%rax
  81f43f:	00 00 00 
  81f442:	ff d0                	callq  *%rax
  81f444:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f448:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f44d:	0f 84 9b 01 00 00    	je     81f5ee <tcp_receive+0x1a1c>
                  cseg->next = next;
  81f453:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f457:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f45b:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81f45e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f462:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f466:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81f469:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f46d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f471:	8b 50 04             	mov    0x4(%rax),%edx
  81f474:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f478:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f47c:	0f b7 c0             	movzwl %ax,%eax
  81f47f:	01 c2                	add    %eax,%edx
  81f481:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f488:	00 00 00 
  81f48b:	8b 00                	mov    (%rax),%eax
  81f48d:	89 d3                	mov    %edx,%ebx
  81f48f:	29 c3                	sub    %eax,%ebx
  81f491:	89 d8                	mov    %ebx,%eax
  81f493:	85 c0                	test   %eax,%eax
  81f495:	0f 8e 53 01 00 00    	jle    81f5ee <tcp_receive+0x1a1c>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81f49b:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f4a2:	00 00 00 
  81f4a5:	8b 00                	mov    (%rax),%eax
  81f4a7:	89 c2                	mov    %eax,%edx
  81f4a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f4ad:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f4b1:	8b 40 04             	mov    0x4(%rax),%eax
  81f4b4:	66 29 c2             	sub    %ax,%dx
  81f4b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f4bb:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81f4bf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f4c3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f4c7:	0f b7 d0             	movzwl %ax,%edx
  81f4ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f4ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f4d2:	89 d6                	mov    %edx,%esi
  81f4d4:	48 89 c7             	mov    %rax,%rdi
  81f4d7:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  81f4de:	00 00 00 
  81f4e1:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f4e3:	e9 06 01 00 00       	jmpq   81f5ee <tcp_receive+0x1a1c>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f4e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f4ec:	48 8b 00             	mov    (%rax),%rax
  81f4ef:	48 85 c0             	test   %rax,%rax
  81f4f2:	0f 85 ca 00 00 00    	jne    81f5c2 <tcp_receive+0x19f0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81f4f8:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f4ff:	00 00 00 
  81f502:	8b 10                	mov    (%rax),%edx
  81f504:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f508:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f50c:	8b 40 04             	mov    0x4(%rax),%eax
  81f50f:	89 d1                	mov    %edx,%ecx
  81f511:	29 c1                	sub    %eax,%ecx
  81f513:	89 c8                	mov    %ecx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f515:	85 c0                	test   %eax,%eax
  81f517:	0f 8e a5 00 00 00    	jle    81f5c2 <tcp_receive+0x19f0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81f51d:	48 bf a0 74 b5 00 00 	movabs $0xb574a0,%rdi
  81f524:	00 00 00 
  81f527:	48 b8 4d ff 80 00 00 	movabs $0x80ff4d,%rax
  81f52e:	00 00 00 
  81f531:	ff d0                	callq  *%rax
  81f533:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f537:	48 89 02             	mov    %rax,(%rdx)
                if (next->next != NULL) {
  81f53a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f53e:	48 8b 00             	mov    (%rax),%rax
  81f541:	48 85 c0             	test   %rax,%rax
  81f544:	0f 84 a7 00 00 00    	je     81f5f1 <tcp_receive+0x1a1f>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81f54a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f54e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f552:	8b 50 04             	mov    0x4(%rax),%edx
  81f555:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f559:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f55d:	0f b7 c0             	movzwl %ax,%eax
  81f560:	01 c2                	add    %eax,%edx
  81f562:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f569:	00 00 00 
  81f56c:	8b 00                	mov    (%rax),%eax
  81f56e:	89 d3                	mov    %edx,%ebx
  81f570:	29 c3                	sub    %eax,%ebx
  81f572:	89 d8                	mov    %ebx,%eax
  81f574:	85 c0                	test   %eax,%eax
  81f576:	7e 79                	jle    81f5f1 <tcp_receive+0x1a1f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81f578:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f57f:	00 00 00 
  81f582:	8b 00                	mov    (%rax),%eax
  81f584:	89 c2                	mov    %eax,%edx
  81f586:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f58a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f58e:	8b 40 04             	mov    0x4(%rax),%eax
  81f591:	66 29 c2             	sub    %ax,%dx
  81f594:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f598:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81f59c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5a0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f5a4:	0f b7 d0             	movzwl %ax,%edx
  81f5a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f5af:	89 d6                	mov    %edx,%esi
  81f5b1:	48 89 c7             	mov    %rax,%rdi
  81f5b4:	48 b8 3f d3 80 00 00 	movabs $0x80d33f,%rax
  81f5bb:	00 00 00 
  81f5be:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f5c0:	eb 2f                	jmp    81f5f1 <tcp_receive+0x1a1f>
              }
            }
            prev = next;
  81f5c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5c6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f5ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5ce:	48 8b 00             	mov    (%rax),%rax
  81f5d1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f5d5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81f5da:	0f 85 30 fb ff ff    	jne    81f110 <tcp_receive+0x153e>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f5e0:	e9 ad 00 00 00       	jmpq   81f692 <tcp_receive+0x1ac0>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81f5e5:	90                   	nop
  81f5e6:	eb 0a                	jmp    81f5f2 <tcp_receive+0x1a20>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
                      pbuf_realloc(cseg->p, cseg->len);
                    }
                  }
                }
                break;
  81f5e8:	90                   	nop
  81f5e9:	eb 07                	jmp    81f5f2 <tcp_receive+0x1a20>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
  81f5eb:	90                   	nop
  81f5ec:	eb 04                	jmp    81f5f2 <tcp_receive+0x1a20>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                    pbuf_realloc(prev->p, prev->len);
                  }
                }
                break;
  81f5ee:	90                   	nop
  81f5ef:	eb 01                	jmp    81f5f2 <tcp_receive+0x1a20>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
  81f5f1:	90                   	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f5f2:	90                   	nop
  81f5f3:	e9 9a 00 00 00       	jmpq   81f692 <tcp_receive+0x1ac0>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81f5f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f5fc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f600:	89 c2                	mov    %eax,%edx
  81f602:	83 ca 02             	or     $0x2,%edx
  81f605:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f609:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f60c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f610:	48 89 c7             	mov    %rax,%rdi
  81f613:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81f61a:	00 00 00 
  81f61d:	ff d0                	callq  *%rax
  81f61f:	eb 71                	jmp    81f692 <tcp_receive+0x1ac0>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81f621:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f628:	00 00 00 
  81f62b:	8b 10                	mov    (%rax),%edx
  81f62d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f631:	8b 40 30             	mov    0x30(%rax),%eax
  81f634:	89 d1                	mov    %edx,%ecx
  81f636:	29 c1                	sub    %eax,%ecx
  81f638:	89 c8                	mov    %ecx,%eax
  81f63a:	85 c0                	test   %eax,%eax
  81f63c:	78 2d                	js     81f66b <tcp_receive+0x1a99>
  81f63e:	48 b8 d8 74 b5 00 00 	movabs $0xb574d8,%rax
  81f645:	00 00 00 
  81f648:	8b 10                	mov    (%rax),%edx
  81f64a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f64e:	8b 48 30             	mov    0x30(%rax),%ecx
  81f651:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f655:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f659:	0f b7 c0             	movzwl %ax,%eax
  81f65c:	01 c8                	add    %ecx,%eax
  81f65e:	89 d3                	mov    %edx,%ebx
  81f660:	29 c3                	sub    %eax,%ebx
  81f662:	89 d8                	mov    %ebx,%eax
  81f664:	83 c0 01             	add    $0x1,%eax
  81f667:	85 c0                	test   %eax,%eax
  81f669:	7e 27                	jle    81f692 <tcp_receive+0x1ac0>
      tcp_ack_now(pcb);
  81f66b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f66f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f673:	89 c2                	mov    %eax,%edx
  81f675:	83 ca 02             	or     $0x2,%edx
  81f678:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f67c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f67f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f683:	48 89 c7             	mov    %rax,%rdi
  81f686:	48 b8 e2 36 81 00 00 	movabs $0x8136e2,%rax
  81f68d:	00 00 00 
  81f690:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81f692:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81f696:	48 83 c4 58          	add    $0x58,%rsp
  81f69a:	5b                   	pop    %rbx
  81f69b:	41 5c                	pop    %r12
  81f69d:	41 5d                	pop    %r13
  81f69f:	5d                   	pop    %rbp
  81f6a0:	c3                   	retq   

000000000081f6a1 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81f6a1:	55                   	push   %rbp
  81f6a2:	48 89 e5             	mov    %rsp,%rbp
  81f6a5:	53                   	push   %rbx
  81f6a6:	48 83 ec 38          	sub    $0x38,%rsp
  81f6aa:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81f6ae:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81f6b5:	00 00 00 
  81f6b8:	48 8b 00             	mov    (%rax),%rax
  81f6bb:	48 83 c0 14          	add    $0x14,%rax
  81f6bf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81f6c3:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81f6ca:	00 00 00 
  81f6cd:	48 8b 00             	mov    (%rax),%rax
  81f6d0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f6d4:	0f b7 c0             	movzwl %ax,%eax
  81f6d7:	89 c7                	mov    %eax,%edi
  81f6d9:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81f6e0:	00 00 00 
  81f6e3:	ff d0                	callq  *%rax
  81f6e5:	66 c1 e8 0c          	shr    $0xc,%ax
  81f6e9:	66 83 f8 05          	cmp    $0x5,%ax
  81f6ed:	0f 86 02 01 00 00    	jbe    81f7f5 <tcp_parseopt+0x154>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f6f3:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81f6f7:	e9 b8 00 00 00       	jmpq   81f7b4 <tcp_parseopt+0x113>
      opt = opts[c];
  81f6fc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f700:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f704:	0f b6 00             	movzbl (%rax),%eax
  81f707:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81f70a:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81f70e:	0f 84 dd 00 00 00    	je     81f7f1 <tcp_parseopt+0x150>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  81f714:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81f718:	75 09                	jne    81f723 <tcp_parseopt+0x82>
        ++c;
  81f71a:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81f71e:	e9 91 00 00 00       	jmpq   81f7b4 <tcp_parseopt+0x113>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f723:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81f727:	75 66                	jne    81f78f <tcp_parseopt+0xee>
        opts[c + 1] == 0x04) {
  81f729:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f72d:	48 83 c0 01          	add    $0x1,%rax
  81f731:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f735:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f738:	3c 04                	cmp    $0x4,%al
  81f73a:	75 53                	jne    81f78f <tcp_parseopt+0xee>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81f73c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f740:	48 83 c0 02          	add    $0x2,%rax
  81f744:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f748:	0f b6 00             	movzbl (%rax),%eax
  81f74b:	0f b6 c0             	movzbl %al,%eax
  81f74e:	c1 e0 08             	shl    $0x8,%eax
  81f751:	89 c2                	mov    %eax,%edx
  81f753:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f757:	48 83 c0 03          	add    $0x3,%rax
  81f75b:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f75f:	0f b6 00             	movzbl (%rax),%eax
  81f762:	0f b6 c0             	movzbl %al,%eax
  81f765:	09 d0                	or     %edx,%eax
  81f767:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81f76b:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81f771:	77 0d                	ja     81f780 <tcp_parseopt+0xdf>
  81f773:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81f778:	74 06                	je     81f780 <tcp_parseopt+0xdf>
  81f77a:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81f77e:	eb 05                	jmp    81f785 <tcp_parseopt+0xe4>
  81f780:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81f785:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f789:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81f78d:	eb 66                	jmp    81f7f5 <tcp_parseopt+0x154>
      } else {
        if (opts[c + 1] == 0) {
  81f78f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f793:	48 83 c0 01          	add    $0x1,%rax
  81f797:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f79b:	0f b6 00             	movzbl (%rax),%eax
  81f79e:	84 c0                	test   %al,%al
  81f7a0:	74 52                	je     81f7f4 <tcp_parseopt+0x153>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81f7a2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f7a6:	48 83 c0 01          	add    $0x1,%rax
  81f7aa:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f7ae:	0f b6 00             	movzbl (%rax),%eax
  81f7b1:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f7b4:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81f7b8:	48 b8 c8 74 b5 00 00 	movabs $0xb574c8,%rax
  81f7bf:	00 00 00 
  81f7c2:	48 8b 00             	mov    (%rax),%rax
  81f7c5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f7c9:	0f b7 c0             	movzwl %ax,%eax
  81f7cc:	89 c7                	mov    %eax,%edi
  81f7ce:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81f7d5:	00 00 00 
  81f7d8:	ff d0                	callq  *%rax
  81f7da:	66 c1 e8 0c          	shr    $0xc,%ax
  81f7de:	0f b7 c0             	movzwl %ax,%eax
  81f7e1:	83 e8 05             	sub    $0x5,%eax
  81f7e4:	c1 e0 02             	shl    $0x2,%eax
  81f7e7:	39 c3                	cmp    %eax,%ebx
  81f7e9:	0f 8c 0d ff ff ff    	jl     81f6fc <tcp_parseopt+0x5b>
  81f7ef:	eb 04                	jmp    81f7f5 <tcp_parseopt+0x154>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
  81f7f1:	90                   	nop
  81f7f2:	eb 01                	jmp    81f7f5 <tcp_parseopt+0x154>
        break;
      } else {
        if (opts[c + 1] == 0) {
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81f7f4:	90                   	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81f7f5:	48 83 c4 38          	add    $0x38,%rsp
  81f7f9:	5b                   	pop    %rbx
  81f7fa:	5d                   	pop    %rbp
  81f7fb:	c3                   	retq   

000000000081f7fc <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81f7fc:	55                   	push   %rbp
  81f7fd:	48 89 e5             	mov    %rsp,%rbp
  81f800:	48 83 ec 40          	sub    $0x40,%rsp
  81f804:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81f808:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81f80c:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81f810:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81f814:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f818:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81f81c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f820:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81f824:	0f b7 c0             	movzwl %ax,%eax
  81f827:	89 c7                	mov    %eax,%edi
  81f829:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81f830:	00 00 00 
  81f833:	ff d0                	callq  *%rax
  81f835:	66 25 ff 00          	and    $0xff,%ax
  81f839:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81f83d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81f844:	00 
  pcb = raw_pcbs;
  81f845:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81f84c:	00 00 00 
  81f84f:	48 8b 00             	mov    (%rax),%rax
  81f852:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81f856:	e9 ab 00 00 00       	jmpq   81f906 <raw_input+0x10a>
    if (pcb->protocol == proto) {
  81f85b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f85f:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81f863:	0f b6 d0             	movzbl %al,%edx
  81f866:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81f86a:	39 c2                	cmp    %eax,%edx
  81f86c:	0f 85 80 00 00 00    	jne    81f8f2 <raw_input+0xf6>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81f872:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f876:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f87a:	48 85 c0             	test   %rax,%rax
  81f87d:	74 73                	je     81f8f2 <raw_input+0xf6>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81f87f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f883:	4c 8b 40 20          	mov    0x20(%rax),%r8
  81f887:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81f88b:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81f88f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f893:	48 8b 40 28          	mov    0x28(%rax),%rax
  81f897:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f89b:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81f89f:	48 89 c7             	mov    %rax,%rdi
  81f8a2:	41 ff d0             	callq  *%r8
  81f8a5:	84 c0                	test   %al,%al
  81f8a7:	74 49                	je     81f8f2 <raw_input+0xf6>
        {
          /* receive function ate the packet */
          p = NULL;
  81f8a9:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81f8b0:	00 
          eaten = 1;
  81f8b1:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81f8b5:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f8ba:	74 36                	je     81f8f2 <raw_input+0xf6>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81f8bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f8c0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81f8c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f8c8:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81f8cc:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81f8d3:	00 00 00 
  81f8d6:	48 8b 10             	mov    (%rax),%rdx
  81f8d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f8dd:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81f8e1:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81f8e8:	00 00 00 
  81f8eb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f8ef:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81f8f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f8f6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81f8fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f8fe:	48 8b 40 10          	mov    0x10(%rax),%rax
  81f902:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81f906:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81f90a:	75 0b                	jne    81f917 <raw_input+0x11b>
  81f90c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81f911:	0f 85 44 ff ff ff    	jne    81f85b <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  81f917:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81f91b:	c9                   	leaveq 
  81f91c:	c3                   	retq   

000000000081f91d <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81f91d:	55                   	push   %rbp
  81f91e:	48 89 e5             	mov    %rsp,%rbp
  81f921:	48 83 ec 10          	sub    $0x10,%rsp
  81f925:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f929:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  81f92d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f932:	74 08                	je     81f93c <raw_bind+0x1f>
  81f934:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f938:	8b 00                	mov    (%rax),%eax
  81f93a:	eb 05                	jmp    81f941 <raw_bind+0x24>
  81f93c:	b8 00 00 00 00       	mov    $0x0,%eax
  81f941:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f945:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  81f947:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81f94c:	c9                   	leaveq 
  81f94d:	c3                   	retq   

000000000081f94e <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81f94e:	55                   	push   %rbp
  81f94f:	48 89 e5             	mov    %rsp,%rbp
  81f952:	48 83 ec 10          	sub    $0x10,%rsp
  81f956:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f95a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81f95e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81f963:	74 08                	je     81f96d <raw_connect+0x1f>
  81f965:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81f969:	8b 00                	mov    (%rax),%eax
  81f96b:	eb 05                	jmp    81f972 <raw_connect+0x24>
  81f96d:	b8 00 00 00 00       	mov    $0x0,%eax
  81f972:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81f976:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  81f979:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81f97e:	c9                   	leaveq 
  81f97f:	c3                   	retq   

000000000081f980 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81f980:	55                   	push   %rbp
  81f981:	48 89 e5             	mov    %rsp,%rbp
  81f984:	48 83 ec 18          	sub    $0x18,%rsp
  81f988:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81f98c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81f990:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81f994:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f998:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81f99c:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81f9a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81f9a4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81f9a8:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81f9ac:	c9                   	leaveq 
  81f9ad:	c3                   	retq   

000000000081f9ae <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  81f9ae:	55                   	push   %rbp
  81f9af:	48 89 e5             	mov    %rsp,%rbp
  81f9b2:	48 83 ec 50          	sub    $0x50,%rsp
  81f9b6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81f9ba:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81f9be:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81f9c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f9c6:	be 14 00 00 00       	mov    $0x14,%esi
  81f9cb:	48 89 c7             	mov    %rax,%rdi
  81f9ce:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81f9d5:	00 00 00 
  81f9d8:	ff d0                	callq  *%rax
  81f9da:	84 c0                	test   %al,%al
  81f9dc:	74 4c                	je     81fa2a <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81f9de:	ba 00 00 00 00       	mov    $0x0,%edx
  81f9e3:	be 00 00 00 00       	mov    $0x0,%esi
  81f9e8:	bf 01 00 00 00       	mov    $0x1,%edi
  81f9ed:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  81f9f4:	00 00 00 
  81f9f7:	ff d0                	callq  *%rax
  81f9f9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81f9fd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fa02:	75 0a                	jne    81fa0e <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  81fa04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81fa09:	e9 42 01 00 00       	jmpq   81fb50 <raw_sendto+0x1a2>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81fa0e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81fa12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fa16:	48 89 d6             	mov    %rdx,%rsi
  81fa19:	48 89 c7             	mov    %rax,%rdi
  81fa1c:	48 b8 76 da 80 00 00 	movabs $0x80da76,%rax
  81fa23:	00 00 00 
  81fa26:	ff d0                	callq  *%rax
  81fa28:	eb 4e                	jmp    81fa78 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81fa2a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fa2e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  81fa32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fa36:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81fa3b:	48 89 c7             	mov    %rax,%rdi
  81fa3e:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81fa45:	00 00 00 
  81fa48:	ff d0                	callq  *%rax
  81fa4a:	84 c0                	test   %al,%al
  81fa4c:	74 2a                	je     81fa78 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  81fa4e:	48 ba 98 35 82 00 00 	movabs $0x823598,%rdx
  81fa55:	00 00 00 
  81fa58:	be e3 00 00 00       	mov    $0xe3,%esi
  81fa5d:	48 bf be 35 82 00 00 	movabs $0x8235be,%rdi
  81fa64:	00 00 00 
  81fa67:	b8 00 00 00 00       	mov    $0x0,%eax
  81fa6c:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81fa73:	00 00 00 
  81fa76:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  81fa78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fa7c:	48 89 c7             	mov    %rax,%rdi
  81fa7f:	48 b8 40 08 81 00 00 	movabs $0x810840,%rax
  81fa86:	00 00 00 
  81fa89:	ff d0                	callq  *%rax
  81fa8b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81fa8f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81fa94:	75 27                	jne    81fabd <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81fa96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fa9a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fa9e:	74 13                	je     81fab3 <raw_sendto+0x105>
      pbuf_free(q);
  81faa0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81faa4:	48 89 c7             	mov    %rax,%rdi
  81faa7:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81faae:	00 00 00 
  81fab1:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  81fab3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81fab8:	e9 93 00 00 00       	jmpq   81fb50 <raw_sendto+0x1a2>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81fabd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fac1:	48 85 c0             	test   %rax,%rax
  81fac4:	74 0a                	je     81fad0 <raw_sendto+0x122>
  81fac6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81faca:	8b 00                	mov    (%rax),%eax
  81facc:	85 c0                	test   %eax,%eax
  81face:	75 0e                	jne    81fade <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81fad0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fad4:	48 83 c0 08          	add    $0x8,%rax
  81fad8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fadc:	eb 08                	jmp    81fae6 <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  81fade:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fae2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  81fae6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81faea:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81faee:	44 0f b6 c8          	movzbl %al,%r9d
  81faf2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81faf6:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81fafa:	44 0f b6 c0          	movzbl %al,%r8d
  81fafe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fb02:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81fb06:	0f b6 c8             	movzbl %al,%ecx
  81fb09:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fb0d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81fb11:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb15:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  81fb19:	48 89 3c 24          	mov    %rdi,(%rsp)
  81fb1d:	48 89 c7             	mov    %rax,%rdi
  81fb20:	48 b8 77 0d 81 00 00 	movabs $0x810d77,%rax
  81fb27:	00 00 00 
  81fb2a:	ff d0                	callq  *%rax
  81fb2c:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81fb2f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb33:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fb37:	74 13                	je     81fb4c <raw_sendto+0x19e>
    /* free the header */
    pbuf_free(q);
  81fb39:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb3d:	48 89 c7             	mov    %rax,%rdi
  81fb40:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81fb47:	00 00 00 
  81fb4a:	ff d0                	callq  *%rax
  }
  return err;
  81fb4c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  81fb50:	c9                   	leaveq 
  81fb51:	c3                   	retq   

000000000081fb52 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  81fb52:	55                   	push   %rbp
  81fb53:	48 89 e5             	mov    %rsp,%rbp
  81fb56:	48 83 ec 10          	sub    $0x10,%rsp
  81fb5a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb5e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81fb62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fb66:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81fb6a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81fb6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fb72:	48 89 ce             	mov    %rcx,%rsi
  81fb75:	48 89 c7             	mov    %rax,%rdi
  81fb78:	48 b8 ae f9 81 00 00 	movabs $0x81f9ae,%rax
  81fb7f:	00 00 00 
  81fb82:	ff d0                	callq  *%rax
}
  81fb84:	c9                   	leaveq 
  81fb85:	c3                   	retq   

000000000081fb86 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81fb86:	55                   	push   %rbp
  81fb87:	48 89 e5             	mov    %rsp,%rbp
  81fb8a:	48 83 ec 20          	sub    $0x20,%rsp
  81fb8e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  81fb92:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fb99:	00 00 00 
  81fb9c:	48 8b 00             	mov    (%rax),%rax
  81fb9f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81fba3:	75 20                	jne    81fbc5 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  81fba5:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fbac:	00 00 00 
  81fbaf:	48 8b 00             	mov    (%rax),%rax
  81fbb2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fbb6:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fbbd:	00 00 00 
  81fbc0:	48 89 10             	mov    %rdx,(%rax)
  81fbc3:	eb 51                	jmp    81fc16 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81fbc5:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fbcc:	00 00 00 
  81fbcf:	48 8b 00             	mov    (%rax),%rax
  81fbd2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fbd6:	eb 37                	jmp    81fc0f <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  81fbd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fbdc:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fbe0:	48 85 c0             	test   %rax,%rax
  81fbe3:	74 1e                	je     81fc03 <raw_remove+0x7d>
  81fbe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fbe9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fbed:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81fbf1:	75 10                	jne    81fc03 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81fbf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fbf7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fbfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fbff:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81fc03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc07:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fc0b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fc0f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fc14:	75 c2                	jne    81fbd8 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  81fc16:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fc1a:	48 89 c6             	mov    %rax,%rsi
  81fc1d:	bf 00 00 00 00       	mov    $0x0,%edi
  81fc22:	48 b8 0c c9 80 00 00 	movabs $0x80c90c,%rax
  81fc29:	00 00 00 
  81fc2c:	ff d0                	callq  *%rax
}
  81fc2e:	c9                   	leaveq 
  81fc2f:	c3                   	retq   

000000000081fc30 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  81fc30:	55                   	push   %rbp
  81fc31:	48 89 e5             	mov    %rsp,%rbp
  81fc34:	48 83 ec 20          	sub    $0x20,%rsp
  81fc38:	89 f8                	mov    %edi,%eax
  81fc3a:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  81fc3d:	bf 00 00 00 00       	mov    $0x0,%edi
  81fc42:	48 b8 61 c8 80 00 00 	movabs $0x80c861,%rax
  81fc49:	00 00 00 
  81fc4c:	ff d0                	callq  *%rax
  81fc4e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  81fc52:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fc57:	74 56                	je     81fcaf <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  81fc59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc5d:	ba 30 00 00 00       	mov    $0x30,%edx
  81fc62:	be 00 00 00 00       	mov    $0x0,%esi
  81fc67:	48 89 c7             	mov    %rax,%rdi
  81fc6a:	48 b8 c3 1f 80 00 00 	movabs $0x801fc3,%rax
  81fc71:	00 00 00 
  81fc74:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  81fc76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc7a:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  81fc7e:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  81fc81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc85:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  81fc89:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fc90:	00 00 00 
  81fc93:	48 8b 10             	mov    (%rax),%rdx
  81fc96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fc9a:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  81fc9e:	48 b8 f0 74 b5 00 00 	movabs $0xb574f0,%rax
  81fca5:	00 00 00 
  81fca8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fcac:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  81fcaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81fcb3:	c9                   	leaveq 
  81fcb4:	c3                   	retq   
  81fcb5:	00 00                	add    %al,(%rax)
	...

000000000081fcb8 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  81fcb8:	55                   	push   %rbp
  81fcb9:	48 89 e5             	mov    %rsp,%rbp
  81fcbc:	53                   	push   %rbx
  81fcbd:	48 83 ec 58          	sub    $0x58,%rsp
  81fcc1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  81fcc5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  81fcc9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fccd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fcd1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  81fcd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fcd9:	0f b7 00             	movzwl (%rax),%eax
  81fcdc:	0f b7 c0             	movzwl %ax,%eax
  81fcdf:	89 c7                	mov    %eax,%edi
  81fce1:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  81fce8:	00 00 00 
  81fceb:	ff d0                	callq  *%rax
  81fced:	66 c1 e8 08          	shr    $0x8,%ax
  81fcf1:	83 e0 0f             	and    $0xf,%eax
  81fcf4:	c1 e0 02             	shl    $0x2,%eax
  81fcf7:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  81fcfb:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  81fcff:	f7 d8                	neg    %eax
  81fd01:	0f bf d0             	movswl %ax,%edx
  81fd04:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fd08:	89 d6                	mov    %edx,%esi
  81fd0a:	48 89 c7             	mov    %rax,%rdi
  81fd0d:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81fd14:	00 00 00 
  81fd17:	ff d0                	callq  *%rax
  81fd19:	84 c0                	test   %al,%al
  81fd1b:	0f 85 8c 04 00 00    	jne    8201ad <icmp_input+0x4f5>
  81fd21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fd25:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81fd29:	66 83 f8 03          	cmp    $0x3,%ax
  81fd2d:	0f 86 7a 04 00 00    	jbe    8201ad <icmp_input+0x4f5>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  81fd33:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fd37:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fd3b:	0f b6 00             	movzbl (%rax),%eax
  81fd3e:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  81fd41:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fd45:	48 8b 40 08          	mov    0x8(%rax),%rax
  81fd49:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  81fd4d:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  81fd50:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  81fd54:	83 f8 08             	cmp    $0x8,%eax
  81fd57:	0f 85 3b 04 00 00    	jne    820198 <icmp_input+0x4e0>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  81fd5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fd61:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81fd65:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81fd69:	48 89 c6             	mov    %rax,%rsi
  81fd6c:	48 89 d7             	mov    %rdx,%rdi
  81fd6f:	48 b8 a0 07 81 00 00 	movabs $0x8107a0,%rax
  81fd76:	00 00 00 
  81fd79:	ff d0                	callq  *%rax
  81fd7b:	84 c0                	test   %al,%al
  81fd7d:	75 2f                	jne    81fdae <icmp_input+0xf6>
  81fd7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fd83:	8b 58 10             	mov    0x10(%rax),%ebx
  81fd86:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81fd8b:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81fd92:	00 00 00 
  81fd95:	ff d0                	callq  *%rax
  81fd97:	21 c3                	and    %eax,%ebx
  81fd99:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81fd9e:	48 b8 21 2b 81 00 00 	movabs $0x812b21,%rax
  81fda5:	00 00 00 
  81fda8:	ff d0                	callq  *%rax
  81fdaa:	39 c3                	cmp    %eax,%ebx
  81fdac:	75 18                	jne    81fdc6 <icmp_input+0x10e>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  81fdae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fdb2:	48 89 c7             	mov    %rax,%rdi
  81fdb5:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81fdbc:	00 00 00 
  81fdbf:	ff d0                	callq  *%rax
      return;
  81fdc1:	e9 15 04 00 00       	jmpq   8201db <icmp_input+0x523>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  81fdc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fdca:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81fdce:	66 83 f8 07          	cmp    $0x7,%ax
  81fdd2:	0f 86 d8 03 00 00    	jbe    8201b0 <icmp_input+0x4f8>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  81fdd8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fddc:	48 89 c7             	mov    %rax,%rdi
  81fddf:	48 b8 c5 25 81 00 00 	movabs $0x8125c5,%rax
  81fde6:	00 00 00 
  81fde9:	ff d0                	callq  *%rax
  81fdeb:	66 85 c0             	test   %ax,%ax
  81fdee:	74 18                	je     81fe08 <icmp_input+0x150>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  81fdf0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fdf4:	48 89 c7             	mov    %rax,%rdi
  81fdf7:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81fdfe:	00 00 00 
  81fe01:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  81fe03:	e9 d3 03 00 00       	jmpq   8201db <icmp_input+0x523>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  81fe08:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fe0c:	be 22 00 00 00       	mov    $0x22,%esi
  81fe11:	48 89 c7             	mov    %rax,%rdi
  81fe14:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81fe1b:	00 00 00 
  81fe1e:	ff d0                	callq  *%rax
  81fe20:	84 c0                	test   %al,%al
  81fe22:	0f 84 79 01 00 00    	je     81ffa1 <icmp_input+0x2e9>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  81fe28:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  81fe2c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fe30:	89 d6                	mov    %edx,%esi
  81fe32:	48 89 c7             	mov    %rax,%rdi
  81fe35:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81fe3c:	00 00 00 
  81fe3f:	ff d0                	callq  *%rax
  81fe41:	84 c0                	test   %al,%al
  81fe43:	74 2a                	je     81fe6f <icmp_input+0x1b7>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  81fe45:	48 ba d8 35 82 00 00 	movabs $0x8235d8,%rdx
  81fe4c:	00 00 00 
  81fe4f:	be 7b 00 00 00       	mov    $0x7b,%esi
  81fe54:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  81fe5b:	00 00 00 
  81fe5e:	b8 00 00 00 00       	mov    $0x0,%eax
  81fe63:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81fe6a:	00 00 00 
  81fe6d:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  81fe6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fe73:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81fe77:	0f b7 c0             	movzwl %ax,%eax
  81fe7a:	ba 00 00 00 00       	mov    $0x0,%edx
  81fe7f:	89 c6                	mov    %eax,%esi
  81fe81:	bf 02 00 00 00       	mov    $0x2,%edi
  81fe86:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  81fe8d:	00 00 00 
  81fe90:	ff d0                	callq  *%rax
  81fe92:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  81fe96:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81fe9b:	0f 84 25 03 00 00    	je     8201c6 <icmp_input+0x50e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  81fea1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fea5:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81fea9:	0f b7 c0             	movzwl %ax,%eax
  81feac:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  81feb1:	48 83 c2 08          	add    $0x8,%rdx
  81feb5:	48 39 d0             	cmp    %rdx,%rax
  81feb8:	73 2a                	jae    81fee4 <icmp_input+0x22c>
  81feba:	48 ba 28 36 82 00 00 	movabs $0x823628,%rdx
  81fec1:	00 00 00 
  81fec4:	be 85 00 00 00       	mov    $0x85,%esi
  81fec9:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  81fed0:	00 00 00 
  81fed3:	b8 00 00 00 00       	mov    $0x0,%eax
  81fed8:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81fedf:	00 00 00 
  81fee2:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  81fee4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  81fee8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81feec:	48 89 d6             	mov    %rdx,%rsi
  81feef:	48 89 c7             	mov    %rax,%rdi
  81fef2:	48 b8 d4 db 80 00 00 	movabs $0x80dbd4,%rax
  81fef9:	00 00 00 
  81fefc:	ff d0                	callq  *%rax
  81fefe:	84 c0                	test   %al,%al
  81ff00:	74 2a                	je     81ff2c <icmp_input+0x274>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  81ff02:	48 ba 60 36 82 00 00 	movabs $0x823660,%rdx
  81ff09:	00 00 00 
  81ff0c:	be 88 00 00 00       	mov    $0x88,%esi
  81ff11:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  81ff18:	00 00 00 
  81ff1b:	b8 00 00 00 00       	mov    $0x0,%eax
  81ff20:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ff27:	00 00 00 
  81ff2a:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  81ff2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ff30:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff34:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  81ff38:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  81ff3c:	f7 d8                	neg    %eax
  81ff3e:	0f bf d0             	movswl %ax,%edx
  81ff41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ff45:	89 d6                	mov    %edx,%esi
  81ff47:	48 89 c7             	mov    %rax,%rdi
  81ff4a:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81ff51:	00 00 00 
  81ff54:	ff d0                	callq  *%rax
  81ff56:	84 c0                	test   %al,%al
  81ff58:	74 2a                	je     81ff84 <icmp_input+0x2cc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  81ff5a:	48 ba 88 36 82 00 00 	movabs $0x823688,%rdx
  81ff61:	00 00 00 
  81ff64:	be 8e 00 00 00       	mov    $0x8e,%esi
  81ff69:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  81ff70:	00 00 00 
  81ff73:	b8 00 00 00 00       	mov    $0x0,%eax
  81ff78:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ff7f:	00 00 00 
  81ff82:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  81ff84:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff88:	48 89 c7             	mov    %rax,%rdi
  81ff8b:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  81ff92:	00 00 00 
  81ff95:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  81ff97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81ff9b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  81ff9f:	eb 46                	jmp    81ffe7 <icmp_input+0x32f>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  81ffa1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffa5:	be de ff ff ff       	mov    $0xffffffde,%esi
  81ffaa:	48 89 c7             	mov    %rax,%rdi
  81ffad:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  81ffb4:	00 00 00 
  81ffb7:	ff d0                	callq  *%rax
  81ffb9:	84 c0                	test   %al,%al
  81ffbb:	74 2a                	je     81ffe7 <icmp_input+0x32f>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  81ffbd:	48 ba 88 36 82 00 00 	movabs $0x823688,%rdx
  81ffc4:	00 00 00 
  81ffc7:	be 98 00 00 00       	mov    $0x98,%esi
  81ffcc:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  81ffd3:	00 00 00 
  81ffd6:	b8 00 00 00 00       	mov    $0x0,%eax
  81ffdb:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  81ffe2:	00 00 00 
  81ffe5:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  81ffe7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffeb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ffef:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  81fff3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fff7:	8b 40 0c             	mov    0xc(%rax),%eax
  81fffa:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  81fffd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820001:	8b 50 10             	mov    0x10(%rax),%edx
  820004:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820008:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  82000b:	8b 55 c0             	mov    -0x40(%rbp),%edx
  82000e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820012:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  820015:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820019:	0f b7 00             	movzwl (%rax),%eax
  82001c:	0f b7 c0             	movzwl %ax,%eax
  82001f:	89 c7                	mov    %eax,%edi
  820021:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  820028:	00 00 00 
  82002b:	ff d0                	callq  *%rax
  82002d:	0f b7 c0             	movzwl %ax,%eax
  820030:	25 ff 00 00 00       	and    $0xff,%eax
  820035:	89 c7                	mov    %eax,%edi
  820037:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  82003e:	00 00 00 
  820041:	ff d0                	callq  *%rax
  820043:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  820047:	66 89 02             	mov    %ax,(%rdx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  82004a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82004e:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820052:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  820057:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  82005e:	00 00 00 
  820061:	ff d0                	callq  *%rax
  820063:	66 39 c3             	cmp    %ax,%bx
  820066:	72 28                	jb     820090 <icmp_input+0x3d8>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  820068:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82006c:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820070:	bf 00 08 00 00       	mov    $0x800,%edi
  820075:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  82007c:	00 00 00 
  82007f:	ff d0                	callq  *%rax
  820081:	01 d8                	add    %ebx,%eax
  820083:	8d 50 01             	lea    0x1(%rax),%edx
  820086:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82008a:	66 89 50 02          	mov    %dx,0x2(%rax)
  82008e:	eb 24                	jmp    8200b4 <icmp_input+0x3fc>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  820090:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820094:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820098:	bf 00 08 00 00       	mov    $0x800,%edi
  82009d:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8200a4:	00 00 00 
  8200a7:	ff d0                	callq  *%rax
  8200a9:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  8200ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8200b0:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  8200b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8200b8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8200bc:	0f b7 c0             	movzwl %ax,%eax
  8200bf:	89 c7                	mov    %eax,%edi
  8200c1:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8200c8:	00 00 00 
  8200cb:	ff d0                	callq  *%rax
  8200cd:	66 0d 00 ff          	or     $0xff00,%ax
  8200d1:	0f b7 c0             	movzwl %ax,%eax
  8200d4:	89 c7                	mov    %eax,%edi
  8200d6:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8200dd:	00 00 00 
  8200e0:	ff d0                	callq  *%rax
  8200e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8200e6:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  8200ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8200ee:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8200f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8200f8:	be 14 00 00 00       	mov    $0x14,%esi
  8200fd:	48 89 c7             	mov    %rax,%rdi
  820100:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  820107:	00 00 00 
  82010a:	ff d0                	callq  *%rax
  82010c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820110:	66 89 42 0a          	mov    %ax,0xa(%rdx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  820114:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  820118:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82011c:	89 d6                	mov    %edx,%esi
  82011e:	48 89 c7             	mov    %rax,%rdi
  820121:	48 b8 8f d5 80 00 00 	movabs $0x80d58f,%rax
  820128:	00 00 00 
  82012b:	ff d0                	callq  *%rax
  82012d:	84 c0                	test   %al,%al
  82012f:	74 2a                	je     82015b <icmp_input+0x4a3>
      LWIP_ASSERT("Can't move over header in packet", 0);
  820131:	48 ba c0 36 82 00 00 	movabs $0x8236c0,%rdx
  820138:	00 00 00 
  82013b:	be b9 00 00 00       	mov    $0xb9,%esi
  820140:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  820147:	00 00 00 
  82014a:	b8 00 00 00 00       	mov    $0x0,%eax
  82014f:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  820156:	00 00 00 
  820159:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  82015b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82015f:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  820163:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820167:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  82016b:	48 89 14 24          	mov    %rdx,(%rsp)
  82016f:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820175:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  82017b:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820180:	ba 00 00 00 00       	mov    $0x0,%edx
  820185:	48 89 c7             	mov    %rax,%rdi
  820188:	48 b8 77 0d 81 00 00 	movabs $0x810d77,%rax
  82018f:	00 00 00 
  820192:	ff d0                	callq  *%rax
  820194:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  820197:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  820198:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82019c:	48 89 c7             	mov    %rax,%rdi
  82019f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8201a6:	00 00 00 
  8201a9:	ff d0                	callq  *%rax
  return;
  8201ab:	eb 2e                	jmp    8201db <icmp_input+0x523>

  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  8201ad:	90                   	nop
  8201ae:	eb 01                	jmp    8201b1 <icmp_input+0x4f9>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  8201b0:	90                   	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
  8201b1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201b5:	48 89 c7             	mov    %rax,%rdi
  8201b8:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8201bf:	00 00 00 
  8201c2:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8201c4:	eb 15                	jmp    8201db <icmp_input+0x523>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  8201c6:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  8201c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201cb:	48 89 c7             	mov    %rax,%rdi
  8201ce:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  8201d5:	00 00 00 
  8201d8:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  8201da:	90                   	nop
}
  8201db:	48 83 c4 58          	add    $0x58,%rsp
  8201df:	5b                   	pop    %rbx
  8201e0:	5d                   	pop    %rbp
  8201e1:	c3                   	retq   

00000000008201e2 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  8201e2:	55                   	push   %rbp
  8201e3:	48 89 e5             	mov    %rsp,%rbp
  8201e6:	48 83 ec 30          	sub    $0x30,%rsp
  8201ea:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8201ee:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8201f1:	ba 00 00 00 00       	mov    $0x0,%edx
  8201f6:	be 24 00 00 00       	mov    $0x24,%esi
  8201fb:	bf 01 00 00 00       	mov    $0x1,%edi
  820200:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  820207:	00 00 00 
  82020a:	ff d0                	callq  *%rax
  82020c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  820210:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820215:	0f 84 63 01 00 00    	je     82037e <icmp_dest_unreach+0x19c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  82021b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82021f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820223:	66 83 f8 23          	cmp    $0x23,%ax
  820227:	77 2a                	ja     820253 <icmp_dest_unreach+0x71>
  820229:	48 ba e8 36 82 00 00 	movabs $0x8236e8,%rdx
  820230:	00 00 00 
  820233:	be ef 00 00 00       	mov    $0xef,%esi
  820238:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  82023f:	00 00 00 
  820242:	b8 00 00 00 00       	mov    $0x0,%eax
  820247:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  82024e:	00 00 00 
  820251:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820253:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820257:	48 8b 40 08          	mov    0x8(%rax),%rax
  82025b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  82025f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820263:	48 8b 40 08          	mov    0x8(%rax),%rax
  820267:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  82026b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82026f:	0f b7 00             	movzwl (%rax),%eax
  820272:	0f b7 c0             	movzwl %ax,%eax
  820275:	89 c7                	mov    %eax,%edi
  820277:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  82027e:	00 00 00 
  820281:	ff d0                	callq  *%rax
  820283:	66 25 ff 00          	and    $0xff,%ax
  820287:	80 cc 03             	or     $0x3,%ah
  82028a:	0f b7 c0             	movzwl %ax,%eax
  82028d:	89 c7                	mov    %eax,%edi
  82028f:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  820296:	00 00 00 
  820299:	ff d0                	callq  *%rax
  82029b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82029f:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(idur, t);
  8202a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202a6:	0f b7 00             	movzwl (%rax),%eax
  8202a9:	0f b7 c0             	movzwl %ax,%eax
  8202ac:	89 c7                	mov    %eax,%edi
  8202ae:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  8202b5:	00 00 00 
  8202b8:	ff d0                	callq  *%rax
  8202ba:	89 c2                	mov    %eax,%edx
  8202bc:	b2 00                	mov    $0x0,%dl
  8202be:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8202c1:	09 d0                	or     %edx,%eax
  8202c3:	0f b7 c0             	movzwl %ax,%eax
  8202c6:	89 c7                	mov    %eax,%edi
  8202c8:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  8202cf:	00 00 00 
  8202d2:	ff d0                	callq  *%rax
  8202d4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8202d8:	66 89 02             	mov    %ax,(%rdx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8202db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8202df:	48 8b 40 08          	mov    0x8(%rax),%rax
  8202e3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8202e7:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8202eb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8202ef:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8202f4:	48 89 c6             	mov    %rax,%rsi
  8202f7:	48 89 cf             	mov    %rcx,%rdi
  8202fa:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  820301:	00 00 00 
  820304:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  820306:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82030a:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  820310:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820314:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820318:	0f b7 d0             	movzwl %ax,%edx
  82031b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82031f:	89 d6                	mov    %edx,%esi
  820321:	48 89 c7             	mov    %rax,%rdi
  820324:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  82032b:	00 00 00 
  82032e:	ff d0                	callq  *%rax
  820330:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820334:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  820338:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82033c:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820340:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820344:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  82034a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820350:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820355:	be 00 00 00 00       	mov    $0x0,%esi
  82035a:	48 89 c7             	mov    %rax,%rdi
  82035d:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  820364:	00 00 00 
  820367:	ff d0                	callq  *%rax
  pbuf_free(q);
  820369:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82036d:	48 89 c7             	mov    %rax,%rdi
  820370:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  820377:	00 00 00 
  82037a:	ff d0                	callq  *%rax
  82037c:	eb 01                	jmp    82037f <icmp_dest_unreach+0x19d>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  82037e:	90                   	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  82037f:	c9                   	leaveq 
  820380:	c3                   	retq   

0000000000820381 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  820381:	55                   	push   %rbp
  820382:	48 89 e5             	mov    %rsp,%rbp
  820385:	48 83 ec 30          	sub    $0x30,%rsp
  820389:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  82038d:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820390:	ba 00 00 00 00       	mov    $0x0,%edx
  820395:	be 24 00 00 00       	mov    $0x24,%esi
  82039a:	bf 01 00 00 00       	mov    $0x1,%edi
  82039f:	48 b8 6c ce 80 00 00 	movabs $0x80ce6c,%rax
  8203a6:	00 00 00 
  8203a9:	ff d0                	callq  *%rax
  8203ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  8203af:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8203b4:	0f 84 63 01 00 00    	je     82051d <icmp_time_exceeded+0x19c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8203ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8203be:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8203c2:	66 83 f8 23          	cmp    $0x23,%ax
  8203c6:	77 2a                	ja     8203f2 <icmp_time_exceeded+0x71>
  8203c8:	48 ba e8 36 82 00 00 	movabs $0x8236e8,%rdx
  8203cf:	00 00 00 
  8203d2:	be 1e 01 00 00       	mov    $0x11e,%esi
  8203d7:	48 bf 0b 36 82 00 00 	movabs $0x82360b,%rdi
  8203de:	00 00 00 
  8203e1:	b8 00 00 00 00       	mov    $0x0,%eax
  8203e6:	48 b9 20 0f 80 00 00 	movabs $0x800f20,%rcx
  8203ed:	00 00 00 
  8203f0:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8203f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8203f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8203fa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  8203fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820402:	48 8b 40 08          	mov    0x8(%rax),%rax
  820406:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  82040a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82040e:	0f b7 00             	movzwl (%rax),%eax
  820411:	0f b7 c0             	movzwl %ax,%eax
  820414:	89 c7                	mov    %eax,%edi
  820416:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  82041d:	00 00 00 
  820420:	ff d0                	callq  *%rax
  820422:	66 25 ff 00          	and    $0xff,%ax
  820426:	80 cc 0b             	or     $0xb,%ah
  820429:	0f b7 c0             	movzwl %ax,%eax
  82042c:	89 c7                	mov    %eax,%edi
  82042e:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  820435:	00 00 00 
  820438:	ff d0                	callq  *%rax
  82043a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82043e:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(tehdr, t);
  820441:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820445:	0f b7 00             	movzwl (%rax),%eax
  820448:	0f b7 c0             	movzwl %ax,%eax
  82044b:	89 c7                	mov    %eax,%edi
  82044d:	48 b8 c7 2a 81 00 00 	movabs $0x812ac7,%rax
  820454:	00 00 00 
  820457:	ff d0                	callq  *%rax
  820459:	89 c2                	mov    %eax,%edx
  82045b:	b2 00                	mov    $0x0,%dl
  82045d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820460:	09 d0                	or     %edx,%eax
  820462:	0f b7 c0             	movzwl %ax,%eax
  820465:	89 c7                	mov    %eax,%edi
  820467:	48 b8 a4 2a 81 00 00 	movabs $0x812aa4,%rax
  82046e:	00 00 00 
  820471:	ff d0                	callq  *%rax
  820473:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820477:	66 89 02             	mov    %ax,(%rdx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  82047a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82047e:	48 8b 40 08          	mov    0x8(%rax),%rax
  820482:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820486:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  82048a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  82048e:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820493:	48 89 c6             	mov    %rax,%rsi
  820496:	48 89 cf             	mov    %rcx,%rdi
  820499:	48 b8 65 21 80 00 00 	movabs $0x802165,%rax
  8204a0:	00 00 00 
  8204a3:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  8204a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204a9:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  8204af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8204b3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8204b7:	0f b7 d0             	movzwl %ax,%edx
  8204ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204be:	89 d6                	mov    %edx,%esi
  8204c0:	48 89 c7             	mov    %rax,%rdi
  8204c3:	48 b8 96 25 81 00 00 	movabs $0x812596,%rax
  8204ca:	00 00 00 
  8204cd:	ff d0                	callq  *%rax
  8204cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8204d3:	66 89 42 02          	mov    %ax,0x2(%rdx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  8204d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8204db:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8204df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8204e3:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8204e9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8204ef:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8204f4:	be 00 00 00 00       	mov    $0x0,%esi
  8204f9:	48 89 c7             	mov    %rax,%rdi
  8204fc:	48 b8 2d 10 81 00 00 	movabs $0x81102d,%rax
  820503:	00 00 00 
  820506:	ff d0                	callq  *%rax
  pbuf_free(q);
  820508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82050c:	48 89 c7             	mov    %rax,%rdi
  82050f:	48 b8 52 d7 80 00 00 	movabs $0x80d752,%rax
  820516:	00 00 00 
  820519:	ff d0                	callq  *%rax
  82051b:	eb 01                	jmp    82051e <icmp_time_exceeded+0x19d>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  82051d:	90                   	nop
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  82051e:	c9                   	leaveq 
  82051f:	c3                   	retq   
